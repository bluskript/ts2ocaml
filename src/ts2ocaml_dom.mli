[@@@ocaml.warning "-7-11-32-33-39"]
[@@@js.implem 
  [@@@ocaml.warning "-7-11-32-33-39"]
]
open Ts2ocaml_min
open Ts2ocaml_es


(**
  `URLSearchParams` class is a global reference for `require('url').URLSearchParams`
  https://nodejs.org/api/url.html#class-urlsearchparams
*)
module[@js.scope "URLSearchParams"] URLSearchParams : sig
  type t = [`URLSearchParams | (string * string) IterableIterator.tags_1] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`URLSearchParams | (string * string) IterableIterator.tags_1]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`URLSearchParams | (string * string) IterableIterator.tags_1]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `URLSearchParams ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  (* [Symbol.iterator]: unit -> (string * string) IterableIterator.t_1 *)
  
  (** Returns an array of key, value pairs for every entry in the search params. *)
  val entries: 'tags this -> (string * string) IterableIterator.t_1 [@@js.call "entries"]
  
  (** Returns a list of keys in the search params. *)
  val keys: 'tags this -> string IterableIterator.t_1 [@@js.call "keys"]
  
  (** Returns a list of values in the search params. *)
  val values: 'tags this -> string IterableIterator.t_1 [@@js.call "values"]
  
  (** Appends a specified key/value pair as a new search parameter. *)
  val append: 'tags this -> name:string -> value:string -> unit [@@js.call "append"]
  
  (** Deletes the given search parameter, and its associated value, from the list of all search parameters. *)
  val delete: 'tags this -> name:string -> unit [@@js.call "delete"]
  
  (** Returns the first value associated to the given search parameter. *)
  val get_: 'tags this -> name:string -> string option [@@js.call "get"]
  
  (** Returns all the values association with a given search parameter. *)
  val getAll: 'tags this -> name:string -> string list [@@js.call "getAll"]
  
  (** Returns a Boolean indicating if such a search parameter exists. *)
  val has: 'tags this -> name:string -> bool [@@js.call "has"]
  
  (** Sets the value associated to a given search parameter to the given value. If there were several values, delete the others. *)
  val set_: 'tags this -> name:string -> value:string -> unit [@@js.call "set"]
  val sort: 'tags this -> unit [@@js.call "sort"]
  
  (** Returns a string containing a query string suitable for use in a URL. Does not include the question mark. *)
  val toString: 'tags this -> string [@@js.call "toString"]
  val forEach: 'tags this -> callbackfn:(value:string -> key:string -> parent:t -> unit) -> ?thisArg:any -> unit -> unit [@@js.call "forEach"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: ?init:([`U1 of string list list | `U2 of (string, string) Record.t_2 | `U3 of string | `U4 of t] [@js.union]) -> unit -> t [@@js.create]
  val toString': unit -> string [@@js.global "toString"]
end

(** Used to represent a set of time ranges, primarily for the purpose of tracking which portions of media have been buffered when loading it for use by the <audio> and <video> elements. *)
module[@js.scope "TimeRanges"] TimeRanges : sig
  type t = [`TimeRanges] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`TimeRanges]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`TimeRanges]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `TimeRanges ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Returns the number of ranges in the object. *)
  val get_length: 'tags this -> float [@@js.get "length"]
  
  (**
    Returns the time for the end of the range with the given index.
    
    Throws an "IndexSizeError" DOMException if the index is out of range.
  *)
  val end_: 'tags this -> index:float -> float [@@js.call "end"]
  
  (**
    Returns the time for the start of the range with the given index.
    
    Throws an "IndexSizeError" DOMException if the index is out of range.
  *)
  val start: 'tags this -> index:float -> float [@@js.call "start"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module AppendMode : sig
  type t = ([`L_s708_segments[@js "segments"] | `L_s716_sequence[@js "sequence"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module BufferSource : sig
  type t = (ArrayBuffer.t_0, ArrayBufferView.t_0) union2
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module EventInit : sig
  type t = [`EventInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `EventInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_bubbles: 'tags this -> bool option [@@js.get "bubbles"]
  val set_bubbles: 'tags this -> bool -> unit [@@js.set "bubbles"]
  val get_cancelable: 'tags this -> bool option [@@js.get "cancelable"]
  val set_cancelable: 'tags this -> bool -> unit [@@js.set "cancelable"]
  val get_composed: 'tags this -> bool option [@@js.get "composed"]
  val set_composed: 'tags this -> bool -> unit [@@js.set "composed"]
  val create: ?bubbles:bool -> ?cancelable:bool -> ?composed:bool -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module DOMHighResTimeStamp : sig
  type t = float
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module EventListenerOptions : sig
  type t = [`EventListenerOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventListenerOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventListenerOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `EventListenerOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_capture: 'tags this -> bool option [@@js.get "capture"]
  val set_capture: 'tags this -> bool -> unit [@@js.set "capture"]
  val create: ?capture:bool -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** A signal object that allows you to communicate with a DOM request (such as a Fetch) and abort it if required via an AbortController object. *)
module[@js.scope "AbortSignal"] rec AbortSignal : sig
  type t = [`AbortSignal | `EventTarget] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AbortSignal | `EventTarget]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AbortSignal | `EventTarget]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `AbortSignal ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Returns true if this AbortSignal's AbortController has signaled to abort, and false otherwise. *)
  val get_aborted: 'tags this -> bool [@@js.get "aborted"]
  val get_onabort: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onabort"]
  val set_onabort: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onabort"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'AbortSignalEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'AbortSignalEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
and AddEventListenerOptions : sig
  type t = [`AddEventListenerOptions | `EventListenerOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AddEventListenerOptions | `EventListenerOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AddEventListenerOptions | `EventListenerOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `AddEventListenerOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_once: 'tags this -> bool option [@@js.get "once"]
  val set_once: 'tags this -> bool -> unit [@@js.set "once"]
  val get_passive: 'tags this -> bool option [@@js.get "passive"]
  val set_passive: 'tags this -> bool -> unit [@@js.set "passive"]
  val get_signal: 'tags this -> AbortSignal.t option [@@js.get "signal"]
  val set_signal: 'tags this -> AbortSignal.t -> unit [@@js.set "signal"]
  val create: ?once:bool -> ?passive:bool -> ?signal:AbortSignal.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** An event which takes place in the DOM. *)
and[@js.scope "Event"] Event : sig
  type t = [`Event] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Event]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Event]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `Event ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Returns true or false depending on how event was initialized. True if event goes through its target's ancestors in reverse tree order, and false otherwise. *)
  val get_bubbles: 'tags this -> bool [@@js.get "bubbles"]
  val get_cancelBubble: 'tags this -> bool [@@js.get "cancelBubble"]
  val set_cancelBubble: 'tags this -> bool -> unit [@@js.set "cancelBubble"]
  
  (** Returns true or false depending on how event was initialized. Its return value does not always carry meaning, but true can indicate that part of the operation during which event was dispatched, can be canceled by invoking the preventDefault() method. *)
  val get_cancelable: 'tags this -> bool [@@js.get "cancelable"]
  
  (** Returns true or false depending on how event was initialized. True if event invokes listeners past a ShadowRoot node that is the root of its target, and false otherwise. *)
  val get_composed: 'tags this -> bool [@@js.get "composed"]
  
  (** Returns the object whose event listener's callback is currently being invoked. *)
  val get_currentTarget: 'tags this -> EventTarget.t option [@@js.get "currentTarget"]
  
  (** Returns true if preventDefault() was invoked successfully to indicate cancelation, and false otherwise. *)
  val get_defaultPrevented: 'tags this -> bool [@@js.get "defaultPrevented"]
  
  (** Returns the event's phase, which is one of NONE, CAPTURING_PHASE, AT_TARGET, and BUBBLING_PHASE. *)
  val get_eventPhase: 'tags this -> float [@@js.get "eventPhase"]
  
  (** Returns true if event was dispatched by the user agent, and false otherwise. *)
  val get_isTrusted: 'tags this -> bool [@@js.get "isTrusted"]
  
  (** @deprecated  *)
  val get_returnValue: 'tags this -> bool [@@js.get "returnValue"]
  
  (** @deprecated  *)
  val set_returnValue: 'tags this -> bool -> unit [@@js.set "returnValue"]
  
  (** @deprecated  *)
  val get_srcElement: 'tags this -> EventTarget.t option [@@js.get "srcElement"]
  
  (** Returns the object to which event is dispatched (its target). *)
  val get_target: 'tags this -> EventTarget.t option [@@js.get "target"]
  
  (** Returns the event's timestamp as the number of milliseconds measured relative to the time origin. *)
  val get_timeStamp: 'tags this -> DOMHighResTimeStamp.t [@@js.get "timeStamp"]
  
  (** Returns the type of event, e.g. "click", "hashchange", or "submit". *)
  val get_type: 'tags this -> string [@@js.get "type"]
  
  (** Returns the invocation target objects of event's path (objects on which listeners will be invoked), except for any nodes in shadow trees of which the shadow root's mode is "closed" that are not reachable from event's currentTarget. *)
  val composedPath: 'tags this -> EventTarget.t list [@@js.call "composedPath"]
  
  (** @deprecated  *)
  val initEvent: 'tags this -> type_:string -> ?bubbles:bool -> ?cancelable:bool -> unit -> unit [@@js.call "initEvent"]
  
  (** If invoked when the cancelable attribute value is true, and while executing a listener for the event with passive set to false, signals to the operation that caused event to be dispatched that it needs to be canceled. *)
  val preventDefault: 'tags this -> unit [@@js.call "preventDefault"]
  
  (** Invoking this method prevents event from reaching any registered event listeners after the current one finishes running and, when dispatched in a tree, also prevents event from reaching any other objects. *)
  val stopImmediatePropagation: 'tags this -> unit [@@js.call "stopImmediatePropagation"]
  
  (** When dispatched in a tree, invoking this method prevents event from reaching any objects other than the current object. *)
  val stopPropagation: 'tags this -> unit [@@js.call "stopPropagation"]
  val get_AT_TARGET: 'tags this -> float [@@js.get "AT_TARGET"]
  val get_BUBBLING_PHASE: 'tags this -> float [@@js.get "BUBBLING_PHASE"]
  val get_CAPTURING_PHASE: 'tags this -> float [@@js.get "CAPTURING_PHASE"]
  val get_NONE: 'tags this -> float [@@js.get "NONE"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: type_:string -> ?eventInitDict:EventInit.t -> unit -> t [@@js.create]
  val at_target: unit -> float [@@js.get "AT_TARGET"]
  val bubbling_phase: unit -> float [@@js.get "BUBBLING_PHASE"]
  val capturing_phase: unit -> float [@@js.get "CAPTURING_PHASE"]
  val none: unit -> float [@@js.get "NONE"]
end
and EventListener : sig
  type t = [`EventListener] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventListener]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventListener]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `EventListener ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val apply: 'tags this -> evt:Event.t -> unit [@@js.apply]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
and EventListenerObject : sig
  type t = [`EventListenerObject] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventListenerObject]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventListenerObject]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `EventListenerObject ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val handleEvent: 'tags this -> object_:Event.t -> unit [@@js.call "handleEvent"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
and EventListenerOrEventListenerObject : sig
  type t = (EventListener.t, EventListenerObject.t) union2
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end

(** EventTarget is a DOM interface implemented by objects that can receive events and may have listeners for them. *)
and[@js.scope "EventTarget"] EventTarget : sig
  type t = [`EventTarget] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventTarget]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventTarget]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `EventTarget ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:string -> callback:EventListenerOrEventListenerObject.t option -> ?options:([`U1 of AddEventListenerOptions.t | `U2 of bool] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Dispatches a synthetic event event to target and returns true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, and false otherwise. *)
  val dispatchEvent: 'tags this -> event:Event.t -> bool [@@js.call "dispatchEvent"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:string -> callback:EventListenerOrEventListenerObject.t option -> ?options:([`U1 of EventListenerOptions.t | `U2 of bool] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** A chunk of media to be passed into an HTMLMediaElement and played, via a MediaSource object. This can be made up of one or several media segments. *)
module[@js.scope "SourceBuffer"] SourceBuffer : sig
  type t = [`EventTarget | `SourceBuffer] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventTarget | `SourceBuffer]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventTarget | `SourceBuffer]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SourceBuffer ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_appendWindowEnd: 'tags this -> float [@@js.get "appendWindowEnd"]
  val set_appendWindowEnd: 'tags this -> float -> unit [@@js.set "appendWindowEnd"]
  val get_appendWindowStart: 'tags this -> float [@@js.get "appendWindowStart"]
  val set_appendWindowStart: 'tags this -> float -> unit [@@js.set "appendWindowStart"]
  val get_buffered: 'tags this -> TimeRanges.t [@@js.get "buffered"]
  val get_mode: 'tags this -> AppendMode.t [@@js.get "mode"]
  val set_mode: 'tags this -> AppendMode.t -> unit [@@js.set "mode"]
  val get_onabort: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onabort"]
  val set_onabort: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onabort"]
  val get_onerror: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onerror"]
  val set_onerror: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onerror"]
  val get_onupdate: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onupdate"]
  val set_onupdate: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onupdate"]
  val get_onupdateend: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onupdateend"]
  val set_onupdateend: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onupdateend"]
  val get_onupdatestart: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onupdatestart"]
  val set_onupdatestart: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onupdatestart"]
  val get_timestampOffset: 'tags this -> float [@@js.get "timestampOffset"]
  val set_timestampOffset: 'tags this -> float -> unit [@@js.set "timestampOffset"]
  val get_updating: 'tags this -> bool [@@js.get "updating"]
  val abort: 'tags this -> unit [@@js.call "abort"]
  val appendBuffer: 'tags this -> data:BufferSource.t -> unit [@@js.call "appendBuffer"]
  val changeType: 'tags this -> type_:string -> unit [@@js.call "changeType"]
  val remove: 'tags this -> start:float -> end_:float -> unit [@@js.call "remove"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SourceBufferEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SourceBufferEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** A simple container list for multiple SourceBuffer objects. *)
module[@js.scope "SourceBufferList"] SourceBufferList : sig
  type t = [`EventTarget | `SourceBufferList | SourceBuffer.t ArrayLike.tags_1 | SourceBuffer.t IterableIterator.tags_1] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventTarget | `SourceBufferList | SourceBuffer.t ArrayLike.tags_1 | SourceBuffer.t IterableIterator.tags_1]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventTarget | `SourceBufferList | SourceBuffer.t ArrayLike.tags_1 | SourceBuffer.t IterableIterator.tags_1]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SourceBufferList ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  (* [Symbol.iterator]: unit -> SourceBuffer.t IterableIterator.t_1 *)
  val get_length: 'tags this -> float [@@js.get "length"]
  val get_onaddsourcebuffer: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onaddsourcebuffer"]
  val set_onaddsourcebuffer: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onaddsourcebuffer"]
  val get_onremovesourcebuffer: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onremovesourcebuffer"]
  val set_onremovesourcebuffer: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onremovesourcebuffer"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SourceBufferListEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SourceBufferListEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val get: 'tags this -> float -> SourceBuffer.t [@@js.index_get]
  val set: 'tags this -> float -> SourceBuffer.t -> unit [@@js.index_set]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module ReadyState : sig
  type t = ([`L_s199_closed[@js "closed"] | `L_s291_ended[@js "ended"] | `L_s564_open[@js "open"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module EndOfStreamError : sig
  type t = ([`L_s239_decode[@js "decode"] | `L_s537_network[@js "network"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end

(** This Media Source Extensions API interface represents a source of media data for an HTMLMediaElement object. A MediaSource object can be attached to a HTMLMediaElement to be played in the user agent. *)
module[@js.scope "MediaSource"] MediaSource : sig
  type t = [`EventTarget | `MediaSource] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventTarget | `MediaSource]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventTarget | `MediaSource]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MediaSource ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_activeSourceBuffers: 'tags this -> SourceBufferList.t [@@js.get "activeSourceBuffers"]
  val get_duration: 'tags this -> float [@@js.get "duration"]
  val set_duration: 'tags this -> float -> unit [@@js.set "duration"]
  val get_onsourceclose: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onsourceclose"]
  val set_onsourceclose: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onsourceclose"]
  val get_onsourceended: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onsourceended"]
  val set_onsourceended: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onsourceended"]
  val get_onsourceopen: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onsourceopen"]
  val set_onsourceopen: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onsourceopen"]
  val get_readyState: 'tags this -> ReadyState.t [@@js.get "readyState"]
  val get_sourceBuffers: 'tags this -> SourceBufferList.t [@@js.get "sourceBuffers"]
  val addSourceBuffer: 'tags this -> type_:string -> SourceBuffer.t [@@js.call "addSourceBuffer"]
  val clearLiveSeekableRange: 'tags this -> unit [@@js.call "clearLiveSeekableRange"]
  val endOfStream: 'tags this -> ?error:EndOfStreamError.t -> unit -> unit [@@js.call "endOfStream"]
  val removeSourceBuffer: 'tags this -> sourceBuffer:SourceBuffer.t -> unit [@@js.call "removeSourceBuffer"]
  val setLiveSeekableRange: 'tags this -> start:float -> end_:float -> unit [@@js.call "setLiveSeekableRange"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'MediaSourceEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'MediaSourceEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
  val isTypeSupported: string -> bool [@@js.global "isTypeSupported"]
end
module[@js.scope "ReadableStreamDefaultController"] ReadableStreamDefaultController : sig
  type 'R t = [`ReadableStreamDefaultController of 'R] intf [@@js.custom { of_js=(fun _R -> Obj.magic); to_js=(fun _R -> Obj.magic) }]
  type 'R t_1 = 'R t
  type t_0 = any t
  [@@@js.stop]
  type 'R tags = [`ReadableStreamDefaultController of 'R]
  type 'R tags_1 = 'R tags
  type tags_0 = any tags
  [@@@js.start]
  [@@@js.implem 
    type 'R tags = [`ReadableStreamDefaultController of 'R]
    type 'R tags_1 = 'R tags
    type tags_0 = any tags
  ]
  type ('tags, 'R) this = 'tags intf constraint 'tags = [> `ReadableStreamDefaultController of 'R ]
  val t_to_js: ('R -> Ojs.t) -> 'R t -> Ojs.t
  val t_of_js: (Ojs.t -> 'R) -> Ojs.t -> 'R t
  val t_1_to_js: ('R -> Ojs.t) -> 'R t_1 -> Ojs.t
  val t_1_of_js: (Ojs.t -> 'R) -> Ojs.t -> 'R t_1
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_desiredSize: ('tags, 'R) this -> float option [@@js.get "desiredSize"]
  val close: ('tags, 'R) this -> unit [@@js.call "close"]
  val enqueue: ('tags, 'R) this -> ?chunk:'R -> unit -> unit [@@js.call "enqueue"]
  val error: ('tags, 'R) this -> ?e:any -> unit -> unit [@@js.call "error"]
  val cast_from: ('tags, 'R) this -> 'R t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t_0 [@@js.get "prototype"]
  val create: unit -> t_0 [@@js.create]
end
module ReadableStreamController : sig
  type 'T t = 'T ReadableStreamDefaultController.t
  type 'T t_1 = 'T t
  val t_to_js: ('T -> Ojs.t) -> 'T t -> Ojs.t
  val t_of_js: (Ojs.t -> 'T) -> Ojs.t -> 'T t
  val t_1_to_js: ('T -> Ojs.t) -> 'T t_1 -> Ojs.t
  val t_1_of_js: (Ojs.t -> 'T) -> Ojs.t -> 'T t_1
end
module UnderlyingSourceStartCallback : sig
  type 'R t = [`UnderlyingSourceStartCallback of 'R] intf [@@js.custom { of_js=(fun _R -> Obj.magic); to_js=(fun _R -> Obj.magic) }]
  type 'R t_1 = 'R t
  [@@@js.stop]
  type 'R tags = [`UnderlyingSourceStartCallback of 'R]
  type 'R tags_1 = 'R tags
  [@@@js.start]
  [@@@js.implem 
    type 'R tags = [`UnderlyingSourceStartCallback of 'R]
    type 'R tags_1 = 'R tags
  ]
  type ('tags, 'R) this = 'tags intf constraint 'tags = [> `UnderlyingSourceStartCallback of 'R ]
  val t_to_js: ('R -> Ojs.t) -> 'R t -> Ojs.t
  val t_of_js: (Ojs.t -> 'R) -> Ojs.t -> 'R t
  val t_1_to_js: ('R -> Ojs.t) -> 'R t_1 -> Ojs.t
  val t_1_of_js: (Ojs.t -> 'R) -> Ojs.t -> 'R t_1
  val apply: ('tags, 'R) this -> controller:'R ReadableStreamController.t -> any [@@js.apply]
  val cast_from: ('tags, 'R) this -> 'R t [@@js.custom let cast_from = Obj.magic]
end
module UnderlyingSourcePullCallback : sig
  type 'R t = [`UnderlyingSourcePullCallback of 'R] intf [@@js.custom { of_js=(fun _R -> Obj.magic); to_js=(fun _R -> Obj.magic) }]
  type 'R t_1 = 'R t
  [@@@js.stop]
  type 'R tags = [`UnderlyingSourcePullCallback of 'R]
  type 'R tags_1 = 'R tags
  [@@@js.start]
  [@@@js.implem 
    type 'R tags = [`UnderlyingSourcePullCallback of 'R]
    type 'R tags_1 = 'R tags
  ]
  type ('tags, 'R) this = 'tags intf constraint 'tags = [> `UnderlyingSourcePullCallback of 'R ]
  val t_to_js: ('R -> Ojs.t) -> 'R t -> Ojs.t
  val t_of_js: (Ojs.t -> 'R) -> Ojs.t -> 'R t
  val t_1_to_js: ('R -> Ojs.t) -> 'R t_1 -> Ojs.t
  val t_1_of_js: (Ojs.t -> 'R) -> Ojs.t -> 'R t_1
  val apply: ('tags, 'R) this -> controller:'R ReadableStreamController.t -> (unit, unit PromiseLike.t_1) union2 [@@js.apply]
  val cast_from: ('tags, 'R) this -> 'R t [@@js.custom let cast_from = Obj.magic]
end
module UnderlyingSourceCancelCallback : sig
  type t = [`UnderlyingSourceCancelCallback] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`UnderlyingSourceCancelCallback]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`UnderlyingSourceCancelCallback]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `UnderlyingSourceCancelCallback ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val apply: 'tags this -> ?reason:any -> unit -> (unit, unit PromiseLike.t_1) union2 [@@js.apply]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module UnderlyingSource : sig
  type 'R t = [`UnderlyingSource of 'R] intf [@@js.custom { of_js=(fun _R -> Obj.magic); to_js=(fun _R -> Obj.magic) }]
  type 'R t_1 = 'R t
  type t_0 = any t
  [@@@js.stop]
  type 'R tags = [`UnderlyingSource of 'R]
  type 'R tags_1 = 'R tags
  type tags_0 = any tags
  [@@@js.start]
  [@@@js.implem 
    type 'R tags = [`UnderlyingSource of 'R]
    type 'R tags_1 = 'R tags
    type tags_0 = any tags
  ]
  type ('tags, 'R) this = 'tags intf constraint 'tags = [> `UnderlyingSource of 'R ]
  val t_to_js: ('R -> Ojs.t) -> 'R t -> Ojs.t
  val t_of_js: (Ojs.t -> 'R) -> Ojs.t -> 'R t
  val t_1_to_js: ('R -> Ojs.t) -> 'R t_1 -> Ojs.t
  val t_1_of_js: (Ojs.t -> 'R) -> Ojs.t -> 'R t_1
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_cancel: ('tags, 'R) this -> UnderlyingSourceCancelCallback.t option [@@js.get "cancel"]
  val set_cancel: ('tags, 'R) this -> UnderlyingSourceCancelCallback.t -> unit [@@js.set "cancel"]
  val get_pull: ('tags, 'R) this -> 'R UnderlyingSourcePullCallback.t option [@@js.get "pull"]
  val set_pull: ('tags, 'R) this -> 'R UnderlyingSourcePullCallback.t -> unit [@@js.set "pull"]
  val get_start: ('tags, 'R) this -> 'R UnderlyingSourceStartCallback.t option [@@js.get "start"]
  val set_start: ('tags, 'R) this -> 'R UnderlyingSourceStartCallback.t -> unit [@@js.set "start"]
  val get_type: ('tags, 'R) this -> undefined [@@js.get "type"]
  val set_type: ('tags, 'R) this -> undefined -> unit [@@js.set "type"]
  val create: ?cancel:UnderlyingSourceCancelCallback.t -> ?pull:'R UnderlyingSourcePullCallback.t -> ?start:'R UnderlyingSourceStartCallback.t -> ?type_:(never[@js "type"]) -> unit -> 'R t [@@js.builder]
  val cast_from: ('tags, 'R) this -> 'R t [@@js.custom let cast_from = Obj.magic]
end
module StreamPipeOptions : sig
  type t = [`StreamPipeOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`StreamPipeOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`StreamPipeOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `StreamPipeOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_preventAbort: 'tags this -> bool option [@@js.get "preventAbort"]
  val set_preventAbort: 'tags this -> bool -> unit [@@js.set "preventAbort"]
  val get_preventCancel: 'tags this -> bool option [@@js.get "preventCancel"]
  val set_preventCancel: 'tags this -> bool -> unit [@@js.set "preventCancel"]
  
  (**
    Pipes this readable stream to a given writable stream destination. The way in which the piping process behaves under various error conditions can be customized with a number of passed options. It returns a promise that fulfills when the piping process completes successfully, or rejects if any errors were encountered.
    
    Piping a stream will lock it for the duration of the pipe, preventing any other consumer from acquiring a reader.
    
    Errors and closures of the source and destination streams propagate as follows:
    
    An error in this source readable stream will abort destination, unless preventAbort is truthy. The returned promise will be rejected with the source's error, or with any error that occurs during aborting the destination.
    
    An error in destination will cancel this source readable stream, unless preventCancel is truthy. The returned promise will be rejected with the destination's error, or with any error that occurs during canceling the source.
    
    When this source readable stream closes, destination will be closed, unless preventClose is truthy. The returned promise will be fulfilled once this process completes, unless an error is encountered while closing the destination, in which case it will be rejected with that error.
    
    If destination starts out closed or closing, this source readable stream will be canceled, unless preventCancel is true. The returned promise will be rejected with an error indicating piping to a closed stream failed, or with any error that occurs during canceling the source.
    
    The signal option can be set to an AbortSignal to allow aborting an ongoing pipe operation via the corresponding AbortController. In this case, this source readable stream will be canceled, and destination aborted, unless the respective options preventCancel or preventAbort are set.
  *)
  val get_preventClose: 'tags this -> bool option [@@js.get "preventClose"]
  
  (**
    Pipes this readable stream to a given writable stream destination. The way in which the piping process behaves under various error conditions can be customized with a number of passed options. It returns a promise that fulfills when the piping process completes successfully, or rejects if any errors were encountered.
    
    Piping a stream will lock it for the duration of the pipe, preventing any other consumer from acquiring a reader.
    
    Errors and closures of the source and destination streams propagate as follows:
    
    An error in this source readable stream will abort destination, unless preventAbort is truthy. The returned promise will be rejected with the source's error, or with any error that occurs during aborting the destination.
    
    An error in destination will cancel this source readable stream, unless preventCancel is truthy. The returned promise will be rejected with the destination's error, or with any error that occurs during canceling the source.
    
    When this source readable stream closes, destination will be closed, unless preventClose is truthy. The returned promise will be fulfilled once this process completes, unless an error is encountered while closing the destination, in which case it will be rejected with that error.
    
    If destination starts out closed or closing, this source readable stream will be canceled, unless preventCancel is true. The returned promise will be rejected with an error indicating piping to a closed stream failed, or with any error that occurs during canceling the source.
    
    The signal option can be set to an AbortSignal to allow aborting an ongoing pipe operation via the corresponding AbortController. In this case, this source readable stream will be canceled, and destination aborted, unless the respective options preventCancel or preventAbort are set.
  *)
  val set_preventClose: 'tags this -> bool -> unit [@@js.set "preventClose"]
  val get_signal: 'tags this -> AbortSignal.t option [@@js.get "signal"]
  val set_signal: 'tags this -> AbortSignal.t -> unit [@@js.set "signal"]
  val create: ?preventAbort:bool -> ?preventCancel:bool -> ?preventClose:bool -> ?signal:AbortSignal.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** This Streams API interface represents a controller allowing control of a WritableStream's state. When constructing a WritableStream, the underlying sink is given a corresponding WritableStreamDefaultController instance to manipulate. *)
module[@js.scope "WritableStreamDefaultController"] WritableStreamDefaultController : sig
  type t = [`WritableStreamDefaultController] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`WritableStreamDefaultController]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`WritableStreamDefaultController]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `WritableStreamDefaultController ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val error: 'tags this -> ?e:any -> unit -> unit [@@js.call "error"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module UnderlyingSinkWriteCallback : sig
  type 'W t = [`UnderlyingSinkWriteCallback of 'W] intf [@@js.custom { of_js=(fun _W -> Obj.magic); to_js=(fun _W -> Obj.magic) }]
  type 'W t_1 = 'W t
  [@@@js.stop]
  type 'W tags = [`UnderlyingSinkWriteCallback of 'W]
  type 'W tags_1 = 'W tags
  [@@@js.start]
  [@@@js.implem 
    type 'W tags = [`UnderlyingSinkWriteCallback of 'W]
    type 'W tags_1 = 'W tags
  ]
  type ('tags, 'W) this = 'tags intf constraint 'tags = [> `UnderlyingSinkWriteCallback of 'W ]
  val t_to_js: ('W -> Ojs.t) -> 'W t -> Ojs.t
  val t_of_js: (Ojs.t -> 'W) -> Ojs.t -> 'W t
  val t_1_to_js: ('W -> Ojs.t) -> 'W t_1 -> Ojs.t
  val t_1_of_js: (Ojs.t -> 'W) -> Ojs.t -> 'W t_1
  val apply: ('tags, 'W) this -> chunk:'W -> controller:WritableStreamDefaultController.t -> (unit, unit PromiseLike.t_1) union2 [@@js.apply]
  val cast_from: ('tags, 'W) this -> 'W t [@@js.custom let cast_from = Obj.magic]
end
module UnderlyingSinkStartCallback : sig
  type t = [`UnderlyingSinkStartCallback] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`UnderlyingSinkStartCallback]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`UnderlyingSinkStartCallback]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `UnderlyingSinkStartCallback ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val apply: 'tags this -> controller:WritableStreamDefaultController.t -> any [@@js.apply]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module UnderlyingSinkCloseCallback : sig
  type t = [`UnderlyingSinkCloseCallback] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`UnderlyingSinkCloseCallback]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`UnderlyingSinkCloseCallback]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `UnderlyingSinkCloseCallback ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val apply: 'tags this -> (unit, unit PromiseLike.t_1) union2 [@@js.apply]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module UnderlyingSinkAbortCallback : sig
  type t = [`UnderlyingSinkAbortCallback] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`UnderlyingSinkAbortCallback]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`UnderlyingSinkAbortCallback]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `UnderlyingSinkAbortCallback ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val apply: 'tags this -> ?reason:any -> unit -> (unit, unit PromiseLike.t_1) union2 [@@js.apply]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module UnderlyingSink : sig
  type 'W t = [`UnderlyingSink of 'W] intf [@@js.custom { of_js=(fun _W -> Obj.magic); to_js=(fun _W -> Obj.magic) }]
  type 'W t_1 = 'W t
  type t_0 = any t
  [@@@js.stop]
  type 'W tags = [`UnderlyingSink of 'W]
  type 'W tags_1 = 'W tags
  type tags_0 = any tags
  [@@@js.start]
  [@@@js.implem 
    type 'W tags = [`UnderlyingSink of 'W]
    type 'W tags_1 = 'W tags
    type tags_0 = any tags
  ]
  type ('tags, 'W) this = 'tags intf constraint 'tags = [> `UnderlyingSink of 'W ]
  val t_to_js: ('W -> Ojs.t) -> 'W t -> Ojs.t
  val t_of_js: (Ojs.t -> 'W) -> Ojs.t -> 'W t
  val t_1_to_js: ('W -> Ojs.t) -> 'W t_1 -> Ojs.t
  val t_1_of_js: (Ojs.t -> 'W) -> Ojs.t -> 'W t_1
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_abort: ('tags, 'W) this -> UnderlyingSinkAbortCallback.t option [@@js.get "abort"]
  val set_abort: ('tags, 'W) this -> UnderlyingSinkAbortCallback.t -> unit [@@js.set "abort"]
  val get_close: ('tags, 'W) this -> UnderlyingSinkCloseCallback.t option [@@js.get "close"]
  val set_close: ('tags, 'W) this -> UnderlyingSinkCloseCallback.t -> unit [@@js.set "close"]
  val get_start: ('tags, 'W) this -> UnderlyingSinkStartCallback.t option [@@js.get "start"]
  val set_start: ('tags, 'W) this -> UnderlyingSinkStartCallback.t -> unit [@@js.set "start"]
  val get_type: ('tags, 'W) this -> undefined [@@js.get "type"]
  val set_type: ('tags, 'W) this -> undefined -> unit [@@js.set "type"]
  val get_write: ('tags, 'W) this -> 'W UnderlyingSinkWriteCallback.t option [@@js.get "write"]
  val set_write: ('tags, 'W) this -> 'W UnderlyingSinkWriteCallback.t -> unit [@@js.set "write"]
  val create: ?abort:UnderlyingSinkAbortCallback.t -> ?close:UnderlyingSinkCloseCallback.t -> ?start:UnderlyingSinkStartCallback.t -> ?type_:(never[@js "type"]) -> ?write:'W UnderlyingSinkWriteCallback.t -> unit -> 'W t [@@js.builder]
  val cast_from: ('tags, 'W) this -> 'W t [@@js.custom let cast_from = Obj.magic]
end
module QueuingStrategySize : sig
  type 'T t = [`QueuingStrategySize of 'T] intf [@@js.custom { of_js=(fun _T -> Obj.magic); to_js=(fun _T -> Obj.magic) }]
  type 'T t_1 = 'T t
  type t_0 = any t
  [@@@js.stop]
  type 'T tags = [`QueuingStrategySize of 'T]
  type 'T tags_1 = 'T tags
  type tags_0 = any tags
  [@@@js.start]
  [@@@js.implem 
    type 'T tags = [`QueuingStrategySize of 'T]
    type 'T tags_1 = 'T tags
    type tags_0 = any tags
  ]
  type ('tags, 'T) this = 'tags intf constraint 'tags = [> `QueuingStrategySize of 'T ]
  val t_to_js: ('T -> Ojs.t) -> 'T t -> Ojs.t
  val t_of_js: (Ojs.t -> 'T) -> Ojs.t -> 'T t
  val t_1_to_js: ('T -> Ojs.t) -> 'T t_1 -> Ojs.t
  val t_1_of_js: (Ojs.t -> 'T) -> Ojs.t -> 'T t_1
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val apply: ('tags, 'T) this -> chunk:'T -> float [@@js.apply]
  val cast_from: ('tags, 'T) this -> 'T t [@@js.custom let cast_from = Obj.magic]
end
module QueuingStrategy : sig
  type 'T t = [`QueuingStrategy of 'T] intf [@@js.custom { of_js=(fun _T -> Obj.magic); to_js=(fun _T -> Obj.magic) }]
  type 'T t_1 = 'T t
  type t_0 = any t
  [@@@js.stop]
  type 'T tags = [`QueuingStrategy of 'T]
  type 'T tags_1 = 'T tags
  type tags_0 = any tags
  [@@@js.start]
  [@@@js.implem 
    type 'T tags = [`QueuingStrategy of 'T]
    type 'T tags_1 = 'T tags
    type tags_0 = any tags
  ]
  type ('tags, 'T) this = 'tags intf constraint 'tags = [> `QueuingStrategy of 'T ]
  val t_to_js: ('T -> Ojs.t) -> 'T t -> Ojs.t
  val t_of_js: (Ojs.t -> 'T) -> Ojs.t -> 'T t
  val t_1_to_js: ('T -> Ojs.t) -> 'T t_1 -> Ojs.t
  val t_1_of_js: (Ojs.t -> 'T) -> Ojs.t -> 'T t_1
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_highWaterMark: ('tags, 'T) this -> float option [@@js.get "highWaterMark"]
  val set_highWaterMark: ('tags, 'T) this -> float -> unit [@@js.set "highWaterMark"]
  val get_size: ('tags, 'T) this -> 'T QueuingStrategySize.t option [@@js.get "size"]
  val set_size: ('tags, 'T) this -> 'T QueuingStrategySize.t -> unit [@@js.set "size"]
  val create: ?highWaterMark:float -> ?size:'T QueuingStrategySize.t -> unit -> 'T t [@@js.builder]
  val cast_from: ('tags, 'T) this -> 'T t [@@js.custom let cast_from = Obj.magic]
end

(** This Streams API interface provides a standard abstraction for writing streaming data to a destination, known as a sink. This object comes with built-in backpressure and queuing. *)
module[@js.scope "WritableStream"] rec WritableStream : sig
  type 'W t = [`WritableStream of 'W] intf [@@js.custom { of_js=(fun _W -> Obj.magic); to_js=(fun _W -> Obj.magic) }]
  type 'W t_1 = 'W t
  type t_0 = any t
  [@@@js.stop]
  type 'W tags = [`WritableStream of 'W]
  type 'W tags_1 = 'W tags
  type tags_0 = any tags
  [@@@js.start]
  [@@@js.implem 
    type 'W tags = [`WritableStream of 'W]
    type 'W tags_1 = 'W tags
    type tags_0 = any tags
  ]
  type ('tags, 'W) this = 'tags intf constraint 'tags = [> `WritableStream of 'W ]
  val t_to_js: ('W -> Ojs.t) -> 'W t -> Ojs.t
  val t_of_js: (Ojs.t -> 'W) -> Ojs.t -> 'W t
  val t_1_to_js: ('W -> Ojs.t) -> 'W t_1 -> Ojs.t
  val t_1_of_js: (Ojs.t -> 'W) -> Ojs.t -> 'W t_1
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_locked: ('tags, 'W) this -> bool [@@js.get "locked"]
  val abort: ('tags, 'W) this -> ?reason:any -> unit -> unit Promise.t_1 [@@js.call "abort"]
  val close: ('tags, 'W) this -> unit Promise.t_1 [@@js.call "close"]
  val getWriter: ('tags, 'W) this -> 'W WritableStreamDefaultWriter.t [@@js.call "getWriter"]
  val cast_from: ('tags, 'W) this -> 'W t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t_0 [@@js.get "prototype"]
  val create: ?underlyingSink:'W UnderlyingSink.t -> ?strategy:'W QueuingStrategy.t -> unit -> 'W t [@@js.create]
end

(** This Streams API interface is the object returned by WritableStream.getWriter() and once created locks the < writer to the WritableStream ensuring that no other streams can write to the underlying sink. *)
and[@js.scope "WritableStreamDefaultWriter"] WritableStreamDefaultWriter : sig
  type 'W t = [`WritableStreamDefaultWriter of 'W] intf [@@js.custom { of_js=(fun _W -> Obj.magic); to_js=(fun _W -> Obj.magic) }]
  type 'W t_1 = 'W t
  type t_0 = any t
  [@@@js.stop]
  type 'W tags = [`WritableStreamDefaultWriter of 'W]
  type 'W tags_1 = 'W tags
  type tags_0 = any tags
  [@@@js.start]
  [@@@js.implem 
    type 'W tags = [`WritableStreamDefaultWriter of 'W]
    type 'W tags_1 = 'W tags
    type tags_0 = any tags
  ]
  type ('tags, 'W) this = 'tags intf constraint 'tags = [> `WritableStreamDefaultWriter of 'W ]
  val t_to_js: ('W -> Ojs.t) -> 'W t -> Ojs.t
  val t_of_js: (Ojs.t -> 'W) -> Ojs.t -> 'W t
  val t_1_to_js: ('W -> Ojs.t) -> 'W t_1 -> Ojs.t
  val t_1_of_js: (Ojs.t -> 'W) -> Ojs.t -> 'W t_1
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_closed: ('tags, 'W) this -> undefined Promise.t_1 [@@js.get "closed"]
  val get_desiredSize: ('tags, 'W) this -> float option [@@js.get "desiredSize"]
  val get_ready: ('tags, 'W) this -> undefined Promise.t_1 [@@js.get "ready"]
  val abort: ('tags, 'W) this -> ?reason:any -> unit -> unit Promise.t_1 [@@js.call "abort"]
  val close: ('tags, 'W) this -> unit Promise.t_1 [@@js.call "close"]
  val releaseLock: ('tags, 'W) this -> unit [@@js.call "releaseLock"]
  val write: ('tags, 'W) this -> ?chunk:'W -> unit -> unit Promise.t_1 [@@js.call "write"]
  val cast_from: ('tags, 'W) this -> 'W t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t_0 [@@js.get "prototype"]
  val create: 'W WritableStream.t -> 'W t [@@js.create]
end
module ReadableStreamGenericReader : sig
  type t = [`ReadableStreamGenericReader] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ReadableStreamGenericReader]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ReadableStreamGenericReader]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ReadableStreamGenericReader ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_closed: 'tags this -> undefined Promise.t_1 [@@js.get "closed"]
  val cancel: 'tags this -> ?reason:any -> unit -> unit Promise.t_1 [@@js.call "cancel"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module ReadableStreamDefaultReadValueResult : sig
  type 'T t = [`ReadableStreamDefaultReadValueResult of 'T] intf [@@js.custom { of_js=(fun _T -> Obj.magic); to_js=(fun _T -> Obj.magic) }]
  type 'T t_1 = 'T t
  [@@@js.stop]
  type 'T tags = [`ReadableStreamDefaultReadValueResult of 'T]
  type 'T tags_1 = 'T tags
  [@@@js.start]
  [@@@js.implem 
    type 'T tags = [`ReadableStreamDefaultReadValueResult of 'T]
    type 'T tags_1 = 'T tags
  ]
  type ('tags, 'T) this = 'tags intf constraint 'tags = [> `ReadableStreamDefaultReadValueResult of 'T ]
  val t_to_js: ('T -> Ojs.t) -> 'T t -> Ojs.t
  val t_of_js: (Ojs.t -> 'T) -> Ojs.t -> 'T t
  val t_1_to_js: ('T -> Ojs.t) -> 'T t_1 -> Ojs.t
  val t_1_of_js: (Ojs.t -> 'T) -> Ojs.t -> 'T t_1
  val get_done: ('tags, 'T) this -> ([`L_b_false[@js false]] [@js.enum]) [@@js.get "done"]
  val set_done: ('tags, 'T) this -> ([`L_b_false[@js false]] [@js.enum]) -> unit [@@js.set "done"]
  val get_value: ('tags, 'T) this -> 'T [@@js.get "value"]
  val set_value: ('tags, 'T) this -> 'T -> unit [@@js.set "value"]
  val create: done_:(([`L_b_false[@js false]] [@js.enum])[@js "done"]) -> value:'T -> unit -> 'T t [@@js.builder]
  val cast_from: ('tags, 'T) this -> 'T t [@@js.custom let cast_from = Obj.magic]
end
module ReadableStreamDefaultReadDoneResult : sig
  type t = [`ReadableStreamDefaultReadDoneResult] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ReadableStreamDefaultReadDoneResult]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ReadableStreamDefaultReadDoneResult]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ReadableStreamDefaultReadDoneResult ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_done: 'tags this -> ([`L_b_true[@js true]] [@js.enum]) [@@js.get "done"]
  val set_done: 'tags this -> ([`L_b_true[@js true]] [@js.enum]) -> unit [@@js.set "done"]
  val get_value: 'tags this -> undefined [@@js.get "value"]
  val set_value: 'tags this -> undefined -> unit [@@js.set "value"]
  val create: done_:(([`L_b_true[@js true]] [@js.enum])[@js "done"]) -> ?value:never -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module ReadableStreamDefaultReadResult : sig
  type 'T t = ([`U_b_false of 'T ReadableStreamDefaultReadValueResult.t [@js false] | `U_b_true of ReadableStreamDefaultReadDoneResult.t [@js true]] [@js.union on_field "done"])
  type 'T t_1 = 'T t
  val t_to_js: ('T -> Ojs.t) -> 'T t -> Ojs.t
  val t_of_js: (Ojs.t -> 'T) -> Ojs.t -> 'T t
  val t_1_to_js: ('T -> Ojs.t) -> 'T t_1 -> Ojs.t
  val t_1_of_js: (Ojs.t -> 'T) -> Ojs.t -> 'T t_1
end

(** This Streams API interface represents a readable stream of byte data. The Fetch API offers a concrete instance of a ReadableStream through the body property of a Response object. *)
module[@js.scope "ReadableStream"] rec ReadableStream : sig
  type 'R t = [`ReadableStream of 'R] intf [@@js.custom { of_js=(fun _R -> Obj.magic); to_js=(fun _R -> Obj.magic) }]
  type 'R t_1 = 'R t
  type t_0 = any t
  [@@@js.stop]
  type 'R tags = [`ReadableStream of 'R]
  type 'R tags_1 = 'R tags
  type tags_0 = any tags
  [@@@js.start]
  [@@@js.implem 
    type 'R tags = [`ReadableStream of 'R]
    type 'R tags_1 = 'R tags
    type tags_0 = any tags
  ]
  type ('tags, 'R) this = 'tags intf constraint 'tags = [> `ReadableStream of 'R ]
  val t_to_js: ('R -> Ojs.t) -> 'R t -> Ojs.t
  val t_of_js: (Ojs.t -> 'R) -> Ojs.t -> 'R t
  val t_1_to_js: ('R -> Ojs.t) -> 'R t_1 -> Ojs.t
  val t_1_of_js: (Ojs.t -> 'R) -> Ojs.t -> 'R t_1
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_locked: ('tags, 'R) this -> bool [@@js.get "locked"]
  val cancel: ('tags, 'R) this -> ?reason:any -> unit -> unit Promise.t_1 [@@js.call "cancel"]
  val getReader: ('tags, 'R) this -> 'R ReadableStreamDefaultReader.t [@@js.call "getReader"]
  val pipeThrough: ('tags, 'R) this -> transform:('T, 'R) ReadableWritablePair.t -> ?options:StreamPipeOptions.t -> unit -> 'T t [@@js.call "pipeThrough"]
  val pipeTo: ('tags, 'R) this -> destination:'R WritableStream.t -> ?options:StreamPipeOptions.t -> unit -> unit Promise.t_1 [@@js.call "pipeTo"]
  val tee: ('tags, 'R) this -> ('R t * 'R t) [@@js.call "tee"]
  val cast_from: ('tags, 'R) this -> 'R t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t_0 [@@js.get "prototype"]
  val create: ?underlyingSource:'R UnderlyingSource.t -> ?strategy:'R QueuingStrategy.t -> unit -> 'R t [@@js.create]
end
and[@js.scope "ReadableStreamDefaultReader"] ReadableStreamDefaultReader : sig
  type 'R t = [`ReadableStreamDefaultReader of 'R | `ReadableStreamGenericReader] intf [@@js.custom { of_js=(fun _R -> Obj.magic); to_js=(fun _R -> Obj.magic) }]
  type 'R t_1 = 'R t
  type t_0 = any t
  [@@@js.stop]
  type 'R tags = [`ReadableStreamDefaultReader of 'R | `ReadableStreamGenericReader]
  type 'R tags_1 = 'R tags
  type tags_0 = any tags
  [@@@js.start]
  [@@@js.implem 
    type 'R tags = [`ReadableStreamDefaultReader of 'R | `ReadableStreamGenericReader]
    type 'R tags_1 = 'R tags
    type tags_0 = any tags
  ]
  type ('tags, 'R) this = 'tags intf constraint 'tags = [> `ReadableStreamDefaultReader of 'R ]
  val t_to_js: ('R -> Ojs.t) -> 'R t -> Ojs.t
  val t_of_js: (Ojs.t -> 'R) -> Ojs.t -> 'R t
  val t_1_to_js: ('R -> Ojs.t) -> 'R t_1 -> Ojs.t
  val t_1_of_js: (Ojs.t -> 'R) -> Ojs.t -> 'R t_1
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val read: ('tags, 'R) this -> 'R ReadableStreamDefaultReadResult.t Promise.t_1 [@@js.call "read"]
  val releaseLock: ('tags, 'R) this -> unit [@@js.call "releaseLock"]
  val cast_from: ('tags, 'R) this -> 'R t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t_0 [@@js.get "prototype"]
  val create: 'R ReadableStream.t -> 'R t [@@js.create]
end
and ReadableWritablePair : sig
  type ('R, 'W) t = [`ReadableWritablePair of ('R * 'W)] intf [@@js.custom { of_js=(fun _R _W -> Obj.magic); to_js=(fun _R _W -> Obj.magic) }]
  type ('R, 'W) t_2 = ('R, 'W) t
  type 'R t_1 = ('R, any) t
  type t_0 = (any, any) t
  [@@@js.stop]
  type ('R, 'W) tags = [`ReadableWritablePair of ('R * 'W)]
  type ('R, 'W) tags_2 = ('R, 'W) tags
  type 'R tags_1 = ('R, any) tags
  type tags_0 = (any, any) tags
  [@@@js.start]
  [@@@js.implem 
    type ('R, 'W) tags = [`ReadableWritablePair of ('R * 'W)]
    type ('R, 'W) tags_2 = ('R, 'W) tags
    type 'R tags_1 = ('R, any) tags
    type tags_0 = (any, any) tags
  ]
  type ('tags, 'R, 'W) this = 'tags intf constraint 'tags = [> `ReadableWritablePair of ('R * 'W) ]
  val t_to_js: ('R -> Ojs.t) -> ('W -> Ojs.t) -> ('R, 'W) t -> Ojs.t
  val t_of_js: (Ojs.t -> 'R) -> (Ojs.t -> 'W) -> Ojs.t -> ('R, 'W) t
  val t_2_to_js: ('R -> Ojs.t) -> ('W -> Ojs.t) -> ('R, 'W) t_2 -> Ojs.t
  val t_2_of_js: (Ojs.t -> 'R) -> (Ojs.t -> 'W) -> Ojs.t -> ('R, 'W) t_2
  val t_1_to_js: ('R -> Ojs.t) -> 'R t_1 -> Ojs.t
  val t_1_of_js: (Ojs.t -> 'R) -> Ojs.t -> 'R t_1
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_readable: ('tags, 'R, 'W) this -> 'R ReadableStream.t [@@js.get "readable"]
  val set_readable: ('tags, 'R, 'W) this -> 'R ReadableStream.t -> unit [@@js.set "readable"]
  
  (**
    Provides a convenient, chainable way of piping this readable stream through a transform stream (or any other \{ writable, readable \} pair). It simply pipes the stream into the writable side of the supplied pair, and returns the readable side for further use.
    
    Piping a stream will lock it for the duration of the pipe, preventing any other consumer from acquiring a reader.
  *)
  val get_writable: ('tags, 'R, 'W) this -> 'W WritableStream.t [@@js.get "writable"]
  
  (**
    Provides a convenient, chainable way of piping this readable stream through a transform stream (or any other \{ writable, readable \} pair). It simply pipes the stream into the writable side of the supplied pair, and returns the readable side for further use.
    
    Piping a stream will lock it for the duration of the pipe, preventing any other consumer from acquiring a reader.
  *)
  val set_writable: ('tags, 'R, 'W) this -> 'W WritableStream.t -> unit [@@js.set "writable"]
  val create: readable:'R ReadableStream.t -> writable:'W WritableStream.t -> unit -> ('R, 'W) t [@@js.builder]
  val cast_from: ('tags, 'R, 'W) this -> ('R, 'W) t [@@js.custom let cast_from = Obj.magic]
end
module EndingType : sig
  type t = ([`L_s531_native[@js "native"] | `L_s816_transparent[@js "transparent"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module BlobPropertyBag : sig
  type t = [`BlobPropertyBag] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`BlobPropertyBag]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`BlobPropertyBag]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `BlobPropertyBag ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_endings: 'tags this -> EndingType.t option [@@js.get "endings"]
  val set_endings: 'tags this -> EndingType.t -> unit [@@js.set "endings"]
  val get_type: 'tags this -> string option [@@js.get "type"]
  val set_type: 'tags this -> string -> unit [@@js.set "type"]
  val create: ?endings:EndingType.t -> ?type_:(string[@js "type"]) -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** A file-like object of immutable, raw data. Blobs represent data that isn't necessarily in a JavaScript-native format. The File interface is based on Blob, inheriting blob functionality and expanding it to support files on the user's system. *)
module[@js.scope "Blob"] rec Blob : sig
  type t = [`Blob] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Blob]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Blob]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `Blob ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_size: 'tags this -> float [@@js.get "size"]
  val get_type: 'tags this -> string [@@js.get "type"]
  val arrayBuffer: 'tags this -> ArrayBuffer.t_0 Promise.t_1 [@@js.call "arrayBuffer"]
  val slice: 'tags this -> ?start:float -> ?end_:float -> ?contentType:string -> unit -> t [@@js.call "slice"]
  val stream: 'tags this -> ReadableStream.t_0 [@@js.call "stream"]
  val text: 'tags this -> string Promise.t_1 [@@js.call "text"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: ?blobParts:BlobPart.t list -> ?options:BlobPropertyBag.t -> unit -> t [@@js.create]
end
and BlobPart : sig
  type t = ([`String of string | `Other of (Blob.t, BufferSource.t) union2] [@js.union on_field "dummy"]) Primitive.t
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end

(**
  The URL interface represents an object providing static methods used for creating object URLs.
  
  
  `URL` class is a global reference for `require('url').URL`
  https://nodejs.org/api/url.html#the-whatwg-url-api
*)
module[@js.scope "URL"] URL : sig
  type t = [`URL] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`URL]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`URL]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `URL ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_hash: 'tags this -> string [@@js.get "hash"]
  val set_hash: 'tags this -> string -> unit [@@js.set "hash"]
  val get_host: 'tags this -> string [@@js.get "host"]
  val set_host: 'tags this -> string -> unit [@@js.set "host"]
  val get_hostname: 'tags this -> string [@@js.get "hostname"]
  val set_hostname: 'tags this -> string -> unit [@@js.set "hostname"]
  val get_href: 'tags this -> string [@@js.get "href"]
  val set_href: 'tags this -> string -> unit [@@js.set "href"]
  val toString: 'tags this -> string [@@js.call "toString"]
  val get_origin: 'tags this -> string [@@js.get "origin"]
  val get_password: 'tags this -> string [@@js.get "password"]
  val set_password: 'tags this -> string -> unit [@@js.set "password"]
  val get_pathname: 'tags this -> string [@@js.get "pathname"]
  val set_pathname: 'tags this -> string -> unit [@@js.set "pathname"]
  val get_port: 'tags this -> string [@@js.get "port"]
  val set_port: 'tags this -> string -> unit [@@js.set "port"]
  val get_protocol: 'tags this -> string [@@js.get "protocol"]
  val set_protocol: 'tags this -> string -> unit [@@js.set "protocol"]
  val get_search: 'tags this -> string [@@js.get "search"]
  val set_search: 'tags this -> string -> unit [@@js.set "search"]
  val get_searchParams: 'tags this -> URLSearchParams.t [@@js.get "searchParams"]
  val get_username: 'tags this -> string [@@js.get "username"]
  val set_username: 'tags this -> string -> unit [@@js.set "username"]
  val toJSON: 'tags this -> string [@@js.call "toJSON"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: url:([`U1 of string | `U2 of t] [@js.union]) -> ?base:([`U1 of string | `U2 of t] [@js.union]) -> unit -> t [@@js.create]
  val createObjectURL: ([`U1 of Blob.t | `U2 of MediaSource.t] [@js.union]) -> string [@@js.global "createObjectURL"]
  val revokeObjectURL: string -> unit [@@js.global "revokeObjectURL"]
end
module[@js.scope "webkitURL"] WebkitURL : sig
  type t = URL.t
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val prototype: unit -> URL.t [@@js.get "prototype"]
  val create: url:([`U1 of string | `U2 of URL.t] [@js.union]) -> ?base:([`U1 of string | `U2 of URL.t] [@js.union]) -> unit -> URL.t [@@js.create]
  val createObjectURL: ([`U1 of Blob.t | `U2 of MediaSource.t] [@js.union]) -> string [@@js.global "createObjectURL"]
  val revokeObjectURL: string -> unit [@@js.global "revokeObjectURL"]
end
module[@js.scope "VisualViewport"] VisualViewport : sig
  type t = [`EventTarget | `VisualViewport] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventTarget | `VisualViewport]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventTarget | `VisualViewport]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `VisualViewport ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_height: 'tags this -> float [@@js.get "height"]
  val get_offsetLeft: 'tags this -> float [@@js.get "offsetLeft"]
  val get_offsetTop: 'tags this -> float [@@js.get "offsetTop"]
  val get_onresize: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onresize"]
  val set_onresize: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onresize"]
  val get_onscroll: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onscroll"]
  val set_onscroll: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onscroll"]
  val get_pageLeft: 'tags this -> float [@@js.get "pageLeft"]
  val get_pageTop: 'tags this -> float [@@js.get "pageTop"]
  val get_scale: 'tags this -> float [@@js.get "scale"]
  val get_width: 'tags this -> float [@@js.get "width"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'VisualViewportEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'VisualViewportEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module[@js.scope "visualViewport"] VisualViewportStatic : sig
  val height: unit -> float [@@js.get "height"]
  val offsetLeft: unit -> float [@@js.get "offsetLeft"]
  val offsetTop: unit -> float [@@js.get "offsetTop"]
  val onresize: unit -> (this:VisualViewport.t -> ev:Event.t -> any) option [@@js.get "onresize"]
  val onscroll: unit -> (this:VisualViewport.t -> ev:Event.t -> any) option [@@js.get "onscroll"]
  val pageLeft: unit -> float [@@js.get "pageLeft"]
  val pageTop: unit -> float [@@js.get "pageTop"]
  val scale: unit -> float [@@js.get "scale"]
  val width: unit -> float [@@js.get "width"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: type_:'K -> listener:(this:VisualViewport.t -> ev:(* FIXME: unknown type 'VisualViewportEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.global "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.global "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: type_:'K -> listener:(this:VisualViewport.t -> ev:(* FIXME: unknown type 'VisualViewportEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.global "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.global "removeEventListener"]
end
module[@js.scope "toolbar"] ToolbarStatic : sig
  val visible: unit -> bool [@@js.get "visible"]
end
module[@js.scope "statusbar"] StatusbarStatic : sig
  val visible: unit -> bool [@@js.get "visible"]
end

(** This Web Speech API interface represents a voice that the system supports. Every SpeechSynthesisVoice has its own relative speech service including information about language, name and URI. *)
module[@js.scope "SpeechSynthesisVoice"] SpeechSynthesisVoice : sig
  type t = [`SpeechSynthesisVoice] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`SpeechSynthesisVoice]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`SpeechSynthesisVoice]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SpeechSynthesisVoice ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_default: 'tags this -> bool [@@js.get "default"]
  val get_lang: 'tags this -> string [@@js.get "lang"]
  val get_localService: 'tags this -> bool [@@js.get "localService"]
  val get_name: 'tags this -> string [@@js.get "name"]
  val get_voiceURI: 'tags this -> string [@@js.get "voiceURI"]
  val create: default:bool -> lang:string -> localService:bool -> name:string -> voiceURI:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end
module SpeechSynthesisErrorCode : sig
  type t = ([`L_s134_audio_busy[@js "audio-busy"] | `L_s135_audio_hardware[@js "audio-hardware"] | `L_s177_canceled[@js "canceled"] | `L_s436_interrupted[@js "interrupted"] | `L_s438_invalid_argument[@js "invalid-argument"] | `L_s452_language_unavailable[@js "language-unavailable"] | `L_s537_network[@js "network"] | `L_s552_not_allowed[@js "not-allowed"] | `L_s779_synthesis_failed[@js "synthesis-failed"] | `L_s780_synthesis_unavailable[@js "synthesis-unavailable"] | `L_s788_text_too_long[@js "text-too-long"] | `L_s857_voice_unavailable[@js "voice-unavailable"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module[@js.scope "SpeechSynthesisErrorEvent"] rec SpeechSynthesisErrorEvent : sig
  type t = [`Event | `SpeechSynthesisErrorEvent | `SpeechSynthesisEvent] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Event | `SpeechSynthesisErrorEvent | `SpeechSynthesisEvent]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Event | `SpeechSynthesisErrorEvent | `SpeechSynthesisEvent]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SpeechSynthesisErrorEvent ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_error: 'tags this -> SpeechSynthesisErrorCode.t [@@js.get "error"]
  val create: error:SpeechSynthesisErrorCode.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': type_:string -> eventInitDict:SpeechSynthesisErrorEventInit.t -> t [@@js.create]
end
and SpeechSynthesisErrorEventInit : sig
  type t = [`EventInit | `SpeechSynthesisErrorEventInit | `SpeechSynthesisEventInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventInit | `SpeechSynthesisErrorEventInit | `SpeechSynthesisEventInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventInit | `SpeechSynthesisErrorEventInit | `SpeechSynthesisEventInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SpeechSynthesisErrorEventInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_error: 'tags this -> SpeechSynthesisErrorCode.t [@@js.get "error"]
  val set_error: 'tags this -> SpeechSynthesisErrorCode.t -> unit [@@js.set "error"]
  val create: error:SpeechSynthesisErrorCode.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** This Web Speech API interface contains information about the current state of SpeechSynthesisUtterance objects that have been processed in the speech service. *)
and[@js.scope "SpeechSynthesisEvent"] SpeechSynthesisEvent : sig
  type t = [`Event | `SpeechSynthesisEvent] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Event | `SpeechSynthesisEvent]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Event | `SpeechSynthesisEvent]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SpeechSynthesisEvent ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_charIndex: 'tags this -> float [@@js.get "charIndex"]
  val get_charLength: 'tags this -> float [@@js.get "charLength"]
  val get_elapsedTime: 'tags this -> float [@@js.get "elapsedTime"]
  val get_name: 'tags this -> string [@@js.get "name"]
  val get_utterance: 'tags this -> SpeechSynthesisUtterance.t [@@js.get "utterance"]
  val create: charIndex:float -> charLength:float -> elapsedTime:float -> name:string -> utterance:SpeechSynthesisUtterance.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': type_:string -> eventInitDict:SpeechSynthesisEventInit.t -> t [@@js.create]
end
and SpeechSynthesisEventInit : sig
  type t = [`EventInit | `SpeechSynthesisEventInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventInit | `SpeechSynthesisEventInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventInit | `SpeechSynthesisEventInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SpeechSynthesisEventInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_charIndex: 'tags this -> float option [@@js.get "charIndex"]
  val set_charIndex: 'tags this -> float -> unit [@@js.set "charIndex"]
  val get_charLength: 'tags this -> float option [@@js.get "charLength"]
  val set_charLength: 'tags this -> float -> unit [@@js.set "charLength"]
  val get_elapsedTime: 'tags this -> float option [@@js.get "elapsedTime"]
  val set_elapsedTime: 'tags this -> float -> unit [@@js.set "elapsedTime"]
  val get_name: 'tags this -> string option [@@js.get "name"]
  val set_name: 'tags this -> string -> unit [@@js.set "name"]
  val get_utterance: 'tags this -> SpeechSynthesisUtterance.t [@@js.get "utterance"]
  val set_utterance: 'tags this -> SpeechSynthesisUtterance.t -> unit [@@js.set "utterance"]
  val create: ?charIndex:float -> ?charLength:float -> ?elapsedTime:float -> ?name:string -> utterance:SpeechSynthesisUtterance.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** This Web Speech API interface represents a speech request. It contains the content the speech service should read and information about how to read it (e.g. language, pitch and volume.) *)
and[@js.scope "SpeechSynthesisUtterance"] SpeechSynthesisUtterance : sig
  type t = [`EventTarget | `SpeechSynthesisUtterance] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventTarget | `SpeechSynthesisUtterance]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventTarget | `SpeechSynthesisUtterance]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SpeechSynthesisUtterance ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_lang: 'tags this -> string [@@js.get "lang"]
  val set_lang: 'tags this -> string -> unit [@@js.set "lang"]
  val get_onboundary: 'tags this -> (this:t -> ev:SpeechSynthesisEvent.t -> any) option [@@js.get "onboundary"]
  val set_onboundary: 'tags this -> (this:t -> ev:SpeechSynthesisEvent.t -> any) option -> unit [@@js.set "onboundary"]
  val get_onend: 'tags this -> (this:t -> ev:SpeechSynthesisEvent.t -> any) option [@@js.get "onend"]
  val set_onend: 'tags this -> (this:t -> ev:SpeechSynthesisEvent.t -> any) option -> unit [@@js.set "onend"]
  val get_onerror: 'tags this -> (this:t -> ev:SpeechSynthesisErrorEvent.t -> any) option [@@js.get "onerror"]
  val set_onerror: 'tags this -> (this:t -> ev:SpeechSynthesisErrorEvent.t -> any) option -> unit [@@js.set "onerror"]
  val get_onmark: 'tags this -> (this:t -> ev:SpeechSynthesisEvent.t -> any) option [@@js.get "onmark"]
  val set_onmark: 'tags this -> (this:t -> ev:SpeechSynthesisEvent.t -> any) option -> unit [@@js.set "onmark"]
  val get_onpause: 'tags this -> (this:t -> ev:SpeechSynthesisEvent.t -> any) option [@@js.get "onpause"]
  val set_onpause: 'tags this -> (this:t -> ev:SpeechSynthesisEvent.t -> any) option -> unit [@@js.set "onpause"]
  val get_onresume: 'tags this -> (this:t -> ev:SpeechSynthesisEvent.t -> any) option [@@js.get "onresume"]
  val set_onresume: 'tags this -> (this:t -> ev:SpeechSynthesisEvent.t -> any) option -> unit [@@js.set "onresume"]
  val get_onstart: 'tags this -> (this:t -> ev:SpeechSynthesisEvent.t -> any) option [@@js.get "onstart"]
  val set_onstart: 'tags this -> (this:t -> ev:SpeechSynthesisEvent.t -> any) option -> unit [@@js.set "onstart"]
  val get_pitch: 'tags this -> float [@@js.get "pitch"]
  val set_pitch: 'tags this -> float -> unit [@@js.set "pitch"]
  val get_rate: 'tags this -> float [@@js.get "rate"]
  val set_rate: 'tags this -> float -> unit [@@js.set "rate"]
  val get_text: 'tags this -> string [@@js.get "text"]
  val set_text: 'tags this -> string -> unit [@@js.set "text"]
  val get_voice: 'tags this -> SpeechSynthesisVoice.t option [@@js.get "voice"]
  val set_voice: 'tags this -> SpeechSynthesisVoice.t option -> unit [@@js.set "voice"]
  val get_volume: 'tags this -> float [@@js.get "volume"]
  val set_volume: 'tags this -> float -> unit [@@js.set "volume"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SpeechSynthesisUtteranceEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SpeechSynthesisUtteranceEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: ?text:string -> unit -> t [@@js.create]
end

(** This Web Speech API interface is the controller interface for the speech service; this can be used to retrieve information about the synthesis voices available on the device, start and pause speech, and other commands besides. *)
module[@js.scope "SpeechSynthesis"] SpeechSynthesis : sig
  type t = [`EventTarget | `SpeechSynthesis] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventTarget | `SpeechSynthesis]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventTarget | `SpeechSynthesis]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SpeechSynthesis ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_onvoiceschanged: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onvoiceschanged"]
  val set_onvoiceschanged: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onvoiceschanged"]
  val get_paused: 'tags this -> bool [@@js.get "paused"]
  val get_pending: 'tags this -> bool [@@js.get "pending"]
  val get_speaking: 'tags this -> bool [@@js.get "speaking"]
  val cancel: 'tags this -> unit [@@js.call "cancel"]
  val getVoices: 'tags this -> SpeechSynthesisVoice.t list [@@js.call "getVoices"]
  val pause: 'tags this -> unit [@@js.call "pause"]
  val resume: 'tags this -> unit [@@js.call "resume"]
  val speak: 'tags this -> utterance:SpeechSynthesisUtterance.t -> unit [@@js.call "speak"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SpeechSynthesisEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SpeechSynthesisEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module[@js.scope "speechSynthesis"] SpeechSynthesisStatic : sig
  val onvoiceschanged: unit -> (this:SpeechSynthesis.t -> ev:Event.t -> any) option [@@js.get "onvoiceschanged"]
  val paused: unit -> bool [@@js.get "paused"]
  val pending: unit -> bool [@@js.get "pending"]
  val speaking: unit -> bool [@@js.get "speaking"]
  val cancel: unit -> unit [@@js.global "cancel"]
  val getVoices: unit -> SpeechSynthesisVoice.t list [@@js.global "getVoices"]
  val pause: unit -> unit [@@js.global "pause"]
  val resume: unit -> unit [@@js.global "resume"]
  val speak: SpeechSynthesisUtterance.t -> unit [@@js.global "speak"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: type_:'K -> listener:(this:SpeechSynthesis.t -> ev:(* FIXME: unknown type 'SpeechSynthesisEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.global "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.global "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: type_:'K -> listener:(this:SpeechSynthesis.t -> ev:(* FIXME: unknown type 'SpeechSynthesisEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.global "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.global "removeEventListener"]
end
module[@js.scope "sessionStorage"] SessionStorageStatic : sig
  
  (** Returns the number of key/value pairs. *)
  val length: unit -> float [@@js.get "length"]
  
  (**
    Removes all key/value pairs, if there are any.
    
    Dispatches a storage event on Window objects holding an equivalent Storage object.
  *)
  val clear: unit -> unit [@@js.global "clear"]
  
  (** Returns the current value associated with the given key, or null if the given key does not exist. *)
  val getItem: string -> string option [@@js.global "getItem"]
  
  (** Returns the name of the nth key, or null if n is greater than or equal to the number of key/value pairs. *)
  val key: float -> string option [@@js.global "key"]
  
  (**
    Removes the key/value pair with the given key, if a key/value pair with the given key exists.
    
    Dispatches a storage event on Window objects holding an equivalent Storage object.
  *)
  val removeItem: string -> unit [@@js.global "removeItem"]
  
  (**
    Sets the value of the pair identified by key to value, creating a new key/value pair if none existed for key previously.
    
    Throws a "QuotaExceededError" DOMException exception if the new value couldn't be set. (Setting could fail if, e.g., the user has disabled storage for the site, or if the quota has been exceeded.)
    
    Dispatches a storage event on Window objects holding an equivalent Storage object.
  *)
  val setItem: key:string -> value:string -> unit [@@js.global "setItem"]
  (* unsupported indexer of type: (~name:String -> Any) *)
end
module[@js.scope "scrollbars"] ScrollbarsStatic : sig
  val visible: unit -> bool [@@js.get "visible"]
end
module OrientationType : sig
  type t = ([`L_s450_landscape_primary[@js "landscape-primary"] | `L_s451_landscape_secondary[@js "landscape-secondary"] | `L_s623_portrait_primary[@js "portrait-primary"] | `L_s624_portrait_secondary[@js "portrait-secondary"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module OrientationLockType : sig
  type t = ([`L_s121_any[@js "any"] | `L_s449_landscape[@js "landscape"] | `L_s450_landscape_primary[@js "landscape-primary"] | `L_s451_landscape_secondary[@js "landscape-secondary"] | `L_s532_natural[@js "natural"] | `L_s622_portrait[@js "portrait"] | `L_s623_portrait_primary[@js "portrait-primary"] | `L_s624_portrait_secondary[@js "portrait-secondary"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module[@js.scope "ScreenOrientation"] ScreenOrientation : sig
  type t = [`EventTarget | `ScreenOrientation] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventTarget | `ScreenOrientation]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventTarget | `ScreenOrientation]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ScreenOrientation ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_angle: 'tags this -> float [@@js.get "angle"]
  val get_onchange: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onchange"]
  val set_onchange: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onchange"]
  val get_type: 'tags this -> OrientationType.t [@@js.get "type"]
  val lock: 'tags this -> orientation:OrientationLockType.t -> unit Promise.t_1 [@@js.call "lock"]
  val unlock: 'tags this -> unit [@@js.call "unlock"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'ScreenOrientationEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'ScreenOrientationEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module[@js.scope "screen"] ScreenStatic : sig
  val availHeight: unit -> float [@@js.get "availHeight"]
  val availWidth: unit -> float [@@js.get "availWidth"]
  val colorDepth: unit -> float [@@js.get "colorDepth"]
  val height: unit -> float [@@js.get "height"]
  val orientation: unit -> ScreenOrientation.t [@@js.get "orientation"]
  val pixelDepth: unit -> float [@@js.get "pixelDepth"]
  val width: unit -> float [@@js.get "width"]
end
module[@js.scope "personalbar"] PersonalbarStatic : sig
  val visible: unit -> bool [@@js.get "visible"]
end

(** A legacy interface kept for backwards compatibility and contains properties that offer performance timing information for various events which occur during the loading and use of the current page. You get a PerformanceTiming object describing your page using the window.performance.timing property. *)
module[@js.scope "PerformanceTiming"] PerformanceTiming : sig
  type t = [`PerformanceTiming] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`PerformanceTiming]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`PerformanceTiming]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PerformanceTiming ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** @deprecated  *)
  val get_connectEnd: 'tags this -> float [@@js.get "connectEnd"]
  
  (** @deprecated  *)
  val get_connectStart: 'tags this -> float [@@js.get "connectStart"]
  
  (** @deprecated  *)
  val get_domComplete: 'tags this -> float [@@js.get "domComplete"]
  
  (** @deprecated  *)
  val get_domContentLoadedEventEnd: 'tags this -> float [@@js.get "domContentLoadedEventEnd"]
  
  (** @deprecated  *)
  val get_domContentLoadedEventStart: 'tags this -> float [@@js.get "domContentLoadedEventStart"]
  
  (** @deprecated  *)
  val get_domInteractive: 'tags this -> float [@@js.get "domInteractive"]
  
  (** @deprecated  *)
  val get_domLoading: 'tags this -> float [@@js.get "domLoading"]
  
  (** @deprecated  *)
  val get_domainLookupEnd: 'tags this -> float [@@js.get "domainLookupEnd"]
  
  (** @deprecated  *)
  val get_domainLookupStart: 'tags this -> float [@@js.get "domainLookupStart"]
  
  (** @deprecated  *)
  val get_fetchStart: 'tags this -> float [@@js.get "fetchStart"]
  
  (** @deprecated  *)
  val get_loadEventEnd: 'tags this -> float [@@js.get "loadEventEnd"]
  
  (** @deprecated  *)
  val get_loadEventStart: 'tags this -> float [@@js.get "loadEventStart"]
  
  (** @deprecated  *)
  val get_navigationStart: 'tags this -> float [@@js.get "navigationStart"]
  
  (** @deprecated  *)
  val get_redirectEnd: 'tags this -> float [@@js.get "redirectEnd"]
  
  (** @deprecated  *)
  val get_redirectStart: 'tags this -> float [@@js.get "redirectStart"]
  
  (** @deprecated  *)
  val get_requestStart: 'tags this -> float [@@js.get "requestStart"]
  
  (** @deprecated  *)
  val get_responseEnd: 'tags this -> float [@@js.get "responseEnd"]
  
  (** @deprecated  *)
  val get_responseStart: 'tags this -> float [@@js.get "responseStart"]
  
  (** @deprecated  *)
  val get_secureConnectionStart: 'tags this -> float [@@js.get "secureConnectionStart"]
  
  (** @deprecated  *)
  val get_unloadEventEnd: 'tags this -> float [@@js.get "unloadEventEnd"]
  
  (** @deprecated  *)
  val get_unloadEventStart: 'tags this -> float [@@js.get "unloadEventStart"]
  
  (** @deprecated  *)
  val toJSON: 'tags this -> any [@@js.call "toJSON"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** The legacy PerformanceNavigation interface represents information about how the navigation to the current document was done. *)
module[@js.scope "PerformanceNavigation"] PerformanceNavigation : sig
  type t = [`PerformanceNavigation] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`PerformanceNavigation]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`PerformanceNavigation]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PerformanceNavigation ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** @deprecated  *)
  val get_redirectCount: 'tags this -> float [@@js.get "redirectCount"]
  
  (** @deprecated  *)
  val get_type: 'tags this -> float [@@js.get "type"]
  
  (** @deprecated  *)
  val toJSON: 'tags this -> any [@@js.call "toJSON"]
  val get_TYPE_BACK_FORWARD: 'tags this -> float [@@js.get "TYPE_BACK_FORWARD"]
  val get_TYPE_NAVIGATE: 'tags this -> float [@@js.get "TYPE_NAVIGATE"]
  val get_TYPE_RELOAD: 'tags this -> float [@@js.get "TYPE_RELOAD"]
  val get_TYPE_RESERVED: 'tags this -> float [@@js.get "TYPE_RESERVED"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
  val type_back_forward: unit -> float [@@js.get "TYPE_BACK_FORWARD"]
  val type_navigate: unit -> float [@@js.get "TYPE_NAVIGATE"]
  val type_reload: unit -> float [@@js.get "TYPE_RELOAD"]
  val type_reserved: unit -> float [@@js.get "TYPE_RESERVED"]
end
module PerformanceMeasureOptions : sig
  type t = [`PerformanceMeasureOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`PerformanceMeasureOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`PerformanceMeasureOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PerformanceMeasureOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_detail: 'tags this -> any option [@@js.get "detail"]
  val set_detail: 'tags this -> any -> unit [@@js.set "detail"]
  val get_duration: 'tags this -> DOMHighResTimeStamp.t option [@@js.get "duration"]
  val set_duration: 'tags this -> DOMHighResTimeStamp.t -> unit [@@js.set "duration"]
  val get_end: 'tags this -> ([`String of string | `Other of DOMHighResTimeStamp.t] [@js.union on_field "dummy"]) Primitive.t option [@@js.get "end"]
  val set_end: 'tags this -> ([`U1 of string | `U2 of DOMHighResTimeStamp.t] [@js.union]) -> unit [@@js.set "end"]
  val get_start: 'tags this -> ([`String of string | `Other of DOMHighResTimeStamp.t] [@js.union on_field "dummy"]) Primitive.t option [@@js.get "start"]
  val set_start: 'tags this -> ([`U1 of string | `U2 of DOMHighResTimeStamp.t] [@js.union]) -> unit [@@js.set "start"]
  val create: ?detail:any -> ?duration:DOMHighResTimeStamp.t -> ?end_:(([`String of string | `Other of DOMHighResTimeStamp.t] [@js.union on_field "dummy"]) Primitive.t[@js "end"]) -> ?start:([`String of string | `Other of DOMHighResTimeStamp.t] [@js.union on_field "dummy"]) Primitive.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** Encapsulates a single performance metric that is part of the performance timeline. A performance entry can be directly created by making a performance mark or measure (for example by calling the mark() method) at an explicit point in an application. Performance entries are also created in indirect ways such as loading a resource (such as an image). *)
module[@js.scope "PerformanceEntry"] PerformanceEntry : sig
  type t = [`PerformanceEntry] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`PerformanceEntry]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`PerformanceEntry]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PerformanceEntry ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_duration: 'tags this -> DOMHighResTimeStamp.t [@@js.get "duration"]
  val get_entryType: 'tags this -> string [@@js.get "entryType"]
  val get_name: 'tags this -> string [@@js.get "name"]
  val get_startTime: 'tags this -> DOMHighResTimeStamp.t [@@js.get "startTime"]
  val toJSON: 'tags this -> any [@@js.call "toJSON"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** PerformanceMeasure is an abstract interface for PerformanceEntry objects with an entryType of "measure". Entries of this type are created by calling performance.measure() to add a named DOMHighResTimeStamp (the measure) between two marks to the browser's performance timeline. *)
module[@js.scope "PerformanceMeasure"] PerformanceMeasure : sig
  type t = [`PerformanceEntry | `PerformanceMeasure] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`PerformanceEntry | `PerformanceMeasure]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`PerformanceEntry | `PerformanceMeasure]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PerformanceMeasure ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_detail: 'tags this -> any [@@js.get "detail"]
  val create: detail:any -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end
module PerformanceMarkOptions : sig
  type t = [`PerformanceMarkOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`PerformanceMarkOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`PerformanceMarkOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PerformanceMarkOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_detail: 'tags this -> any option [@@js.get "detail"]
  val set_detail: 'tags this -> any -> unit [@@js.set "detail"]
  val get_startTime: 'tags this -> DOMHighResTimeStamp.t option [@@js.get "startTime"]
  val set_startTime: 'tags this -> DOMHighResTimeStamp.t -> unit [@@js.set "startTime"]
  val create: ?detail:any -> ?startTime:DOMHighResTimeStamp.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** PerformanceMark is an abstract interface for PerformanceEntry objects with an entryType of "mark". Entries of this type are created by calling performance.mark() to add a named DOMHighResTimeStamp (the mark) to the browser's performance timeline. *)
module[@js.scope "PerformanceMark"] PerformanceMark : sig
  type t = [`PerformanceEntry | `PerformanceMark] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`PerformanceEntry | `PerformanceMark]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`PerformanceEntry | `PerformanceMark]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PerformanceMark ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_detail: 'tags this -> any [@@js.get "detail"]
  val create: detail:any -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': markName:string -> ?markOptions:PerformanceMarkOptions.t -> unit -> t [@@js.create]
end
module PerformanceEntryList : sig
  type t = PerformanceEntry.t list
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end

(** Provides access to performance-related information for the current page. It's part of the High Resolution Time API, but is enhanced by the Performance Timeline API, the Navigation Timing API, the User Timing API, and the Resource Timing API. *)
module[@js.scope "Performance"] Performance : sig
  type t = [`EventTarget | `Performance] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventTarget | `Performance]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventTarget | `Performance]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `Performance ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** @deprecated  *)
  val get_navigation: 'tags this -> PerformanceNavigation.t [@@js.get "navigation"]
  val get_onresourcetimingbufferfull: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onresourcetimingbufferfull"]
  val set_onresourcetimingbufferfull: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onresourcetimingbufferfull"]
  val get_timeOrigin: 'tags this -> DOMHighResTimeStamp.t [@@js.get "timeOrigin"]
  
  (** @deprecated  *)
  val get_timing: 'tags this -> PerformanceTiming.t [@@js.get "timing"]
  val clearMarks: 'tags this -> ?markName:string -> unit -> unit [@@js.call "clearMarks"]
  val clearMeasures: 'tags this -> ?measureName:string -> unit -> unit [@@js.call "clearMeasures"]
  val clearResourceTimings: 'tags this -> unit [@@js.call "clearResourceTimings"]
  val getEntries: 'tags this -> PerformanceEntryList.t [@@js.call "getEntries"]
  val getEntriesByName: 'tags this -> name:string -> ?type_:string -> unit -> PerformanceEntryList.t [@@js.call "getEntriesByName"]
  val getEntriesByType: 'tags this -> type_:string -> PerformanceEntryList.t [@@js.call "getEntriesByType"]
  val mark: 'tags this -> markName:string -> ?markOptions:PerformanceMarkOptions.t -> unit -> PerformanceMark.t [@@js.call "mark"]
  val measure: 'tags this -> measureName:string -> ?startOrMeasureOptions:([`U1 of string | `U2 of PerformanceMeasureOptions.t] [@js.union]) -> ?endMark:string -> unit -> PerformanceMeasure.t [@@js.call "measure"]
  val now: 'tags this -> DOMHighResTimeStamp.t [@@js.call "now"]
  val setResourceTimingBufferSize: 'tags this -> maxSize:float -> unit [@@js.call "setResourceTimingBufferSize"]
  val toJSON: 'tags this -> any [@@js.call "toJSON"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'PerformanceEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'PerformanceEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module[@js.scope "performance"] PerformanceStatic : sig
  
  (** @deprecated  *)
  val navigation: unit -> PerformanceNavigation.t [@@js.get "navigation"]
  val onresourcetimingbufferfull: unit -> (this:Performance.t -> ev:Event.t -> any) option [@@js.get "onresourcetimingbufferfull"]
  val timeOrigin: unit -> DOMHighResTimeStamp.t [@@js.get "timeOrigin"]
  
  (** @deprecated  *)
  val timing: unit -> PerformanceTiming.t [@@js.get "timing"]
  val clearMarks: ?markName:string -> unit -> unit [@@js.global "clearMarks"]
  val clearMeasures: ?measureName:string -> unit -> unit [@@js.global "clearMeasures"]
  val clearResourceTimings: unit -> unit [@@js.global "clearResourceTimings"]
  val getEntries: unit -> PerformanceEntryList.t [@@js.global "getEntries"]
  val getEntriesByName: name:string -> ?type_:string -> unit -> PerformanceEntryList.t [@@js.global "getEntriesByName"]
  val getEntriesByType: string -> PerformanceEntryList.t [@@js.global "getEntriesByType"]
  val mark: markName:string -> ?markOptions:PerformanceMarkOptions.t -> unit -> PerformanceMark.t [@@js.global "mark"]
  val measure: measureName:string -> ?startOrMeasureOptions:([`U1 of string | `U2 of PerformanceMeasureOptions.t] [@js.union]) -> ?endMark:string -> unit -> PerformanceMeasure.t [@@js.global "measure"]
  val now: unit -> DOMHighResTimeStamp.t [@@js.global "now"]
  val setResourceTimingBufferSize: float -> unit [@@js.global "setResourceTimingBufferSize"]
  val toJSON: unit -> any [@@js.global "toJSON"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: type_:'K -> listener:(this:Performance.t -> ev:(* FIXME: unknown type 'PerformanceEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.global "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.global "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: type_:'K -> listener:(this:Performance.t -> ev:(* FIXME: unknown type 'PerformanceEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.global "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.global "removeEventListener"]
end
module GetRootNodeOptions : sig
  type t = [`GetRootNodeOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`GetRootNodeOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`GetRootNodeOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `GetRootNodeOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_composed: 'tags this -> bool option [@@js.get "composed"]
  val set_composed: 'tags this -> bool -> unit [@@js.set "composed"]
  val create: ?composed:bool -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module XPathNSResolver : sig
  module AnonymousInterface546 : sig
    type t = private Ojs.t
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    val lookupNamespaceURI: t -> prefix:string option -> string option [@@js.call "lookupNamespaceURI"]
  end
  type t = (AnonymousInterface546.t, (string option -> string option)) union2
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module WebGLContextEventInit : sig
  type t = [`EventInit | `WebGLContextEventInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventInit | `WebGLContextEventInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventInit | `WebGLContextEventInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `WebGLContextEventInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_statusMessage: 'tags this -> string option [@@js.get "statusMessage"]
  val set_statusMessage: 'tags this -> string -> unit [@@js.set "statusMessage"]
  val create: ?statusMessage:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** The WebContextEvent interface is part of the WebGL API and is an interface for an event that is generated in response to a status change to the WebGL rendering context. *)
module[@js.scope "WebGLContextEvent"] WebGLContextEvent : sig
  type t = [`Event | `WebGLContextEvent] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Event | `WebGLContextEvent]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Event | `WebGLContextEvent]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `WebGLContextEvent ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_statusMessage: 'tags this -> string [@@js.get "statusMessage"]
  val create: statusMessage:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': type_:string -> ?eventInit:WebGLContextEventInit.t -> unit -> t [@@js.create]
end
module RTCRtpTransceiverDirection : sig
  type t = ([`L_s421_inactive[@js "inactive"] | `L_s655_recvonly[@js "recvonly"] | `L_s714_sendonly[@js "sendonly"] | `L_s715_sendrecv[@js "sendrecv"] | `L_s758_stopped[@js "stopped"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module RTCRtpCodingParameters : sig
  type t = [`RTCRtpCodingParameters] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`RTCRtpCodingParameters]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`RTCRtpCodingParameters]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RTCRtpCodingParameters ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_rid: 'tags this -> string option [@@js.get "rid"]
  val set_rid: 'tags this -> string -> unit [@@js.set "rid"]
  val create: ?rid:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module RTCPriorityType : sig
  type t = ([`L_s395_high[@js "high"] | `L_s484_low[@js "low"] | `L_s506_medium[@js "medium"] | `L_s850_very_low[@js "very-low"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module RTCRtpEncodingParameters : sig
  type t = [`RTCRtpCodingParameters | `RTCRtpEncodingParameters] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`RTCRtpCodingParameters | `RTCRtpEncodingParameters]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`RTCRtpCodingParameters | `RTCRtpEncodingParameters]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RTCRtpEncodingParameters ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_active: 'tags this -> bool option [@@js.get "active"]
  val set_active: 'tags this -> bool -> unit [@@js.set "active"]
  val get_maxBitrate: 'tags this -> float option [@@js.get "maxBitrate"]
  val set_maxBitrate: 'tags this -> float -> unit [@@js.set "maxBitrate"]
  val get_priority: 'tags this -> RTCPriorityType.t option [@@js.get "priority"]
  val set_priority: 'tags this -> RTCPriorityType.t -> unit [@@js.set "priority"]
  val get_scaleResolutionDownBy: 'tags this -> float option [@@js.get "scaleResolutionDownBy"]
  val set_scaleResolutionDownBy: 'tags this -> float -> unit [@@js.set "scaleResolutionDownBy"]
  val create: ?active:bool -> ?maxBitrate:float -> ?priority:RTCPriorityType.t -> ?scaleResolutionDownBy:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module RTCDegradationPreference : sig
  type t = ([`L_s147_balanced[@js "balanced"] | `L_s492_maintain_framerate[@js "maintain-framerate"] | `L_s493_maintain_resolution[@js "maintain-resolution"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module RTCRtpHeaderExtensionParameters : sig
  type t = [`RTCRtpHeaderExtensionParameters] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`RTCRtpHeaderExtensionParameters]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`RTCRtpHeaderExtensionParameters]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RTCRtpHeaderExtensionParameters ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_encrypted: 'tags this -> bool option [@@js.get "encrypted"]
  val set_encrypted: 'tags this -> bool -> unit [@@js.set "encrypted"]
  val get_id: 'tags this -> float [@@js.get "id"]
  val set_id: 'tags this -> float -> unit [@@js.set "id"]
  val get_uri: 'tags this -> string [@@js.get "uri"]
  val set_uri: 'tags this -> string -> unit [@@js.set "uri"]
  val create: ?encrypted:bool -> id:float -> uri:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module RTCRtpCodecParameters : sig
  type t = [`RTCRtpCodecParameters] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`RTCRtpCodecParameters]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`RTCRtpCodecParameters]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RTCRtpCodecParameters ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_channels: 'tags this -> float option [@@js.get "channels"]
  val set_channels: 'tags this -> float -> unit [@@js.set "channels"]
  val get_clockRate: 'tags this -> float [@@js.get "clockRate"]
  val set_clockRate: 'tags this -> float -> unit [@@js.set "clockRate"]
  val get_mimeType: 'tags this -> string [@@js.get "mimeType"]
  val set_mimeType: 'tags this -> string -> unit [@@js.set "mimeType"]
  val get_payloadType: 'tags this -> float [@@js.get "payloadType"]
  val set_payloadType: 'tags this -> float -> unit [@@js.set "payloadType"]
  val get_sdpFmtpLine: 'tags this -> string option [@@js.get "sdpFmtpLine"]
  val set_sdpFmtpLine: 'tags this -> string -> unit [@@js.set "sdpFmtpLine"]
  val create: ?channels:float -> clockRate:float -> mimeType:string -> payloadType:float -> ?sdpFmtpLine:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module RTCRtcpParameters : sig
  type t = [`RTCRtcpParameters] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`RTCRtcpParameters]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`RTCRtcpParameters]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RTCRtcpParameters ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_cname: 'tags this -> string option [@@js.get "cname"]
  val set_cname: 'tags this -> string -> unit [@@js.set "cname"]
  val get_reducedSize: 'tags this -> bool option [@@js.get "reducedSize"]
  val set_reducedSize: 'tags this -> bool -> unit [@@js.set "reducedSize"]
  val create: ?cname:string -> ?reducedSize:bool -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module RTCRtpParameters : sig
  type t = [`RTCRtpParameters] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`RTCRtpParameters]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`RTCRtpParameters]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RTCRtpParameters ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_codecs: 'tags this -> RTCRtpCodecParameters.t list [@@js.get "codecs"]
  val set_codecs: 'tags this -> RTCRtpCodecParameters.t list -> unit [@@js.set "codecs"]
  val get_headerExtensions: 'tags this -> RTCRtpHeaderExtensionParameters.t list [@@js.get "headerExtensions"]
  val set_headerExtensions: 'tags this -> RTCRtpHeaderExtensionParameters.t list -> unit [@@js.set "headerExtensions"]
  val get_rtcp: 'tags this -> RTCRtcpParameters.t [@@js.get "rtcp"]
  val set_rtcp: 'tags this -> RTCRtcpParameters.t -> unit [@@js.set "rtcp"]
  val create: codecs:RTCRtpCodecParameters.t list -> headerExtensions:RTCRtpHeaderExtensionParameters.t list -> rtcp:RTCRtcpParameters.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module RTCRtpSendParameters : sig
  type t = [`RTCRtpParameters | `RTCRtpSendParameters] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`RTCRtpParameters | `RTCRtpSendParameters]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`RTCRtpParameters | `RTCRtpSendParameters]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RTCRtpSendParameters ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_degradationPreference: 'tags this -> RTCDegradationPreference.t option [@@js.get "degradationPreference"]
  val set_degradationPreference: 'tags this -> RTCDegradationPreference.t -> unit [@@js.set "degradationPreference"]
  val get_encodings: 'tags this -> RTCRtpEncodingParameters.t list [@@js.get "encodings"]
  val set_encodings: 'tags this -> RTCRtpEncodingParameters.t list -> unit [@@js.set "encodings"]
  val get_transactionId: 'tags this -> string [@@js.get "transactionId"]
  val set_transactionId: 'tags this -> string -> unit [@@js.set "transactionId"]
  val create: ?degradationPreference:RTCDegradationPreference.t -> encodings:RTCRtpEncodingParameters.t list -> transactionId:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module RTCDTMFToneChangeEventInit : sig
  type t = [`EventInit | `RTCDTMFToneChangeEventInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventInit | `RTCDTMFToneChangeEventInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventInit | `RTCDTMFToneChangeEventInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RTCDTMFToneChangeEventInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_tone: 'tags this -> string option [@@js.get "tone"]
  val set_tone: 'tags this -> string -> unit [@@js.set "tone"]
  val create: ?tone:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** Events sent to indicate that DTMF tones have started or finished playing. This interface is used by the tonechange event. *)
module[@js.scope "RTCDTMFToneChangeEvent"] RTCDTMFToneChangeEvent : sig
  type t = [`Event | `RTCDTMFToneChangeEvent] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Event | `RTCDTMFToneChangeEvent]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Event | `RTCDTMFToneChangeEvent]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RTCDTMFToneChangeEvent ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_tone: 'tags this -> string [@@js.get "tone"]
  val create: tone:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': type_:string -> ?eventInitDict:RTCDTMFToneChangeEventInit.t -> unit -> t [@@js.create]
end
module[@js.scope "RTCDTMFSender"] RTCDTMFSender : sig
  type t = [`EventTarget | `RTCDTMFSender] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventTarget | `RTCDTMFSender]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventTarget | `RTCDTMFSender]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RTCDTMFSender ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_canInsertDTMF: 'tags this -> bool [@@js.get "canInsertDTMF"]
  val get_ontonechange: 'tags this -> (this:t -> ev:RTCDTMFToneChangeEvent.t -> any) option [@@js.get "ontonechange"]
  val set_ontonechange: 'tags this -> (this:t -> ev:RTCDTMFToneChangeEvent.t -> any) option -> unit [@@js.set "ontonechange"]
  val get_toneBuffer: 'tags this -> string [@@js.get "toneBuffer"]
  val insertDTMF: 'tags this -> tones:string -> ?duration:float -> ?interToneGap:float -> unit -> unit [@@js.call "insertDTMF"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'RTCDTMFSenderEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'RTCDTMFSenderEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module[@js.scope "RTCStatsReport"] RTCStatsReport : sig
  type t = [`RTCStatsReport] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`RTCStatsReport]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`RTCStatsReport]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RTCStatsReport ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val forEach: 'tags this -> callbackfn:(value:any -> key:string -> parent:t -> unit) -> ?thisArg:any -> unit -> unit [@@js.call "forEach"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module RTCRtpHeaderExtensionCapability : sig
  type t = [`RTCRtpHeaderExtensionCapability] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`RTCRtpHeaderExtensionCapability]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`RTCRtpHeaderExtensionCapability]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RTCRtpHeaderExtensionCapability ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_uri: 'tags this -> string option [@@js.get "uri"]
  val set_uri: 'tags this -> string -> unit [@@js.set "uri"]
  val create: ?uri:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module RTCRtpCodecCapability : sig
  type t = [`RTCRtpCodecCapability] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`RTCRtpCodecCapability]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`RTCRtpCodecCapability]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RTCRtpCodecCapability ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_channels: 'tags this -> float option [@@js.get "channels"]
  val set_channels: 'tags this -> float -> unit [@@js.set "channels"]
  val get_clockRate: 'tags this -> float [@@js.get "clockRate"]
  val set_clockRate: 'tags this -> float -> unit [@@js.set "clockRate"]
  val get_mimeType: 'tags this -> string [@@js.get "mimeType"]
  val set_mimeType: 'tags this -> string -> unit [@@js.set "mimeType"]
  val get_sdpFmtpLine: 'tags this -> string option [@@js.get "sdpFmtpLine"]
  val set_sdpFmtpLine: 'tags this -> string -> unit [@@js.set "sdpFmtpLine"]
  val create: ?channels:float -> clockRate:float -> mimeType:string -> ?sdpFmtpLine:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module RTCRtpCapabilities : sig
  type t = [`RTCRtpCapabilities] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`RTCRtpCapabilities]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`RTCRtpCapabilities]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RTCRtpCapabilities ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_codecs: 'tags this -> RTCRtpCodecCapability.t list [@@js.get "codecs"]
  val set_codecs: 'tags this -> RTCRtpCodecCapability.t list -> unit [@@js.set "codecs"]
  val get_headerExtensions: 'tags this -> RTCRtpHeaderExtensionCapability.t list [@@js.get "headerExtensions"]
  val set_headerExtensions: 'tags this -> RTCRtpHeaderExtensionCapability.t list -> unit [@@js.set "headerExtensions"]
  val create: codecs:RTCRtpCodecCapability.t list -> headerExtensions:RTCRtpHeaderExtensionCapability.t list -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module RTCDtlsTransportState : sig
  type t = ([`L_s199_closed[@js "closed"] | `L_s216_connected[@js "connected"] | `L_s217_connecting[@js "connecting"] | `L_s314_failed[@js "failed"] | `L_s538_new[@js "new"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module[@js.scope "RTCDtlsTransport"] RTCDtlsTransport : sig
  type t = [`EventTarget | `RTCDtlsTransport] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventTarget | `RTCDtlsTransport]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventTarget | `RTCDtlsTransport]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RTCDtlsTransport ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_onstatechange: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onstatechange"]
  val set_onstatechange: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onstatechange"]
  val get_state: 'tags this -> RTCDtlsTransportState.t [@@js.get "state"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'RTCDtlsTransportEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'RTCDtlsTransportEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module MediaTrackSettings : sig
  type t = [`MediaTrackSettings] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`MediaTrackSettings]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`MediaTrackSettings]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MediaTrackSettings ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_aspectRatio: 'tags this -> float option [@@js.get "aspectRatio"]
  val set_aspectRatio: 'tags this -> float -> unit [@@js.set "aspectRatio"]
  val get_autoGainControl: 'tags this -> bool option [@@js.get "autoGainControl"]
  val set_autoGainControl: 'tags this -> bool -> unit [@@js.set "autoGainControl"]
  val get_deviceId: 'tags this -> string option [@@js.get "deviceId"]
  val set_deviceId: 'tags this -> string -> unit [@@js.set "deviceId"]
  val get_echoCancellation: 'tags this -> bool option [@@js.get "echoCancellation"]
  val set_echoCancellation: 'tags this -> bool -> unit [@@js.set "echoCancellation"]
  val get_facingMode: 'tags this -> string option [@@js.get "facingMode"]
  val set_facingMode: 'tags this -> string -> unit [@@js.set "facingMode"]
  val get_frameRate: 'tags this -> float option [@@js.get "frameRate"]
  val set_frameRate: 'tags this -> float -> unit [@@js.set "frameRate"]
  val get_groupId: 'tags this -> string option [@@js.get "groupId"]
  val set_groupId: 'tags this -> string -> unit [@@js.set "groupId"]
  val get_height: 'tags this -> float option [@@js.get "height"]
  val set_height: 'tags this -> float -> unit [@@js.set "height"]
  val get_noiseSuppression: 'tags this -> bool option [@@js.get "noiseSuppression"]
  val set_noiseSuppression: 'tags this -> bool -> unit [@@js.set "noiseSuppression"]
  val get_restrictOwnAudio: 'tags this -> bool option [@@js.get "restrictOwnAudio"]
  val set_restrictOwnAudio: 'tags this -> bool -> unit [@@js.set "restrictOwnAudio"]
  val get_sampleRate: 'tags this -> float option [@@js.get "sampleRate"]
  val set_sampleRate: 'tags this -> float -> unit [@@js.set "sampleRate"]
  val get_sampleSize: 'tags this -> float option [@@js.get "sampleSize"]
  val set_sampleSize: 'tags this -> float -> unit [@@js.set "sampleSize"]
  val get_width: 'tags this -> float option [@@js.get "width"]
  val set_width: 'tags this -> float -> unit [@@js.set "width"]
  val create: ?aspectRatio:float -> ?autoGainControl:bool -> ?deviceId:string -> ?echoCancellation:bool -> ?facingMode:string -> ?frameRate:float -> ?groupId:string -> ?height:float -> ?noiseSuppression:bool -> ?restrictOwnAudio:bool -> ?sampleRate:float -> ?sampleSize:float -> ?width:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module ULongRange : sig
  type t = [`ULongRange] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ULongRange]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ULongRange]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ULongRange ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_max: 'tags this -> float option [@@js.get "max"]
  val set_max: 'tags this -> float -> unit [@@js.set "max"]
  val get_min: 'tags this -> float option [@@js.get "min"]
  val set_min: 'tags this -> float -> unit [@@js.set "min"]
  val create: ?max:float -> ?min:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module DoubleRange : sig
  type t = [`DoubleRange] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`DoubleRange]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`DoubleRange]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `DoubleRange ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_max: 'tags this -> float option [@@js.get "max"]
  val set_max: 'tags this -> float -> unit [@@js.set "max"]
  val get_min: 'tags this -> float option [@@js.get "min"]
  val set_min: 'tags this -> float -> unit [@@js.set "min"]
  val create: ?max:float -> ?min:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module MediaTrackCapabilities : sig
  type t = [`MediaTrackCapabilities] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`MediaTrackCapabilities]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`MediaTrackCapabilities]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MediaTrackCapabilities ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_aspectRatio: 'tags this -> DoubleRange.t option [@@js.get "aspectRatio"]
  val set_aspectRatio: 'tags this -> DoubleRange.t -> unit [@@js.set "aspectRatio"]
  val get_autoGainControl: 'tags this -> bool list option [@@js.get "autoGainControl"]
  val set_autoGainControl: 'tags this -> bool list -> unit [@@js.set "autoGainControl"]
  val get_channelCount: 'tags this -> ULongRange.t option [@@js.get "channelCount"]
  val set_channelCount: 'tags this -> ULongRange.t -> unit [@@js.set "channelCount"]
  val get_cursor: 'tags this -> string list option [@@js.get "cursor"]
  val set_cursor: 'tags this -> string list -> unit [@@js.set "cursor"]
  val get_deviceId: 'tags this -> string option [@@js.get "deviceId"]
  val set_deviceId: 'tags this -> string -> unit [@@js.set "deviceId"]
  val get_displaySurface: 'tags this -> string option [@@js.get "displaySurface"]
  val set_displaySurface: 'tags this -> string -> unit [@@js.set "displaySurface"]
  val get_echoCancellation: 'tags this -> bool list option [@@js.get "echoCancellation"]
  val set_echoCancellation: 'tags this -> bool list -> unit [@@js.set "echoCancellation"]
  val get_facingMode: 'tags this -> string list option [@@js.get "facingMode"]
  val set_facingMode: 'tags this -> string list -> unit [@@js.set "facingMode"]
  val get_frameRate: 'tags this -> DoubleRange.t option [@@js.get "frameRate"]
  val set_frameRate: 'tags this -> DoubleRange.t -> unit [@@js.set "frameRate"]
  val get_groupId: 'tags this -> string option [@@js.get "groupId"]
  val set_groupId: 'tags this -> string -> unit [@@js.set "groupId"]
  val get_height: 'tags this -> ULongRange.t option [@@js.get "height"]
  val set_height: 'tags this -> ULongRange.t -> unit [@@js.set "height"]
  val get_latency: 'tags this -> DoubleRange.t option [@@js.get "latency"]
  val set_latency: 'tags this -> DoubleRange.t -> unit [@@js.set "latency"]
  val get_logicalSurface: 'tags this -> bool option [@@js.get "logicalSurface"]
  val set_logicalSurface: 'tags this -> bool -> unit [@@js.set "logicalSurface"]
  val get_noiseSuppression: 'tags this -> bool list option [@@js.get "noiseSuppression"]
  val set_noiseSuppression: 'tags this -> bool list -> unit [@@js.set "noiseSuppression"]
  val get_resizeMode: 'tags this -> string list option [@@js.get "resizeMode"]
  val set_resizeMode: 'tags this -> string list -> unit [@@js.set "resizeMode"]
  val get_sampleRate: 'tags this -> ULongRange.t option [@@js.get "sampleRate"]
  val set_sampleRate: 'tags this -> ULongRange.t -> unit [@@js.set "sampleRate"]
  val get_sampleSize: 'tags this -> ULongRange.t option [@@js.get "sampleSize"]
  val set_sampleSize: 'tags this -> ULongRange.t -> unit [@@js.set "sampleSize"]
  val get_width: 'tags this -> ULongRange.t option [@@js.get "width"]
  val set_width: 'tags this -> ULongRange.t -> unit [@@js.set "width"]
  val create: ?aspectRatio:DoubleRange.t -> ?autoGainControl:bool list -> ?channelCount:ULongRange.t -> ?cursor:string list -> ?deviceId:string -> ?displaySurface:string -> ?echoCancellation:bool list -> ?facingMode:string list -> ?frameRate:DoubleRange.t -> ?groupId:string -> ?height:ULongRange.t -> ?latency:DoubleRange.t -> ?logicalSurface:bool -> ?noiseSuppression:bool list -> ?resizeMode:string list -> ?sampleRate:ULongRange.t -> ?sampleSize:ULongRange.t -> ?width:ULongRange.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module MediaStreamTrackState : sig
  type t = ([`L_s291_ended[@js "ended"] | `L_s472_live[@js "live"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module ConstrainULongRange : sig
  type t = [`ConstrainULongRange | `ULongRange] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ConstrainULongRange | `ULongRange]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ConstrainULongRange | `ULongRange]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ConstrainULongRange ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_exact: 'tags this -> float option [@@js.get "exact"]
  val set_exact: 'tags this -> float -> unit [@@js.set "exact"]
  val get_ideal: 'tags this -> float option [@@js.get "ideal"]
  val set_ideal: 'tags this -> float -> unit [@@js.set "ideal"]
  val create: ?exact:float -> ?ideal:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module ConstrainULong : sig
  type t = ([`Number of float | `Other of ConstrainULongRange.t] [@js.union on_field "dummy"]) Primitive.t
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module ConstrainDoubleRange : sig
  type t = [`ConstrainDoubleRange | `DoubleRange] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ConstrainDoubleRange | `DoubleRange]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ConstrainDoubleRange | `DoubleRange]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ConstrainDoubleRange ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_exact: 'tags this -> float option [@@js.get "exact"]
  val set_exact: 'tags this -> float -> unit [@@js.set "exact"]
  val get_ideal: 'tags this -> float option [@@js.get "ideal"]
  val set_ideal: 'tags this -> float -> unit [@@js.set "ideal"]
  val create: ?exact:float -> ?ideal:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module ConstrainDouble : sig
  type t = ([`Number of float | `Other of ConstrainDoubleRange.t] [@js.union on_field "dummy"]) Primitive.t
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module ConstrainDOMStringParameters : sig
  type t = [`ConstrainDOMStringParameters] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ConstrainDOMStringParameters]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ConstrainDOMStringParameters]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ConstrainDOMStringParameters ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_exact: 'tags this -> ([`String of string | `Other of string list] [@js.union on_field "dummy"]) Primitive.t option [@@js.get "exact"]
  val set_exact: 'tags this -> ([`U1 of string | `U2 of string list] [@js.union]) -> unit [@@js.set "exact"]
  val get_ideal: 'tags this -> ([`String of string | `Other of string list] [@js.union on_field "dummy"]) Primitive.t option [@@js.get "ideal"]
  val set_ideal: 'tags this -> ([`U1 of string | `U2 of string list] [@js.union]) -> unit [@@js.set "ideal"]
  val create: ?exact:([`String of string | `Other of string list] [@js.union on_field "dummy"]) Primitive.t -> ?ideal:([`String of string | `Other of string list] [@js.union on_field "dummy"]) Primitive.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module ConstrainDOMString : sig
  type t = ([`String of string | `Other of (string list, ConstrainDOMStringParameters.t) union2] [@js.union on_field "dummy"]) Primitive.t
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module ConstrainBooleanParameters : sig
  type t = [`ConstrainBooleanParameters] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ConstrainBooleanParameters]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ConstrainBooleanParameters]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ConstrainBooleanParameters ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_exact: 'tags this -> bool option [@@js.get "exact"]
  val set_exact: 'tags this -> bool -> unit [@@js.set "exact"]
  val get_ideal: 'tags this -> bool option [@@js.get "ideal"]
  val set_ideal: 'tags this -> bool -> unit [@@js.set "ideal"]
  val create: ?exact:bool -> ?ideal:bool -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module ConstrainBoolean : sig
  type t = ([`Boolean of bool | `Other of ConstrainBooleanParameters.t] [@js.union on_field "dummy"]) Primitive.t
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module MediaTrackConstraintSet : sig
  type t = [`MediaTrackConstraintSet] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`MediaTrackConstraintSet]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`MediaTrackConstraintSet]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MediaTrackConstraintSet ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_aspectRatio: 'tags this -> ConstrainDouble.t option [@@js.get "aspectRatio"]
  val set_aspectRatio: 'tags this -> ConstrainDouble.t -> unit [@@js.set "aspectRatio"]
  val get_autoGainControl: 'tags this -> ConstrainBoolean.t option [@@js.get "autoGainControl"]
  val set_autoGainControl: 'tags this -> ConstrainBoolean.t -> unit [@@js.set "autoGainControl"]
  val get_channelCount: 'tags this -> ConstrainULong.t option [@@js.get "channelCount"]
  val set_channelCount: 'tags this -> ConstrainULong.t -> unit [@@js.set "channelCount"]
  val get_deviceId: 'tags this -> ConstrainDOMString.t option [@@js.get "deviceId"]
  val set_deviceId: 'tags this -> ConstrainDOMString.t -> unit [@@js.set "deviceId"]
  val get_echoCancellation: 'tags this -> ConstrainBoolean.t option [@@js.get "echoCancellation"]
  val set_echoCancellation: 'tags this -> ConstrainBoolean.t -> unit [@@js.set "echoCancellation"]
  val get_facingMode: 'tags this -> ConstrainDOMString.t option [@@js.get "facingMode"]
  val set_facingMode: 'tags this -> ConstrainDOMString.t -> unit [@@js.set "facingMode"]
  val get_frameRate: 'tags this -> ConstrainDouble.t option [@@js.get "frameRate"]
  val set_frameRate: 'tags this -> ConstrainDouble.t -> unit [@@js.set "frameRate"]
  val get_groupId: 'tags this -> ConstrainDOMString.t option [@@js.get "groupId"]
  val set_groupId: 'tags this -> ConstrainDOMString.t -> unit [@@js.set "groupId"]
  val get_height: 'tags this -> ConstrainULong.t option [@@js.get "height"]
  val set_height: 'tags this -> ConstrainULong.t -> unit [@@js.set "height"]
  val get_latency: 'tags this -> ConstrainDouble.t option [@@js.get "latency"]
  val set_latency: 'tags this -> ConstrainDouble.t -> unit [@@js.set "latency"]
  val get_noiseSuppression: 'tags this -> ConstrainBoolean.t option [@@js.get "noiseSuppression"]
  val set_noiseSuppression: 'tags this -> ConstrainBoolean.t -> unit [@@js.set "noiseSuppression"]
  val get_sampleRate: 'tags this -> ConstrainULong.t option [@@js.get "sampleRate"]
  val set_sampleRate: 'tags this -> ConstrainULong.t -> unit [@@js.set "sampleRate"]
  val get_sampleSize: 'tags this -> ConstrainULong.t option [@@js.get "sampleSize"]
  val set_sampleSize: 'tags this -> ConstrainULong.t -> unit [@@js.set "sampleSize"]
  val get_suppressLocalAudioPlayback: 'tags this -> ConstrainBoolean.t option [@@js.get "suppressLocalAudioPlayback"]
  val set_suppressLocalAudioPlayback: 'tags this -> ConstrainBoolean.t -> unit [@@js.set "suppressLocalAudioPlayback"]
  val get_width: 'tags this -> ConstrainULong.t option [@@js.get "width"]
  val set_width: 'tags this -> ConstrainULong.t -> unit [@@js.set "width"]
  val create: ?aspectRatio:ConstrainDouble.t -> ?autoGainControl:ConstrainBoolean.t -> ?channelCount:ConstrainULong.t -> ?deviceId:ConstrainDOMString.t -> ?echoCancellation:ConstrainBoolean.t -> ?facingMode:ConstrainDOMString.t -> ?frameRate:ConstrainDouble.t -> ?groupId:ConstrainDOMString.t -> ?height:ConstrainULong.t -> ?latency:ConstrainDouble.t -> ?noiseSuppression:ConstrainBoolean.t -> ?sampleRate:ConstrainULong.t -> ?sampleSize:ConstrainULong.t -> ?suppressLocalAudioPlayback:ConstrainBoolean.t -> ?width:ConstrainULong.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module MediaTrackConstraints : sig
  type t = [`MediaTrackConstraintSet | `MediaTrackConstraints] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`MediaTrackConstraintSet | `MediaTrackConstraints]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`MediaTrackConstraintSet | `MediaTrackConstraints]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MediaTrackConstraints ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_advanced: 'tags this -> MediaTrackConstraintSet.t list option [@@js.get "advanced"]
  val set_advanced: 'tags this -> MediaTrackConstraintSet.t list -> unit [@@js.set "advanced"]
  val create: ?advanced:MediaTrackConstraintSet.t list -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** A single media track within a stream; typically, these are audio or video tracks, but other track types may exist as well. *)
module[@js.scope "MediaStreamTrack"] MediaStreamTrack : sig
  type t = [`EventTarget | `MediaStreamTrack] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventTarget | `MediaStreamTrack]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventTarget | `MediaStreamTrack]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MediaStreamTrack ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_contentHint: 'tags this -> string [@@js.get "contentHint"]
  val set_contentHint: 'tags this -> string -> unit [@@js.set "contentHint"]
  val get_enabled: 'tags this -> bool [@@js.get "enabled"]
  val set_enabled: 'tags this -> bool -> unit [@@js.set "enabled"]
  val get_id: 'tags this -> string [@@js.get "id"]
  val get_kind: 'tags this -> string [@@js.get "kind"]
  val get_label: 'tags this -> string [@@js.get "label"]
  val get_muted: 'tags this -> bool [@@js.get "muted"]
  val get_onended: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onended"]
  val set_onended: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onended"]
  val get_onmute: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onmute"]
  val set_onmute: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onmute"]
  val get_onunmute: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onunmute"]
  val set_onunmute: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onunmute"]
  val get_readyState: 'tags this -> MediaStreamTrackState.t [@@js.get "readyState"]
  val applyConstraints: 'tags this -> ?constraints:MediaTrackConstraints.t -> unit -> unit Promise.t_1 [@@js.call "applyConstraints"]
  val clone: 'tags this -> t [@@js.call "clone"]
  val getCapabilities: 'tags this -> MediaTrackCapabilities.t [@@js.call "getCapabilities"]
  val getConstraints: 'tags this -> MediaTrackConstraints.t [@@js.call "getConstraints"]
  val getSettings: 'tags this -> MediaTrackSettings.t [@@js.call "getSettings"]
  val stop: 'tags this -> unit [@@js.call "stop"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'MediaStreamTrackEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'MediaStreamTrackEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module MediaStreamTrackEventInit : sig
  type t = [`EventInit | `MediaStreamTrackEventInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventInit | `MediaStreamTrackEventInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventInit | `MediaStreamTrackEventInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MediaStreamTrackEventInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_track: 'tags this -> MediaStreamTrack.t [@@js.get "track"]
  val set_track: 'tags this -> MediaStreamTrack.t -> unit [@@js.set "track"]
  val create: track:MediaStreamTrack.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** Events which indicate that a MediaStream has had tracks added to or removed from the stream through calls to Media Stream API methods. These events are sent to the stream when these changes occur. *)
module[@js.scope "MediaStreamTrackEvent"] MediaStreamTrackEvent : sig
  type t = [`Event | `MediaStreamTrackEvent] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Event | `MediaStreamTrackEvent]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Event | `MediaStreamTrackEvent]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MediaStreamTrackEvent ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_track: 'tags this -> MediaStreamTrack.t [@@js.get "track"]
  val create: track:MediaStreamTrack.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': type_:string -> eventInitDict:MediaStreamTrackEventInit.t -> t [@@js.create]
end

(** A stream of media content. A stream consists of several tracks such as video or audio tracks. Each track is specified as an instance of MediaStreamTrack. *)
module[@js.scope "MediaStream"] MediaStream : sig
  type t = [`EventTarget | `MediaStream] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventTarget | `MediaStream]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventTarget | `MediaStream]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MediaStream ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_active: 'tags this -> bool [@@js.get "active"]
  val get_id: 'tags this -> string [@@js.get "id"]
  val get_onaddtrack: 'tags this -> (this:t -> ev:MediaStreamTrackEvent.t -> any) option [@@js.get "onaddtrack"]
  val set_onaddtrack: 'tags this -> (this:t -> ev:MediaStreamTrackEvent.t -> any) option -> unit [@@js.set "onaddtrack"]
  val get_onremovetrack: 'tags this -> (this:t -> ev:MediaStreamTrackEvent.t -> any) option [@@js.get "onremovetrack"]
  val set_onremovetrack: 'tags this -> (this:t -> ev:MediaStreamTrackEvent.t -> any) option -> unit [@@js.set "onremovetrack"]
  val addTrack: 'tags this -> track:MediaStreamTrack.t -> unit [@@js.call "addTrack"]
  val clone: 'tags this -> t [@@js.call "clone"]
  val getAudioTracks: 'tags this -> MediaStreamTrack.t list [@@js.call "getAudioTracks"]
  val getTrackById: 'tags this -> trackId:string -> MediaStreamTrack.t option [@@js.call "getTrackById"]
  val getTracks: 'tags this -> MediaStreamTrack.t list [@@js.call "getTracks"]
  val getVideoTracks: 'tags this -> MediaStreamTrack.t list [@@js.call "getVideoTracks"]
  val removeTrack: 'tags this -> track:MediaStreamTrack.t -> unit [@@js.call "removeTrack"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'MediaStreamEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'MediaStreamEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
  val create': t -> t [@@js.create]
  val create'': MediaStreamTrack.t list -> t [@@js.create]
end

(** Provides the ability to control and obtain details about how a particular MediaStreamTrack is encoded and sent to a remote peer. *)
module[@js.scope "RTCRtpSender"] RTCRtpSender : sig
  type t = [`RTCRtpSender] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`RTCRtpSender]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`RTCRtpSender]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RTCRtpSender ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_dtmf: 'tags this -> RTCDTMFSender.t option [@@js.get "dtmf"]
  val get_track: 'tags this -> MediaStreamTrack.t option [@@js.get "track"]
  val get_transport: 'tags this -> RTCDtlsTransport.t option [@@js.get "transport"]
  val getParameters: 'tags this -> RTCRtpSendParameters.t [@@js.call "getParameters"]
  val getStats: 'tags this -> RTCStatsReport.t Promise.t_1 [@@js.call "getStats"]
  val replaceTrack: 'tags this -> withTrack:MediaStreamTrack.t option -> unit Promise.t_1 [@@js.call "replaceTrack"]
  val setParameters: 'tags this -> parameters:RTCRtpSendParameters.t -> unit Promise.t_1 [@@js.call "setParameters"]
  val setStreams: 'tags this -> streams:(MediaStream.t list [@js.variadic]) -> unit [@@js.call "setStreams"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
  val getCapabilities: string -> RTCRtpCapabilities.t option [@@js.global "getCapabilities"]
end
module RTCRtpContributingSource : sig
  type t = [`RTCRtpContributingSource] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`RTCRtpContributingSource]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`RTCRtpContributingSource]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RTCRtpContributingSource ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_audioLevel: 'tags this -> float option [@@js.get "audioLevel"]
  val set_audioLevel: 'tags this -> float -> unit [@@js.set "audioLevel"]
  val get_rtpTimestamp: 'tags this -> float [@@js.get "rtpTimestamp"]
  val set_rtpTimestamp: 'tags this -> float -> unit [@@js.set "rtpTimestamp"]
  val get_source: 'tags this -> float [@@js.get "source"]
  val set_source: 'tags this -> float -> unit [@@js.set "source"]
  val get_timestamp: 'tags this -> DOMHighResTimeStamp.t [@@js.get "timestamp"]
  val set_timestamp: 'tags this -> DOMHighResTimeStamp.t -> unit [@@js.set "timestamp"]
  val create: ?audioLevel:float -> rtpTimestamp:float -> source:float -> timestamp:DOMHighResTimeStamp.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module RTCRtpSynchronizationSource : sig
  type t = [`RTCRtpContributingSource | `RTCRtpSynchronizationSource] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`RTCRtpContributingSource | `RTCRtpSynchronizationSource]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`RTCRtpContributingSource | `RTCRtpSynchronizationSource]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RTCRtpSynchronizationSource ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module RTCRtpReceiveParameters : sig
  type t = [`RTCRtpParameters | `RTCRtpReceiveParameters] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`RTCRtpParameters | `RTCRtpReceiveParameters]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`RTCRtpParameters | `RTCRtpReceiveParameters]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RTCRtpReceiveParameters ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** This WebRTC API interface manages the reception and decoding of data for a MediaStreamTrack on an RTCPeerConnection. *)
module[@js.scope "RTCRtpReceiver"] RTCRtpReceiver : sig
  type t = [`RTCRtpReceiver] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`RTCRtpReceiver]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`RTCRtpReceiver]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RTCRtpReceiver ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_track: 'tags this -> MediaStreamTrack.t [@@js.get "track"]
  val get_transport: 'tags this -> RTCDtlsTransport.t option [@@js.get "transport"]
  val getContributingSources: 'tags this -> RTCRtpContributingSource.t list [@@js.call "getContributingSources"]
  val getParameters: 'tags this -> RTCRtpReceiveParameters.t [@@js.call "getParameters"]
  val getStats: 'tags this -> RTCStatsReport.t Promise.t_1 [@@js.call "getStats"]
  val getSynchronizationSources: 'tags this -> RTCRtpSynchronizationSource.t list [@@js.call "getSynchronizationSources"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
  val getCapabilities: string -> RTCRtpCapabilities.t option [@@js.global "getCapabilities"]
end
module[@js.scope "RTCRtpTransceiver"] RTCRtpTransceiver : sig
  type t = [`RTCRtpTransceiver] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`RTCRtpTransceiver]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`RTCRtpTransceiver]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RTCRtpTransceiver ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val setCodecPreferences: 'tags this -> codecs:RTCRtpCodecCapability.t Iterable.t_1 -> unit [@@js.call "setCodecPreferences"]
  val get_currentDirection: 'tags this -> RTCRtpTransceiverDirection.t option [@@js.get "currentDirection"]
  val get_direction: 'tags this -> RTCRtpTransceiverDirection.t [@@js.get "direction"]
  val set_direction: 'tags this -> RTCRtpTransceiverDirection.t -> unit [@@js.set "direction"]
  val get_mid: 'tags this -> string option [@@js.get "mid"]
  val get_receiver: 'tags this -> RTCRtpReceiver.t [@@js.get "receiver"]
  val get_sender: 'tags this -> RTCRtpSender.t [@@js.get "sender"]
  val setCodecPreferences': 'tags this -> codecs:RTCRtpCodecCapability.t list -> unit [@@js.call "setCodecPreferences"]
  val stop: 'tags this -> unit [@@js.call "stop"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module RTCTrackEventInit : sig
  type t = [`EventInit | `RTCTrackEventInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventInit | `RTCTrackEventInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventInit | `RTCTrackEventInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RTCTrackEventInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_receiver: 'tags this -> RTCRtpReceiver.t [@@js.get "receiver"]
  val set_receiver: 'tags this -> RTCRtpReceiver.t -> unit [@@js.set "receiver"]
  val get_streams: 'tags this -> MediaStream.t list option [@@js.get "streams"]
  val set_streams: 'tags this -> MediaStream.t list -> unit [@@js.set "streams"]
  val get_track: 'tags this -> MediaStreamTrack.t [@@js.get "track"]
  val set_track: 'tags this -> MediaStreamTrack.t -> unit [@@js.set "track"]
  val get_transceiver: 'tags this -> RTCRtpTransceiver.t [@@js.get "transceiver"]
  val set_transceiver: 'tags this -> RTCRtpTransceiver.t -> unit [@@js.set "transceiver"]
  val create: receiver:RTCRtpReceiver.t -> ?streams:MediaStream.t list -> track:MediaStreamTrack.t -> transceiver:RTCRtpTransceiver.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module[@js.scope "RTCTrackEvent"] RTCTrackEvent : sig
  type t = [`Event | `RTCTrackEvent] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Event | `RTCTrackEvent]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Event | `RTCTrackEvent]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RTCTrackEvent ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_receiver: 'tags this -> RTCRtpReceiver.t [@@js.get "receiver"]
  val get_streams: 'tags this -> MediaStream.t list [@@js.get "streams"]
  val get_track: 'tags this -> MediaStreamTrack.t [@@js.get "track"]
  val get_transceiver: 'tags this -> RTCRtpTransceiver.t [@@js.get "transceiver"]
  val create: receiver:RTCRtpReceiver.t -> streams:MediaStream.t list -> track:MediaStreamTrack.t -> transceiver:RTCRtpTransceiver.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': type_:string -> eventInitDict:RTCTrackEventInit.t -> t [@@js.create]
end
module RTCIceTcpCandidateType : sig
  type t = ([`L_s587_passive[@js "passive"] | `L_s735_so[@js "so"] | `L_s98_active[@js "active"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module RTCIceProtocol : sig
  type t = ([`L_s783_tcp[@js "tcp"] | `L_s821_udp[@js "udp"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module RTCIceComponent : sig
  type t = ([`L_s686_rtcp[@js "rtcp"] | `L_s688_rtp[@js "rtp"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module RTCIceCandidateType : sig
  type t = ([`L_s400_host[@js "host"] | `L_s635_prflx[@js "prflx"] | `L_s659_relay[@js "relay"] | `L_s749_srflx[@js "srflx"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module RTCIceCandidateInit : sig
  type t = [`RTCIceCandidateInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`RTCIceCandidateInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`RTCIceCandidateInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RTCIceCandidateInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_candidate: 'tags this -> string option [@@js.get "candidate"]
  val set_candidate: 'tags this -> string -> unit [@@js.set "candidate"]
  val get_sdpMLineIndex: 'tags this -> float option option [@@js.get "sdpMLineIndex"]
  val set_sdpMLineIndex: 'tags this -> float option -> unit [@@js.set "sdpMLineIndex"]
  val get_sdpMid: 'tags this -> string option option [@@js.get "sdpMid"]
  val set_sdpMid: 'tags this -> string option -> unit [@@js.set "sdpMid"]
  val get_usernameFragment: 'tags this -> string option option [@@js.get "usernameFragment"]
  val set_usernameFragment: 'tags this -> string option -> unit [@@js.set "usernameFragment"]
  val create: ?candidate:string -> ?sdpMLineIndex:float -> ?sdpMid:string -> ?usernameFragment:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** The RTCIceCandidate interface—part of the WebRTC API—represents a candidate Internet Connectivity Establishment (ICE) configuration which may be used to establish an RTCPeerConnection. *)
module[@js.scope "RTCIceCandidate"] RTCIceCandidate : sig
  type t = [`RTCIceCandidate] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`RTCIceCandidate]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`RTCIceCandidate]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RTCIceCandidate ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_address: 'tags this -> string option [@@js.get "address"]
  val get_candidate: 'tags this -> string [@@js.get "candidate"]
  val get_component: 'tags this -> RTCIceComponent.t option [@@js.get "component"]
  val get_foundation: 'tags this -> string option [@@js.get "foundation"]
  val get_port: 'tags this -> float option [@@js.get "port"]
  val get_priority: 'tags this -> float option [@@js.get "priority"]
  val get_protocol: 'tags this -> RTCIceProtocol.t option [@@js.get "protocol"]
  val get_relatedAddress: 'tags this -> string option [@@js.get "relatedAddress"]
  val get_relatedPort: 'tags this -> float option [@@js.get "relatedPort"]
  val get_sdpMLineIndex: 'tags this -> float option [@@js.get "sdpMLineIndex"]
  val get_sdpMid: 'tags this -> string option [@@js.get "sdpMid"]
  val get_tcpType: 'tags this -> RTCIceTcpCandidateType.t option [@@js.get "tcpType"]
  val get_type: 'tags this -> RTCIceCandidateType.t option [@@js.get "type"]
  val get_usernameFragment: 'tags this -> string option [@@js.get "usernameFragment"]
  val toJSON: 'tags this -> RTCIceCandidateInit.t [@@js.call "toJSON"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: ?candidateInitDict:RTCIceCandidateInit.t -> unit -> t [@@js.create]
end
module RTCPeerConnectionIceEventInit : sig
  type t = [`EventInit | `RTCPeerConnectionIceEventInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventInit | `RTCPeerConnectionIceEventInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventInit | `RTCPeerConnectionIceEventInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RTCPeerConnectionIceEventInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_candidate: 'tags this -> RTCIceCandidate.t option option [@@js.get "candidate"]
  val set_candidate: 'tags this -> RTCIceCandidate.t option -> unit [@@js.set "candidate"]
  val get_url: 'tags this -> string option option [@@js.get "url"]
  val set_url: 'tags this -> string option -> unit [@@js.set "url"]
  val create: ?candidate:RTCIceCandidate.t -> ?url:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** Events that occurs in relation to ICE candidates with the target, usually an RTCPeerConnection. Only one event is of this type: icecandidate. *)
module[@js.scope "RTCPeerConnectionIceEvent"] RTCPeerConnectionIceEvent : sig
  type t = [`Event | `RTCPeerConnectionIceEvent] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Event | `RTCPeerConnectionIceEvent]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Event | `RTCPeerConnectionIceEvent]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RTCPeerConnectionIceEvent ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_candidate: 'tags this -> RTCIceCandidate.t option [@@js.get "candidate"]
  val create: ?candidate:RTCIceCandidate.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': type_:string -> ?eventInitDict:RTCPeerConnectionIceEventInit.t -> unit -> t [@@js.create]
end
module RTCPeerConnectionIceErrorEventInit : sig
  type t = [`EventInit | `RTCPeerConnectionIceErrorEventInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventInit | `RTCPeerConnectionIceErrorEventInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventInit | `RTCPeerConnectionIceErrorEventInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RTCPeerConnectionIceErrorEventInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_address: 'tags this -> string option option [@@js.get "address"]
  val set_address: 'tags this -> string option -> unit [@@js.set "address"]
  val get_errorCode: 'tags this -> float [@@js.get "errorCode"]
  val set_errorCode: 'tags this -> float -> unit [@@js.set "errorCode"]
  val get_errorText: 'tags this -> string option [@@js.get "errorText"]
  val set_errorText: 'tags this -> string -> unit [@@js.set "errorText"]
  val get_port: 'tags this -> float option option [@@js.get "port"]
  val set_port: 'tags this -> float option -> unit [@@js.set "port"]
  val get_url: 'tags this -> string option [@@js.get "url"]
  val set_url: 'tags this -> string -> unit [@@js.set "url"]
  val create: ?address:string -> errorCode:float -> ?errorText:string -> ?port:float -> ?url:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module[@js.scope "RTCPeerConnectionIceErrorEvent"] RTCPeerConnectionIceErrorEvent : sig
  type t = [`Event | `RTCPeerConnectionIceErrorEvent] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Event | `RTCPeerConnectionIceErrorEvent]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Event | `RTCPeerConnectionIceErrorEvent]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RTCPeerConnectionIceErrorEvent ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_address: 'tags this -> string option [@@js.get "address"]
  val get_errorCode: 'tags this -> float [@@js.get "errorCode"]
  val get_errorText: 'tags this -> string [@@js.get "errorText"]
  val get_port: 'tags this -> float option [@@js.get "port"]
  val get_url: 'tags this -> string [@@js.get "url"]
  val create: ?address:string -> errorCode:float -> errorText:string -> ?port:float -> url:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': type_:string -> eventInitDict:RTCPeerConnectionIceErrorEventInit.t -> t [@@js.create]
end
module RTCDataChannelState : sig
  type t = ([`L_s199_closed[@js "closed"] | `L_s201_closing[@js "closing"] | `L_s217_connecting[@js "connecting"] | `L_s564_open[@js "open"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module BinaryType : sig
  type t = ([`L_s127_arraybuffer[@js "arraybuffer"] | `L_s161_blob[@js "blob"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module PaymentCurrencyAmount : sig
  type t = [`PaymentCurrencyAmount] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`PaymentCurrencyAmount]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`PaymentCurrencyAmount]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PaymentCurrencyAmount ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_currency: 'tags this -> string [@@js.get "currency"]
  val set_currency: 'tags this -> string -> unit [@@js.set "currency"]
  val get_value: 'tags this -> string [@@js.get "value"]
  val set_value: 'tags this -> string -> unit [@@js.set "value"]
  val create: currency:string -> value:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module PaymentItem : sig
  type t = [`PaymentItem] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`PaymentItem]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`PaymentItem]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PaymentItem ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_amount: 'tags this -> PaymentCurrencyAmount.t [@@js.get "amount"]
  val set_amount: 'tags this -> PaymentCurrencyAmount.t -> unit [@@js.set "amount"]
  val get_label: 'tags this -> string [@@js.get "label"]
  val set_label: 'tags this -> string -> unit [@@js.set "label"]
  val get_pending: 'tags this -> bool option [@@js.get "pending"]
  val set_pending: 'tags this -> bool -> unit [@@js.set "pending"]
  val create: amount:PaymentCurrencyAmount.t -> label:string -> ?pending:bool -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module PaymentDetailsModifier : sig
  type t = [`PaymentDetailsModifier] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`PaymentDetailsModifier]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`PaymentDetailsModifier]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PaymentDetailsModifier ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_additionalDisplayItems: 'tags this -> PaymentItem.t list option [@@js.get "additionalDisplayItems"]
  val set_additionalDisplayItems: 'tags this -> PaymentItem.t list -> unit [@@js.set "additionalDisplayItems"]
  val get_data: 'tags this -> any option [@@js.get "data"]
  val set_data: 'tags this -> any -> unit [@@js.set "data"]
  val get_supportedMethods: 'tags this -> string [@@js.get "supportedMethods"]
  val set_supportedMethods: 'tags this -> string -> unit [@@js.set "supportedMethods"]
  val get_total: 'tags this -> PaymentItem.t option [@@js.get "total"]
  val set_total: 'tags this -> PaymentItem.t -> unit [@@js.set "total"]
  val create: ?additionalDisplayItems:PaymentItem.t list -> ?data:any -> supportedMethods:string -> ?total:PaymentItem.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module PaymentDetailsBase : sig
  type t = [`PaymentDetailsBase] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`PaymentDetailsBase]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`PaymentDetailsBase]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PaymentDetailsBase ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_displayItems: 'tags this -> PaymentItem.t list option [@@js.get "displayItems"]
  val set_displayItems: 'tags this -> PaymentItem.t list -> unit [@@js.set "displayItems"]
  val get_modifiers: 'tags this -> PaymentDetailsModifier.t list option [@@js.get "modifiers"]
  val set_modifiers: 'tags this -> PaymentDetailsModifier.t list -> unit [@@js.set "modifiers"]
  val create: ?displayItems:PaymentItem.t list -> ?modifiers:PaymentDetailsModifier.t list -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module PaymentDetailsUpdate : sig
  type t = [`PaymentDetailsBase | `PaymentDetailsUpdate] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`PaymentDetailsBase | `PaymentDetailsUpdate]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`PaymentDetailsBase | `PaymentDetailsUpdate]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PaymentDetailsUpdate ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_paymentMethodErrors: 'tags this -> any option [@@js.get "paymentMethodErrors"]
  val set_paymentMethodErrors: 'tags this -> any -> unit [@@js.set "paymentMethodErrors"]
  val get_total: 'tags this -> PaymentItem.t option [@@js.get "total"]
  val set_total: 'tags this -> PaymentItem.t -> unit [@@js.set "total"]
  val create: ?paymentMethodErrors:any -> ?total:PaymentItem.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module PaymentRequestUpdateEventInit : sig
  type t = [`EventInit | `PaymentRequestUpdateEventInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventInit | `PaymentRequestUpdateEventInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventInit | `PaymentRequestUpdateEventInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PaymentRequestUpdateEventInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(**
  This Payment Request API interface enables a web page to update the details of a PaymentRequest in response to a user action.
  Available only in secure contexts.
*)
module[@js.scope "PaymentRequestUpdateEvent"] PaymentRequestUpdateEvent : sig
  type t = [`Event | `PaymentRequestUpdateEvent] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Event | `PaymentRequestUpdateEvent]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Event | `PaymentRequestUpdateEvent]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PaymentRequestUpdateEvent ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val updateWith: 'tags this -> detailsPromise:([`U1 of PaymentDetailsUpdate.t | `U2 of PaymentDetailsUpdate.t PromiseLike.t_1] [@js.union]) -> unit [@@js.call "updateWith"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: type_:string -> ?eventInitDict:PaymentRequestUpdateEventInit.t -> unit -> t [@@js.create]
end
module PaymentMethodChangeEventInit : sig
  type t = [`EventInit | `PaymentMethodChangeEventInit | `PaymentRequestUpdateEventInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventInit | `PaymentMethodChangeEventInit | `PaymentRequestUpdateEventInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventInit | `PaymentMethodChangeEventInit | `PaymentRequestUpdateEventInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PaymentMethodChangeEventInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_methodDetails: 'tags this -> any option [@@js.get "methodDetails"]
  val set_methodDetails: 'tags this -> any -> unit [@@js.set "methodDetails"]
  val get_methodName: 'tags this -> string option [@@js.get "methodName"]
  val set_methodName: 'tags this -> string -> unit [@@js.set "methodName"]
  val create: ?methodDetails:any -> ?methodName:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** Available only in secure contexts. *)
module[@js.scope "PaymentMethodChangeEvent"] PaymentMethodChangeEvent : sig
  type t = [`Event | `PaymentMethodChangeEvent | `PaymentRequestUpdateEvent] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Event | `PaymentMethodChangeEvent | `PaymentRequestUpdateEvent]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Event | `PaymentMethodChangeEvent | `PaymentRequestUpdateEvent]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PaymentMethodChangeEvent ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_methodDetails: 'tags this -> any [@@js.get "methodDetails"]
  val get_methodName: 'tags this -> string [@@js.get "methodName"]
  val create: methodDetails:any -> methodName:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': type_:string -> ?eventInitDict:PaymentMethodChangeEventInit.t -> unit -> t [@@js.create]
end
module AudioBufferOptions : sig
  type t = [`AudioBufferOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AudioBufferOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AudioBufferOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `AudioBufferOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_length: 'tags this -> float [@@js.get "length"]
  val set_length: 'tags this -> float -> unit [@@js.set "length"]
  val get_numberOfChannels: 'tags this -> float option [@@js.get "numberOfChannels"]
  val set_numberOfChannels: 'tags this -> float -> unit [@@js.set "numberOfChannels"]
  val get_sampleRate: 'tags this -> float [@@js.get "sampleRate"]
  val set_sampleRate: 'tags this -> float -> unit [@@js.set "sampleRate"]
  val create: length:float -> ?numberOfChannels:float -> sampleRate:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** A short audio asset residing in memory, created from an audio file using the AudioContext.decodeAudioData() method, or from raw data using AudioContext.createBuffer(). Once put into an AudioBuffer, the audio can then be played by being passed into an AudioBufferSourceNode. *)
module[@js.scope "AudioBuffer"] AudioBuffer : sig
  type t = [`AudioBuffer] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AudioBuffer]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AudioBuffer]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `AudioBuffer ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_duration: 'tags this -> float [@@js.get "duration"]
  val get_length: 'tags this -> float [@@js.get "length"]
  val get_numberOfChannels: 'tags this -> float [@@js.get "numberOfChannels"]
  val get_sampleRate: 'tags this -> float [@@js.get "sampleRate"]
  val copyFromChannel: 'tags this -> destination:Float32Array.t_0 -> channelNumber:float -> ?bufferOffset:float -> unit -> unit [@@js.call "copyFromChannel"]
  val copyToChannel: 'tags this -> source:Float32Array.t_0 -> channelNumber:float -> ?bufferOffset:float -> unit -> unit [@@js.call "copyToChannel"]
  val getChannelData: 'tags this -> channel:float -> Float32Array.t_0 [@@js.call "getChannelData"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: AudioBufferOptions.t -> t [@@js.create]
end
module OfflineAudioCompletionEventInit : sig
  type t = [`EventInit | `OfflineAudioCompletionEventInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventInit | `OfflineAudioCompletionEventInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventInit | `OfflineAudioCompletionEventInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `OfflineAudioCompletionEventInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_renderedBuffer: 'tags this -> AudioBuffer.t [@@js.get "renderedBuffer"]
  val set_renderedBuffer: 'tags this -> AudioBuffer.t -> unit [@@js.set "renderedBuffer"]
  val create: renderedBuffer:AudioBuffer.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** The Web Audio API OfflineAudioCompletionEvent interface represents events that occur when the processing of an OfflineAudioContext is terminated. The complete event implements this interface. *)
module[@js.scope "OfflineAudioCompletionEvent"] OfflineAudioCompletionEvent : sig
  type t = [`Event | `OfflineAudioCompletionEvent] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Event | `OfflineAudioCompletionEvent]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Event | `OfflineAudioCompletionEvent]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `OfflineAudioCompletionEvent ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_renderedBuffer: 'tags this -> AudioBuffer.t [@@js.get "renderedBuffer"]
  val create: renderedBuffer:AudioBuffer.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': type_:string -> eventInitDict:OfflineAudioCompletionEventInit.t -> t [@@js.create]
end

(** An abnormal event (called an exception) which occurs as a result of calling a method or accessing a property of a web API. *)
module[@js.scope "DOMException"] DOMException : sig
  type t = [`DOMException] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`DOMException]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`DOMException]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `DOMException ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_code: 'tags this -> float [@@js.get "code"]
  val get_message: 'tags this -> string [@@js.get "message"]
  val get_name: 'tags this -> string [@@js.get "name"]
  val get_ABORT_ERR: 'tags this -> float [@@js.get "ABORT_ERR"]
  val get_DATA_CLONE_ERR: 'tags this -> float [@@js.get "DATA_CLONE_ERR"]
  val get_DOMSTRING_SIZE_ERR: 'tags this -> float [@@js.get "DOMSTRING_SIZE_ERR"]
  val get_HIERARCHY_REQUEST_ERR: 'tags this -> float [@@js.get "HIERARCHY_REQUEST_ERR"]
  val get_INDEX_SIZE_ERR: 'tags this -> float [@@js.get "INDEX_SIZE_ERR"]
  val get_INUSE_ATTRIBUTE_ERR: 'tags this -> float [@@js.get "INUSE_ATTRIBUTE_ERR"]
  val get_INVALID_ACCESS_ERR: 'tags this -> float [@@js.get "INVALID_ACCESS_ERR"]
  val get_INVALID_CHARACTER_ERR: 'tags this -> float [@@js.get "INVALID_CHARACTER_ERR"]
  val get_INVALID_MODIFICATION_ERR: 'tags this -> float [@@js.get "INVALID_MODIFICATION_ERR"]
  val get_INVALID_NODE_TYPE_ERR: 'tags this -> float [@@js.get "INVALID_NODE_TYPE_ERR"]
  val get_INVALID_STATE_ERR: 'tags this -> float [@@js.get "INVALID_STATE_ERR"]
  val get_NAMESPACE_ERR: 'tags this -> float [@@js.get "NAMESPACE_ERR"]
  val get_NETWORK_ERR: 'tags this -> float [@@js.get "NETWORK_ERR"]
  val get_NOT_FOUND_ERR: 'tags this -> float [@@js.get "NOT_FOUND_ERR"]
  val get_NOT_SUPPORTED_ERR: 'tags this -> float [@@js.get "NOT_SUPPORTED_ERR"]
  val get_NO_DATA_ALLOWED_ERR: 'tags this -> float [@@js.get "NO_DATA_ALLOWED_ERR"]
  val get_NO_MODIFICATION_ALLOWED_ERR: 'tags this -> float [@@js.get "NO_MODIFICATION_ALLOWED_ERR"]
  val get_QUOTA_EXCEEDED_ERR: 'tags this -> float [@@js.get "QUOTA_EXCEEDED_ERR"]
  val get_SECURITY_ERR: 'tags this -> float [@@js.get "SECURITY_ERR"]
  val get_SYNTAX_ERR: 'tags this -> float [@@js.get "SYNTAX_ERR"]
  val get_TIMEOUT_ERR: 'tags this -> float [@@js.get "TIMEOUT_ERR"]
  val get_TYPE_MISMATCH_ERR: 'tags this -> float [@@js.get "TYPE_MISMATCH_ERR"]
  val get_URL_MISMATCH_ERR: 'tags this -> float [@@js.get "URL_MISMATCH_ERR"]
  val get_VALIDATION_ERR: 'tags this -> float [@@js.get "VALIDATION_ERR"]
  val get_WRONG_DOCUMENT_ERR: 'tags this -> float [@@js.get "WRONG_DOCUMENT_ERR"]
  val create: code:float -> message:string -> name:string -> abort_err:(float[@js "ABORT_ERR"]) -> data_clone_err:(float[@js "DATA_CLONE_ERR"]) -> domstring_size_err:(float[@js "DOMSTRING_SIZE_ERR"]) -> hierarchy_request_err:(float[@js "HIERARCHY_REQUEST_ERR"]) -> index_size_err:(float[@js "INDEX_SIZE_ERR"]) -> inuse_attribute_err:(float[@js "INUSE_ATTRIBUTE_ERR"]) -> invalid_access_err:(float[@js "INVALID_ACCESS_ERR"]) -> invalid_character_err:(float[@js "INVALID_CHARACTER_ERR"]) -> invalid_modification_err:(float[@js "INVALID_MODIFICATION_ERR"]) -> invalid_node_type_err:(float[@js "INVALID_NODE_TYPE_ERR"]) -> invalid_state_err:(float[@js "INVALID_STATE_ERR"]) -> namespace_err:(float[@js "NAMESPACE_ERR"]) -> network_err:(float[@js "NETWORK_ERR"]) -> not_found_err:(float[@js "NOT_FOUND_ERR"]) -> not_supported_err:(float[@js "NOT_SUPPORTED_ERR"]) -> no_data_allowed_err:(float[@js "NO_DATA_ALLOWED_ERR"]) -> no_modification_allowed_err:(float[@js "NO_MODIFICATION_ALLOWED_ERR"]) -> quota_exceeded_err:(float[@js "QUOTA_EXCEEDED_ERR"]) -> security_err:(float[@js "SECURITY_ERR"]) -> syntax_err:(float[@js "SYNTAX_ERR"]) -> timeout_err:(float[@js "TIMEOUT_ERR"]) -> type_mismatch_err:(float[@js "TYPE_MISMATCH_ERR"]) -> url_mismatch_err:(float[@js "URL_MISMATCH_ERR"]) -> validation_err:(float[@js "VALIDATION_ERR"]) -> wrong_document_err:(float[@js "WRONG_DOCUMENT_ERR"]) -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': ?message:string -> ?name:string -> unit -> t [@@js.create]
  val abort_err: unit -> float [@@js.get "ABORT_ERR"]
  val data_clone_err: unit -> float [@@js.get "DATA_CLONE_ERR"]
  val domstring_size_err: unit -> float [@@js.get "DOMSTRING_SIZE_ERR"]
  val hierarchy_request_err: unit -> float [@@js.get "HIERARCHY_REQUEST_ERR"]
  val index_size_err: unit -> float [@@js.get "INDEX_SIZE_ERR"]
  val inuse_attribute_err: unit -> float [@@js.get "INUSE_ATTRIBUTE_ERR"]
  val invalid_access_err: unit -> float [@@js.get "INVALID_ACCESS_ERR"]
  val invalid_character_err: unit -> float [@@js.get "INVALID_CHARACTER_ERR"]
  val invalid_modification_err: unit -> float [@@js.get "INVALID_MODIFICATION_ERR"]
  val invalid_node_type_err: unit -> float [@@js.get "INVALID_NODE_TYPE_ERR"]
  val invalid_state_err: unit -> float [@@js.get "INVALID_STATE_ERR"]
  val namespace_err: unit -> float [@@js.get "NAMESPACE_ERR"]
  val network_err: unit -> float [@@js.get "NETWORK_ERR"]
  val not_found_err: unit -> float [@@js.get "NOT_FOUND_ERR"]
  val not_supported_err: unit -> float [@@js.get "NOT_SUPPORTED_ERR"]
  val no_data_allowed_err: unit -> float [@@js.get "NO_DATA_ALLOWED_ERR"]
  val no_modification_allowed_err: unit -> float [@@js.get "NO_MODIFICATION_ALLOWED_ERR"]
  val quota_exceeded_err: unit -> float [@@js.get "QUOTA_EXCEEDED_ERR"]
  val security_err: unit -> float [@@js.get "SECURITY_ERR"]
  val syntax_err: unit -> float [@@js.get "SYNTAX_ERR"]
  val timeout_err: unit -> float [@@js.get "TIMEOUT_ERR"]
  val type_mismatch_err: unit -> float [@@js.get "TYPE_MISMATCH_ERR"]
  val url_mismatch_err: unit -> float [@@js.get "URL_MISMATCH_ERR"]
  val validation_err: unit -> float [@@js.get "VALIDATION_ERR"]
  val wrong_document_err: unit -> float [@@js.get "WRONG_DOCUMENT_ERR"]
end
module MediaRecorderErrorEventInit : sig
  type t = [`EventInit | `MediaRecorderErrorEventInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventInit | `MediaRecorderErrorEventInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventInit | `MediaRecorderErrorEventInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MediaRecorderErrorEventInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_error: 'tags this -> DOMException.t [@@js.get "error"]
  val set_error: 'tags this -> DOMException.t -> unit [@@js.set "error"]
  val create: error:DOMException.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module[@js.scope "MediaRecorderErrorEvent"] MediaRecorderErrorEvent : sig
  type t = [`Event | `MediaRecorderErrorEvent] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Event | `MediaRecorderErrorEvent]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Event | `MediaRecorderErrorEvent]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MediaRecorderErrorEvent ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_error: 'tags this -> DOMException.t [@@js.get "error"]
  val create: error:DOMException.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': type_:string -> eventInitDict:MediaRecorderErrorEventInit.t -> t [@@js.create]
end
module HTMLHyperlinkElementUtils : sig
  type t = [`HTMLHyperlinkElementUtils] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`HTMLHyperlinkElementUtils]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`HTMLHyperlinkElementUtils]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLHyperlinkElementUtils ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    Returns the hyperlink's URL's fragment (includes leading "#" if non-empty).
    
    Can be set, to change the URL's fragment (ignores leading "#").
  *)
  val get_hash: 'tags this -> string [@@js.get "hash"]
  
  (**
    Returns the hyperlink's URL's fragment (includes leading "#" if non-empty).
    
    Can be set, to change the URL's fragment (ignores leading "#").
  *)
  val set_hash: 'tags this -> string -> unit [@@js.set "hash"]
  
  (**
    Returns the hyperlink's URL's host and port (if different from the default port for the scheme).
    
    Can be set, to change the URL's host and port.
  *)
  val get_host: 'tags this -> string [@@js.get "host"]
  
  (**
    Returns the hyperlink's URL's host and port (if different from the default port for the scheme).
    
    Can be set, to change the URL's host and port.
  *)
  val set_host: 'tags this -> string -> unit [@@js.set "host"]
  
  (**
    Returns the hyperlink's URL's host.
    
    Can be set, to change the URL's host.
  *)
  val get_hostname: 'tags this -> string [@@js.get "hostname"]
  
  (**
    Returns the hyperlink's URL's host.
    
    Can be set, to change the URL's host.
  *)
  val set_hostname: 'tags this -> string -> unit [@@js.set "hostname"]
  
  (**
    Returns the hyperlink's URL.
    
    Can be set, to change the URL.
  *)
  val get_href: 'tags this -> string [@@js.get "href"]
  
  (**
    Returns the hyperlink's URL.
    
    Can be set, to change the URL.
  *)
  val set_href: 'tags this -> string -> unit [@@js.set "href"]
  val toString: 'tags this -> string [@@js.call "toString"]
  
  (** Returns the hyperlink's URL's origin. *)
  val get_origin: 'tags this -> string [@@js.get "origin"]
  
  (**
    Returns the hyperlink's URL's password.
    
    Can be set, to change the URL's password.
  *)
  val get_password: 'tags this -> string [@@js.get "password"]
  
  (**
    Returns the hyperlink's URL's password.
    
    Can be set, to change the URL's password.
  *)
  val set_password: 'tags this -> string -> unit [@@js.set "password"]
  
  (**
    Returns the hyperlink's URL's path.
    
    Can be set, to change the URL's path.
  *)
  val get_pathname: 'tags this -> string [@@js.get "pathname"]
  
  (**
    Returns the hyperlink's URL's path.
    
    Can be set, to change the URL's path.
  *)
  val set_pathname: 'tags this -> string -> unit [@@js.set "pathname"]
  
  (**
    Returns the hyperlink's URL's port.
    
    Can be set, to change the URL's port.
  *)
  val get_port: 'tags this -> string [@@js.get "port"]
  
  (**
    Returns the hyperlink's URL's port.
    
    Can be set, to change the URL's port.
  *)
  val set_port: 'tags this -> string -> unit [@@js.set "port"]
  
  (**
    Returns the hyperlink's URL's scheme.
    
    Can be set, to change the URL's scheme.
  *)
  val get_protocol: 'tags this -> string [@@js.get "protocol"]
  
  (**
    Returns the hyperlink's URL's scheme.
    
    Can be set, to change the URL's scheme.
  *)
  val set_protocol: 'tags this -> string -> unit [@@js.set "protocol"]
  
  (**
    Returns the hyperlink's URL's query (includes leading "?" if non-empty).
    
    Can be set, to change the URL's query (ignores leading "?").
  *)
  val get_search: 'tags this -> string [@@js.get "search"]
  
  (**
    Returns the hyperlink's URL's query (includes leading "?" if non-empty).
    
    Can be set, to change the URL's query (ignores leading "?").
  *)
  val set_search: 'tags this -> string -> unit [@@js.set "search"]
  
  (**
    Returns the hyperlink's URL's username.
    
    Can be set, to change the URL's username.
  *)
  val get_username: 'tags this -> string [@@js.get "username"]
  
  (**
    Returns the hyperlink's URL's username.
    
    Can be set, to change the URL's username.
  *)
  val set_username: 'tags this -> string -> unit [@@js.set "username"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module FontFaceSetLoadStatus : sig
  type t = ([`L_s474_loaded[@js "loaded"] | `L_s478_loading[@js "loading"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module FontFaceLoadStatus : sig
  type t = ([`L_s298_error[@js "error"] | `L_s474_loaded[@js "loaded"] | `L_s478_loading[@js "loading"] | `L_s830_unloaded[@js "unloaded"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module FontFaceDescriptors : sig
  type t = [`FontFaceDescriptors] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`FontFaceDescriptors]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`FontFaceDescriptors]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `FontFaceDescriptors ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_display: 'tags this -> string option [@@js.get "display"]
  val set_display: 'tags this -> string -> unit [@@js.set "display"]
  val get_featureSettings: 'tags this -> string option [@@js.get "featureSettings"]
  val set_featureSettings: 'tags this -> string -> unit [@@js.set "featureSettings"]
  val get_stretch: 'tags this -> string option [@@js.get "stretch"]
  val set_stretch: 'tags this -> string -> unit [@@js.set "stretch"]
  val get_style: 'tags this -> string option [@@js.get "style"]
  val set_style: 'tags this -> string -> unit [@@js.set "style"]
  val get_unicodeRange: 'tags this -> string option [@@js.get "unicodeRange"]
  val set_unicodeRange: 'tags this -> string -> unit [@@js.set "unicodeRange"]
  val get_variant: 'tags this -> string option [@@js.get "variant"]
  val set_variant: 'tags this -> string -> unit [@@js.set "variant"]
  val get_weight: 'tags this -> string option [@@js.get "weight"]
  val set_weight: 'tags this -> string -> unit [@@js.set "weight"]
  val create: ?display:string -> ?featureSettings:string -> ?stretch:string -> ?style:string -> ?unicodeRange:string -> ?variant:string -> ?weight:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module BinaryData : sig
  type t = (ArrayBuffer.t_0, ArrayBufferView.t_0) union2
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module[@js.scope "FontFace"] FontFace : sig
  type t = [`FontFace] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`FontFace]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`FontFace]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `FontFace ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_ascentOverride: 'tags this -> string [@@js.get "ascentOverride"]
  val set_ascentOverride: 'tags this -> string -> unit [@@js.set "ascentOverride"]
  val get_descentOverride: 'tags this -> string [@@js.get "descentOverride"]
  val set_descentOverride: 'tags this -> string -> unit [@@js.set "descentOverride"]
  val get_display: 'tags this -> string [@@js.get "display"]
  val set_display: 'tags this -> string -> unit [@@js.set "display"]
  val get_family: 'tags this -> string [@@js.get "family"]
  val set_family: 'tags this -> string -> unit [@@js.set "family"]
  val get_featureSettings: 'tags this -> string [@@js.get "featureSettings"]
  val set_featureSettings: 'tags this -> string -> unit [@@js.set "featureSettings"]
  val get_lineGapOverride: 'tags this -> string [@@js.get "lineGapOverride"]
  val set_lineGapOverride: 'tags this -> string -> unit [@@js.set "lineGapOverride"]
  val get_loaded: 'tags this -> t Promise.t_1 [@@js.get "loaded"]
  val get_status: 'tags this -> FontFaceLoadStatus.t [@@js.get "status"]
  val get_stretch: 'tags this -> string [@@js.get "stretch"]
  val set_stretch: 'tags this -> string -> unit [@@js.set "stretch"]
  val get_style: 'tags this -> string [@@js.get "style"]
  val set_style: 'tags this -> string -> unit [@@js.set "style"]
  val get_unicodeRange: 'tags this -> string [@@js.get "unicodeRange"]
  val set_unicodeRange: 'tags this -> string -> unit [@@js.set "unicodeRange"]
  val get_variant: 'tags this -> string [@@js.get "variant"]
  val set_variant: 'tags this -> string -> unit [@@js.set "variant"]
  val get_variationSettings: 'tags this -> string [@@js.get "variationSettings"]
  val set_variationSettings: 'tags this -> string -> unit [@@js.set "variationSettings"]
  val get_weight: 'tags this -> string [@@js.get "weight"]
  val set_weight: 'tags this -> string -> unit [@@js.set "weight"]
  val load: 'tags this -> t Promise.t_1 [@@js.call "load"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: family:string -> source:([`U1 of string | `U2 of BinaryData.t] [@js.union]) -> ?descriptors:FontFaceDescriptors.t -> unit -> t [@@js.create]
end
module[@js.scope "FontFaceSet"] FontFaceSet : sig
  type t = [`EventTarget | `FontFaceSet] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventTarget | `FontFaceSet]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventTarget | `FontFaceSet]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `FontFaceSet ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_onloading: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onloading"]
  val set_onloading: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onloading"]
  val get_onloadingdone: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onloadingdone"]
  val set_onloadingdone: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onloadingdone"]
  val get_onloadingerror: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onloadingerror"]
  val set_onloadingerror: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onloadingerror"]
  val get_ready: 'tags this -> t Promise.t_1 [@@js.get "ready"]
  val get_status: 'tags this -> FontFaceSetLoadStatus.t [@@js.get "status"]
  val check: 'tags this -> font:string -> ?text:string -> unit -> bool [@@js.call "check"]
  val load: 'tags this -> font:string -> ?text:string -> unit -> FontFace.t list Promise.t_1 [@@js.call "load"]
  val forEach: 'tags this -> callbackfn:(value:FontFace.t -> key:FontFace.t -> parent:t -> unit) -> ?thisArg:any -> unit -> unit [@@js.call "forEach"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'FontFaceSetEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'FontFaceSetEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: FontFace.t list -> t [@@js.create]
end
module FontFaceSource : sig
  type t = [`FontFaceSource] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`FontFaceSource]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`FontFaceSource]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `FontFaceSource ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_fonts: 'tags this -> FontFaceSet.t [@@js.get "fonts"]
  val create: fonts:FontFaceSet.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module FontFaceSetLoadEventInit : sig
  type t = [`EventInit | `FontFaceSetLoadEventInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventInit | `FontFaceSetLoadEventInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventInit | `FontFaceSetLoadEventInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `FontFaceSetLoadEventInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_fontfaces: 'tags this -> FontFace.t list option [@@js.get "fontfaces"]
  val set_fontfaces: 'tags this -> FontFace.t list -> unit [@@js.set "fontfaces"]
  val create: ?fontfaces:FontFace.t list -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module[@js.scope "FontFaceSetLoadEvent"] FontFaceSetLoadEvent : sig
  type t = [`Event | `FontFaceSetLoadEvent] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Event | `FontFaceSetLoadEvent]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Event | `FontFaceSetLoadEvent]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `FontFaceSetLoadEvent ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_fontfaces: 'tags this -> FontFace.t list [@@js.get "fontfaces"]
  val create: fontfaces:FontFace.t list -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': type_:string -> ?eventInitDict:FontFaceSetLoadEventInit.t -> unit -> t [@@js.create]
end
module ElementCreationOptions : sig
  type t = [`ElementCreationOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ElementCreationOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ElementCreationOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ElementCreationOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_is: 'tags this -> string option [@@js.get "is"]
  val set_is: 'tags this -> string -> unit [@@js.set "is"]
  val create: ?is:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module DocumentVisibilityState : sig
  type t = ([`L_s393_hidden[@js "hidden"] | `L_s856_visible[@js "visible"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module DocumentTimelineOptions : sig
  type t = [`DocumentTimelineOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`DocumentTimelineOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`DocumentTimelineOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `DocumentTimelineOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_originTime: 'tags this -> DOMHighResTimeStamp.t option [@@js.get "originTime"]
  val set_originTime: 'tags this -> DOMHighResTimeStamp.t -> unit [@@js.set "originTime"]
  val create: ?originTime:DOMHighResTimeStamp.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module[@js.scope "AnimationTimeline"] AnimationTimeline : sig
  type t = [`AnimationTimeline] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AnimationTimeline]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AnimationTimeline]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `AnimationTimeline ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_currentTime: 'tags this -> float option [@@js.get "currentTime"]
  val create: ?currentTime:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end
module[@js.scope "DocumentTimeline"] DocumentTimeline : sig
  type t = [`AnimationTimeline | `DocumentTimeline] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AnimationTimeline | `DocumentTimeline]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AnimationTimeline | `DocumentTimeline]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `DocumentTimeline ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: ?options:DocumentTimelineOptions.t -> unit -> t [@@js.create]
end
module DocumentReadyState : sig
  type t = ([`L_s209_complete[@js "complete"] | `L_s433_interactive[@js "interactive"] | `L_s478_loading[@js "loading"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module CustomEventInit : sig
  type 'T t = [`CustomEventInit of 'T | `EventInit] intf [@@js.custom { of_js=(fun _T -> Obj.magic); to_js=(fun _T -> Obj.magic) }]
  type 'T t_1 = 'T t
  type t_0 = any t
  [@@@js.stop]
  type 'T tags = [`CustomEventInit of 'T | `EventInit]
  type 'T tags_1 = 'T tags
  type tags_0 = any tags
  [@@@js.start]
  [@@@js.implem 
    type 'T tags = [`CustomEventInit of 'T | `EventInit]
    type 'T tags_1 = 'T tags
    type tags_0 = any tags
  ]
  type ('tags, 'T) this = 'tags intf constraint 'tags = [> `CustomEventInit of 'T ]
  val t_to_js: ('T -> Ojs.t) -> 'T t -> Ojs.t
  val t_of_js: (Ojs.t -> 'T) -> Ojs.t -> 'T t
  val t_1_to_js: ('T -> Ojs.t) -> 'T t_1 -> Ojs.t
  val t_1_of_js: (Ojs.t -> 'T) -> Ojs.t -> 'T t_1
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_detail: ('tags, 'T) this -> 'T option [@@js.get "detail"]
  val set_detail: ('tags, 'T) this -> 'T -> unit [@@js.set "detail"]
  val create: ?detail:'T -> unit -> 'T t [@@js.builder]
  val cast_from: ('tags, 'T) this -> 'T t [@@js.custom let cast_from = Obj.magic]
end
module[@js.scope "CustomEvent"] CustomEvent : sig
  type 'T t = [`CustomEvent of 'T | `Event] intf [@@js.custom { of_js=(fun _T -> Obj.magic); to_js=(fun _T -> Obj.magic) }]
  type 'T t_1 = 'T t
  type t_0 = any t
  [@@@js.stop]
  type 'T tags = [`CustomEvent of 'T | `Event]
  type 'T tags_1 = 'T tags
  type tags_0 = any tags
  [@@@js.start]
  [@@@js.implem 
    type 'T tags = [`CustomEvent of 'T | `Event]
    type 'T tags_1 = 'T tags
    type tags_0 = any tags
  ]
  type ('tags, 'T) this = 'tags intf constraint 'tags = [> `CustomEvent of 'T ]
  val t_to_js: ('T -> Ojs.t) -> 'T t -> Ojs.t
  val t_of_js: (Ojs.t -> 'T) -> Ojs.t -> 'T t
  val t_1_to_js: ('T -> Ojs.t) -> 'T t_1 -> Ojs.t
  val t_1_of_js: (Ojs.t -> 'T) -> Ojs.t -> 'T t_1
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Returns any custom data event was created with. Typically used for synthetic events. *)
  val get_detail: ('tags, 'T) this -> 'T [@@js.get "detail"]
  
  (** @deprecated  *)
  val initCustomEvent: ('tags, 'T) this -> type_:string -> ?bubbles:bool -> ?cancelable:bool -> ?detail:'T -> unit -> unit [@@js.call "initCustomEvent"]
  val cast_from: ('tags, 'T) this -> 'T t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t_0 [@@js.get "prototype"]
  val create: type_:string -> ?eventInitDict:'T CustomEventInit.t -> unit -> 'T t [@@js.create]
end
module CloseEventInit : sig
  type t = [`CloseEventInit | `EventInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`CloseEventInit | `EventInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`CloseEventInit | `EventInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `CloseEventInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_code: 'tags this -> float option [@@js.get "code"]
  val set_code: 'tags this -> float -> unit [@@js.set "code"]
  val get_reason: 'tags this -> string option [@@js.get "reason"]
  val set_reason: 'tags this -> string -> unit [@@js.set "reason"]
  val get_wasClean: 'tags this -> bool option [@@js.get "wasClean"]
  val set_wasClean: 'tags this -> bool -> unit [@@js.set "wasClean"]
  val create: ?code:float -> ?reason:string -> ?wasClean:bool -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** A CloseEvent is sent to clients using WebSockets when the connection is closed. This is delivered to the listener indicated by the WebSocket object's onclose attribute. *)
module[@js.scope "CloseEvent"] CloseEvent : sig
  type t = [`CloseEvent | `Event] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`CloseEvent | `Event]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`CloseEvent | `Event]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `CloseEvent ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Returns the WebSocket connection close code provided by the server. *)
  val get_code: 'tags this -> float [@@js.get "code"]
  
  (** Returns the WebSocket connection close reason provided by the server. *)
  val get_reason: 'tags this -> string [@@js.get "reason"]
  
  (** Returns true if the connection closed cleanly; false otherwise. *)
  val get_wasClean: 'tags this -> bool [@@js.get "wasClean"]
  val create: code:float -> reason:string -> wasClean:bool -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': type_:string -> ?eventInitDict:CloseEventInit.t -> unit -> t [@@js.create]
end
module BlobEventInit : sig
  type t = [`BlobEventInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`BlobEventInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`BlobEventInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `BlobEventInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_data: 'tags this -> Blob.t [@@js.get "data"]
  val set_data: 'tags this -> Blob.t -> unit [@@js.set "data"]
  val get_timecode: 'tags this -> DOMHighResTimeStamp.t option [@@js.get "timecode"]
  val set_timecode: 'tags this -> DOMHighResTimeStamp.t -> unit [@@js.set "timecode"]
  val create: data:Blob.t -> ?timecode:DOMHighResTimeStamp.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module[@js.scope "BlobEvent"] BlobEvent : sig
  type t = [`BlobEvent | `Event] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`BlobEvent | `Event]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`BlobEvent | `Event]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `BlobEvent ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_data: 'tags this -> Blob.t [@@js.get "data"]
  val get_timecode: 'tags this -> DOMHighResTimeStamp.t [@@js.get "timecode"]
  val create: data:Blob.t -> timecode:DOMHighResTimeStamp.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': type_:string -> eventInitDict:BlobEventInit.t -> t [@@js.create]
end
module AudioProcessingEventInit : sig
  type t = [`AudioProcessingEventInit | `EventInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AudioProcessingEventInit | `EventInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AudioProcessingEventInit | `EventInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `AudioProcessingEventInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_inputBuffer: 'tags this -> AudioBuffer.t [@@js.get "inputBuffer"]
  val set_inputBuffer: 'tags this -> AudioBuffer.t -> unit [@@js.set "inputBuffer"]
  val get_outputBuffer: 'tags this -> AudioBuffer.t [@@js.get "outputBuffer"]
  val set_outputBuffer: 'tags this -> AudioBuffer.t -> unit [@@js.set "outputBuffer"]
  val get_playbackTime: 'tags this -> float [@@js.get "playbackTime"]
  val set_playbackTime: 'tags this -> float -> unit [@@js.set "playbackTime"]
  val create: inputBuffer:AudioBuffer.t -> outputBuffer:AudioBuffer.t -> playbackTime:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** The Web Audio API events that occur when a ScriptProcessorNode input buffer is ready to be processed. *)
module[@js.scope "AudioProcessingEvent"] AudioProcessingEvent : sig
  type t = [`AudioProcessingEvent | `Event] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AudioProcessingEvent | `Event]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AudioProcessingEvent | `Event]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `AudioProcessingEvent ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** @deprecated  *)
  val get_inputBuffer: 'tags this -> AudioBuffer.t [@@js.get "inputBuffer"]
  
  (** @deprecated  *)
  val get_outputBuffer: 'tags this -> AudioBuffer.t [@@js.get "outputBuffer"]
  
  (** @deprecated  *)
  val get_playbackTime: 'tags this -> float [@@js.get "playbackTime"]
  val create: inputBuffer:AudioBuffer.t -> outputBuffer:AudioBuffer.t -> playbackTime:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': type_:string -> eventInitDict:AudioProcessingEventInit.t -> t [@@js.create]
end
module AssignedNodesOptions : sig
  type t = [`AssignedNodesOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AssignedNodesOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AssignedNodesOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `AssignedNodesOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_flatten: 'tags this -> bool option [@@js.get "flatten"]
  val set_flatten: 'tags this -> bool -> unit [@@js.set "flatten"]
  val create: ?flatten:bool -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module SlotAssignmentMode : sig
  type t = ([`L_s495_manual[@js "manual"] | `L_s530_named[@js "named"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module ShadowRootMode : sig
  type t = ([`L_s199_closed[@js "closed"] | `L_s564_open[@js "open"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module ShadowRootInit : sig
  type t = [`ShadowRootInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ShadowRootInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ShadowRootInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ShadowRootInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_delegatesFocus: 'tags this -> bool option [@@js.get "delegatesFocus"]
  val set_delegatesFocus: 'tags this -> bool -> unit [@@js.set "delegatesFocus"]
  val get_mode: 'tags this -> ShadowRootMode.t [@@js.get "mode"]
  val set_mode: 'tags this -> ShadowRootMode.t -> unit [@@js.set "mode"]
  val get_slotAssignment: 'tags this -> SlotAssignmentMode.t option [@@js.get "slotAssignment"]
  val set_slotAssignment: 'tags this -> SlotAssignmentMode.t -> unit [@@js.set "slotAssignment"]
  val create: ?delegatesFocus:bool -> mode:ShadowRootMode.t -> ?slotAssignment:SlotAssignmentMode.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module ScrollLogicalPosition : sig
  type t = ([`L_s185_center[@js "center"] | `L_s290_end[@js "end"] | `L_s535_nearest[@js "nearest"] | `L_s754_start[@js "start"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module ScrollBehavior : sig
  type t = ([`L_s141_auto[@js "auto"] | `L_s731_smooth[@js "smooth"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module ScrollOptions : sig
  type t = [`ScrollOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ScrollOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ScrollOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ScrollOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_behavior: 'tags this -> ScrollBehavior.t option [@@js.get "behavior"]
  val set_behavior: 'tags this -> ScrollBehavior.t -> unit [@@js.set "behavior"]
  val create: ?behavior:ScrollBehavior.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module ScrollIntoViewOptions : sig
  type t = [`ScrollIntoViewOptions | `ScrollOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ScrollIntoViewOptions | `ScrollOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ScrollIntoViewOptions | `ScrollOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ScrollIntoViewOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_block: 'tags this -> ScrollLogicalPosition.t option [@@js.get "block"]
  val set_block: 'tags this -> ScrollLogicalPosition.t -> unit [@@js.set "block"]
  val get_inline: 'tags this -> ScrollLogicalPosition.t option [@@js.get "inline"]
  val set_inline: 'tags this -> ScrollLogicalPosition.t -> unit [@@js.set "inline"]
  val create: ?block:ScrollLogicalPosition.t -> ?inline:ScrollLogicalPosition.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module InsertPosition : sig
  type t = ([`L_s103_afterbegin[@js "afterbegin"] | `L_s104_afterend[@js "afterend"] | `L_s153_beforebegin[@js "beforebegin"] | `L_s154_beforeend[@js "beforeend"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module TransitionEventInit : sig
  type t = [`EventInit | `TransitionEventInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventInit | `TransitionEventInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventInit | `TransitionEventInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `TransitionEventInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_elapsedTime: 'tags this -> float option [@@js.get "elapsedTime"]
  val set_elapsedTime: 'tags this -> float -> unit [@@js.set "elapsedTime"]
  val get_propertyName: 'tags this -> string option [@@js.get "propertyName"]
  val set_propertyName: 'tags this -> string -> unit [@@js.set "propertyName"]
  val get_pseudoElement: 'tags this -> string option [@@js.get "pseudoElement"]
  val set_pseudoElement: 'tags this -> string -> unit [@@js.set "pseudoElement"]
  val create: ?elapsedTime:float -> ?propertyName:string -> ?pseudoElement:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** Events providing information related to transitions. *)
module[@js.scope "TransitionEvent"] TransitionEvent : sig
  type t = [`Event | `TransitionEvent] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Event | `TransitionEvent]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Event | `TransitionEvent]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `TransitionEvent ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_elapsedTime: 'tags this -> float [@@js.get "elapsedTime"]
  val get_propertyName: 'tags this -> string [@@js.get "propertyName"]
  val get_pseudoElement: 'tags this -> string [@@js.get "pseudoElement"]
  val create: elapsedTime:float -> propertyName:string -> pseudoElement:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': type_:string -> ?transitionEventInitDict:TransitionEventInit.t -> unit -> t [@@js.create]
end
module TouchType : sig
  type t = ([`L_s262_direct[@js "direct"] | `L_s765_stylus[@js "stylus"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module TouchInit : sig
  type t = [`TouchInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`TouchInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`TouchInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `TouchInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_altitudeAngle: 'tags this -> float option [@@js.get "altitudeAngle"]
  val set_altitudeAngle: 'tags this -> float -> unit [@@js.set "altitudeAngle"]
  val get_azimuthAngle: 'tags this -> float option [@@js.get "azimuthAngle"]
  val set_azimuthAngle: 'tags this -> float -> unit [@@js.set "azimuthAngle"]
  val get_clientX: 'tags this -> float option [@@js.get "clientX"]
  val set_clientX: 'tags this -> float -> unit [@@js.set "clientX"]
  val get_clientY: 'tags this -> float option [@@js.get "clientY"]
  val set_clientY: 'tags this -> float -> unit [@@js.set "clientY"]
  val get_force: 'tags this -> float option [@@js.get "force"]
  val set_force: 'tags this -> float -> unit [@@js.set "force"]
  val get_identifier: 'tags this -> float [@@js.get "identifier"]
  val set_identifier: 'tags this -> float -> unit [@@js.set "identifier"]
  val get_pageX: 'tags this -> float option [@@js.get "pageX"]
  val set_pageX: 'tags this -> float -> unit [@@js.set "pageX"]
  val get_pageY: 'tags this -> float option [@@js.get "pageY"]
  val set_pageY: 'tags this -> float -> unit [@@js.set "pageY"]
  val get_radiusX: 'tags this -> float option [@@js.get "radiusX"]
  val set_radiusX: 'tags this -> float -> unit [@@js.set "radiusX"]
  val get_radiusY: 'tags this -> float option [@@js.get "radiusY"]
  val set_radiusY: 'tags this -> float -> unit [@@js.set "radiusY"]
  val get_rotationAngle: 'tags this -> float option [@@js.get "rotationAngle"]
  val set_rotationAngle: 'tags this -> float -> unit [@@js.set "rotationAngle"]
  val get_screenX: 'tags this -> float option [@@js.get "screenX"]
  val set_screenX: 'tags this -> float -> unit [@@js.set "screenX"]
  val get_screenY: 'tags this -> float option [@@js.get "screenY"]
  val set_screenY: 'tags this -> float -> unit [@@js.set "screenY"]
  val get_target: 'tags this -> EventTarget.t [@@js.get "target"]
  val set_target: 'tags this -> EventTarget.t -> unit [@@js.set "target"]
  val get_touchType: 'tags this -> TouchType.t option [@@js.get "touchType"]
  val set_touchType: 'tags this -> TouchType.t -> unit [@@js.set "touchType"]
  val create: ?altitudeAngle:float -> ?azimuthAngle:float -> ?clientX:float -> ?clientY:float -> ?force:float -> identifier:float -> ?pageX:float -> ?pageY:float -> ?radiusX:float -> ?radiusY:float -> ?rotationAngle:float -> ?screenX:float -> ?screenY:float -> target:EventTarget.t -> ?touchType:TouchType.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** A single contact point on a touch-sensitive device. The contact point is commonly a finger or stylus and the device may be a touchscreen or trackpad. *)
module[@js.scope "Touch"] Touch : sig
  type t = [`Touch] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Touch]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Touch]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `Touch ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_clientX: 'tags this -> float [@@js.get "clientX"]
  val get_clientY: 'tags this -> float [@@js.get "clientY"]
  val get_force: 'tags this -> float [@@js.get "force"]
  val get_identifier: 'tags this -> float [@@js.get "identifier"]
  val get_pageX: 'tags this -> float [@@js.get "pageX"]
  val get_pageY: 'tags this -> float [@@js.get "pageY"]
  val get_radiusX: 'tags this -> float [@@js.get "radiusX"]
  val get_radiusY: 'tags this -> float [@@js.get "radiusY"]
  val get_rotationAngle: 'tags this -> float [@@js.get "rotationAngle"]
  val get_screenX: 'tags this -> float [@@js.get "screenX"]
  val get_screenY: 'tags this -> float [@@js.get "screenY"]
  val get_target: 'tags this -> EventTarget.t [@@js.get "target"]
  val create: clientX:float -> clientY:float -> force:float -> identifier:float -> pageX:float -> pageY:float -> radiusX:float -> radiusY:float -> rotationAngle:float -> screenX:float -> screenY:float -> target:EventTarget.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': TouchInit.t -> t [@@js.create]
end

(** A list of contact points on a touch surface. For example, if the user has three fingers on the touch surface (such as a screen or trackpad), the corresponding TouchList object would have one Touch object for each finger, for a total of three entries. *)
module[@js.scope "TouchList"] TouchList : sig
  type t = [`TouchList | Touch.t ArrayLike.tags_1 | Touch.t IterableIterator.tags_1] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`TouchList | Touch.t ArrayLike.tags_1 | Touch.t IterableIterator.tags_1]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`TouchList | Touch.t ArrayLike.tags_1 | Touch.t IterableIterator.tags_1]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `TouchList ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  (* [Symbol.iterator]: unit -> Touch.t IterableIterator.t_1 *)
  val get_length: 'tags this -> float [@@js.get "length"]
  val item: 'tags this -> index:float -> Touch.t option [@@js.call "item"]
  val get: 'tags this -> float -> Touch.t [@@js.index_get]
  val set: 'tags this -> float -> Touch.t -> unit [@@js.index_set]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module SecurityPolicyViolationEventDisposition : sig
  type t = ([`L_s292_enforce[@js "enforce"] | `L_s671_report[@js "report"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module SecurityPolicyViolationEventInit : sig
  type t = [`EventInit | `SecurityPolicyViolationEventInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventInit | `SecurityPolicyViolationEventInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventInit | `SecurityPolicyViolationEventInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SecurityPolicyViolationEventInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_blockedURI: 'tags this -> string option [@@js.get "blockedURI"]
  val set_blockedURI: 'tags this -> string -> unit [@@js.set "blockedURI"]
  val get_columnNumber: 'tags this -> float option [@@js.get "columnNumber"]
  val set_columnNumber: 'tags this -> float -> unit [@@js.set "columnNumber"]
  val get_disposition: 'tags this -> SecurityPolicyViolationEventDisposition.t [@@js.get "disposition"]
  val set_disposition: 'tags this -> SecurityPolicyViolationEventDisposition.t -> unit [@@js.set "disposition"]
  val get_documentURI: 'tags this -> string [@@js.get "documentURI"]
  val set_documentURI: 'tags this -> string -> unit [@@js.set "documentURI"]
  val get_effectiveDirective: 'tags this -> string [@@js.get "effectiveDirective"]
  val set_effectiveDirective: 'tags this -> string -> unit [@@js.set "effectiveDirective"]
  val get_lineNumber: 'tags this -> float option [@@js.get "lineNumber"]
  val set_lineNumber: 'tags this -> float -> unit [@@js.set "lineNumber"]
  val get_originalPolicy: 'tags this -> string [@@js.get "originalPolicy"]
  val set_originalPolicy: 'tags this -> string -> unit [@@js.set "originalPolicy"]
  val get_referrer: 'tags this -> string option [@@js.get "referrer"]
  val set_referrer: 'tags this -> string -> unit [@@js.set "referrer"]
  val get_sample: 'tags this -> string option [@@js.get "sample"]
  val set_sample: 'tags this -> string -> unit [@@js.set "sample"]
  val get_sourceFile: 'tags this -> string option [@@js.get "sourceFile"]
  val set_sourceFile: 'tags this -> string -> unit [@@js.set "sourceFile"]
  val get_statusCode: 'tags this -> float [@@js.get "statusCode"]
  val set_statusCode: 'tags this -> float -> unit [@@js.set "statusCode"]
  val get_violatedDirective: 'tags this -> string [@@js.get "violatedDirective"]
  val set_violatedDirective: 'tags this -> string -> unit [@@js.set "violatedDirective"]
  val create: ?blockedURI:string -> ?columnNumber:float -> disposition:SecurityPolicyViolationEventDisposition.t -> documentURI:string -> effectiveDirective:string -> ?lineNumber:float -> originalPolicy:string -> ?referrer:string -> ?sample:string -> ?sourceFile:string -> statusCode:float -> violatedDirective:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** Inherits from Event, and represents the event object of an event sent on a document or worker when its content security policy is violated. *)
module[@js.scope "SecurityPolicyViolationEvent"] SecurityPolicyViolationEvent : sig
  type t = [`Event | `SecurityPolicyViolationEvent] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Event | `SecurityPolicyViolationEvent]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Event | `SecurityPolicyViolationEvent]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SecurityPolicyViolationEvent ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_blockedURI: 'tags this -> string [@@js.get "blockedURI"]
  val get_columnNumber: 'tags this -> float [@@js.get "columnNumber"]
  val get_disposition: 'tags this -> SecurityPolicyViolationEventDisposition.t [@@js.get "disposition"]
  val get_documentURI: 'tags this -> string [@@js.get "documentURI"]
  val get_effectiveDirective: 'tags this -> string [@@js.get "effectiveDirective"]
  val get_lineNumber: 'tags this -> float [@@js.get "lineNumber"]
  val get_originalPolicy: 'tags this -> string [@@js.get "originalPolicy"]
  val get_referrer: 'tags this -> string [@@js.get "referrer"]
  val get_sample: 'tags this -> string [@@js.get "sample"]
  val get_sourceFile: 'tags this -> string [@@js.get "sourceFile"]
  val get_statusCode: 'tags this -> float [@@js.get "statusCode"]
  val get_violatedDirective: 'tags this -> string [@@js.get "violatedDirective"]
  val create: blockedURI:string -> columnNumber:float -> disposition:SecurityPolicyViolationEventDisposition.t -> documentURI:string -> effectiveDirective:string -> lineNumber:float -> originalPolicy:string -> referrer:string -> sample:string -> sourceFile:string -> statusCode:float -> violatedDirective:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': type_:string -> ?eventInitDict:SecurityPolicyViolationEventInit.t -> unit -> t [@@js.create]
end
module ProgressEventInit : sig
  type t = [`EventInit | `ProgressEventInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventInit | `ProgressEventInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventInit | `ProgressEventInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ProgressEventInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_lengthComputable: 'tags this -> bool option [@@js.get "lengthComputable"]
  val set_lengthComputable: 'tags this -> bool -> unit [@@js.set "lengthComputable"]
  val get_loaded: 'tags this -> float option [@@js.get "loaded"]
  val set_loaded: 'tags this -> float -> unit [@@js.set "loaded"]
  val get_total: 'tags this -> float option [@@js.get "total"]
  val set_total: 'tags this -> float -> unit [@@js.set "total"]
  val create: ?lengthComputable:bool -> ?loaded:float -> ?total:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** Events measuring progress of an underlying process, like an HTTP request (for an XMLHttpRequest, or the loading of the underlying resource of an <img>, <audio>, <video>, <style> or <link>). *)
module[@js.scope "ProgressEvent"] ProgressEvent : sig
  type 'T t = [`Event | `ProgressEvent of 'T] intf [@@js.custom { of_js=(fun _T -> Obj.magic); to_js=(fun _T -> Obj.magic) }]
  type 'T t_1 = 'T t
  type t_0 = EventTarget.t t
  [@@@js.stop]
  type 'T tags = [`Event | `ProgressEvent of 'T]
  type 'T tags_1 = 'T tags
  type tags_0 = EventTarget.t tags
  [@@@js.start]
  [@@@js.implem 
    type 'T tags = [`Event | `ProgressEvent of 'T]
    type 'T tags_1 = 'T tags
    type tags_0 = EventTarget.t tags
  ]
  type ('tags, 'T) this = 'tags intf constraint 'tags = [> `ProgressEvent of 'T ]
  val t_to_js: ('T -> Ojs.t) -> 'T t -> Ojs.t
  val t_of_js: (Ojs.t -> 'T) -> Ojs.t -> 'T t
  val t_1_to_js: ('T -> Ojs.t) -> 'T t_1 -> Ojs.t
  val t_1_of_js: (Ojs.t -> 'T) -> Ojs.t -> 'T t_1
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_lengthComputable: ('tags, 'T) this -> bool [@@js.get "lengthComputable"]
  val get_loaded: ('tags, 'T) this -> float [@@js.get "loaded"]
  
  (** Returns the object to which event is dispatched (its target). *)
  val get_target: ('tags, 'T) this -> 'T option [@@js.get "target"]
  val get_total: ('tags, 'T) this -> float [@@js.get "total"]
  val create: lengthComputable:bool -> loaded:float -> ?target:'T -> total:float -> unit -> 'T t [@@js.builder]
  val cast_from: ('tags, 'T) this -> 'T t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t_0 [@@js.get "prototype"]
  val create': type_:string -> ?eventInitDict:ProgressEventInit.t -> unit -> t_0 [@@js.create]
end
module OnErrorEventHandlerNonNull : sig
  type t = [`OnErrorEventHandlerNonNull] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`OnErrorEventHandlerNonNull]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`OnErrorEventHandlerNonNull]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `OnErrorEventHandlerNonNull ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val apply: 'tags this -> event:([`U1 of Event.t | `U2 of string] [@js.union]) -> ?source:string -> ?lineno:float -> ?colno:float -> ?error:Error.t_0 -> unit -> any [@@js.apply]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module OnErrorEventHandler : sig
  type t = OnErrorEventHandlerNonNull.t option
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end

(** This Web Storage API interface provides access to a particular domain's session or local storage. It allows, for example, the addition, modification, or deletion of stored data items. *)
module[@js.scope "Storage"] Storage : sig
  type t = [`Storage] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Storage]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Storage]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `Storage ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Returns the number of key/value pairs. *)
  val get_length: 'tags this -> float [@@js.get "length"]
  
  (**
    Removes all key/value pairs, if there are any.
    
    Dispatches a storage event on Window objects holding an equivalent Storage object.
  *)
  val clear: 'tags this -> unit [@@js.call "clear"]
  
  (** Returns the current value associated with the given key, or null if the given key does not exist. *)
  val getItem: 'tags this -> key:string -> string option [@@js.call "getItem"]
  
  (** Returns the name of the nth key, or null if n is greater than or equal to the number of key/value pairs. *)
  val key: 'tags this -> index:float -> string option [@@js.call "key"]
  
  (**
    Removes the key/value pair with the given key, if a key/value pair with the given key exists.
    
    Dispatches a storage event on Window objects holding an equivalent Storage object.
  *)
  val removeItem: 'tags this -> key:string -> unit [@@js.call "removeItem"]
  
  (**
    Sets the value of the pair identified by key to value, creating a new key/value pair if none existed for key previously.
    
    Throws a "QuotaExceededError" DOMException exception if the new value couldn't be set. (Setting could fail if, e.g., the user has disabled storage for the site, or if the quota has been exceeded.)
    
    Dispatches a storage event on Window objects holding an equivalent Storage object.
  *)
  val setItem: 'tags this -> key:string -> value:string -> unit [@@js.call "setItem"]
  val get: 'tags this -> string -> any [@@js.index_get]
  val set: 'tags this -> string -> any -> unit [@@js.index_set]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module WindowSessionStorage : sig
  type t = [`WindowSessionStorage] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`WindowSessionStorage]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`WindowSessionStorage]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `WindowSessionStorage ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_sessionStorage: 'tags this -> Storage.t [@@js.get "sessionStorage"]
  val create: sessionStorage:Storage.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module VoidFunction : sig
  type t = [`VoidFunction] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`VoidFunction]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`VoidFunction]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `VoidFunction ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val apply: 'tags this -> unit [@@js.apply]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module TimerHandler : sig
  type t = ([`String of string | `Other of untyped_function] [@js.union on_field "dummy"]) Primitive.t
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end

(** The SVGStringList defines a list of DOMString objects. *)
module[@js.scope "SVGStringList"] SVGStringList : sig
  type t = [`SVGStringList | string ArrayLike.tags_1 | string IterableIterator.tags_1] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`SVGStringList | string ArrayLike.tags_1 | string IterableIterator.tags_1]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`SVGStringList | string ArrayLike.tags_1 | string IterableIterator.tags_1]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGStringList ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  (* [Symbol.iterator]: unit -> string IterableIterator.t_1 *)
  val get_length: 'tags this -> float [@@js.get "length"]
  val get_numberOfItems: 'tags this -> float [@@js.get "numberOfItems"]
  val appendItem: 'tags this -> newItem:string -> string [@@js.call "appendItem"]
  val clear: 'tags this -> unit [@@js.call "clear"]
  val getItem: 'tags this -> index:float -> string [@@js.call "getItem"]
  val initialize: 'tags this -> newItem:string -> string [@@js.call "initialize"]
  val insertItemBefore: 'tags this -> newItem:string -> index:float -> string [@@js.call "insertItemBefore"]
  val removeItem: 'tags this -> index:float -> string [@@js.call "removeItem"]
  val replaceItem: 'tags this -> newItem:string -> index:float -> string [@@js.call "replaceItem"]
  val get: 'tags this -> float -> string [@@js.index_get]
  val set: 'tags this -> float -> string -> unit [@@js.index_set]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module SVGTests : sig
  type t = [`SVGTests] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`SVGTests]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`SVGTests]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGTests ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_requiredExtensions: 'tags this -> SVGStringList.t [@@js.get "requiredExtensions"]
  val get_systemLanguage: 'tags this -> SVGStringList.t [@@js.get "systemLanguage"]
  val create: requiredExtensions:SVGStringList.t -> systemLanguage:SVGStringList.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** The SVGAnimatedString interface represents string attributes which can be animated from each SVG declaration. You need to create SVG attribute before doing anything else, everything should be declared inside this. *)
module[@js.scope "SVGAnimatedString"] SVGAnimatedString : sig
  type t = [`SVGAnimatedString] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`SVGAnimatedString]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`SVGAnimatedString]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGAnimatedString ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_animVal: 'tags this -> string [@@js.get "animVal"]
  val get_baseVal: 'tags this -> string [@@js.get "baseVal"]
  val set_baseVal: 'tags this -> string -> unit [@@js.set "baseVal"]
  val create: animVal:string -> baseVal:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end
module SVGURIReference : sig
  type t = [`SVGURIReference] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`SVGURIReference]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`SVGURIReference]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGURIReference ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_href: 'tags this -> SVGAnimatedString.t [@@js.get "href"]
  val create: href:SVGAnimatedString.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** Used for attributes whose value must be a constant from a particular enumeration and which can be animated. *)
module[@js.scope "SVGAnimatedEnumeration"] SVGAnimatedEnumeration : sig
  type t = [`SVGAnimatedEnumeration] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`SVGAnimatedEnumeration]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`SVGAnimatedEnumeration]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGAnimatedEnumeration ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_animVal: 'tags this -> float [@@js.get "animVal"]
  val get_baseVal: 'tags this -> float [@@js.get "baseVal"]
  val set_baseVal: 'tags this -> float -> unit [@@js.set "baseVal"]
  val create: animVal:float -> baseVal:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end

(** Corresponds to the <number> basic data type. *)
module[@js.scope "SVGNumber"] SVGNumber : sig
  type t = [`SVGNumber] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`SVGNumber]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`SVGNumber]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGNumber ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_value: 'tags this -> float [@@js.get "value"]
  val set_value: 'tags this -> float -> unit [@@js.set "value"]
  val create: value:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end

(** The SVGNumberList defines a list of SVGNumber objects. *)
module[@js.scope "SVGNumberList"] SVGNumberList : sig
  type t = [`SVGNumberList | SVGNumber.t ArrayLike.tags_1 | SVGNumber.t IterableIterator.tags_1] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`SVGNumberList | SVGNumber.t ArrayLike.tags_1 | SVGNumber.t IterableIterator.tags_1]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`SVGNumberList | SVGNumber.t ArrayLike.tags_1 | SVGNumber.t IterableIterator.tags_1]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGNumberList ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  (* [Symbol.iterator]: unit -> SVGNumber.t IterableIterator.t_1 *)
  val get_length: 'tags this -> float [@@js.get "length"]
  val get_numberOfItems: 'tags this -> float [@@js.get "numberOfItems"]
  val appendItem: 'tags this -> newItem:SVGNumber.t -> SVGNumber.t [@@js.call "appendItem"]
  val clear: 'tags this -> unit [@@js.call "clear"]
  val getItem: 'tags this -> index:float -> SVGNumber.t [@@js.call "getItem"]
  val initialize: 'tags this -> newItem:SVGNumber.t -> SVGNumber.t [@@js.call "initialize"]
  val insertItemBefore: 'tags this -> newItem:SVGNumber.t -> index:float -> SVGNumber.t [@@js.call "insertItemBefore"]
  val removeItem: 'tags this -> index:float -> SVGNumber.t [@@js.call "removeItem"]
  val replaceItem: 'tags this -> newItem:SVGNumber.t -> index:float -> SVGNumber.t [@@js.call "replaceItem"]
  val get: 'tags this -> float -> SVGNumber.t [@@js.index_get]
  val set: 'tags this -> float -> SVGNumber.t -> unit [@@js.index_set]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** The SVGAnimatedNumber interface is used for attributes which take a list of numbers and which can be animated. *)
module[@js.scope "SVGAnimatedNumberList"] SVGAnimatedNumberList : sig
  type t = [`SVGAnimatedNumberList] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`SVGAnimatedNumberList]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`SVGAnimatedNumberList]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGAnimatedNumberList ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_animVal: 'tags this -> SVGNumberList.t [@@js.get "animVal"]
  val get_baseVal: 'tags this -> SVGNumberList.t [@@js.get "baseVal"]
  val create: animVal:SVGNumberList.t -> baseVal:SVGNumberList.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end

(** Correspond to the <length> basic data type. *)
module[@js.scope "SVGLength"] SVGLength : sig
  type t = [`SVGLength] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`SVGLength]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`SVGLength]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGLength ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_unitType: 'tags this -> float [@@js.get "unitType"]
  val get_value: 'tags this -> float [@@js.get "value"]
  val set_value: 'tags this -> float -> unit [@@js.set "value"]
  val get_valueAsString: 'tags this -> string [@@js.get "valueAsString"]
  val set_valueAsString: 'tags this -> string -> unit [@@js.set "valueAsString"]
  val get_valueInSpecifiedUnits: 'tags this -> float [@@js.get "valueInSpecifiedUnits"]
  val set_valueInSpecifiedUnits: 'tags this -> float -> unit [@@js.set "valueInSpecifiedUnits"]
  val convertToSpecifiedUnits: 'tags this -> unitType:float -> unit [@@js.call "convertToSpecifiedUnits"]
  val newValueSpecifiedUnits: 'tags this -> unitType:float -> valueInSpecifiedUnits:float -> unit [@@js.call "newValueSpecifiedUnits"]
  val get_SVG_LENGTHTYPE_CM: 'tags this -> float [@@js.get "SVG_LENGTHTYPE_CM"]
  val get_SVG_LENGTHTYPE_EMS: 'tags this -> float [@@js.get "SVG_LENGTHTYPE_EMS"]
  val get_SVG_LENGTHTYPE_EXS: 'tags this -> float [@@js.get "SVG_LENGTHTYPE_EXS"]
  val get_SVG_LENGTHTYPE_IN: 'tags this -> float [@@js.get "SVG_LENGTHTYPE_IN"]
  val get_SVG_LENGTHTYPE_MM: 'tags this -> float [@@js.get "SVG_LENGTHTYPE_MM"]
  val get_SVG_LENGTHTYPE_NUMBER: 'tags this -> float [@@js.get "SVG_LENGTHTYPE_NUMBER"]
  val get_SVG_LENGTHTYPE_PC: 'tags this -> float [@@js.get "SVG_LENGTHTYPE_PC"]
  val get_SVG_LENGTHTYPE_PERCENTAGE: 'tags this -> float [@@js.get "SVG_LENGTHTYPE_PERCENTAGE"]
  val get_SVG_LENGTHTYPE_PT: 'tags this -> float [@@js.get "SVG_LENGTHTYPE_PT"]
  val get_SVG_LENGTHTYPE_PX: 'tags this -> float [@@js.get "SVG_LENGTHTYPE_PX"]
  val get_SVG_LENGTHTYPE_UNKNOWN: 'tags this -> float [@@js.get "SVG_LENGTHTYPE_UNKNOWN"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
  val svg_lengthtype_cm: unit -> float [@@js.get "SVG_LENGTHTYPE_CM"]
  val svg_lengthtype_ems: unit -> float [@@js.get "SVG_LENGTHTYPE_EMS"]
  val svg_lengthtype_exs: unit -> float [@@js.get "SVG_LENGTHTYPE_EXS"]
  val svg_lengthtype_in: unit -> float [@@js.get "SVG_LENGTHTYPE_IN"]
  val svg_lengthtype_mm: unit -> float [@@js.get "SVG_LENGTHTYPE_MM"]
  val svg_lengthtype_number: unit -> float [@@js.get "SVG_LENGTHTYPE_NUMBER"]
  val svg_lengthtype_pc: unit -> float [@@js.get "SVG_LENGTHTYPE_PC"]
  val svg_lengthtype_percentage: unit -> float [@@js.get "SVG_LENGTHTYPE_PERCENTAGE"]
  val svg_lengthtype_pt: unit -> float [@@js.get "SVG_LENGTHTYPE_PT"]
  val svg_lengthtype_px: unit -> float [@@js.get "SVG_LENGTHTYPE_PX"]
  val svg_lengthtype_unknown: unit -> float [@@js.get "SVG_LENGTHTYPE_UNKNOWN"]
end

(** The SVGLengthList defines a list of SVGLength objects. *)
module[@js.scope "SVGLengthList"] SVGLengthList : sig
  type t = [`SVGLengthList | SVGLength.t ArrayLike.tags_1 | SVGLength.t IterableIterator.tags_1] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`SVGLengthList | SVGLength.t ArrayLike.tags_1 | SVGLength.t IterableIterator.tags_1]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`SVGLengthList | SVGLength.t ArrayLike.tags_1 | SVGLength.t IterableIterator.tags_1]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGLengthList ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  (* [Symbol.iterator]: unit -> SVGLength.t IterableIterator.t_1 *)
  val get_length: 'tags this -> float [@@js.get "length"]
  val get_numberOfItems: 'tags this -> float [@@js.get "numberOfItems"]
  val appendItem: 'tags this -> newItem:SVGLength.t -> SVGLength.t [@@js.call "appendItem"]
  val clear: 'tags this -> unit [@@js.call "clear"]
  val getItem: 'tags this -> index:float -> SVGLength.t [@@js.call "getItem"]
  val initialize: 'tags this -> newItem:SVGLength.t -> SVGLength.t [@@js.call "initialize"]
  val insertItemBefore: 'tags this -> newItem:SVGLength.t -> index:float -> SVGLength.t [@@js.call "insertItemBefore"]
  val removeItem: 'tags this -> index:float -> SVGLength.t [@@js.call "removeItem"]
  val replaceItem: 'tags this -> newItem:SVGLength.t -> index:float -> SVGLength.t [@@js.call "replaceItem"]
  val get: 'tags this -> float -> SVGLength.t [@@js.index_get]
  val set: 'tags this -> float -> SVGLength.t -> unit [@@js.index_set]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Used for attributes of type SVGLengthList which can be animated. *)
module[@js.scope "SVGAnimatedLengthList"] SVGAnimatedLengthList : sig
  type t = [`SVGAnimatedLengthList] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`SVGAnimatedLengthList]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`SVGAnimatedLengthList]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGAnimatedLengthList ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_animVal: 'tags this -> SVGLengthList.t [@@js.get "animVal"]
  val get_baseVal: 'tags this -> SVGLengthList.t [@@js.get "baseVal"]
  val create: animVal:SVGLengthList.t -> baseVal:SVGLengthList.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end
module DOMPointInit : sig
  type t = [`DOMPointInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`DOMPointInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`DOMPointInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `DOMPointInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_w: 'tags this -> float option [@@js.get "w"]
  val set_w: 'tags this -> float -> unit [@@js.set "w"]
  val get_x: 'tags this -> float option [@@js.get "x"]
  val set_x: 'tags this -> float -> unit [@@js.set "x"]
  val get_y: 'tags this -> float option [@@js.get "y"]
  val set_y: 'tags this -> float -> unit [@@js.set "y"]
  val get_z: 'tags this -> float option [@@js.get "z"]
  val set_z: 'tags this -> float -> unit [@@js.set "z"]
  val create: ?w:float -> ?x:float -> ?y:float -> ?z:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module DOMMatrix2DInit : sig
  type t = [`DOMMatrix2DInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`DOMMatrix2DInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`DOMMatrix2DInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `DOMMatrix2DInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_a: 'tags this -> float option [@@js.get "a"]
  val set_a: 'tags this -> float -> unit [@@js.set "a"]
  val get_b: 'tags this -> float option [@@js.get "b"]
  val set_b: 'tags this -> float -> unit [@@js.set "b"]
  val get_c: 'tags this -> float option [@@js.get "c"]
  val set_c: 'tags this -> float -> unit [@@js.set "c"]
  val get_d: 'tags this -> float option [@@js.get "d"]
  val set_d: 'tags this -> float -> unit [@@js.set "d"]
  val get_e: 'tags this -> float option [@@js.get "e"]
  val set_e: 'tags this -> float -> unit [@@js.set "e"]
  val get_f: 'tags this -> float option [@@js.get "f"]
  val set_f: 'tags this -> float -> unit [@@js.set "f"]
  val get_m11: 'tags this -> float option [@@js.get "m11"]
  val set_m11: 'tags this -> float -> unit [@@js.set "m11"]
  val get_m12: 'tags this -> float option [@@js.get "m12"]
  val set_m12: 'tags this -> float -> unit [@@js.set "m12"]
  val get_m21: 'tags this -> float option [@@js.get "m21"]
  val set_m21: 'tags this -> float -> unit [@@js.set "m21"]
  val get_m22: 'tags this -> float option [@@js.get "m22"]
  val set_m22: 'tags this -> float -> unit [@@js.set "m22"]
  val get_m41: 'tags this -> float option [@@js.get "m41"]
  val set_m41: 'tags this -> float -> unit [@@js.set "m41"]
  val get_m42: 'tags this -> float option [@@js.get "m42"]
  val set_m42: 'tags this -> float -> unit [@@js.set "m42"]
  val create: ?a:float -> ?b:float -> ?c:float -> ?d:float -> ?e:float -> ?f:float -> ?m11:float -> ?m12:float -> ?m21:float -> ?m22:float -> ?m41:float -> ?m42:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module DOMMatrixInit : sig
  type t = [`DOMMatrix2DInit | `DOMMatrixInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`DOMMatrix2DInit | `DOMMatrixInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`DOMMatrix2DInit | `DOMMatrixInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `DOMMatrixInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_is2D: 'tags this -> bool option [@@js.get "is2D"]
  val set_is2D: 'tags this -> bool -> unit [@@js.set "is2D"]
  val get_m13: 'tags this -> float option [@@js.get "m13"]
  val set_m13: 'tags this -> float -> unit [@@js.set "m13"]
  val get_m14: 'tags this -> float option [@@js.get "m14"]
  val set_m14: 'tags this -> float -> unit [@@js.set "m14"]
  val get_m23: 'tags this -> float option [@@js.get "m23"]
  val set_m23: 'tags this -> float -> unit [@@js.set "m23"]
  val get_m24: 'tags this -> float option [@@js.get "m24"]
  val set_m24: 'tags this -> float -> unit [@@js.set "m24"]
  val get_m31: 'tags this -> float option [@@js.get "m31"]
  val set_m31: 'tags this -> float -> unit [@@js.set "m31"]
  val get_m32: 'tags this -> float option [@@js.get "m32"]
  val set_m32: 'tags this -> float -> unit [@@js.set "m32"]
  val get_m33: 'tags this -> float option [@@js.get "m33"]
  val set_m33: 'tags this -> float -> unit [@@js.set "m33"]
  val get_m34: 'tags this -> float option [@@js.get "m34"]
  val set_m34: 'tags this -> float -> unit [@@js.set "m34"]
  val get_m43: 'tags this -> float option [@@js.get "m43"]
  val set_m43: 'tags this -> float -> unit [@@js.set "m43"]
  val get_m44: 'tags this -> float option [@@js.get "m44"]
  val set_m44: 'tags this -> float -> unit [@@js.set "m44"]
  val create: ?is2D:bool -> ?m13:float -> ?m14:float -> ?m23:float -> ?m24:float -> ?m31:float -> ?m32:float -> ?m33:float -> ?m34:float -> ?m43:float -> ?m44:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module[@js.scope "DOMPoint"] rec DOMPoint : sig
  type t = [`DOMPoint | `DOMPointReadOnly] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`DOMPoint | `DOMPointReadOnly]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`DOMPoint | `DOMPointReadOnly]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `DOMPoint ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_w: 'tags this -> float [@@js.get "w"]
  val set_w: 'tags this -> float -> unit [@@js.set "w"]
  val get_x: 'tags this -> float [@@js.get "x"]
  val set_x: 'tags this -> float -> unit [@@js.set "x"]
  val get_y: 'tags this -> float [@@js.get "y"]
  val set_y: 'tags this -> float -> unit [@@js.set "y"]
  val get_z: 'tags this -> float [@@js.get "z"]
  val set_z: 'tags this -> float -> unit [@@js.set "z"]
  val create: w:float -> x:float -> y:float -> z:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': ?x:float -> ?y:float -> ?z:float -> ?w:float -> unit -> t [@@js.create]
  val fromPoint: ?other:DOMPointInit.t -> unit -> t [@@js.global "fromPoint"]
end
and[@js.scope "DOMPointReadOnly"] DOMPointReadOnly : sig
  type t = [`DOMPointReadOnly] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`DOMPointReadOnly]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`DOMPointReadOnly]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `DOMPointReadOnly ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_w: 'tags this -> float [@@js.get "w"]
  val get_x: 'tags this -> float [@@js.get "x"]
  val get_y: 'tags this -> float [@@js.get "y"]
  val get_z: 'tags this -> float [@@js.get "z"]
  val matrixTransform: 'tags this -> ?matrix:DOMMatrixInit.t -> unit -> DOMPoint.t [@@js.call "matrixTransform"]
  val toJSON: 'tags this -> any [@@js.call "toJSON"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: ?x:float -> ?y:float -> ?z:float -> ?w:float -> unit -> t [@@js.create]
  val fromPoint: ?other:DOMPointInit.t -> unit -> t [@@js.global "fromPoint"]
end
module[@js.scope "SVGPointList"] SVGPointList : sig
  type t = [`SVGPointList | DOMPoint.t ArrayLike.tags_1 | DOMPoint.t IterableIterator.tags_1] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`SVGPointList | DOMPoint.t ArrayLike.tags_1 | DOMPoint.t IterableIterator.tags_1]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`SVGPointList | DOMPoint.t ArrayLike.tags_1 | DOMPoint.t IterableIterator.tags_1]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGPointList ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  (* [Symbol.iterator]: unit -> DOMPoint.t IterableIterator.t_1 *)
  val get_length: 'tags this -> float [@@js.get "length"]
  val get_numberOfItems: 'tags this -> float [@@js.get "numberOfItems"]
  val appendItem: 'tags this -> newItem:DOMPoint.t -> DOMPoint.t [@@js.call "appendItem"]
  val clear: 'tags this -> unit [@@js.call "clear"]
  val getItem: 'tags this -> index:float -> DOMPoint.t [@@js.call "getItem"]
  val initialize: 'tags this -> newItem:DOMPoint.t -> DOMPoint.t [@@js.call "initialize"]
  val insertItemBefore: 'tags this -> newItem:DOMPoint.t -> index:float -> DOMPoint.t [@@js.call "insertItemBefore"]
  val removeItem: 'tags this -> index:float -> DOMPoint.t [@@js.call "removeItem"]
  val replaceItem: 'tags this -> newItem:DOMPoint.t -> index:float -> DOMPoint.t [@@js.call "replaceItem"]
  val get: 'tags this -> float -> DOMPoint.t [@@js.index_get]
  val set: 'tags this -> float -> DOMPoint.t -> unit [@@js.index_set]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module SVGAnimatedPoints : sig
  type t = [`SVGAnimatedPoints] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`SVGAnimatedPoints]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`SVGAnimatedPoints]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGAnimatedPoints ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_animatedPoints: 'tags this -> SVGPointList.t [@@js.get "animatedPoints"]
  val get_points: 'tags this -> SVGPointList.t [@@js.get "points"]
  val create: animatedPoints:SVGPointList.t -> points:SVGPointList.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module DOMRectInit : sig
  type t = [`DOMRectInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`DOMRectInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`DOMRectInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `DOMRectInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_height: 'tags this -> float option [@@js.get "height"]
  val set_height: 'tags this -> float -> unit [@@js.set "height"]
  val get_width: 'tags this -> float option [@@js.get "width"]
  val set_width: 'tags this -> float -> unit [@@js.set "width"]
  val get_x: 'tags this -> float option [@@js.get "x"]
  val set_x: 'tags this -> float -> unit [@@js.set "x"]
  val get_y: 'tags this -> float option [@@js.get "y"]
  val set_y: 'tags this -> float -> unit [@@js.set "y"]
  val create: ?height:float -> ?width:float -> ?x:float -> ?y:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module[@js.scope "DOMRectReadOnly"] DOMRectReadOnly : sig
  type t = [`DOMRectReadOnly] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`DOMRectReadOnly]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`DOMRectReadOnly]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `DOMRectReadOnly ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_bottom: 'tags this -> float [@@js.get "bottom"]
  val get_height: 'tags this -> float [@@js.get "height"]
  val get_left: 'tags this -> float [@@js.get "left"]
  val get_right: 'tags this -> float [@@js.get "right"]
  val get_top: 'tags this -> float [@@js.get "top"]
  val get_width: 'tags this -> float [@@js.get "width"]
  val get_x: 'tags this -> float [@@js.get "x"]
  val get_y: 'tags this -> float [@@js.get "y"]
  val toJSON: 'tags this -> any [@@js.call "toJSON"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: ?x:float -> ?y:float -> ?width:float -> ?height:float -> unit -> t [@@js.create]
  val fromRect: ?other:DOMRectInit.t -> unit -> t [@@js.global "fromRect"]
end
module[@js.scope "DOMRect"] DOMRect : sig
  type t = [`DOMRect | `DOMRectReadOnly] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`DOMRect | `DOMRectReadOnly]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`DOMRect | `DOMRectReadOnly]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `DOMRect ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_height: 'tags this -> float [@@js.get "height"]
  val set_height: 'tags this -> float -> unit [@@js.set "height"]
  val get_width: 'tags this -> float [@@js.get "width"]
  val set_width: 'tags this -> float -> unit [@@js.set "width"]
  val get_x: 'tags this -> float [@@js.get "x"]
  val set_x: 'tags this -> float -> unit [@@js.set "x"]
  val get_y: 'tags this -> float [@@js.get "y"]
  val set_y: 'tags this -> float -> unit [@@js.set "y"]
  val create: height:float -> width:float -> x:float -> y:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': ?x:float -> ?y:float -> ?width:float -> ?height:float -> unit -> t [@@js.create]
  val fromRect: ?other:DOMRectInit.t -> unit -> t [@@js.global "fromRect"]
end

(** Used for attributes of basic SVGRect which can be animated. *)
module[@js.scope "SVGAnimatedRect"] SVGAnimatedRect : sig
  type t = [`SVGAnimatedRect] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`SVGAnimatedRect]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`SVGAnimatedRect]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGAnimatedRect ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_animVal: 'tags this -> DOMRectReadOnly.t [@@js.get "animVal"]
  val get_baseVal: 'tags this -> DOMRect.t [@@js.get "baseVal"]
  val create: animVal:DOMRectReadOnly.t -> baseVal:DOMRect.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end

(** Corresponds to the preserveAspectRatio attribute, which is available for some of SVG's elements. *)
module[@js.scope "SVGPreserveAspectRatio"] SVGPreserveAspectRatio : sig
  type t = [`SVGPreserveAspectRatio] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`SVGPreserveAspectRatio]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`SVGPreserveAspectRatio]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGPreserveAspectRatio ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_align: 'tags this -> float [@@js.get "align"]
  val set_align: 'tags this -> float -> unit [@@js.set "align"]
  val get_meetOrSlice: 'tags this -> float [@@js.get "meetOrSlice"]
  val set_meetOrSlice: 'tags this -> float -> unit [@@js.set "meetOrSlice"]
  val get_SVG_MEETORSLICE_MEET: 'tags this -> float [@@js.get "SVG_MEETORSLICE_MEET"]
  val get_SVG_MEETORSLICE_SLICE: 'tags this -> float [@@js.get "SVG_MEETORSLICE_SLICE"]
  val get_SVG_MEETORSLICE_UNKNOWN: 'tags this -> float [@@js.get "SVG_MEETORSLICE_UNKNOWN"]
  val get_SVG_PRESERVEASPECTRATIO_NONE: 'tags this -> float [@@js.get "SVG_PRESERVEASPECTRATIO_NONE"]
  val get_SVG_PRESERVEASPECTRATIO_UNKNOWN: 'tags this -> float [@@js.get "SVG_PRESERVEASPECTRATIO_UNKNOWN"]
  val get_SVG_PRESERVEASPECTRATIO_XMAXYMAX: 'tags this -> float [@@js.get "SVG_PRESERVEASPECTRATIO_XMAXYMAX"]
  val get_SVG_PRESERVEASPECTRATIO_XMAXYMID: 'tags this -> float [@@js.get "SVG_PRESERVEASPECTRATIO_XMAXYMID"]
  val get_SVG_PRESERVEASPECTRATIO_XMAXYMIN: 'tags this -> float [@@js.get "SVG_PRESERVEASPECTRATIO_XMAXYMIN"]
  val get_SVG_PRESERVEASPECTRATIO_XMIDYMAX: 'tags this -> float [@@js.get "SVG_PRESERVEASPECTRATIO_XMIDYMAX"]
  val get_SVG_PRESERVEASPECTRATIO_XMIDYMID: 'tags this -> float [@@js.get "SVG_PRESERVEASPECTRATIO_XMIDYMID"]
  val get_SVG_PRESERVEASPECTRATIO_XMIDYMIN: 'tags this -> float [@@js.get "SVG_PRESERVEASPECTRATIO_XMIDYMIN"]
  val get_SVG_PRESERVEASPECTRATIO_XMINYMAX: 'tags this -> float [@@js.get "SVG_PRESERVEASPECTRATIO_XMINYMAX"]
  val get_SVG_PRESERVEASPECTRATIO_XMINYMID: 'tags this -> float [@@js.get "SVG_PRESERVEASPECTRATIO_XMINYMID"]
  val get_SVG_PRESERVEASPECTRATIO_XMINYMIN: 'tags this -> float [@@js.get "SVG_PRESERVEASPECTRATIO_XMINYMIN"]
  val create: align:float -> meetOrSlice:float -> svg_meetorslice_meet:(float[@js "SVG_MEETORSLICE_MEET"]) -> svg_meetorslice_slice:(float[@js "SVG_MEETORSLICE_SLICE"]) -> svg_meetorslice_unknown:(float[@js "SVG_MEETORSLICE_UNKNOWN"]) -> svg_preserveaspectratio_none:(float[@js "SVG_PRESERVEASPECTRATIO_NONE"]) -> svg_preserveaspectratio_unknown:(float[@js "SVG_PRESERVEASPECTRATIO_UNKNOWN"]) -> svg_preserveaspectratio_xmaxymax:(float[@js "SVG_PRESERVEASPECTRATIO_XMAXYMAX"]) -> svg_preserveaspectratio_xmaxymid:(float[@js "SVG_PRESERVEASPECTRATIO_XMAXYMID"]) -> svg_preserveaspectratio_xmaxymin:(float[@js "SVG_PRESERVEASPECTRATIO_XMAXYMIN"]) -> svg_preserveaspectratio_xmidymax:(float[@js "SVG_PRESERVEASPECTRATIO_XMIDYMAX"]) -> svg_preserveaspectratio_xmidymid:(float[@js "SVG_PRESERVEASPECTRATIO_XMIDYMID"]) -> svg_preserveaspectratio_xmidymin:(float[@js "SVG_PRESERVEASPECTRATIO_XMIDYMIN"]) -> svg_preserveaspectratio_xminymax:(float[@js "SVG_PRESERVEASPECTRATIO_XMINYMAX"]) -> svg_preserveaspectratio_xminymid:(float[@js "SVG_PRESERVEASPECTRATIO_XMINYMID"]) -> svg_preserveaspectratio_xminymin:(float[@js "SVG_PRESERVEASPECTRATIO_XMINYMIN"]) -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
  val svg_meetorslice_meet: unit -> float [@@js.get "SVG_MEETORSLICE_MEET"]
  val svg_meetorslice_slice: unit -> float [@@js.get "SVG_MEETORSLICE_SLICE"]
  val svg_meetorslice_unknown: unit -> float [@@js.get "SVG_MEETORSLICE_UNKNOWN"]
  val svg_preserveaspectratio_none: unit -> float [@@js.get "SVG_PRESERVEASPECTRATIO_NONE"]
  val svg_preserveaspectratio_unknown: unit -> float [@@js.get "SVG_PRESERVEASPECTRATIO_UNKNOWN"]
  val svg_preserveaspectratio_xmaxymax: unit -> float [@@js.get "SVG_PRESERVEASPECTRATIO_XMAXYMAX"]
  val svg_preserveaspectratio_xmaxymid: unit -> float [@@js.get "SVG_PRESERVEASPECTRATIO_XMAXYMID"]
  val svg_preserveaspectratio_xmaxymin: unit -> float [@@js.get "SVG_PRESERVEASPECTRATIO_XMAXYMIN"]
  val svg_preserveaspectratio_xmidymax: unit -> float [@@js.get "SVG_PRESERVEASPECTRATIO_XMIDYMAX"]
  val svg_preserveaspectratio_xmidymid: unit -> float [@@js.get "SVG_PRESERVEASPECTRATIO_XMIDYMID"]
  val svg_preserveaspectratio_xmidymin: unit -> float [@@js.get "SVG_PRESERVEASPECTRATIO_XMIDYMIN"]
  val svg_preserveaspectratio_xminymax: unit -> float [@@js.get "SVG_PRESERVEASPECTRATIO_XMINYMAX"]
  val svg_preserveaspectratio_xminymid: unit -> float [@@js.get "SVG_PRESERVEASPECTRATIO_XMINYMID"]
  val svg_preserveaspectratio_xminymin: unit -> float [@@js.get "SVG_PRESERVEASPECTRATIO_XMINYMIN"]
end

(** Used for attributes of type SVGPreserveAspectRatio which can be animated. *)
module[@js.scope "SVGAnimatedPreserveAspectRatio"] SVGAnimatedPreserveAspectRatio : sig
  type t = [`SVGAnimatedPreserveAspectRatio] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`SVGAnimatedPreserveAspectRatio]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`SVGAnimatedPreserveAspectRatio]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGAnimatedPreserveAspectRatio ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_animVal: 'tags this -> SVGPreserveAspectRatio.t [@@js.get "animVal"]
  val get_baseVal: 'tags this -> SVGPreserveAspectRatio.t [@@js.get "baseVal"]
  val create: animVal:SVGPreserveAspectRatio.t -> baseVal:SVGPreserveAspectRatio.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end
module SVGFitToViewBox : sig
  type t = [`SVGFitToViewBox] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`SVGFitToViewBox]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`SVGFitToViewBox]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGFitToViewBox ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_preserveAspectRatio: 'tags this -> SVGAnimatedPreserveAspectRatio.t [@@js.get "preserveAspectRatio"]
  val get_viewBox: 'tags this -> SVGAnimatedRect.t [@@js.get "viewBox"]
  val create: preserveAspectRatio:SVGAnimatedPreserveAspectRatio.t -> viewBox:SVGAnimatedRect.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** Used for attributes of basic type <Number> which can be animated. *)
module[@js.scope "SVGAnimatedNumber"] SVGAnimatedNumber : sig
  type t = [`SVGAnimatedNumber] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`SVGAnimatedNumber]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`SVGAnimatedNumber]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGAnimatedNumber ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_animVal: 'tags this -> float [@@js.get "animVal"]
  val get_baseVal: 'tags this -> float [@@js.get "baseVal"]
  val set_baseVal: 'tags this -> float -> unit [@@js.set "baseVal"]
  val create: animVal:float -> baseVal:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end

(** Used to represent a value that can be an <angle> or <number> value. An SVGAngle reflected through the animVal attribute is always read only. *)
module[@js.scope "SVGAngle"] SVGAngle : sig
  type t = [`SVGAngle] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`SVGAngle]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`SVGAngle]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGAngle ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_unitType: 'tags this -> float [@@js.get "unitType"]
  val get_value: 'tags this -> float [@@js.get "value"]
  val set_value: 'tags this -> float -> unit [@@js.set "value"]
  val get_valueAsString: 'tags this -> string [@@js.get "valueAsString"]
  val set_valueAsString: 'tags this -> string -> unit [@@js.set "valueAsString"]
  val get_valueInSpecifiedUnits: 'tags this -> float [@@js.get "valueInSpecifiedUnits"]
  val set_valueInSpecifiedUnits: 'tags this -> float -> unit [@@js.set "valueInSpecifiedUnits"]
  val convertToSpecifiedUnits: 'tags this -> unitType:float -> unit [@@js.call "convertToSpecifiedUnits"]
  val newValueSpecifiedUnits: 'tags this -> unitType:float -> valueInSpecifiedUnits:float -> unit [@@js.call "newValueSpecifiedUnits"]
  val get_SVG_ANGLETYPE_DEG: 'tags this -> float [@@js.get "SVG_ANGLETYPE_DEG"]
  val get_SVG_ANGLETYPE_GRAD: 'tags this -> float [@@js.get "SVG_ANGLETYPE_GRAD"]
  val get_SVG_ANGLETYPE_RAD: 'tags this -> float [@@js.get "SVG_ANGLETYPE_RAD"]
  val get_SVG_ANGLETYPE_UNKNOWN: 'tags this -> float [@@js.get "SVG_ANGLETYPE_UNKNOWN"]
  val get_SVG_ANGLETYPE_UNSPECIFIED: 'tags this -> float [@@js.get "SVG_ANGLETYPE_UNSPECIFIED"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
  val svg_angletype_deg: unit -> float [@@js.get "SVG_ANGLETYPE_DEG"]
  val svg_angletype_grad: unit -> float [@@js.get "SVG_ANGLETYPE_GRAD"]
  val svg_angletype_rad: unit -> float [@@js.get "SVG_ANGLETYPE_RAD"]
  val svg_angletype_unknown: unit -> float [@@js.get "SVG_ANGLETYPE_UNKNOWN"]
  val svg_angletype_unspecified: unit -> float [@@js.get "SVG_ANGLETYPE_UNSPECIFIED"]
end
module FocusOptions : sig
  type t = [`FocusOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`FocusOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`FocusOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `FocusOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_preventScroll: 'tags this -> bool option [@@js.get "preventScroll"]
  val set_preventScroll: 'tags this -> bool -> unit [@@js.set "preventScroll"]
  val create: ?preventScroll:bool -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** Used by the dataset HTML attribute to represent data for custom attributes added to elements. *)
module[@js.scope "DOMStringMap"] DOMStringMap : sig
  type t = [`DOMStringMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`DOMStringMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`DOMStringMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `DOMStringMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get: 'tags this -> string -> string option [@@js.index_get]
  val set: 'tags this -> string -> ([`Undefined of undefined | `U1 of string] [@js.union]) -> unit [@@js.index_set]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module HTMLOrSVGElement : sig
  type t = [`HTMLOrSVGElement] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`HTMLOrSVGElement]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`HTMLOrSVGElement]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLOrSVGElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_autofocus: 'tags this -> bool [@@js.get "autofocus"]
  val set_autofocus: 'tags this -> bool -> unit [@@js.set "autofocus"]
  val get_dataset: 'tags this -> DOMStringMap.t [@@js.get "dataset"]
  val get_nonce: 'tags this -> string option [@@js.get "nonce"]
  val set_nonce: 'tags this -> string -> unit [@@js.set "nonce"]
  val get_tabIndex: 'tags this -> float [@@js.get "tabIndex"]
  val set_tabIndex: 'tags this -> float -> unit [@@js.set "tabIndex"]
  val blur: 'tags this -> unit [@@js.call "blur"]
  val focus: 'tags this -> ?options:FocusOptions.t -> unit -> unit [@@js.call "focus"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module SVGBoundingBoxOptions : sig
  type t = [`SVGBoundingBoxOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`SVGBoundingBoxOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`SVGBoundingBoxOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGBoundingBoxOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_clipped: 'tags this -> bool option [@@js.get "clipped"]
  val set_clipped: 'tags this -> bool -> unit [@@js.set "clipped"]
  val get_fill: 'tags this -> bool option [@@js.get "fill"]
  val set_fill: 'tags this -> bool -> unit [@@js.set "fill"]
  val get_markers: 'tags this -> bool option [@@js.get "markers"]
  val set_markers: 'tags this -> bool -> unit [@@js.set "markers"]
  val get_stroke: 'tags this -> bool option [@@js.get "stroke"]
  val set_stroke: 'tags this -> bool -> unit [@@js.set "stroke"]
  val create: ?clipped:bool -> ?fill:bool -> ?markers:bool -> ?stroke:bool -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module[@js.scope "DOMMatrix"] rec DOMMatrix : sig
  type t = [`DOMMatrix | `DOMMatrixReadOnly] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`DOMMatrix | `DOMMatrixReadOnly]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`DOMMatrix | `DOMMatrixReadOnly]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `DOMMatrix ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_a: 'tags this -> float [@@js.get "a"]
  val set_a: 'tags this -> float -> unit [@@js.set "a"]
  val get_b: 'tags this -> float [@@js.get "b"]
  val set_b: 'tags this -> float -> unit [@@js.set "b"]
  val get_c: 'tags this -> float [@@js.get "c"]
  val set_c: 'tags this -> float -> unit [@@js.set "c"]
  val get_d: 'tags this -> float [@@js.get "d"]
  val set_d: 'tags this -> float -> unit [@@js.set "d"]
  val get_e: 'tags this -> float [@@js.get "e"]
  val set_e: 'tags this -> float -> unit [@@js.set "e"]
  val get_f: 'tags this -> float [@@js.get "f"]
  val set_f: 'tags this -> float -> unit [@@js.set "f"]
  val get_m11: 'tags this -> float [@@js.get "m11"]
  val set_m11: 'tags this -> float -> unit [@@js.set "m11"]
  val get_m12: 'tags this -> float [@@js.get "m12"]
  val set_m12: 'tags this -> float -> unit [@@js.set "m12"]
  val get_m13: 'tags this -> float [@@js.get "m13"]
  val set_m13: 'tags this -> float -> unit [@@js.set "m13"]
  val get_m14: 'tags this -> float [@@js.get "m14"]
  val set_m14: 'tags this -> float -> unit [@@js.set "m14"]
  val get_m21: 'tags this -> float [@@js.get "m21"]
  val set_m21: 'tags this -> float -> unit [@@js.set "m21"]
  val get_m22: 'tags this -> float [@@js.get "m22"]
  val set_m22: 'tags this -> float -> unit [@@js.set "m22"]
  val get_m23: 'tags this -> float [@@js.get "m23"]
  val set_m23: 'tags this -> float -> unit [@@js.set "m23"]
  val get_m24: 'tags this -> float [@@js.get "m24"]
  val set_m24: 'tags this -> float -> unit [@@js.set "m24"]
  val get_m31: 'tags this -> float [@@js.get "m31"]
  val set_m31: 'tags this -> float -> unit [@@js.set "m31"]
  val get_m32: 'tags this -> float [@@js.get "m32"]
  val set_m32: 'tags this -> float -> unit [@@js.set "m32"]
  val get_m33: 'tags this -> float [@@js.get "m33"]
  val set_m33: 'tags this -> float -> unit [@@js.set "m33"]
  val get_m34: 'tags this -> float [@@js.get "m34"]
  val set_m34: 'tags this -> float -> unit [@@js.set "m34"]
  val get_m41: 'tags this -> float [@@js.get "m41"]
  val set_m41: 'tags this -> float -> unit [@@js.set "m41"]
  val get_m42: 'tags this -> float [@@js.get "m42"]
  val set_m42: 'tags this -> float -> unit [@@js.set "m42"]
  val get_m43: 'tags this -> float [@@js.get "m43"]
  val set_m43: 'tags this -> float -> unit [@@js.set "m43"]
  val get_m44: 'tags this -> float [@@js.get "m44"]
  val set_m44: 'tags this -> float -> unit [@@js.set "m44"]
  val invertSelf: 'tags this -> t [@@js.call "invertSelf"]
  val multiplySelf: 'tags this -> ?other:DOMMatrixInit.t -> unit -> t [@@js.call "multiplySelf"]
  val preMultiplySelf: 'tags this -> ?other:DOMMatrixInit.t -> unit -> t [@@js.call "preMultiplySelf"]
  val rotateAxisAngleSelf: 'tags this -> ?x:float -> ?y:float -> ?z:float -> ?angle:float -> unit -> t [@@js.call "rotateAxisAngleSelf"]
  val rotateFromVectorSelf: 'tags this -> ?x:float -> ?y:float -> unit -> t [@@js.call "rotateFromVectorSelf"]
  val rotateSelf: 'tags this -> ?rotX:float -> ?rotY:float -> ?rotZ:float -> unit -> t [@@js.call "rotateSelf"]
  val scale3dSelf: 'tags this -> ?scale:float -> ?originX:float -> ?originY:float -> ?originZ:float -> unit -> t [@@js.call "scale3dSelf"]
  val scaleSelf: 'tags this -> ?scaleX:float -> ?scaleY:float -> ?scaleZ:float -> ?originX:float -> ?originY:float -> ?originZ:float -> unit -> t [@@js.call "scaleSelf"]
  val setMatrixValue: 'tags this -> transformList:string -> t [@@js.call "setMatrixValue"]
  val skewXSelf: 'tags this -> ?sx:float -> unit -> t [@@js.call "skewXSelf"]
  val skewYSelf: 'tags this -> ?sy:float -> unit -> t [@@js.call "skewYSelf"]
  val translateSelf: 'tags this -> ?tx:float -> ?ty:float -> ?tz:float -> unit -> t [@@js.call "translateSelf"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: ?init:([`U1 of string | `U2 of float list] [@js.union]) -> unit -> t [@@js.create]
  val fromFloat32Array: Float32Array.t_0 -> t [@@js.global "fromFloat32Array"]
  val fromFloat64Array: Float64Array.t_0 -> t [@@js.global "fromFloat64Array"]
  val fromMatrix: ?other:DOMMatrixInit.t -> unit -> t [@@js.global "fromMatrix"]
end
and[@js.scope "DOMMatrixReadOnly"] DOMMatrixReadOnly : sig
  type t = [`DOMMatrixReadOnly] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`DOMMatrixReadOnly]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`DOMMatrixReadOnly]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `DOMMatrixReadOnly ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_a: 'tags this -> float [@@js.get "a"]
  val get_b: 'tags this -> float [@@js.get "b"]
  val get_c: 'tags this -> float [@@js.get "c"]
  val get_d: 'tags this -> float [@@js.get "d"]
  val get_e: 'tags this -> float [@@js.get "e"]
  val get_f: 'tags this -> float [@@js.get "f"]
  val get_is2D: 'tags this -> bool [@@js.get "is2D"]
  val get_isIdentity: 'tags this -> bool [@@js.get "isIdentity"]
  val get_m11: 'tags this -> float [@@js.get "m11"]
  val get_m12: 'tags this -> float [@@js.get "m12"]
  val get_m13: 'tags this -> float [@@js.get "m13"]
  val get_m14: 'tags this -> float [@@js.get "m14"]
  val get_m21: 'tags this -> float [@@js.get "m21"]
  val get_m22: 'tags this -> float [@@js.get "m22"]
  val get_m23: 'tags this -> float [@@js.get "m23"]
  val get_m24: 'tags this -> float [@@js.get "m24"]
  val get_m31: 'tags this -> float [@@js.get "m31"]
  val get_m32: 'tags this -> float [@@js.get "m32"]
  val get_m33: 'tags this -> float [@@js.get "m33"]
  val get_m34: 'tags this -> float [@@js.get "m34"]
  val get_m41: 'tags this -> float [@@js.get "m41"]
  val get_m42: 'tags this -> float [@@js.get "m42"]
  val get_m43: 'tags this -> float [@@js.get "m43"]
  val get_m44: 'tags this -> float [@@js.get "m44"]
  val flipX: 'tags this -> DOMMatrix.t [@@js.call "flipX"]
  val flipY: 'tags this -> DOMMatrix.t [@@js.call "flipY"]
  val inverse: 'tags this -> DOMMatrix.t [@@js.call "inverse"]
  val multiply: 'tags this -> ?other:DOMMatrixInit.t -> unit -> DOMMatrix.t [@@js.call "multiply"]
  val rotate: 'tags this -> ?rotX:float -> ?rotY:float -> ?rotZ:float -> unit -> DOMMatrix.t [@@js.call "rotate"]
  val rotateAxisAngle: 'tags this -> ?x:float -> ?y:float -> ?z:float -> ?angle:float -> unit -> DOMMatrix.t [@@js.call "rotateAxisAngle"]
  val rotateFromVector: 'tags this -> ?x:float -> ?y:float -> unit -> DOMMatrix.t [@@js.call "rotateFromVector"]
  val scale: 'tags this -> ?scaleX:float -> ?scaleY:float -> ?scaleZ:float -> ?originX:float -> ?originY:float -> ?originZ:float -> unit -> DOMMatrix.t [@@js.call "scale"]
  val scale3d: 'tags this -> ?scale:float -> ?originX:float -> ?originY:float -> ?originZ:float -> unit -> DOMMatrix.t [@@js.call "scale3d"]
  
  (** @deprecated  *)
  val scaleNonUniform: 'tags this -> ?scaleX:float -> ?scaleY:float -> unit -> DOMMatrix.t [@@js.call "scaleNonUniform"]
  val skewX: 'tags this -> ?sx:float -> unit -> DOMMatrix.t [@@js.call "skewX"]
  val skewY: 'tags this -> ?sy:float -> unit -> DOMMatrix.t [@@js.call "skewY"]
  val toFloat32Array: 'tags this -> Float32Array.t_0 [@@js.call "toFloat32Array"]
  val toFloat64Array: 'tags this -> Float64Array.t_0 [@@js.call "toFloat64Array"]
  val toJSON: 'tags this -> any [@@js.call "toJSON"]
  val transformPoint: 'tags this -> ?point:DOMPointInit.t -> unit -> DOMPoint.t [@@js.call "transformPoint"]
  val translate: 'tags this -> ?tx:float -> ?ty:float -> ?tz:float -> unit -> DOMMatrix.t [@@js.call "translate"]
  val toString: 'tags this -> string [@@js.call "toString"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: ?init:([`U1 of string | `U2 of float list] [@js.union]) -> unit -> t [@@js.create]
  val fromFloat32Array: Float32Array.t_0 -> t [@@js.global "fromFloat32Array"]
  val fromFloat64Array: Float64Array.t_0 -> t [@@js.global "fromFloat64Array"]
  val fromMatrix: ?other:DOMMatrixInit.t -> unit -> t [@@js.global "fromMatrix"]
  val toString': unit -> string [@@js.global "toString"]
end

(** SVGTransform is the interface for one of the component transformations within an SVGTransformList; thus, an SVGTransform object corresponds to a single component (e.g., scale(…) or matrix(…)) within a transform attribute. *)
module[@js.scope "SVGTransform"] SVGTransform : sig
  type t = [`SVGTransform] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`SVGTransform]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`SVGTransform]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGTransform ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_angle: 'tags this -> float [@@js.get "angle"]
  val get_matrix: 'tags this -> DOMMatrix.t [@@js.get "matrix"]
  val get_type: 'tags this -> float [@@js.get "type"]
  val setMatrix: 'tags this -> ?matrix:DOMMatrix2DInit.t -> unit -> unit [@@js.call "setMatrix"]
  val setRotate: 'tags this -> angle:float -> cx:float -> cy:float -> unit [@@js.call "setRotate"]
  val setScale: 'tags this -> sx:float -> sy:float -> unit [@@js.call "setScale"]
  val setSkewX: 'tags this -> angle:float -> unit [@@js.call "setSkewX"]
  val setSkewY: 'tags this -> angle:float -> unit [@@js.call "setSkewY"]
  val setTranslate: 'tags this -> tx:float -> ty:float -> unit [@@js.call "setTranslate"]
  val get_SVG_TRANSFORM_MATRIX: 'tags this -> float [@@js.get "SVG_TRANSFORM_MATRIX"]
  val get_SVG_TRANSFORM_ROTATE: 'tags this -> float [@@js.get "SVG_TRANSFORM_ROTATE"]
  val get_SVG_TRANSFORM_SCALE: 'tags this -> float [@@js.get "SVG_TRANSFORM_SCALE"]
  val get_SVG_TRANSFORM_SKEWX: 'tags this -> float [@@js.get "SVG_TRANSFORM_SKEWX"]
  val get_SVG_TRANSFORM_SKEWY: 'tags this -> float [@@js.get "SVG_TRANSFORM_SKEWY"]
  val get_SVG_TRANSFORM_TRANSLATE: 'tags this -> float [@@js.get "SVG_TRANSFORM_TRANSLATE"]
  val get_SVG_TRANSFORM_UNKNOWN: 'tags this -> float [@@js.get "SVG_TRANSFORM_UNKNOWN"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
  val svg_transform_matrix: unit -> float [@@js.get "SVG_TRANSFORM_MATRIX"]
  val svg_transform_rotate: unit -> float [@@js.get "SVG_TRANSFORM_ROTATE"]
  val svg_transform_scale: unit -> float [@@js.get "SVG_TRANSFORM_SCALE"]
  val svg_transform_skewx: unit -> float [@@js.get "SVG_TRANSFORM_SKEWX"]
  val svg_transform_skewy: unit -> float [@@js.get "SVG_TRANSFORM_SKEWY"]
  val svg_transform_translate: unit -> float [@@js.get "SVG_TRANSFORM_TRANSLATE"]
  val svg_transform_unknown: unit -> float [@@js.get "SVG_TRANSFORM_UNKNOWN"]
end

(** The SVGTransformList defines a list of SVGTransform objects. *)
module[@js.scope "SVGTransformList"] SVGTransformList : sig
  type t = [`SVGTransformList | SVGTransform.t ArrayLike.tags_1 | SVGTransform.t IterableIterator.tags_1] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`SVGTransformList | SVGTransform.t ArrayLike.tags_1 | SVGTransform.t IterableIterator.tags_1]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`SVGTransformList | SVGTransform.t ArrayLike.tags_1 | SVGTransform.t IterableIterator.tags_1]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGTransformList ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  (* [Symbol.iterator]: unit -> SVGTransform.t IterableIterator.t_1 *)
  val get_length: 'tags this -> float [@@js.get "length"]
  val get_numberOfItems: 'tags this -> float [@@js.get "numberOfItems"]
  val appendItem: 'tags this -> newItem:SVGTransform.t -> SVGTransform.t [@@js.call "appendItem"]
  val clear: 'tags this -> unit [@@js.call "clear"]
  val consolidate: 'tags this -> SVGTransform.t option [@@js.call "consolidate"]
  val createSVGTransformFromMatrix: 'tags this -> ?matrix:DOMMatrix2DInit.t -> unit -> SVGTransform.t [@@js.call "createSVGTransformFromMatrix"]
  val getItem: 'tags this -> index:float -> SVGTransform.t [@@js.call "getItem"]
  val initialize: 'tags this -> newItem:SVGTransform.t -> SVGTransform.t [@@js.call "initialize"]
  val insertItemBefore: 'tags this -> newItem:SVGTransform.t -> index:float -> SVGTransform.t [@@js.call "insertItemBefore"]
  val removeItem: 'tags this -> index:float -> SVGTransform.t [@@js.call "removeItem"]
  val replaceItem: 'tags this -> newItem:SVGTransform.t -> index:float -> SVGTransform.t [@@js.call "replaceItem"]
  val get: 'tags this -> float -> SVGTransform.t [@@js.index_get]
  val set: 'tags this -> float -> SVGTransform.t -> unit [@@js.index_set]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Used for attributes which take a list of numbers and which can be animated. *)
module[@js.scope "SVGAnimatedTransformList"] SVGAnimatedTransformList : sig
  type t = [`SVGAnimatedTransformList] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`SVGAnimatedTransformList]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`SVGAnimatedTransformList]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGAnimatedTransformList ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_animVal: 'tags this -> SVGTransformList.t [@@js.get "animVal"]
  val get_baseVal: 'tags this -> SVGTransformList.t [@@js.get "baseVal"]
  val create: animVal:SVGTransformList.t -> baseVal:SVGTransformList.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end

(** Used for attributes of basic type <length> which can be animated. *)
module[@js.scope "SVGAnimatedLength"] SVGAnimatedLength : sig
  type t = [`SVGAnimatedLength] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`SVGAnimatedLength]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`SVGAnimatedLength]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGAnimatedLength ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_animVal: 'tags this -> SVGLength.t [@@js.get "animVal"]
  val get_baseVal: 'tags this -> SVGLength.t [@@js.get "baseVal"]
  val create: animVal:SVGLength.t -> baseVal:SVGLength.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end
module GLint : sig
  type t = float
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end

(** Part of the WebGL API and represents the information returned by calling the WebGLRenderingContext.getShaderPrecisionFormat() method. *)
module[@js.scope "WebGLShaderPrecisionFormat"] WebGLShaderPrecisionFormat : sig
  type t = [`WebGLShaderPrecisionFormat] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`WebGLShaderPrecisionFormat]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`WebGLShaderPrecisionFormat]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `WebGLShaderPrecisionFormat ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_precision: 'tags this -> GLint.t [@@js.get "precision"]
  val get_rangeMax: 'tags this -> GLint.t [@@js.get "rangeMax"]
  val get_rangeMin: 'tags this -> GLint.t [@@js.get "rangeMin"]
  val create: precision:GLint.t -> rangeMax:GLint.t -> rangeMin:GLint.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end

(** Part of the WebGL API and represents a buffer that can contain an image, or can be source or target of an rendering operation. *)
module[@js.scope "WebGLRenderbuffer"] WebGLRenderbuffer : sig
  type t = [`WebGLRenderbuffer] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`WebGLRenderbuffer]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`WebGLRenderbuffer]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `WebGLRenderbuffer ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Part of the WebGL API and represents a collection of buffers that serve as a rendering destination. *)
module[@js.scope "WebGLFramebuffer"] WebGLFramebuffer : sig
  type t = [`WebGLFramebuffer] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`WebGLFramebuffer]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`WebGLFramebuffer]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `WebGLFramebuffer ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module WebGLPowerPreference : sig
  type t = ([`L_s241_default[@js "default"] | `L_s396_high_performance[@js "high-performance"] | `L_s485_low_power[@js "low-power"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module WebGLContextAttributes : sig
  type t = [`WebGLContextAttributes] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`WebGLContextAttributes]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`WebGLContextAttributes]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `WebGLContextAttributes ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_alpha: 'tags this -> bool option [@@js.get "alpha"]
  val set_alpha: 'tags this -> bool -> unit [@@js.set "alpha"]
  val get_antialias: 'tags this -> bool option [@@js.get "antialias"]
  val set_antialias: 'tags this -> bool -> unit [@@js.set "antialias"]
  val get_depth: 'tags this -> bool option [@@js.get "depth"]
  val set_depth: 'tags this -> bool -> unit [@@js.set "depth"]
  val get_desynchronized: 'tags this -> bool option [@@js.get "desynchronized"]
  val set_desynchronized: 'tags this -> bool -> unit [@@js.set "desynchronized"]
  val get_failIfMajorPerformanceCaveat: 'tags this -> bool option [@@js.get "failIfMajorPerformanceCaveat"]
  val set_failIfMajorPerformanceCaveat: 'tags this -> bool -> unit [@@js.set "failIfMajorPerformanceCaveat"]
  val get_powerPreference: 'tags this -> WebGLPowerPreference.t option [@@js.get "powerPreference"]
  val set_powerPreference: 'tags this -> WebGLPowerPreference.t -> unit [@@js.set "powerPreference"]
  val get_premultipliedAlpha: 'tags this -> bool option [@@js.get "premultipliedAlpha"]
  val set_premultipliedAlpha: 'tags this -> bool -> unit [@@js.set "premultipliedAlpha"]
  val get_preserveDrawingBuffer: 'tags this -> bool option [@@js.get "preserveDrawingBuffer"]
  val set_preserveDrawingBuffer: 'tags this -> bool -> unit [@@js.set "preserveDrawingBuffer"]
  val get_stencil: 'tags this -> bool option [@@js.get "stencil"]
  val set_stencil: 'tags this -> bool -> unit [@@js.set "stencil"]
  val create: ?alpha:bool -> ?antialias:bool -> ?depth:bool -> ?desynchronized:bool -> ?failIfMajorPerformanceCaveat:bool -> ?powerPreference:WebGLPowerPreference.t -> ?premultipliedAlpha:bool -> ?preserveDrawingBuffer:bool -> ?stencil:bool -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module WEBGL_lose_context : sig
  type t = [`WEBGL_lose_context] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`WEBGL_lose_context]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`WEBGL_lose_context]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `WEBGL_lose_context ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val loseContext: 'tags this -> unit [@@js.call "loseContext"]
  val restoreContext: 'tags this -> unit [@@js.call "restoreContext"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module GLenum : sig
  type t = float
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module WEBGL_draw_buffers : sig
  type t = [`WEBGL_draw_buffers] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`WEBGL_draw_buffers]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`WEBGL_draw_buffers]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `WEBGL_draw_buffers ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val drawBuffersWEBGL: 'tags this -> buffers:GLenum.t Iterable.t_1 -> unit [@@js.call "drawBuffersWEBGL"]
  val drawBuffersWEBGL': 'tags this -> buffers:GLenum.t list -> unit [@@js.call "drawBuffersWEBGL"]
  val get_COLOR_ATTACHMENT0_WEBGL: 'tags this -> GLenum.t [@@js.get "COLOR_ATTACHMENT0_WEBGL"]
  val get_COLOR_ATTACHMENT10_WEBGL: 'tags this -> GLenum.t [@@js.get "COLOR_ATTACHMENT10_WEBGL"]
  val get_COLOR_ATTACHMENT11_WEBGL: 'tags this -> GLenum.t [@@js.get "COLOR_ATTACHMENT11_WEBGL"]
  val get_COLOR_ATTACHMENT12_WEBGL: 'tags this -> GLenum.t [@@js.get "COLOR_ATTACHMENT12_WEBGL"]
  val get_COLOR_ATTACHMENT13_WEBGL: 'tags this -> GLenum.t [@@js.get "COLOR_ATTACHMENT13_WEBGL"]
  val get_COLOR_ATTACHMENT14_WEBGL: 'tags this -> GLenum.t [@@js.get "COLOR_ATTACHMENT14_WEBGL"]
  val get_COLOR_ATTACHMENT15_WEBGL: 'tags this -> GLenum.t [@@js.get "COLOR_ATTACHMENT15_WEBGL"]
  val get_COLOR_ATTACHMENT1_WEBGL: 'tags this -> GLenum.t [@@js.get "COLOR_ATTACHMENT1_WEBGL"]
  val get_COLOR_ATTACHMENT2_WEBGL: 'tags this -> GLenum.t [@@js.get "COLOR_ATTACHMENT2_WEBGL"]
  val get_COLOR_ATTACHMENT3_WEBGL: 'tags this -> GLenum.t [@@js.get "COLOR_ATTACHMENT3_WEBGL"]
  val get_COLOR_ATTACHMENT4_WEBGL: 'tags this -> GLenum.t [@@js.get "COLOR_ATTACHMENT4_WEBGL"]
  val get_COLOR_ATTACHMENT5_WEBGL: 'tags this -> GLenum.t [@@js.get "COLOR_ATTACHMENT5_WEBGL"]
  val get_COLOR_ATTACHMENT6_WEBGL: 'tags this -> GLenum.t [@@js.get "COLOR_ATTACHMENT6_WEBGL"]
  val get_COLOR_ATTACHMENT7_WEBGL: 'tags this -> GLenum.t [@@js.get "COLOR_ATTACHMENT7_WEBGL"]
  val get_COLOR_ATTACHMENT8_WEBGL: 'tags this -> GLenum.t [@@js.get "COLOR_ATTACHMENT8_WEBGL"]
  val get_COLOR_ATTACHMENT9_WEBGL: 'tags this -> GLenum.t [@@js.get "COLOR_ATTACHMENT9_WEBGL"]
  val get_DRAW_BUFFER0_WEBGL: 'tags this -> GLenum.t [@@js.get "DRAW_BUFFER0_WEBGL"]
  val get_DRAW_BUFFER10_WEBGL: 'tags this -> GLenum.t [@@js.get "DRAW_BUFFER10_WEBGL"]
  val get_DRAW_BUFFER11_WEBGL: 'tags this -> GLenum.t [@@js.get "DRAW_BUFFER11_WEBGL"]
  val get_DRAW_BUFFER12_WEBGL: 'tags this -> GLenum.t [@@js.get "DRAW_BUFFER12_WEBGL"]
  val get_DRAW_BUFFER13_WEBGL: 'tags this -> GLenum.t [@@js.get "DRAW_BUFFER13_WEBGL"]
  val get_DRAW_BUFFER14_WEBGL: 'tags this -> GLenum.t [@@js.get "DRAW_BUFFER14_WEBGL"]
  val get_DRAW_BUFFER15_WEBGL: 'tags this -> GLenum.t [@@js.get "DRAW_BUFFER15_WEBGL"]
  val get_DRAW_BUFFER1_WEBGL: 'tags this -> GLenum.t [@@js.get "DRAW_BUFFER1_WEBGL"]
  val get_DRAW_BUFFER2_WEBGL: 'tags this -> GLenum.t [@@js.get "DRAW_BUFFER2_WEBGL"]
  val get_DRAW_BUFFER3_WEBGL: 'tags this -> GLenum.t [@@js.get "DRAW_BUFFER3_WEBGL"]
  val get_DRAW_BUFFER4_WEBGL: 'tags this -> GLenum.t [@@js.get "DRAW_BUFFER4_WEBGL"]
  val get_DRAW_BUFFER5_WEBGL: 'tags this -> GLenum.t [@@js.get "DRAW_BUFFER5_WEBGL"]
  val get_DRAW_BUFFER6_WEBGL: 'tags this -> GLenum.t [@@js.get "DRAW_BUFFER6_WEBGL"]
  val get_DRAW_BUFFER7_WEBGL: 'tags this -> GLenum.t [@@js.get "DRAW_BUFFER7_WEBGL"]
  val get_DRAW_BUFFER8_WEBGL: 'tags this -> GLenum.t [@@js.get "DRAW_BUFFER8_WEBGL"]
  val get_DRAW_BUFFER9_WEBGL: 'tags this -> GLenum.t [@@js.get "DRAW_BUFFER9_WEBGL"]
  val get_MAX_COLOR_ATTACHMENTS_WEBGL: 'tags this -> GLenum.t [@@js.get "MAX_COLOR_ATTACHMENTS_WEBGL"]
  val get_MAX_DRAW_BUFFERS_WEBGL: 'tags this -> GLenum.t [@@js.get "MAX_DRAW_BUFFERS_WEBGL"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** The WEBGL_depth_texture extension is part of the WebGL API and defines 2D depth and depth-stencil textures. *)
module WEBGL_depth_texture : sig
  type t = [`WEBGL_depth_texture] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`WEBGL_depth_texture]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`WEBGL_depth_texture]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `WEBGL_depth_texture ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_UNSIGNED_INT_24_8_WEBGL: 'tags this -> GLenum.t [@@js.get "UNSIGNED_INT_24_8_WEBGL"]
  val create: unsigned_int_24_8_webgl:(GLenum.t[@js "UNSIGNED_INT_24_8_WEBGL"]) -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** The WebGLShader is part of the WebGL API and can either be a vertex or a fragment shader. A WebGLProgram requires both types of shaders. *)
module[@js.scope "WebGLShader"] WebGLShader : sig
  type t = [`WebGLShader] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`WebGLShader]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`WebGLShader]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `WebGLShader ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module WEBGL_debug_shaders : sig
  type t = [`WEBGL_debug_shaders] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`WEBGL_debug_shaders]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`WEBGL_debug_shaders]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `WEBGL_debug_shaders ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val getTranslatedShaderSource: 'tags this -> shader:WebGLShader.t -> string [@@js.call "getTranslatedShaderSource"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** The WEBGL_debug_renderer_info extension is part of the WebGL API and exposes two constants with information about the graphics driver for debugging purposes. *)
module WEBGL_debug_renderer_info : sig
  type t = [`WEBGL_debug_renderer_info] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`WEBGL_debug_renderer_info]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`WEBGL_debug_renderer_info]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `WEBGL_debug_renderer_info ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_UNMASKED_RENDERER_WEBGL: 'tags this -> GLenum.t [@@js.get "UNMASKED_RENDERER_WEBGL"]
  val get_UNMASKED_VENDOR_WEBGL: 'tags this -> GLenum.t [@@js.get "UNMASKED_VENDOR_WEBGL"]
  val create: unmasked_renderer_webgl:(GLenum.t[@js "UNMASKED_RENDERER_WEBGL"]) -> unmasked_vendor_webgl:(GLenum.t[@js "UNMASKED_VENDOR_WEBGL"]) -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module WEBGL_compressed_texture_s3tc_srgb : sig
  type t = [`WEBGL_compressed_texture_s3tc_srgb] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`WEBGL_compressed_texture_s3tc_srgb]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`WEBGL_compressed_texture_s3tc_srgb]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `WEBGL_compressed_texture_s3tc_srgb ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT: 'tags this -> GLenum.t [@@js.get "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT"]
  val get_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT: 'tags this -> GLenum.t [@@js.get "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT"]
  val get_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT: 'tags this -> GLenum.t [@@js.get "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT"]
  val get_COMPRESSED_SRGB_S3TC_DXT1_EXT: 'tags this -> GLenum.t [@@js.get "COMPRESSED_SRGB_S3TC_DXT1_EXT"]
  val create: compressed_srgb_alpha_s3tc_dxt1_ext:(GLenum.t[@js "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT"]) -> compressed_srgb_alpha_s3tc_dxt3_ext:(GLenum.t[@js "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT"]) -> compressed_srgb_alpha_s3tc_dxt5_ext:(GLenum.t[@js "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT"]) -> compressed_srgb_s3tc_dxt1_ext:(GLenum.t[@js "COMPRESSED_SRGB_S3TC_DXT1_EXT"]) -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** The WEBGL_compressed_texture_s3tc extension is part of the WebGL API and exposes four S3TC compressed texture formats. *)
module WEBGL_compressed_texture_s3tc : sig
  type t = [`WEBGL_compressed_texture_s3tc] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`WEBGL_compressed_texture_s3tc]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`WEBGL_compressed_texture_s3tc]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `WEBGL_compressed_texture_s3tc ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_COMPRESSED_RGBA_S3TC_DXT1_EXT: 'tags this -> GLenum.t [@@js.get "COMPRESSED_RGBA_S3TC_DXT1_EXT"]
  val get_COMPRESSED_RGBA_S3TC_DXT3_EXT: 'tags this -> GLenum.t [@@js.get "COMPRESSED_RGBA_S3TC_DXT3_EXT"]
  val get_COMPRESSED_RGBA_S3TC_DXT5_EXT: 'tags this -> GLenum.t [@@js.get "COMPRESSED_RGBA_S3TC_DXT5_EXT"]
  val get_COMPRESSED_RGB_S3TC_DXT1_EXT: 'tags this -> GLenum.t [@@js.get "COMPRESSED_RGB_S3TC_DXT1_EXT"]
  val create: compressed_rgba_s3tc_dxt1_ext:(GLenum.t[@js "COMPRESSED_RGBA_S3TC_DXT1_EXT"]) -> compressed_rgba_s3tc_dxt3_ext:(GLenum.t[@js "COMPRESSED_RGBA_S3TC_DXT3_EXT"]) -> compressed_rgba_s3tc_dxt5_ext:(GLenum.t[@js "COMPRESSED_RGBA_S3TC_DXT5_EXT"]) -> compressed_rgb_s3tc_dxt1_ext:(GLenum.t[@js "COMPRESSED_RGB_S3TC_DXT1_EXT"]) -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module WEBGL_compressed_texture_pvrtc : sig
  type t = [`WEBGL_compressed_texture_pvrtc] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`WEBGL_compressed_texture_pvrtc]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`WEBGL_compressed_texture_pvrtc]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `WEBGL_compressed_texture_pvrtc ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: 'tags this -> GLenum.t [@@js.get "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG"]
  val get_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 'tags this -> GLenum.t [@@js.get "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG"]
  val get_COMPRESSED_RGB_PVRTC_2BPPV1_IMG: 'tags this -> GLenum.t [@@js.get "COMPRESSED_RGB_PVRTC_2BPPV1_IMG"]
  val get_COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 'tags this -> GLenum.t [@@js.get "COMPRESSED_RGB_PVRTC_4BPPV1_IMG"]
  val create: compressed_rgba_pvrtc_2bppv1_img:(GLenum.t[@js "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG"]) -> compressed_rgba_pvrtc_4bppv1_img:(GLenum.t[@js "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG"]) -> compressed_rgb_pvrtc_2bppv1_img:(GLenum.t[@js "COMPRESSED_RGB_PVRTC_2BPPV1_IMG"]) -> compressed_rgb_pvrtc_4bppv1_img:(GLenum.t[@js "COMPRESSED_RGB_PVRTC_4BPPV1_IMG"]) -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module WEBGL_compressed_texture_etc1 : sig
  type t = [`WEBGL_compressed_texture_etc1] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`WEBGL_compressed_texture_etc1]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`WEBGL_compressed_texture_etc1]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `WEBGL_compressed_texture_etc1 ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_COMPRESSED_RGB_ETC1_WEBGL: 'tags this -> GLenum.t [@@js.get "COMPRESSED_RGB_ETC1_WEBGL"]
  val create: compressed_rgb_etc1_webgl:(GLenum.t[@js "COMPRESSED_RGB_ETC1_WEBGL"]) -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module WEBGL_compressed_texture_etc : sig
  type t = [`WEBGL_compressed_texture_etc] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`WEBGL_compressed_texture_etc]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`WEBGL_compressed_texture_etc]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `WEBGL_compressed_texture_etc ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_COMPRESSED_R11_EAC: 'tags this -> GLenum.t [@@js.get "COMPRESSED_R11_EAC"]
  val get_COMPRESSED_RG11_EAC: 'tags this -> GLenum.t [@@js.get "COMPRESSED_RG11_EAC"]
  val get_COMPRESSED_RGB8_ETC2: 'tags this -> GLenum.t [@@js.get "COMPRESSED_RGB8_ETC2"]
  val get_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: 'tags this -> GLenum.t [@@js.get "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2"]
  val get_COMPRESSED_RGBA8_ETC2_EAC: 'tags this -> GLenum.t [@@js.get "COMPRESSED_RGBA8_ETC2_EAC"]
  val get_COMPRESSED_SIGNED_R11_EAC: 'tags this -> GLenum.t [@@js.get "COMPRESSED_SIGNED_R11_EAC"]
  val get_COMPRESSED_SIGNED_RG11_EAC: 'tags this -> GLenum.t [@@js.get "COMPRESSED_SIGNED_RG11_EAC"]
  val get_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: 'tags this -> GLenum.t [@@js.get "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC"]
  val get_COMPRESSED_SRGB8_ETC2: 'tags this -> GLenum.t [@@js.get "COMPRESSED_SRGB8_ETC2"]
  val get_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: 'tags this -> GLenum.t [@@js.get "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"]
  val create: compressed_r11_eac:(GLenum.t[@js "COMPRESSED_R11_EAC"]) -> compressed_rg11_eac:(GLenum.t[@js "COMPRESSED_RG11_EAC"]) -> compressed_rgb8_etc2:(GLenum.t[@js "COMPRESSED_RGB8_ETC2"]) -> compressed_rgb8_punchthrough_alpha1_etc2:(GLenum.t[@js "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2"]) -> compressed_rgba8_etc2_eac:(GLenum.t[@js "COMPRESSED_RGBA8_ETC2_EAC"]) -> compressed_signed_r11_eac:(GLenum.t[@js "COMPRESSED_SIGNED_R11_EAC"]) -> compressed_signed_rg11_eac:(GLenum.t[@js "COMPRESSED_SIGNED_RG11_EAC"]) -> compressed_srgb8_alpha8_etc2_eac:(GLenum.t[@js "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC"]) -> compressed_srgb8_etc2:(GLenum.t[@js "COMPRESSED_SRGB8_ETC2"]) -> compressed_srgb8_punchthrough_alpha1_etc2:(GLenum.t[@js "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"]) -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module WEBGL_compressed_texture_astc : sig
  type t = [`WEBGL_compressed_texture_astc] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`WEBGL_compressed_texture_astc]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`WEBGL_compressed_texture_astc]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `WEBGL_compressed_texture_astc ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val getSupportedProfiles: 'tags this -> string list [@@js.call "getSupportedProfiles"]
  val get_COMPRESSED_RGBA_ASTC_10x10_KHR: 'tags this -> GLenum.t [@@js.get "COMPRESSED_RGBA_ASTC_10x10_KHR"]
  val get_COMPRESSED_RGBA_ASTC_10x5_KHR: 'tags this -> GLenum.t [@@js.get "COMPRESSED_RGBA_ASTC_10x5_KHR"]
  val get_COMPRESSED_RGBA_ASTC_10x6_KHR: 'tags this -> GLenum.t [@@js.get "COMPRESSED_RGBA_ASTC_10x6_KHR"]
  val get_COMPRESSED_RGBA_ASTC_10x8_KHR: 'tags this -> GLenum.t [@@js.get "COMPRESSED_RGBA_ASTC_10x8_KHR"]
  val get_COMPRESSED_RGBA_ASTC_12x10_KHR: 'tags this -> GLenum.t [@@js.get "COMPRESSED_RGBA_ASTC_12x10_KHR"]
  val get_COMPRESSED_RGBA_ASTC_12x12_KHR: 'tags this -> GLenum.t [@@js.get "COMPRESSED_RGBA_ASTC_12x12_KHR"]
  val get_COMPRESSED_RGBA_ASTC_4x4_KHR: 'tags this -> GLenum.t [@@js.get "COMPRESSED_RGBA_ASTC_4x4_KHR"]
  val get_COMPRESSED_RGBA_ASTC_5x4_KHR: 'tags this -> GLenum.t [@@js.get "COMPRESSED_RGBA_ASTC_5x4_KHR"]
  val get_COMPRESSED_RGBA_ASTC_5x5_KHR: 'tags this -> GLenum.t [@@js.get "COMPRESSED_RGBA_ASTC_5x5_KHR"]
  val get_COMPRESSED_RGBA_ASTC_6x5_KHR: 'tags this -> GLenum.t [@@js.get "COMPRESSED_RGBA_ASTC_6x5_KHR"]
  val get_COMPRESSED_RGBA_ASTC_6x6_KHR: 'tags this -> GLenum.t [@@js.get "COMPRESSED_RGBA_ASTC_6x6_KHR"]
  val get_COMPRESSED_RGBA_ASTC_8x5_KHR: 'tags this -> GLenum.t [@@js.get "COMPRESSED_RGBA_ASTC_8x5_KHR"]
  val get_COMPRESSED_RGBA_ASTC_8x6_KHR: 'tags this -> GLenum.t [@@js.get "COMPRESSED_RGBA_ASTC_8x6_KHR"]
  val get_COMPRESSED_RGBA_ASTC_8x8_KHR: 'tags this -> GLenum.t [@@js.get "COMPRESSED_RGBA_ASTC_8x8_KHR"]
  val get_COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR: 'tags this -> GLenum.t [@@js.get "COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR"]
  val get_COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR: 'tags this -> GLenum.t [@@js.get "COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR"]
  val get_COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR: 'tags this -> GLenum.t [@@js.get "COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR"]
  val get_COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR: 'tags this -> GLenum.t [@@js.get "COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR"]
  val get_COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR: 'tags this -> GLenum.t [@@js.get "COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR"]
  val get_COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR: 'tags this -> GLenum.t [@@js.get "COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR"]
  val get_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR: 'tags this -> GLenum.t [@@js.get "COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR"]
  val get_COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR: 'tags this -> GLenum.t [@@js.get "COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR"]
  val get_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR: 'tags this -> GLenum.t [@@js.get "COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR"]
  val get_COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR: 'tags this -> GLenum.t [@@js.get "COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR"]
  val get_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR: 'tags this -> GLenum.t [@@js.get "COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR"]
  val get_COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR: 'tags this -> GLenum.t [@@js.get "COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR"]
  val get_COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR: 'tags this -> GLenum.t [@@js.get "COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR"]
  val get_COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR: 'tags this -> GLenum.t [@@js.get "COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module WEBGL_color_buffer_float : sig
  type t = [`WEBGL_color_buffer_float] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`WEBGL_color_buffer_float]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`WEBGL_color_buffer_float]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `WEBGL_color_buffer_float ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT: 'tags this -> GLenum.t [@@js.get "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT"]
  val get_RGBA32F_EXT: 'tags this -> GLenum.t [@@js.get "RGBA32F_EXT"]
  val get_UNSIGNED_NORMALIZED_EXT: 'tags this -> GLenum.t [@@js.get "UNSIGNED_NORMALIZED_EXT"]
  val create: framebuffer_attachment_component_type_ext:(GLenum.t[@js "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT"]) -> rgba32f_ext:(GLenum.t[@js "RGBA32F_EXT"]) -> unsigned_normalized_ext:(GLenum.t[@js "UNSIGNED_NORMALIZED_EXT"]) -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** Part of the WebGL API and represents an opaque texture object providing storage and state for texturing operations. *)
module[@js.scope "WebGLTexture"] WebGLTexture : sig
  type t = [`WebGLTexture] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`WebGLTexture]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`WebGLTexture]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `WebGLTexture ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module GLsizei : sig
  type t = float
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module OVR_multiview2 : sig
  type t = [`OVR_multiview2] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`OVR_multiview2]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`OVR_multiview2]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `OVR_multiview2 ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val framebufferTextureMultiviewOVR: 'tags this -> target:GLenum.t -> attachment:GLenum.t -> texture:WebGLTexture.t option -> level:GLint.t -> baseViewIndex:GLint.t -> numViews:GLsizei.t -> unit [@@js.call "framebufferTextureMultiviewOVR"]
  val get_FRAMEBUFFER_ATTACHMENT_TEXTURE_BASE_VIEW_INDEX_OVR: 'tags this -> GLenum.t [@@js.get "FRAMEBUFFER_ATTACHMENT_TEXTURE_BASE_VIEW_INDEX_OVR"]
  val get_FRAMEBUFFER_ATTACHMENT_TEXTURE_NUM_VIEWS_OVR: 'tags this -> GLenum.t [@@js.get "FRAMEBUFFER_ATTACHMENT_TEXTURE_NUM_VIEWS_OVR"]
  val get_FRAMEBUFFER_INCOMPLETE_VIEW_TARGETS_OVR: 'tags this -> GLenum.t [@@js.get "FRAMEBUFFER_INCOMPLETE_VIEW_TARGETS_OVR"]
  val get_MAX_VIEWS_OVR: 'tags this -> GLenum.t [@@js.get "MAX_VIEWS_OVR"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module WebGLVertexArrayObjectOES : sig
  type t = [`WebGLVertexArrayObjectOES] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`WebGLVertexArrayObjectOES]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`WebGLVertexArrayObjectOES]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `WebGLVertexArrayObjectOES ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module GLboolean : sig
  type t = bool
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module OES_vertex_array_object : sig
  type t = [`OES_vertex_array_object] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`OES_vertex_array_object]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`OES_vertex_array_object]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `OES_vertex_array_object ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val bindVertexArrayOES: 'tags this -> arrayObject:WebGLVertexArrayObjectOES.t option -> unit [@@js.call "bindVertexArrayOES"]
  val createVertexArrayOES: 'tags this -> WebGLVertexArrayObjectOES.t option [@@js.call "createVertexArrayOES"]
  val deleteVertexArrayOES: 'tags this -> arrayObject:WebGLVertexArrayObjectOES.t option -> unit [@@js.call "deleteVertexArrayOES"]
  val isVertexArrayOES: 'tags this -> arrayObject:WebGLVertexArrayObjectOES.t option -> GLboolean.t [@@js.call "isVertexArrayOES"]
  val get_VERTEX_ARRAY_BINDING_OES: 'tags this -> GLenum.t [@@js.get "VERTEX_ARRAY_BINDING_OES"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** The OES_texture_half_float_linear extension is part of the WebGL API and allows linear filtering with half floating-point pixel types for textures. *)
module OES_texture_half_float_linear : sig
  type t = [`OES_texture_half_float_linear] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`OES_texture_half_float_linear]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`OES_texture_half_float_linear]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `OES_texture_half_float_linear ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** The OES_texture_half_float extension is part of the WebGL API and adds texture formats with 16- (aka half float) and 32-bit floating-point components. *)
module OES_texture_half_float : sig
  type t = [`OES_texture_half_float] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`OES_texture_half_float]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`OES_texture_half_float]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `OES_texture_half_float ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_HALF_FLOAT_OES: 'tags this -> GLenum.t [@@js.get "HALF_FLOAT_OES"]
  val create: half_float_oes:(GLenum.t[@js "HALF_FLOAT_OES"]) -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** The OES_texture_float_linear extension is part of the WebGL API and allows linear filtering with floating-point pixel types for textures. *)
module OES_texture_float_linear : sig
  type t = [`OES_texture_float_linear] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`OES_texture_float_linear]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`OES_texture_float_linear]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `OES_texture_float_linear ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** The OES_texture_float extension is part of the WebGL API and exposes floating-point pixel types for textures. *)
module OES_texture_float : sig
  type t = [`OES_texture_float] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`OES_texture_float]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`OES_texture_float]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `OES_texture_float ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** The OES_standard_derivatives extension is part of the WebGL API and adds the GLSL derivative functions dFdx, dFdy, and fwidth. *)
module OES_standard_derivatives : sig
  type t = [`OES_standard_derivatives] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`OES_standard_derivatives]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`OES_standard_derivatives]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `OES_standard_derivatives ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_FRAGMENT_SHADER_DERIVATIVE_HINT_OES: 'tags this -> GLenum.t [@@js.get "FRAGMENT_SHADER_DERIVATIVE_HINT_OES"]
  val create: fragment_shader_derivative_hint_oes:(GLenum.t[@js "FRAGMENT_SHADER_DERIVATIVE_HINT_OES"]) -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** The OES_element_index_uint extension is part of the WebGL API and adds support for gl.UNSIGNED_INT types to WebGLRenderingContext.drawElements(). *)
module OES_element_index_uint : sig
  type t = [`OES_element_index_uint] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`OES_element_index_uint]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`OES_element_index_uint]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `OES_element_index_uint ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module KHR_parallel_shader_compile : sig
  type t = [`KHR_parallel_shader_compile] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`KHR_parallel_shader_compile]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`KHR_parallel_shader_compile]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `KHR_parallel_shader_compile ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_COMPLETION_STATUS_KHR: 'tags this -> GLenum.t [@@js.get "COMPLETION_STATUS_KHR"]
  val create: completion_status_khr:(GLenum.t[@js "COMPLETION_STATUS_KHR"]) -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module GLclampf : sig
  type t = float
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end

(** The EXT_texture_filter_anisotropic extension is part of the WebGL API and exposes two constants for anisotropic filtering (AF). *)
module EXT_texture_filter_anisotropic : sig
  type t = [`EXT_texture_filter_anisotropic] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EXT_texture_filter_anisotropic]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EXT_texture_filter_anisotropic]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `EXT_texture_filter_anisotropic ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_MAX_TEXTURE_MAX_ANISOTROPY_EXT: 'tags this -> GLenum.t [@@js.get "MAX_TEXTURE_MAX_ANISOTROPY_EXT"]
  val get_TEXTURE_MAX_ANISOTROPY_EXT: 'tags this -> GLenum.t [@@js.get "TEXTURE_MAX_ANISOTROPY_EXT"]
  val create: max_texture_max_anisotropy_ext:(GLenum.t[@js "MAX_TEXTURE_MAX_ANISOTROPY_EXT"]) -> texture_max_anisotropy_ext:(GLenum.t[@js "TEXTURE_MAX_ANISOTROPY_EXT"]) -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module EXT_shader_texture_lod : sig
  type t = [`EXT_shader_texture_lod] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EXT_shader_texture_lod]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EXT_shader_texture_lod]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `EXT_shader_texture_lod ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module EXT_sRGB : sig
  type t = [`EXT_sRGB] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EXT_sRGB]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EXT_sRGB]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `EXT_sRGB ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT: 'tags this -> GLenum.t [@@js.get "FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT"]
  val get_SRGB8_ALPHA8_EXT: 'tags this -> GLenum.t [@@js.get "SRGB8_ALPHA8_EXT"]
  val get_SRGB_ALPHA_EXT: 'tags this -> GLenum.t [@@js.get "SRGB_ALPHA_EXT"]
  val get_SRGB_EXT: 'tags this -> GLenum.t [@@js.get "SRGB_EXT"]
  val create: framebuffer_attachment_color_encoding_ext:(GLenum.t[@js "FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT"]) -> srgb8_alpha8_ext:(GLenum.t[@js "SRGB8_ALPHA8_EXT"]) -> srgb_alpha_ext:(GLenum.t[@js "SRGB_ALPHA_EXT"]) -> srgb_ext:(GLenum.t[@js "SRGB_EXT"]) -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** The EXT_frag_depth extension is part of the WebGL API and enables to set a depth value of a fragment from within the fragment shader. *)
module EXT_frag_depth : sig
  type t = [`EXT_frag_depth] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EXT_frag_depth]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EXT_frag_depth]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `EXT_frag_depth ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module EXT_float_blend : sig
  type t = [`EXT_float_blend] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EXT_float_blend]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EXT_float_blend]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `EXT_float_blend ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module EXT_color_buffer_half_float : sig
  type t = [`EXT_color_buffer_half_float] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EXT_color_buffer_half_float]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EXT_color_buffer_half_float]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `EXT_color_buffer_half_float ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT: 'tags this -> GLenum.t [@@js.get "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT"]
  val get_RGB16F_EXT: 'tags this -> GLenum.t [@@js.get "RGB16F_EXT"]
  val get_RGBA16F_EXT: 'tags this -> GLenum.t [@@js.get "RGBA16F_EXT"]
  val get_UNSIGNED_NORMALIZED_EXT: 'tags this -> GLenum.t [@@js.get "UNSIGNED_NORMALIZED_EXT"]
  val create: framebuffer_attachment_component_type_ext:(GLenum.t[@js "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT"]) -> rgb16f_ext:(GLenum.t[@js "RGB16F_EXT"]) -> rgba16f_ext:(GLenum.t[@js "RGBA16F_EXT"]) -> unsigned_normalized_ext:(GLenum.t[@js "UNSIGNED_NORMALIZED_EXT"]) -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module EXT_color_buffer_float : sig
  type t = [`EXT_color_buffer_float] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EXT_color_buffer_float]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EXT_color_buffer_float]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `EXT_color_buffer_float ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module EXT_blend_minmax : sig
  type t = [`EXT_blend_minmax] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EXT_blend_minmax]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EXT_blend_minmax]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `EXT_blend_minmax ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_MAX_EXT: 'tags this -> GLenum.t [@@js.get "MAX_EXT"]
  val get_MIN_EXT: 'tags this -> GLenum.t [@@js.get "MIN_EXT"]
  val create: max_ext:(GLenum.t[@js "MAX_EXT"]) -> min_ext:(GLenum.t[@js "MIN_EXT"]) -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module[@js.scope "WebGLVertexArrayObject"] WebGLVertexArrayObject : sig
  type t = [`WebGLVertexArrayObject] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`WebGLVertexArrayObject]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`WebGLVertexArrayObject]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `WebGLVertexArrayObject ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Part of the WebGL API and represents the location of a uniform variable in a shader program. *)
module[@js.scope "WebGLUniformLocation"] WebGLUniformLocation : sig
  type t = [`WebGLUniformLocation] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`WebGLUniformLocation]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`WebGLUniformLocation]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `WebGLUniformLocation ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module[@js.scope "WebGLTransformFeedback"] WebGLTransformFeedback : sig
  type t = [`WebGLTransformFeedback] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`WebGLTransformFeedback]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`WebGLTransformFeedback]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `WebGLTransformFeedback ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module[@js.scope "WebGLSync"] WebGLSync : sig
  type t = [`WebGLSync] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`WebGLSync]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`WebGLSync]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `WebGLSync ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module[@js.scope "WebGLSampler"] WebGLSampler : sig
  type t = [`WebGLSampler] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`WebGLSampler]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`WebGLSampler]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `WebGLSampler ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module[@js.scope "WebGLQuery"] WebGLQuery : sig
  type t = [`WebGLQuery] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`WebGLQuery]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`WebGLQuery]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `WebGLQuery ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** The WebGLProgram is part of the WebGL API and is a combination of two compiled WebGLShaders consisting of a vertex shader and a fragment shader (both written in GLSL). *)
module[@js.scope "WebGLProgram"] WebGLProgram : sig
  type t = [`WebGLProgram] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`WebGLProgram]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`WebGLProgram]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `WebGLProgram ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Part of the WebGL API and represents an opaque buffer object storing data such as vertices or colors. *)
module[@js.scope "WebGLBuffer"] WebGLBuffer : sig
  type t = [`WebGLBuffer] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`WebGLBuffer]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`WebGLBuffer]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `WebGLBuffer ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Part of the WebGL API and represents the information returned by calling the WebGLRenderingContext.getActiveAttrib() and WebGLRenderingContext.getActiveUniform() methods. *)
module[@js.scope "WebGLActiveInfo"] WebGLActiveInfo : sig
  type t = [`WebGLActiveInfo] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`WebGLActiveInfo]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`WebGLActiveInfo]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `WebGLActiveInfo ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_name: 'tags this -> string [@@js.get "name"]
  val get_size: 'tags this -> GLint.t [@@js.get "size"]
  val get_type: 'tags this -> GLenum.t [@@js.get "type"]
  val create: name:string -> size:GLint.t -> type_:(GLenum.t[@js "type"]) -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end
module GLuint : sig
  type t = float
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module Uint32List : sig
  type t = (GLuint.t list, Uint32Array.t_0) union2
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end

(** Returned by the HTMLVideoElement.getVideoPlaybackQuality() method and contains metrics that can be used to determine the playback quality of a video. *)
module[@js.scope "VideoPlaybackQuality"] VideoPlaybackQuality : sig
  type t = [`VideoPlaybackQuality] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`VideoPlaybackQuality]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`VideoPlaybackQuality]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `VideoPlaybackQuality ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** @deprecated  *)
  val get_corruptedVideoFrames: 'tags this -> float [@@js.get "corruptedVideoFrames"]
  val get_creationTime: 'tags this -> DOMHighResTimeStamp.t [@@js.get "creationTime"]
  val get_droppedVideoFrames: 'tags this -> float [@@js.get "droppedVideoFrames"]
  val get_totalVideoFrames: 'tags this -> float [@@js.get "totalVideoFrames"]
  val create: corruptedVideoFrames:float -> creationTime:DOMHighResTimeStamp.t -> droppedVideoFrames:float -> totalVideoFrames:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end
module[@js.scope "PictureInPictureWindow"] PictureInPictureWindow : sig
  type t = [`EventTarget | `PictureInPictureWindow] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventTarget | `PictureInPictureWindow]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventTarget | `PictureInPictureWindow]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PictureInPictureWindow ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_height: 'tags this -> float [@@js.get "height"]
  val get_onresize: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onresize"]
  val set_onresize: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onresize"]
  val get_width: 'tags this -> float [@@js.get "width"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'PictureInPictureWindowEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'PictureInPictureWindowEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module TextTrackMode : sig
  type t = ([`L_s264_disabled[@js "disabled"] | `L_s393_hidden[@js "hidden"] | `L_s721_showing[@js "showing"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module TextTrackKind : sig
  type t = ([`L_s183_captions[@js "captions"] | `L_s188_chapters[@js "chapters"] | `L_s248_descriptions[@js "descriptions"] | `L_s512_metadata[@js "metadata"] | `L_s768_subtitles[@js "subtitles"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end

(** This interface also inherits properties from EventTarget. *)
module[@js.scope "TextTrack"] rec TextTrack : sig
  type t = [`EventTarget | `TextTrack] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventTarget | `TextTrack]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventTarget | `TextTrack]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `TextTrack ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Returns the text track cues from the text track list of cues that are currently active (i.e. that start before the current playback position and end after it), as a TextTrackCueList object. *)
  val get_activeCues: 'tags this -> TextTrackCueList.t option [@@js.get "activeCues"]
  
  (** Returns the text track list of cues, as a TextTrackCueList object. *)
  val get_cues: 'tags this -> TextTrackCueList.t option [@@js.get "cues"]
  
  (**
    Returns the ID of the given track.
    
    For in-band tracks, this is the ID that can be used with a fragment if the format supports media fragment syntax, and that can be used with the getTrackById() method.
    
    For TextTrack objects corresponding to track elements, this is the ID of the track element.
  *)
  val get_id: 'tags this -> string [@@js.get "id"]
  
  (** Returns the text track in-band metadata track dispatch type string. *)
  val get_inBandMetadataTrackDispatchType: 'tags this -> string [@@js.get "inBandMetadataTrackDispatchType"]
  
  (** Returns the text track kind string. *)
  val get_kind: 'tags this -> TextTrackKind.t [@@js.get "kind"]
  
  (** Returns the text track label, if there is one, or the empty string otherwise (indicating that a custom label probably needs to be generated from the other attributes of the object if the object is exposed to the user). *)
  val get_label: 'tags this -> string [@@js.get "label"]
  
  (** Returns the text track language string. *)
  val get_language: 'tags this -> string [@@js.get "language"]
  
  (**
    Returns the text track mode, represented by a string from the following list:
    
    Can be set, to change the mode.
  *)
  val get_mode: 'tags this -> TextTrackMode.t [@@js.get "mode"]
  
  (**
    Returns the text track mode, represented by a string from the following list:
    
    Can be set, to change the mode.
  *)
  val set_mode: 'tags this -> TextTrackMode.t -> unit [@@js.set "mode"]
  val get_oncuechange: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "oncuechange"]
  val set_oncuechange: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "oncuechange"]
  
  (** Adds the given cue to textTrack's text track list of cues. *)
  val addCue: 'tags this -> cue:TextTrackCue.t -> unit [@@js.call "addCue"]
  
  (** Removes the given cue from textTrack's text track list of cues. *)
  val removeCue: 'tags this -> cue:TextTrackCue.t -> unit [@@js.call "removeCue"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'TextTrackEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'TextTrackEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** TextTrackCues represent a string of text that will be displayed for some duration of time on a TextTrack. This includes the start and end times that the cue will be displayed. A TextTrackCue cannot be used directly, instead one of the derived types (e.g. VTTCue) must be used. *)
and[@js.scope "TextTrackCue"] TextTrackCue : sig
  type t = [`EventTarget | `TextTrackCue] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventTarget | `TextTrackCue]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventTarget | `TextTrackCue]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `TextTrackCue ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    Returns the text track cue end time, in seconds.
    
    Can be set.
  *)
  val get_endTime: 'tags this -> float [@@js.get "endTime"]
  
  (**
    Returns the text track cue end time, in seconds.
    
    Can be set.
  *)
  val set_endTime: 'tags this -> float -> unit [@@js.set "endTime"]
  
  (**
    Returns the text track cue identifier.
    
    Can be set.
  *)
  val get_id: 'tags this -> string [@@js.get "id"]
  
  (**
    Returns the text track cue identifier.
    
    Can be set.
  *)
  val set_id: 'tags this -> string -> unit [@@js.set "id"]
  val get_onenter: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onenter"]
  val set_onenter: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onenter"]
  val get_onexit: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onexit"]
  val set_onexit: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onexit"]
  
  (**
    Returns true if the text track cue pause-on-exit flag is set, false otherwise.
    
    Can be set.
  *)
  val get_pauseOnExit: 'tags this -> bool [@@js.get "pauseOnExit"]
  
  (**
    Returns true if the text track cue pause-on-exit flag is set, false otherwise.
    
    Can be set.
  *)
  val set_pauseOnExit: 'tags this -> bool -> unit [@@js.set "pauseOnExit"]
  
  (**
    Returns the text track cue start time, in seconds.
    
    Can be set.
  *)
  val get_startTime: 'tags this -> float [@@js.get "startTime"]
  
  (**
    Returns the text track cue start time, in seconds.
    
    Can be set.
  *)
  val set_startTime: 'tags this -> float -> unit [@@js.set "startTime"]
  
  (** Returns the TextTrack object to which this text track cue belongs, if any, or null otherwise. *)
  val get_track: 'tags this -> TextTrack.t option [@@js.get "track"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'TextTrackCueEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'TextTrackCueEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
and[@js.scope "TextTrackCueList"] TextTrackCueList : sig
  type t = [`TextTrackCueList | TextTrackCue.t ArrayLike.tags_1 | TextTrackCue.t IterableIterator.tags_1] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`TextTrackCueList | TextTrackCue.t ArrayLike.tags_1 | TextTrackCue.t IterableIterator.tags_1]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`TextTrackCueList | TextTrackCue.t ArrayLike.tags_1 | TextTrackCue.t IterableIterator.tags_1]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `TextTrackCueList ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  (* [Symbol.iterator]: unit -> TextTrackCue.t IterableIterator.t_1 *)
  
  (** Returns the number of cues in the list. *)
  val get_length: 'tags this -> float [@@js.get "length"]
  
  (**
    Returns the first text track cue (in text track cue order) with text track cue identifier id.
    
    Returns null if none of the cues have the given identifier or if the argument is the empty string.
  *)
  val getCueById: 'tags this -> id:string -> TextTrackCue.t option [@@js.call "getCueById"]
  val get: 'tags this -> float -> TextTrackCue.t [@@js.index_get]
  val set: 'tags this -> float -> TextTrackCue.t -> unit [@@js.index_set]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module TrackEventInit : sig
  type t = [`EventInit | `TrackEventInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventInit | `TrackEventInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventInit | `TrackEventInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `TrackEventInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_track: 'tags this -> TextTrack.t option option [@@js.get "track"]
  val set_track: 'tags this -> TextTrack.t option -> unit [@@js.set "track"]
  val create: ?track:TextTrack.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** The TrackEvent interface, part of the HTML DOM specification, is used for events which represent changes to the set of available tracks on an HTML media element; these events are addtrack and removetrack. *)
module[@js.scope "TrackEvent"] TrackEvent : sig
  type t = [`Event | `TrackEvent] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Event | `TrackEvent]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Event | `TrackEvent]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `TrackEvent ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Returns the track object (TextTrack, AudioTrack, or VideoTrack) to which the event relates. *)
  val get_track: 'tags this -> TextTrack.t option [@@js.get "track"]
  val create: ?track:TextTrack.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': type_:string -> ?eventInitDict:TrackEventInit.t -> unit -> t [@@js.create]
end
module[@js.scope "TextTrackList"] TextTrackList : sig
  type t = [`EventTarget | `TextTrackList | TextTrack.t ArrayLike.tags_1 | TextTrack.t IterableIterator.tags_1] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventTarget | `TextTrackList | TextTrack.t ArrayLike.tags_1 | TextTrack.t IterableIterator.tags_1]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventTarget | `TextTrackList | TextTrack.t ArrayLike.tags_1 | TextTrack.t IterableIterator.tags_1]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `TextTrackList ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  (* [Symbol.iterator]: unit -> TextTrack.t IterableIterator.t_1 *)
  val get_length: 'tags this -> float [@@js.get "length"]
  val get_onaddtrack: 'tags this -> (this:t -> ev:TrackEvent.t -> any) option [@@js.get "onaddtrack"]
  val set_onaddtrack: 'tags this -> (this:t -> ev:TrackEvent.t -> any) option -> unit [@@js.set "onaddtrack"]
  val get_onchange: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onchange"]
  val set_onchange: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onchange"]
  val get_onremovetrack: 'tags this -> (this:t -> ev:TrackEvent.t -> any) option [@@js.get "onremovetrack"]
  val set_onremovetrack: 'tags this -> (this:t -> ev:TrackEvent.t -> any) option -> unit [@@js.set "onremovetrack"]
  val getTrackById: 'tags this -> id:string -> TextTrack.t option [@@js.call "getTrackById"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'TextTrackListEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'TextTrackListEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val get: 'tags this -> float -> TextTrack.t [@@js.index_get]
  val set: 'tags this -> float -> TextTrack.t -> unit [@@js.index_set]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module RemotePlaybackState : sig
  type t = ([`L_s216_connected[@js "connected"] | `L_s217_connecting[@js "connecting"] | `L_s266_disconnected[@js "disconnected"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module RemotePlaybackAvailabilityCallback : sig
  type t = [`RemotePlaybackAvailabilityCallback] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`RemotePlaybackAvailabilityCallback]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`RemotePlaybackAvailabilityCallback]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RemotePlaybackAvailabilityCallback ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val apply: 'tags this -> available:bool -> unit [@@js.apply]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module[@js.scope "RemotePlayback"] RemotePlayback : sig
  type t = [`EventTarget | `RemotePlayback] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventTarget | `RemotePlayback]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventTarget | `RemotePlayback]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RemotePlayback ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_onconnect: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onconnect"]
  val set_onconnect: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onconnect"]
  val get_onconnecting: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onconnecting"]
  val set_onconnecting: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onconnecting"]
  val get_ondisconnect: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "ondisconnect"]
  val set_ondisconnect: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "ondisconnect"]
  val get_state: 'tags this -> RemotePlaybackState.t [@@js.get "state"]
  val cancelWatchAvailability: 'tags this -> ?id:float -> unit -> unit Promise.t_1 [@@js.call "cancelWatchAvailability"]
  val prompt: 'tags this -> unit Promise.t_1 [@@js.call "prompt"]
  val watchAvailability: 'tags this -> callback:RemotePlaybackAvailabilityCallback.t -> float Promise.t_1 [@@js.call "watchAvailability"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'RemotePlaybackEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'RemotePlaybackEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module MediaProvider : sig
  type t = (Blob.t, MediaSource.t, MediaStream.t) union3
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end

(** An error which occurred while handling media in an HTML media element based on HTMLMediaElement, such as <audio> or <video>. *)
module[@js.scope "MediaError"] MediaError : sig
  type t = [`MediaError] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`MediaError]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`MediaError]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MediaError ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_code: 'tags this -> float [@@js.get "code"]
  val get_message: 'tags this -> string [@@js.get "message"]
  val get_MEDIA_ERR_ABORTED: 'tags this -> float [@@js.get "MEDIA_ERR_ABORTED"]
  val get_MEDIA_ERR_DECODE: 'tags this -> float [@@js.get "MEDIA_ERR_DECODE"]
  val get_MEDIA_ERR_NETWORK: 'tags this -> float [@@js.get "MEDIA_ERR_NETWORK"]
  val get_MEDIA_ERR_SRC_NOT_SUPPORTED: 'tags this -> float [@@js.get "MEDIA_ERR_SRC_NOT_SUPPORTED"]
  val create: code:float -> message:string -> media_err_aborted:(float[@js "MEDIA_ERR_ABORTED"]) -> media_err_decode:(float[@js "MEDIA_ERR_DECODE"]) -> media_err_network:(float[@js "MEDIA_ERR_NETWORK"]) -> media_err_src_not_supported:(float[@js "MEDIA_ERR_SRC_NOT_SUPPORTED"]) -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
  val media_err_aborted: unit -> float [@@js.get "MEDIA_ERR_ABORTED"]
  val media_err_decode: unit -> float [@@js.get "MEDIA_ERR_DECODE"]
  val media_err_network: unit -> float [@@js.get "MEDIA_ERR_NETWORK"]
  val media_err_src_not_supported: unit -> float [@@js.get "MEDIA_ERR_SRC_NOT_SUPPORTED"]
end
module MediaEncryptedEventInit : sig
  type t = [`EventInit | `MediaEncryptedEventInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventInit | `MediaEncryptedEventInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventInit | `MediaEncryptedEventInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MediaEncryptedEventInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_initData: 'tags this -> ArrayBuffer.t_0 option option [@@js.get "initData"]
  val set_initData: 'tags this -> ArrayBuffer.t_0 option -> unit [@@js.set "initData"]
  val get_initDataType: 'tags this -> string option [@@js.get "initDataType"]
  val set_initDataType: 'tags this -> string -> unit [@@js.set "initDataType"]
  val create: ?initData:ArrayBuffer.t_0 -> ?initDataType:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module[@js.scope "MediaEncryptedEvent"] MediaEncryptedEvent : sig
  type t = [`Event | `MediaEncryptedEvent] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Event | `MediaEncryptedEvent]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Event | `MediaEncryptedEvent]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MediaEncryptedEvent ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_initData: 'tags this -> ArrayBuffer.t_0 option [@@js.get "initData"]
  val get_initDataType: 'tags this -> string [@@js.get "initDataType"]
  val create: ?initData:ArrayBuffer.t_0 -> initDataType:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': type_:string -> ?eventInitDict:MediaEncryptedEventInit.t -> unit -> t [@@js.create]
end
module CanPlayTypeResult : sig
  type t = ([`L_s0[@js ""] | `L_s504_maybe[@js "maybe"] | `L_s637_probably[@js "probably"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module Int32List : sig
  type t = (GLint.t list, Int32Array.t_0) union2
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module GLuint64 : sig
  type t = float
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module GLsizeiptr : sig
  type t = float
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module GLbitfield : sig
  type t = float
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module GLfloat : sig
  type t = float
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module Float32List : sig
  type t = (GLfloat.t list, Float32Array.t_0) union2
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module GLint64 : sig
  type t = float
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module ImageBitmapRenderingContextSettings : sig
  type t = [`ImageBitmapRenderingContextSettings] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ImageBitmapRenderingContextSettings]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ImageBitmapRenderingContextSettings]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ImageBitmapRenderingContextSettings ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_alpha: 'tags this -> bool option [@@js.get "alpha"]
  val set_alpha: 'tags this -> bool -> unit [@@js.set "alpha"]
  val create: ?alpha:bool -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module CanvasTransform : sig
  type t = [`CanvasTransform] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`CanvasTransform]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`CanvasTransform]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `CanvasTransform ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val getTransform: 'tags this -> DOMMatrix.t [@@js.call "getTransform"]
  val resetTransform: 'tags this -> unit [@@js.call "resetTransform"]
  val rotate: 'tags this -> angle:float -> unit [@@js.call "rotate"]
  val scale: 'tags this -> x:float -> y:float -> unit [@@js.call "scale"]
  val setTransform: 'tags this -> a:float -> b:float -> c:float -> d:float -> e:float -> f:float -> unit [@@js.call "setTransform"]
  val setTransform': 'tags this -> ?transform:DOMMatrix2DInit.t -> unit -> unit [@@js.call "setTransform"]
  val transform: 'tags this -> a:float -> b:float -> c:float -> d:float -> e:float -> f:float -> unit [@@js.call "transform"]
  val translate: 'tags this -> x:float -> y:float -> unit [@@js.call "translate"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module CanvasTextBaseline : sig
  type t = ([`L_s110_alphabetic[@js "alphabetic"] | `L_s169_bottom[@js "bottom"] | `L_s381_hanging[@js "hanging"] | `L_s413_ideographic[@js "ideographic"] | `L_s514_middle[@js "middle"] | `L_s805_top[@js "top"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module CanvasTextAlign : sig
  type t = ([`L_s185_center[@js "center"] | `L_s290_end[@js "end"] | `L_s456_left[@js "left"] | `L_s680_right[@js "right"] | `L_s754_start[@js "start"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module CanvasDirection : sig
  type t = ([`L_s426_inherit[@js "inherit"] | `L_s489_ltr[@js "ltr"] | `L_s687_rtl[@js "rtl"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module CanvasTextDrawingStyles : sig
  type t = [`CanvasTextDrawingStyles] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`CanvasTextDrawingStyles]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`CanvasTextDrawingStyles]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `CanvasTextDrawingStyles ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_direction: 'tags this -> CanvasDirection.t [@@js.get "direction"]
  val set_direction: 'tags this -> CanvasDirection.t -> unit [@@js.set "direction"]
  val get_font: 'tags this -> string [@@js.get "font"]
  val set_font: 'tags this -> string -> unit [@@js.set "font"]
  val get_textAlign: 'tags this -> CanvasTextAlign.t [@@js.get "textAlign"]
  val set_textAlign: 'tags this -> CanvasTextAlign.t -> unit [@@js.set "textAlign"]
  val get_textBaseline: 'tags this -> CanvasTextBaseline.t [@@js.get "textBaseline"]
  val set_textBaseline: 'tags this -> CanvasTextBaseline.t -> unit [@@js.set "textBaseline"]
  val create: direction:CanvasDirection.t -> font:string -> textAlign:CanvasTextAlign.t -> textBaseline:CanvasTextBaseline.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** The dimensions of a piece of text in the canvas, as created by the CanvasRenderingContext2D.measureText() method. *)
module[@js.scope "TextMetrics"] TextMetrics : sig
  type t = [`TextMetrics] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`TextMetrics]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`TextMetrics]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `TextMetrics ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Returns the measurement described below. *)
  val get_actualBoundingBoxAscent: 'tags this -> float [@@js.get "actualBoundingBoxAscent"]
  
  (** Returns the measurement described below. *)
  val get_actualBoundingBoxDescent: 'tags this -> float [@@js.get "actualBoundingBoxDescent"]
  
  (** Returns the measurement described below. *)
  val get_actualBoundingBoxLeft: 'tags this -> float [@@js.get "actualBoundingBoxLeft"]
  
  (** Returns the measurement described below. *)
  val get_actualBoundingBoxRight: 'tags this -> float [@@js.get "actualBoundingBoxRight"]
  
  (** Returns the measurement described below. *)
  val get_fontBoundingBoxAscent: 'tags this -> float [@@js.get "fontBoundingBoxAscent"]
  
  (** Returns the measurement described below. *)
  val get_fontBoundingBoxDescent: 'tags this -> float [@@js.get "fontBoundingBoxDescent"]
  
  (** Returns the measurement described below. *)
  val get_width: 'tags this -> float [@@js.get "width"]
  val create: actualBoundingBoxAscent:float -> actualBoundingBoxDescent:float -> actualBoundingBoxLeft:float -> actualBoundingBoxRight:float -> fontBoundingBoxAscent:float -> fontBoundingBoxDescent:float -> width:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end
module CanvasText : sig
  type t = [`CanvasText] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`CanvasText]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`CanvasText]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `CanvasText ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val fillText: 'tags this -> text:string -> x:float -> y:float -> ?maxWidth:float -> unit -> unit [@@js.call "fillText"]
  val measureText: 'tags this -> text:string -> TextMetrics.t [@@js.call "measureText"]
  val strokeText: 'tags this -> text:string -> x:float -> y:float -> ?maxWidth:float -> unit -> unit [@@js.call "strokeText"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module CanvasState : sig
  type t = [`CanvasState] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`CanvasState]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`CanvasState]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `CanvasState ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val restore: 'tags this -> unit [@@js.call "restore"]
  val save: 'tags this -> unit [@@js.call "save"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module CanvasShadowStyles : sig
  type t = [`CanvasShadowStyles] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`CanvasShadowStyles]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`CanvasShadowStyles]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `CanvasShadowStyles ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_shadowBlur: 'tags this -> float [@@js.get "shadowBlur"]
  val set_shadowBlur: 'tags this -> float -> unit [@@js.set "shadowBlur"]
  val get_shadowColor: 'tags this -> string [@@js.get "shadowColor"]
  val set_shadowColor: 'tags this -> string -> unit [@@js.set "shadowColor"]
  val get_shadowOffsetX: 'tags this -> float [@@js.get "shadowOffsetX"]
  val set_shadowOffsetX: 'tags this -> float -> unit [@@js.set "shadowOffsetX"]
  val get_shadowOffsetY: 'tags this -> float [@@js.get "shadowOffsetY"]
  val set_shadowOffsetY: 'tags this -> float -> unit [@@js.set "shadowOffsetY"]
  val create: shadowBlur:float -> shadowColor:string -> shadowOffsetX:float -> shadowOffsetY:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module PredefinedColorSpace : sig
  type t = ([`L_s269_display_p3[@js "display-p3"] | `L_s750_srgb[@js "srgb"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module CanvasRenderingContext2DSettings : sig
  type t = [`CanvasRenderingContext2DSettings] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`CanvasRenderingContext2DSettings]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`CanvasRenderingContext2DSettings]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `CanvasRenderingContext2DSettings ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_alpha: 'tags this -> bool option [@@js.get "alpha"]
  val set_alpha: 'tags this -> bool -> unit [@@js.set "alpha"]
  val get_colorSpace: 'tags this -> PredefinedColorSpace.t option [@@js.get "colorSpace"]
  val set_colorSpace: 'tags this -> PredefinedColorSpace.t -> unit [@@js.set "colorSpace"]
  val get_desynchronized: 'tags this -> bool option [@@js.get "desynchronized"]
  val set_desynchronized: 'tags this -> bool -> unit [@@js.set "desynchronized"]
  val get_willReadFrequently: 'tags this -> bool option [@@js.get "willReadFrequently"]
  val set_willReadFrequently: 'tags this -> bool -> unit [@@js.set "willReadFrequently"]
  val create: ?alpha:bool -> ?colorSpace:PredefinedColorSpace.t -> ?desynchronized:bool -> ?willReadFrequently:bool -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module CanvasRect : sig
  type t = [`CanvasRect] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`CanvasRect]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`CanvasRect]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `CanvasRect ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val clearRect: 'tags this -> x:float -> y:float -> w:float -> h:float -> unit [@@js.call "clearRect"]
  val fillRect: 'tags this -> x:float -> y:float -> w:float -> h:float -> unit [@@js.call "fillRect"]
  val strokeRect: 'tags this -> x:float -> y:float -> w:float -> h:float -> unit [@@js.call "strokeRect"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module CanvasLineJoin : sig
  type t = ([`L_s158_bevel[@js "bevel"] | `L_s515_miter[@js "miter"] | `L_s683_round[@js "round"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module CanvasLineCap : sig
  type t = ([`L_s174_butt[@js "butt"] | `L_s683_round[@js "round"] | `L_s748_square[@js "square"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module CanvasPathDrawingStyles : sig
  type t = [`CanvasPathDrawingStyles] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`CanvasPathDrawingStyles]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`CanvasPathDrawingStyles]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `CanvasPathDrawingStyles ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val setLineDash: 'tags this -> segments:float Iterable.t_1 -> unit [@@js.call "setLineDash"]
  val get_lineCap: 'tags this -> CanvasLineCap.t [@@js.get "lineCap"]
  val set_lineCap: 'tags this -> CanvasLineCap.t -> unit [@@js.set "lineCap"]
  val get_lineDashOffset: 'tags this -> float [@@js.get "lineDashOffset"]
  val set_lineDashOffset: 'tags this -> float -> unit [@@js.set "lineDashOffset"]
  val get_lineJoin: 'tags this -> CanvasLineJoin.t [@@js.get "lineJoin"]
  val set_lineJoin: 'tags this -> CanvasLineJoin.t -> unit [@@js.set "lineJoin"]
  val get_lineWidth: 'tags this -> float [@@js.get "lineWidth"]
  val set_lineWidth: 'tags this -> float -> unit [@@js.set "lineWidth"]
  val get_miterLimit: 'tags this -> float [@@js.get "miterLimit"]
  val set_miterLimit: 'tags this -> float -> unit [@@js.set "miterLimit"]
  val getLineDash: 'tags this -> float list [@@js.call "getLineDash"]
  val setLineDash': 'tags this -> segments:float list -> unit [@@js.call "setLineDash"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module ImageSmoothingQuality : sig
  type t = ([`L_s395_high[@js "high"] | `L_s484_low[@js "low"] | `L_s506_medium[@js "medium"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module CanvasImageSmoothing : sig
  type t = [`CanvasImageSmoothing] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`CanvasImageSmoothing]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`CanvasImageSmoothing]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `CanvasImageSmoothing ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_imageSmoothingEnabled: 'tags this -> bool [@@js.get "imageSmoothingEnabled"]
  val set_imageSmoothingEnabled: 'tags this -> bool -> unit [@@js.set "imageSmoothingEnabled"]
  val get_imageSmoothingQuality: 'tags this -> ImageSmoothingQuality.t [@@js.get "imageSmoothingQuality"]
  val set_imageSmoothingQuality: 'tags this -> ImageSmoothingQuality.t -> unit [@@js.set "imageSmoothingQuality"]
  val create: imageSmoothingEnabled:bool -> imageSmoothingQuality:ImageSmoothingQuality.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module ImageDataSettings : sig
  type t = [`ImageDataSettings] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ImageDataSettings]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ImageDataSettings]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ImageDataSettings ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_colorSpace: 'tags this -> PredefinedColorSpace.t option [@@js.get "colorSpace"]
  val set_colorSpace: 'tags this -> PredefinedColorSpace.t -> unit [@@js.set "colorSpace"]
  val create: ?colorSpace:PredefinedColorSpace.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** The underlying pixel data of an area of a <canvas> element. It is created using the ImageData() constructor or creator methods on the CanvasRenderingContext2D object associated with a canvas: createImageData() and getImageData(). It can also be used to set a part of the canvas by using putImageData(). *)
module[@js.scope "ImageData"] ImageData : sig
  type t = [`ImageData] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ImageData]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ImageData]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ImageData ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Returns the one-dimensional array containing the data in RGBA order, as integers in the range 0 to 255. *)
  val get_data: 'tags this -> Uint8ClampedArray.t_0 [@@js.get "data"]
  
  (** Returns the actual dimensions of the data in the ImageData object, in pixels. *)
  val get_height: 'tags this -> float [@@js.get "height"]
  
  (** Returns the actual dimensions of the data in the ImageData object, in pixels. *)
  val get_width: 'tags this -> float [@@js.get "width"]
  val create: data:Uint8ClampedArray.t_0 -> height:float -> width:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': sw:float -> sh:float -> ?settings:ImageDataSettings.t -> unit -> t [@@js.create]
  val create'': data:Uint8ClampedArray.t_0 -> sw:float -> ?sh:float -> ?settings:ImageDataSettings.t -> unit -> t [@@js.create]
end
module CanvasImageData : sig
  type t = [`CanvasImageData] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`CanvasImageData]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`CanvasImageData]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `CanvasImageData ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val createImageData: 'tags this -> sw:float -> sh:float -> ?settings:ImageDataSettings.t -> unit -> ImageData.t [@@js.call "createImageData"]
  val createImageData': 'tags this -> imagedata:ImageData.t -> ImageData.t [@@js.call "createImageData"]
  val getImageData: 'tags this -> sx:float -> sy:float -> sw:float -> sh:float -> ?settings:ImageDataSettings.t -> unit -> ImageData.t [@@js.call "getImageData"]
  val putImageData: 'tags this -> imagedata:ImageData.t -> dx:float -> dy:float -> unit [@@js.call "putImageData"]
  val putImageData': 'tags this -> imagedata:ImageData.t -> dx:float -> dy:float -> dirtyX:float -> dirtyY:float -> dirtyWidth:float -> dirtyHeight:float -> unit [@@js.call "putImageData"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module CanvasFilters : sig
  type t = [`CanvasFilters] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`CanvasFilters]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`CanvasFilters]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `CanvasFilters ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_filter: 'tags this -> string [@@js.get "filter"]
  val set_filter: 'tags this -> string -> unit [@@js.set "filter"]
  val create: filter:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** An opaque object describing a pattern, based on an image, a canvas, or a video, created by the CanvasRenderingContext2D.createPattern() method. *)
module[@js.scope "CanvasPattern"] CanvasPattern : sig
  type t = [`CanvasPattern] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`CanvasPattern]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`CanvasPattern]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `CanvasPattern ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Sets the transformation matrix that will be used when rendering the pattern during a fill or stroke painting operation. *)
  val setTransform: 'tags this -> ?transform:DOMMatrix2DInit.t -> unit -> unit [@@js.call "setTransform"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** An opaque object describing a gradient. It is returned by the methods CanvasRenderingContext2D.createLinearGradient() or CanvasRenderingContext2D.createRadialGradient(). *)
module[@js.scope "CanvasGradient"] CanvasGradient : sig
  type t = [`CanvasGradient] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`CanvasGradient]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`CanvasGradient]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `CanvasGradient ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    Adds a color stop with the given color to the gradient at the given offset. 0.0 is the offset at one end of the gradient, 1.0 is the offset at the other end.
    
    Throws an "IndexSizeError" DOMException if the offset is out of range. Throws a "SyntaxError" DOMException if the color cannot be parsed.
  *)
  val addColorStop: 'tags this -> offset:float -> color:string -> unit [@@js.call "addColorStop"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module CanvasPath : sig
  type t = [`CanvasPath] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`CanvasPath]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`CanvasPath]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `CanvasPath ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val arc: 'tags this -> x:float -> y:float -> radius:float -> startAngle:float -> endAngle:float -> ?counterclockwise:bool -> unit -> unit [@@js.call "arc"]
  val arcTo: 'tags this -> x1:float -> y1:float -> x2:float -> y2:float -> radius:float -> unit [@@js.call "arcTo"]
  val bezierCurveTo: 'tags this -> cp1x:float -> cp1y:float -> cp2x:float -> cp2y:float -> x:float -> y:float -> unit [@@js.call "bezierCurveTo"]
  val closePath: 'tags this -> unit [@@js.call "closePath"]
  val ellipse: 'tags this -> x:float -> y:float -> radiusX:float -> radiusY:float -> rotation:float -> startAngle:float -> endAngle:float -> ?counterclockwise:bool -> unit -> unit [@@js.call "ellipse"]
  val lineTo: 'tags this -> x:float -> y:float -> unit [@@js.call "lineTo"]
  val moveTo: 'tags this -> x:float -> y:float -> unit [@@js.call "moveTo"]
  val quadraticCurveTo: 'tags this -> cpx:float -> cpy:float -> x:float -> y:float -> unit [@@js.call "quadraticCurveTo"]
  val rect: 'tags this -> x:float -> y:float -> w:float -> h:float -> unit [@@js.call "rect"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** This Canvas 2D API interface is used to declare a path that can then be used on a CanvasRenderingContext2D object. The path methods of the CanvasRenderingContext2D interface are also present on this interface, which gives you the convenience of being able to retain and replay your path whenever desired. *)
module[@js.scope "Path2D"] Path2D : sig
  type t = [`CanvasPath | `Path2D] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`CanvasPath | `Path2D]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`CanvasPath | `Path2D]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `Path2D ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Adds to the path the path given by the argument. *)
  val addPath: 'tags this -> path:t -> ?transform:DOMMatrix2DInit.t -> unit -> unit [@@js.call "addPath"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: ?path:([`U1 of t | `U2 of string] [@js.union]) -> unit -> t [@@js.create]
end
module CanvasFillRule : sig
  type t = ([`L_s300_evenodd[@js "evenodd"] | `L_s549_nonzero[@js "nonzero"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module CanvasDrawPath : sig
  type t = [`CanvasDrawPath] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`CanvasDrawPath]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`CanvasDrawPath]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `CanvasDrawPath ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val beginPath: 'tags this -> unit [@@js.call "beginPath"]
  val clip: 'tags this -> ?fillRule:CanvasFillRule.t -> unit -> unit [@@js.call "clip"]
  val clip': 'tags this -> path:Path2D.t -> ?fillRule:CanvasFillRule.t -> unit -> unit [@@js.call "clip"]
  val fill: 'tags this -> ?fillRule:CanvasFillRule.t -> unit -> unit [@@js.call "fill"]
  val fill': 'tags this -> path:Path2D.t -> ?fillRule:CanvasFillRule.t -> unit -> unit [@@js.call "fill"]
  val isPointInPath: 'tags this -> x:float -> y:float -> ?fillRule:CanvasFillRule.t -> unit -> bool [@@js.call "isPointInPath"]
  val isPointInPath': 'tags this -> path:Path2D.t -> x:float -> y:float -> ?fillRule:CanvasFillRule.t -> unit -> bool [@@js.call "isPointInPath"]
  val isPointInStroke: 'tags this -> x:float -> y:float -> bool [@@js.call "isPointInStroke"]
  val isPointInStroke': 'tags this -> path:Path2D.t -> x:float -> y:float -> bool [@@js.call "isPointInStroke"]
  val stroke: 'tags this -> unit [@@js.call "stroke"]
  val stroke': 'tags this -> path:Path2D.t -> unit [@@js.call "stroke"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module GlobalCompositeOperation : sig
  type t = ([`L_s206_color[@js "color"] | `L_s207_color_burn[@js "color-burn"] | `L_s208_color_dodge[@js "color-dodge"] | `L_s222_copy[@js "copy"] | `L_s231_darken[@js "darken"] | `L_s249_destination_atop[@js "destination-atop"] | `L_s250_destination_in[@js "destination-in"] | `L_s251_destination_out[@js "destination-out"] | `L_s252_destination_over[@js "destination-over"] | `L_s260_difference[@js "difference"] | `L_s301_exclusion[@js "exclusion"] | `L_s383_hard_light[@js "hard-light"] | `L_s405_hue[@js "hue"] | `L_s462_lighten[@js "lighten"] | `L_s463_lighter[@js "lighter"] | `L_s490_luminosity[@js "luminosity"] | `L_s528_multiply[@js "multiply"] | `L_s578_overlay[@js "overlay"] | `L_s694_saturation[@js "saturation"] | `L_s696_screen[@js "screen"] | `L_s736_soft_light[@js "soft-light"] | `L_s738_source_atop[@js "source-atop"] | `L_s739_source_in[@js "source-in"] | `L_s740_source_out[@js "source-out"] | `L_s741_source_over[@js "source-over"] | `L_s876_xor[@js "xor"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module CanvasCompositing : sig
  type t = [`CanvasCompositing] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`CanvasCompositing]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`CanvasCompositing]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `CanvasCompositing ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_globalAlpha: 'tags this -> float [@@js.get "globalAlpha"]
  val set_globalAlpha: 'tags this -> float -> unit [@@js.set "globalAlpha"]
  val get_globalCompositeOperation: 'tags this -> GlobalCompositeOperation.t [@@js.get "globalCompositeOperation"]
  val set_globalCompositeOperation: 'tags this -> GlobalCompositeOperation.t -> unit [@@js.set "globalCompositeOperation"]
  val create: globalAlpha:float -> globalCompositeOperation:GlobalCompositeOperation.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module BlobCallback : sig
  type t = [`BlobCallback] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`BlobCallback]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`BlobCallback]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `BlobCallback ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val apply: 'tags this -> blob:Blob.t option -> unit [@@js.apply]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module ResizeQuality : sig
  type t = ([`L_s395_high[@js "high"] | `L_s484_low[@js "low"] | `L_s506_medium[@js "medium"] | `L_s603_pixelated[@js "pixelated"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module PremultiplyAlpha : sig
  type t = ([`L_s241_default[@js "default"] | `L_s548_none[@js "none"] | `L_s629_premultiply[@js "premultiply"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module ImageOrientation : sig
  type t = ([`L_s347_flipY[@js "flipY"] | `L_s548_none[@js "none"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module ColorSpaceConversion : sig
  type t = ([`L_s241_default[@js "default"] | `L_s548_none[@js "none"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module ImageBitmapOptions : sig
  type t = [`ImageBitmapOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ImageBitmapOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ImageBitmapOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ImageBitmapOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_colorSpaceConversion: 'tags this -> ColorSpaceConversion.t option [@@js.get "colorSpaceConversion"]
  val set_colorSpaceConversion: 'tags this -> ColorSpaceConversion.t -> unit [@@js.set "colorSpaceConversion"]
  val get_imageOrientation: 'tags this -> ImageOrientation.t option [@@js.get "imageOrientation"]
  val set_imageOrientation: 'tags this -> ImageOrientation.t -> unit [@@js.set "imageOrientation"]
  val get_premultiplyAlpha: 'tags this -> PremultiplyAlpha.t option [@@js.get "premultiplyAlpha"]
  val set_premultiplyAlpha: 'tags this -> PremultiplyAlpha.t -> unit [@@js.set "premultiplyAlpha"]
  val get_resizeHeight: 'tags this -> float option [@@js.get "resizeHeight"]
  val set_resizeHeight: 'tags this -> float -> unit [@@js.set "resizeHeight"]
  val get_resizeQuality: 'tags this -> ResizeQuality.t option [@@js.get "resizeQuality"]
  val set_resizeQuality: 'tags this -> ResizeQuality.t -> unit [@@js.set "resizeQuality"]
  val get_resizeWidth: 'tags this -> float option [@@js.get "resizeWidth"]
  val set_resizeWidth: 'tags this -> float -> unit [@@js.set "resizeWidth"]
  val create: ?colorSpaceConversion:ColorSpaceConversion.t -> ?imageOrientation:ImageOrientation.t -> ?premultiplyAlpha:PremultiplyAlpha.t -> ?resizeHeight:float -> ?resizeQuality:ResizeQuality.t -> ?resizeWidth:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module IDBVersionChangeEventInit : sig
  type t = [`EventInit | `IDBVersionChangeEventInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventInit | `IDBVersionChangeEventInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventInit | `IDBVersionChangeEventInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `IDBVersionChangeEventInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_newVersion: 'tags this -> float option option [@@js.get "newVersion"]
  val set_newVersion: 'tags this -> float option -> unit [@@js.set "newVersion"]
  val get_oldVersion: 'tags this -> float option [@@js.get "oldVersion"]
  val set_oldVersion: 'tags this -> float -> unit [@@js.set "oldVersion"]
  val create: ?newVersion:float -> ?oldVersion:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** This IndexedDB API interface indicates that the version of the database has changed, as the result of an IDBOpenDBRequest.onupgradeneeded event handler function. *)
module[@js.scope "IDBVersionChangeEvent"] IDBVersionChangeEvent : sig
  type t = [`Event | `IDBVersionChangeEvent] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Event | `IDBVersionChangeEvent]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Event | `IDBVersionChangeEvent]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `IDBVersionChangeEvent ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_newVersion: 'tags this -> float option [@@js.get "newVersion"]
  val get_oldVersion: 'tags this -> float [@@js.get "oldVersion"]
  val create: ?newVersion:float -> oldVersion:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': type_:string -> ?eventInitDict:IDBVersionChangeEventInit.t -> unit -> t [@@js.create]
end
module IDBObjectStoreParameters : sig
  type t = [`IDBObjectStoreParameters] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`IDBObjectStoreParameters]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`IDBObjectStoreParameters]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `IDBObjectStoreParameters ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_autoIncrement: 'tags this -> bool option [@@js.get "autoIncrement"]
  val set_autoIncrement: 'tags this -> bool -> unit [@@js.set "autoIncrement"]
  val get_keyPath: 'tags this -> ([`String of string | `Null | `Other of string list] [@js.union on_field "dummy"]) Primitive.t option [@@js.get "keyPath"]
  val set_keyPath: 'tags this -> ([`Null | `U1 of string | `U2 of string list] [@js.union]) -> unit [@@js.set "keyPath"]
  val create: ?autoIncrement:bool -> ?keyPath:([`String of string | `Other of string list] [@js.union on_field "dummy"]) Primitive.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module IDBIndexParameters : sig
  type t = [`IDBIndexParameters] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`IDBIndexParameters]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`IDBIndexParameters]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `IDBIndexParameters ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_multiEntry: 'tags this -> bool option [@@js.get "multiEntry"]
  val set_multiEntry: 'tags this -> bool -> unit [@@js.set "multiEntry"]
  val get_unique: 'tags this -> bool option [@@js.get "unique"]
  val set_unique: 'tags this -> bool -> unit [@@js.set "unique"]
  val create: ?multiEntry:bool -> ?unique:bool -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module IDBValidKey : sig
  type t = ([`Number of float | `String of string | `Other of (t list, BufferSource.t, Date.t_0) union3] [@js.union on_field "dummy"]) Primitive.t
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module IDBTransactionMode : sig
  type t = ([`L_s648_readonly[@js "readonly"] | `L_s649_readwrite[@js "readwrite"] | `L_s849_versionchange[@js "versionchange"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module IDBTransactionDurability : sig
  type t = ([`L_s241_default[@js "default"] | `L_s658_relaxed[@js "relaxed"] | `L_s760_strict[@js "strict"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module IDBRequestReadyState : sig
  type t = ([`L_s273_done[@js "done"] | `L_s597_pending[@js "pending"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end

(** A key range can be a single value or a range with upper and lower bounds or endpoints. If the key range has both upper and lower bounds, then it is bounded; if it has no bounds, it is unbounded. A bounded key range can either be open (the endpoints are excluded) or closed (the endpoints are included). To retrieve all keys within a certain range, you can use the following code constructs: *)
module[@js.scope "IDBKeyRange"] IDBKeyRange : sig
  type t = [`IDBKeyRange] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`IDBKeyRange]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`IDBKeyRange]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `IDBKeyRange ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Returns lower bound, or undefined if none. *)
  val get_lower: 'tags this -> any [@@js.get "lower"]
  
  (** Returns true if the lower open flag is set, and false otherwise. *)
  val get_lowerOpen: 'tags this -> bool [@@js.get "lowerOpen"]
  
  (** Returns upper bound, or undefined if none. *)
  val get_upper: 'tags this -> any [@@js.get "upper"]
  
  (** Returns true if the upper open flag is set, and false otherwise. *)
  val get_upperOpen: 'tags this -> bool [@@js.get "upperOpen"]
  
  (** Returns true if key is included in the range, and false otherwise. *)
  val includes: 'tags this -> key:any -> bool [@@js.call "includes"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
  
  (** Returns a new IDBKeyRange spanning from lower to upper. If lowerOpen is true, lower is not included in the range. If upperOpen is true, upper is not included in the range. *)
  val bound: lower:any -> upper:any -> ?lowerOpen:bool -> ?upperOpen:bool -> unit -> t [@@js.global "bound"]
  
  (** Returns a new IDBKeyRange starting at key with no upper bound. If open is true, key is not included in the range. *)
  val lowerBound: lower:any -> ?open_:bool -> unit -> t [@@js.global "lowerBound"]
  
  (** Returns a new IDBKeyRange spanning only key. *)
  val only: any -> t [@@js.global "only"]
  
  (** Returns a new IDBKeyRange with no lower bound and ending at key. If open is true, key is not included in the range. *)
  val upperBound: upper:any -> ?open_:bool -> unit -> t [@@js.global "upperBound"]
end
module IDBCursorDirection : sig
  type t = ([`L_s539_next[@js "next"] | `L_s541_nextunique[@js "nextunique"] | `L_s632_prev[@js "prev"] | `L_s634_prevunique[@js "prevunique"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end

(** A type returned by some APIs which contains a list of DOMString (strings). *)
module[@js.scope "DOMStringList"] DOMStringList : sig
  type t = [`DOMStringList | string ArrayLike.tags_1 | string IterableIterator.tags_1] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`DOMStringList | string ArrayLike.tags_1 | string IterableIterator.tags_1]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`DOMStringList | string ArrayLike.tags_1 | string IterableIterator.tags_1]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `DOMStringList ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  (* [Symbol.iterator]: unit -> string IterableIterator.t_1 *)
  
  (** Returns the number of strings in strings. *)
  val get_length: 'tags this -> float [@@js.get "length"]
  
  (** Returns true if strings contains string, and false otherwise. *)
  val contains: 'tags this -> string:string -> bool [@@js.call "contains"]
  
  (** Returns the string with index index from strings. *)
  val item: 'tags this -> index:float -> string option [@@js.call "item"]
  val get: 'tags this -> float -> string [@@js.index_get]
  val set: 'tags this -> float -> string -> unit [@@js.index_set]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** This IndexedDB API interface represents a cursor for traversing or iterating over multiple records in a database. *)
module[@js.scope "IDBCursor"] rec IDBCursor : sig
  type t = [`IDBCursor] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`IDBCursor]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`IDBCursor]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `IDBCursor ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Returns the direction ("next", "nextunique", "prev" or "prevunique") of the cursor. *)
  val get_direction: 'tags this -> IDBCursorDirection.t [@@js.get "direction"]
  
  (** Returns the key of the cursor. Throws a "InvalidStateError" DOMException if the cursor is advancing or is finished. *)
  val get_key: 'tags this -> IDBValidKey.t [@@js.get "key"]
  
  (** Returns the effective key of the cursor. Throws a "InvalidStateError" DOMException if the cursor is advancing or is finished. *)
  val get_primaryKey: 'tags this -> IDBValidKey.t [@@js.get "primaryKey"]
  val get_request: 'tags this -> IDBRequest.t_0 [@@js.get "request"]
  
  (** Returns the IDBObjectStore or IDBIndex the cursor was opened from. *)
  val get_source: 'tags this -> (IDBIndex.t, IDBObjectStore.t) union2 [@@js.get "source"]
  
  (** Advances the cursor through the next count records in range. *)
  val advance: 'tags this -> count:float -> unit [@@js.call "advance"]
  
  (** Advances the cursor to the next record in range. *)
  val continue: 'tags this -> ?key:IDBValidKey.t -> unit -> unit [@@js.call "continue"]
  
  (** Advances the cursor to the next record in range matching or after key and primaryKey. Throws an "InvalidAccessError" DOMException if the source is not an index. *)
  val continuePrimaryKey: 'tags this -> key:IDBValidKey.t -> primaryKey:IDBValidKey.t -> unit [@@js.call "continuePrimaryKey"]
  
  (**
    Delete the record pointed at by the cursor with a new value.
    
    If successful, request's result will be undefined.
  *)
  val delete: 'tags this -> undefined IDBRequest.t [@@js.call "delete"]
  
  (**
    Updated the record pointed at by the cursor with a new value.
    
    Throws a "DataError" DOMException if the effective object store uses in-line keys and the key would have changed.
    
    If successful, request's result will be the record's key.
  *)
  val update: 'tags this -> value:any -> IDBValidKey.t IDBRequest.t [@@js.call "update"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** This IndexedDB API interface represents a cursor for traversing or iterating over multiple records in a database. It is the same as the IDBCursor, except that it includes the value property. *)
and[@js.scope "IDBCursorWithValue"] IDBCursorWithValue : sig
  type t = [`IDBCursor | `IDBCursorWithValue] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`IDBCursor | `IDBCursorWithValue]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`IDBCursor | `IDBCursorWithValue]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `IDBCursorWithValue ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Returns the cursor's current value. *)
  val get_value: 'tags this -> any [@@js.get "value"]
  val create: value:any -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end

(** This IndexedDB API interface provides a connection to a database; you can use an IDBDatabase object to open a transaction on your database then create, manipulate, and delete objects (data) in that database. The interface provides the only way to get and manage versions of the database. *)
and[@js.scope "IDBDatabase"] IDBDatabase : sig
  type t = [`EventTarget | `IDBDatabase] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventTarget | `IDBDatabase]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventTarget | `IDBDatabase]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `IDBDatabase ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Returns a new transaction with the given mode ("readonly" or "readwrite") and scope which can be a single object store name or an array of names. *)
  val transaction: 'tags this -> storeNames:([`U1 of string | `U2 of string Iterable.t_1] [@js.union]) -> ?mode:IDBTransactionMode.t -> unit -> IDBTransaction.t [@@js.call "transaction"]
  
  (** Returns the name of the database. *)
  val get_name: 'tags this -> string [@@js.get "name"]
  
  (** Returns a list of the names of object stores in the database. *)
  val get_objectStoreNames: 'tags this -> DOMStringList.t [@@js.get "objectStoreNames"]
  val get_onabort: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onabort"]
  val set_onabort: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onabort"]
  val get_onclose: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onclose"]
  val set_onclose: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onclose"]
  val get_onerror: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onerror"]
  val set_onerror: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onerror"]
  val get_onversionchange: 'tags this -> (this:t -> ev:IDBVersionChangeEvent.t -> any) option [@@js.get "onversionchange"]
  val set_onversionchange: 'tags this -> (this:t -> ev:IDBVersionChangeEvent.t -> any) option -> unit [@@js.set "onversionchange"]
  
  (** Returns the version of the database. *)
  val get_version: 'tags this -> float [@@js.get "version"]
  
  (** Closes the connection once all running transactions have finished. *)
  val close: 'tags this -> unit [@@js.call "close"]
  
  (**
    Creates a new object store with the given name and options and returns a new IDBObjectStore.
    
    Throws a "InvalidStateError" DOMException if not called within an upgrade transaction.
  *)
  val createObjectStore: 'tags this -> name:string -> ?options:IDBObjectStoreParameters.t -> unit -> IDBObjectStore.t [@@js.call "createObjectStore"]
  
  (**
    Deletes the object store with the given name.
    
    Throws a "InvalidStateError" DOMException if not called within an upgrade transaction.
  *)
  val deleteObjectStore: 'tags this -> name:string -> unit [@@js.call "deleteObjectStore"]
  
  (** Returns a new transaction with the given mode ("readonly" or "readwrite") and scope which can be a single object store name or an array of names. *)
  val transaction': 'tags this -> storeNames:([`U1 of string | `U2 of string list] [@js.union]) -> ?mode:IDBTransactionMode.t -> unit -> IDBTransaction.t [@@js.call "transaction"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'IDBDatabaseEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'IDBDatabaseEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** IDBIndex interface of the IndexedDB API provides asynchronous access to an index in a database. An index is a kind of object store for looking up records in another object store, called the referenced object store. You use this interface to retrieve data. *)
and[@js.scope "IDBIndex"] IDBIndex : sig
  type t = [`IDBIndex] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`IDBIndex]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`IDBIndex]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `IDBIndex ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_keyPath: 'tags this -> ([`String of string | `Other of string list] [@js.union on_field "dummy"]) Primitive.t [@@js.get "keyPath"]
  val get_multiEntry: 'tags this -> bool [@@js.get "multiEntry"]
  
  (** Returns the name of the index. *)
  val get_name: 'tags this -> string [@@js.get "name"]
  
  (** Returns the name of the index. *)
  val set_name: 'tags this -> string -> unit [@@js.set "name"]
  
  (** Returns the IDBObjectStore the index belongs to. *)
  val get_objectStore: 'tags this -> IDBObjectStore.t [@@js.get "objectStore"]
  val get_unique: 'tags this -> bool [@@js.get "unique"]
  
  (**
    Retrieves the number of records matching the given key or key range in query.
    
    If successful, request's result will be the count.
  *)
  val count: 'tags this -> ?query:([`U1 of IDBValidKey.t | `U2 of IDBKeyRange.t] [@js.union]) -> unit -> float IDBRequest.t [@@js.call "count"]
  
  (**
    Retrieves the value of the first record matching the given key or key range in query.
    
    If successful, request's result will be the value, or undefined if there was no matching record.
  *)
  val get_: 'tags this -> query:([`U1 of IDBValidKey.t | `U2 of IDBKeyRange.t] [@js.union]) -> any IDBRequest.t [@@js.call "get"]
  
  (**
    Retrieves the values of the records matching the given key or key range in query (up to count if given).
    
    If successful, request's result will be an Array of the values.
  *)
  val getAll: 'tags this -> ?query:([`Null | `U1 of IDBValidKey.t | `U2 of IDBKeyRange.t] [@js.union]) -> ?count:float -> unit -> any list IDBRequest.t [@@js.call "getAll"]
  
  (**
    Retrieves the keys of records matching the given key or key range in query (up to count if given).
    
    If successful, request's result will be an Array of the keys.
  *)
  val getAllKeys: 'tags this -> ?query:([`Null | `U1 of IDBValidKey.t | `U2 of IDBKeyRange.t] [@js.union]) -> ?count:float -> unit -> IDBValidKey.t list IDBRequest.t [@@js.call "getAllKeys"]
  
  (**
    Retrieves the key of the first record matching the given key or key range in query.
    
    If successful, request's result will be the key, or undefined if there was no matching record.
  *)
  val getKey: 'tags this -> query:([`U1 of IDBValidKey.t | `U2 of IDBKeyRange.t] [@js.union]) -> IDBValidKey.t option IDBRequest.t [@@js.call "getKey"]
  
  (**
    Opens a cursor over the records matching query, ordered by direction. If query is null, all records in index are matched.
    
    If successful, request's result will be an IDBCursorWithValue, or null if there were no matching records.
  *)
  val openCursor: 'tags this -> ?query:([`Null | `U1 of IDBValidKey.t | `U2 of IDBKeyRange.t] [@js.union]) -> ?direction:IDBCursorDirection.t -> unit -> IDBCursorWithValue.t option IDBRequest.t [@@js.call "openCursor"]
  
  (**
    Opens a cursor with key only flag set over the records matching query, ordered by direction. If query is null, all records in index are matched.
    
    If successful, request's result will be an IDBCursor, or null if there were no matching records.
  *)
  val openKeyCursor: 'tags this -> ?query:([`Null | `U1 of IDBValidKey.t | `U2 of IDBKeyRange.t] [@js.union]) -> ?direction:IDBCursorDirection.t -> unit -> IDBCursor.t option IDBRequest.t [@@js.call "openKeyCursor"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** This example shows a variety of different uses of object stores, from updating the data structure with IDBObjectStore.createIndex inside an onupgradeneeded function, to adding a new item to our object store with IDBObjectStore.add. For a full working example, see our To-do Notifications app (view example live.) *)
and[@js.scope "IDBObjectStore"] IDBObjectStore : sig
  type t = [`IDBObjectStore] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`IDBObjectStore]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`IDBObjectStore]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `IDBObjectStore ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    Creates a new index in store with the given name, keyPath and options and returns a new IDBIndex. If the keyPath and options define constraints that cannot be satisfied with the data already in store the upgrade transaction will abort with a "ConstraintError" DOMException.
    
    Throws an "InvalidStateError" DOMException if not called within an upgrade transaction.
  *)
  val createIndex: 'tags this -> name:string -> keyPath:([`U1 of string | `U2 of string Iterable.t_1] [@js.union]) -> ?options:IDBIndexParameters.t -> unit -> IDBIndex.t [@@js.call "createIndex"]
  
  (** Returns true if the store has a key generator, and false otherwise. *)
  val get_autoIncrement: 'tags this -> bool [@@js.get "autoIncrement"]
  
  (** Returns a list of the names of indexes in the store. *)
  val get_indexNames: 'tags this -> DOMStringList.t [@@js.get "indexNames"]
  
  (** Returns the key path of the store, or null if none. *)
  val get_keyPath: 'tags this -> ([`String of string | `Other of string list] [@js.union on_field "dummy"]) Primitive.t [@@js.get "keyPath"]
  
  (** Returns the name of the store. *)
  val get_name: 'tags this -> string [@@js.get "name"]
  
  (** Returns the name of the store. *)
  val set_name: 'tags this -> string -> unit [@@js.set "name"]
  
  (** Returns the associated transaction. *)
  val get_transaction: 'tags this -> IDBTransaction.t [@@js.get "transaction"]
  
  (**
    Adds or updates a record in store with the given value and key.
    
    If the store uses in-line keys and key is specified a "DataError" DOMException will be thrown.
    
    If put() is used, any existing record with the key will be replaced. If add() is used, and if a record with the key already exists the request will fail, with request's error set to a "ConstraintError" DOMException.
    
    If successful, request's result will be the record's key.
  *)
  val add: 'tags this -> value:any -> ?key:IDBValidKey.t -> unit -> IDBValidKey.t IDBRequest.t [@@js.call "add"]
  
  (**
    Deletes all records in store.
    
    If successful, request's result will be undefined.
  *)
  val clear: 'tags this -> undefined IDBRequest.t [@@js.call "clear"]
  
  (**
    Retrieves the number of records matching the given key or key range in query.
    
    If successful, request's result will be the count.
  *)
  val count: 'tags this -> ?query:([`U1 of IDBValidKey.t | `U2 of IDBKeyRange.t] [@js.union]) -> unit -> float IDBRequest.t [@@js.call "count"]
  
  (**
    Creates a new index in store with the given name, keyPath and options and returns a new IDBIndex. If the keyPath and options define constraints that cannot be satisfied with the data already in store the upgrade transaction will abort with a "ConstraintError" DOMException.
    
    Throws an "InvalidStateError" DOMException if not called within an upgrade transaction.
  *)
  val createIndex': 'tags this -> name:string -> keyPath:([`U1 of string | `U2 of string list] [@js.union]) -> ?options:IDBIndexParameters.t -> unit -> IDBIndex.t [@@js.call "createIndex"]
  
  (**
    Deletes records in store with the given key or in the given key range in query.
    
    If successful, request's result will be undefined.
  *)
  val delete: 'tags this -> query:([`U1 of IDBValidKey.t | `U2 of IDBKeyRange.t] [@js.union]) -> undefined IDBRequest.t [@@js.call "delete"]
  
  (**
    Deletes the index in store with the given name.
    
    Throws an "InvalidStateError" DOMException if not called within an upgrade transaction.
  *)
  val deleteIndex: 'tags this -> name:string -> unit [@@js.call "deleteIndex"]
  
  (**
    Retrieves the value of the first record matching the given key or key range in query.
    
    If successful, request's result will be the value, or undefined if there was no matching record.
  *)
  val get_: 'tags this -> query:([`U1 of IDBValidKey.t | `U2 of IDBKeyRange.t] [@js.union]) -> any IDBRequest.t [@@js.call "get"]
  
  (**
    Retrieves the values of the records matching the given key or key range in query (up to count if given).
    
    If successful, request's result will be an Array of the values.
  *)
  val getAll: 'tags this -> ?query:([`Null | `U1 of IDBValidKey.t | `U2 of IDBKeyRange.t] [@js.union]) -> ?count:float -> unit -> any list IDBRequest.t [@@js.call "getAll"]
  
  (**
    Retrieves the keys of records matching the given key or key range in query (up to count if given).
    
    If successful, request's result will be an Array of the keys.
  *)
  val getAllKeys: 'tags this -> ?query:([`Null | `U1 of IDBValidKey.t | `U2 of IDBKeyRange.t] [@js.union]) -> ?count:float -> unit -> IDBValidKey.t list IDBRequest.t [@@js.call "getAllKeys"]
  
  (**
    Retrieves the key of the first record matching the given key or key range in query.
    
    If successful, request's result will be the key, or undefined if there was no matching record.
  *)
  val getKey: 'tags this -> query:([`U1 of IDBValidKey.t | `U2 of IDBKeyRange.t] [@js.union]) -> IDBValidKey.t option IDBRequest.t [@@js.call "getKey"]
  val index: 'tags this -> name:string -> IDBIndex.t [@@js.call "index"]
  
  (**
    Opens a cursor over the records matching query, ordered by direction. If query is null, all records in store are matched.
    
    If successful, request's result will be an IDBCursorWithValue pointing at the first matching record, or null if there were no matching records.
  *)
  val openCursor: 'tags this -> ?query:([`Null | `U1 of IDBValidKey.t | `U2 of IDBKeyRange.t] [@js.union]) -> ?direction:IDBCursorDirection.t -> unit -> IDBCursorWithValue.t option IDBRequest.t [@@js.call "openCursor"]
  
  (**
    Opens a cursor with key only flag set over the records matching query, ordered by direction. If query is null, all records in store are matched.
    
    If successful, request's result will be an IDBCursor pointing at the first matching record, or null if there were no matching records.
  *)
  val openKeyCursor: 'tags this -> ?query:([`Null | `U1 of IDBValidKey.t | `U2 of IDBKeyRange.t] [@js.union]) -> ?direction:IDBCursorDirection.t -> unit -> IDBCursor.t option IDBRequest.t [@@js.call "openKeyCursor"]
  
  (**
    Adds or updates a record in store with the given value and key.
    
    If the store uses in-line keys and key is specified a "DataError" DOMException will be thrown.
    
    If put() is used, any existing record with the key will be replaced. If add() is used, and if a record with the key already exists the request will fail, with request's error set to a "ConstraintError" DOMException.
    
    If successful, request's result will be the record's key.
  *)
  val put: 'tags this -> value:any -> ?key:IDBValidKey.t -> unit -> IDBValidKey.t IDBRequest.t [@@js.call "put"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** The request object does not initially contain any information about the result of the operation, but once information becomes available, an event is fired on the request, and the information becomes available through the properties of the IDBRequest instance. *)
and[@js.scope "IDBRequest"] IDBRequest : sig
  type 'T t = [`EventTarget | `IDBRequest of 'T] intf [@@js.custom { of_js=(fun _T -> Obj.magic); to_js=(fun _T -> Obj.magic) }]
  type 'T t_1 = 'T t
  type t_0 = any t
  [@@@js.stop]
  type 'T tags = [`EventTarget | `IDBRequest of 'T]
  type 'T tags_1 = 'T tags
  type tags_0 = any tags
  [@@@js.start]
  [@@@js.implem 
    type 'T tags = [`EventTarget | `IDBRequest of 'T]
    type 'T tags_1 = 'T tags
    type tags_0 = any tags
  ]
  type ('tags, 'T) this = 'tags intf constraint 'tags = [> `IDBRequest of 'T ]
  val t_to_js: ('T -> Ojs.t) -> 'T t -> Ojs.t
  val t_of_js: (Ojs.t -> 'T) -> Ojs.t -> 'T t
  val t_1_to_js: ('T -> Ojs.t) -> 'T t_1 -> Ojs.t
  val t_1_of_js: (Ojs.t -> 'T) -> Ojs.t -> 'T t_1
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** When a request is completed, returns the error (a DOMException), or null if the request succeeded. Throws a "InvalidStateError" DOMException if the request is still pending. *)
  val get_error: ('tags, 'T) this -> DOMException.t option [@@js.get "error"]
  val get_onerror: ('tags, 'T) this -> (this:'T t -> ev:Event.t -> any) option [@@js.get "onerror"]
  val set_onerror: ('tags, 'T) this -> (this:'T t -> ev:Event.t -> any) option -> unit [@@js.set "onerror"]
  val get_onsuccess: ('tags, 'T) this -> (this:'T t -> ev:Event.t -> any) option [@@js.get "onsuccess"]
  val set_onsuccess: ('tags, 'T) this -> (this:'T t -> ev:Event.t -> any) option -> unit [@@js.set "onsuccess"]
  
  (** Returns "pending" until a request is complete, then returns "done". *)
  val get_readyState: ('tags, 'T) this -> IDBRequestReadyState.t [@@js.get "readyState"]
  
  (** When a request is completed, returns the result, or undefined if the request failed. Throws a "InvalidStateError" DOMException if the request is still pending. *)
  val get_result: ('tags, 'T) this -> 'T [@@js.get "result"]
  
  (** Returns the IDBObjectStore, IDBIndex, or IDBCursor the request was made against, or null if is was an open request. *)
  val get_source: ('tags, 'T) this -> (IDBCursor.t, IDBIndex.t, IDBObjectStore.t) union3 [@@js.get "source"]
  
  (** Returns the IDBTransaction the request was made within. If this as an open request, then it returns an upgrade transaction while it is running, or null otherwise. *)
  val get_transaction: ('tags, 'T) this -> IDBTransaction.t option [@@js.get "transaction"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: ('tags, 'T) this -> type_:'K -> listener:(this:'T t -> ev:(* FIXME: unknown type 'IDBRequestEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': ('tags, 'T) this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: ('tags, 'T) this -> type_:'K -> listener:(this:'T t -> ev:(* FIXME: unknown type 'IDBRequestEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': ('tags, 'T) this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: ('tags, 'T) this -> 'T t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t_0 [@@js.get "prototype"]
  val create: unit -> t_0 [@@js.create]
end
and[@js.scope "IDBTransaction"] IDBTransaction : sig
  type t = [`EventTarget | `IDBTransaction] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventTarget | `IDBTransaction]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventTarget | `IDBTransaction]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `IDBTransaction ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Returns the transaction's connection. *)
  val get_db: 'tags this -> IDBDatabase.t [@@js.get "db"]
  val get_durability: 'tags this -> IDBTransactionDurability.t [@@js.get "durability"]
  
  (** If the transaction was aborted, returns the error (a DOMException) providing the reason. *)
  val get_error: 'tags this -> DOMException.t option [@@js.get "error"]
  
  (** Returns the mode the transaction was created with ("readonly" or "readwrite"), or "versionchange" for an upgrade transaction. *)
  val get_mode: 'tags this -> IDBTransactionMode.t [@@js.get "mode"]
  
  (** Returns a list of the names of object stores in the transaction's scope. For an upgrade transaction this is all object stores in the database. *)
  val get_objectStoreNames: 'tags this -> DOMStringList.t [@@js.get "objectStoreNames"]
  val get_onabort: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onabort"]
  val set_onabort: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onabort"]
  val get_oncomplete: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "oncomplete"]
  val set_oncomplete: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "oncomplete"]
  val get_onerror: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onerror"]
  val set_onerror: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onerror"]
  
  (** Aborts the transaction. All pending requests will fail with a "AbortError" DOMException and all changes made to the database will be reverted. *)
  val abort: 'tags this -> unit [@@js.call "abort"]
  val commit: 'tags this -> unit [@@js.call "commit"]
  
  (** Returns an IDBObjectStore in the transaction's scope. *)
  val objectStore: 'tags this -> name:string -> IDBObjectStore.t [@@js.call "objectStore"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'IDBTransactionEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'IDBTransactionEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Also inherits methods from its parents IDBRequest and EventTarget. *)
module[@js.scope "IDBOpenDBRequest"] IDBOpenDBRequest : sig
  type t = [`EventTarget | `IDBOpenDBRequest | `IDBRequest of IDBDatabase.t] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventTarget | `IDBOpenDBRequest | `IDBRequest of IDBDatabase.t]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventTarget | `IDBOpenDBRequest | `IDBRequest of IDBDatabase.t]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `IDBOpenDBRequest ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_onblocked: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onblocked"]
  val set_onblocked: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onblocked"]
  val get_onupgradeneeded: 'tags this -> (this:t -> ev:IDBVersionChangeEvent.t -> any) option [@@js.get "onupgradeneeded"]
  val set_onupgradeneeded: 'tags this -> (this:t -> ev:IDBVersionChangeEvent.t -> any) option -> unit [@@js.set "onupgradeneeded"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'IDBOpenDBRequestEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'IDBOpenDBRequestEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module IDBDatabaseInfo : sig
  type t = [`IDBDatabaseInfo] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`IDBDatabaseInfo]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`IDBDatabaseInfo]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `IDBDatabaseInfo ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_name: 'tags this -> string option [@@js.get "name"]
  val set_name: 'tags this -> string -> unit [@@js.set "name"]
  val get_version: 'tags this -> float option [@@js.get "version"]
  val set_version: 'tags this -> float -> unit [@@js.set "version"]
  val create: ?name:string -> ?version:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** In the following code snippet, we make a request to open a database, and include handlers for the success and error cases. For a full working example, see our To-do Notifications app (view example live.) *)
module[@js.scope "IDBFactory"] IDBFactory : sig
  type t = [`IDBFactory] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`IDBFactory]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`IDBFactory]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `IDBFactory ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    Compares two values as keys. Returns -1 if key1 precedes key2, 1 if key2 precedes key1, and 0 if the keys are equal.
    
    Throws a "DataError" DOMException if either input is not a valid key.
  *)
  val cmp: 'tags this -> first:any -> second:any -> float [@@js.call "cmp"]
  val databases: 'tags this -> IDBDatabaseInfo.t list Promise.t_1 [@@js.call "databases"]
  
  (** Attempts to delete the named database. If the database already exists and there are open connections that don't close in response to a versionchange event, the request will be blocked until all they close. If the request is successful request's result will be null. *)
  val deleteDatabase: 'tags this -> name:string -> IDBOpenDBRequest.t [@@js.call "deleteDatabase"]
  
  (** Attempts to open a connection to the named database with the current version, or 1 if it does not already exist. If the request is successful request's result will be the connection. *)
  val open_: 'tags this -> name:string -> ?version:float -> unit -> IDBOpenDBRequest.t [@@js.call "open"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module Algorithm : sig
  type t = [`Algorithm] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Algorithm]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Algorithm]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `Algorithm ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_name: 'tags this -> string [@@js.get "name"]
  val set_name: 'tags this -> string -> unit [@@js.set "name"]
  val create: name:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module RsaPssParams : sig
  type t = [`Algorithm | `RsaPssParams] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Algorithm | `RsaPssParams]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Algorithm | `RsaPssParams]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RsaPssParams ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_saltLength: 'tags this -> float [@@js.get "saltLength"]
  val set_saltLength: 'tags this -> float -> unit [@@js.set "saltLength"]
  val create: saltLength:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module RsaOaepParams : sig
  type t = [`Algorithm | `RsaOaepParams] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Algorithm | `RsaOaepParams]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Algorithm | `RsaOaepParams]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RsaOaepParams ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_label: 'tags this -> BufferSource.t option [@@js.get "label"]
  val set_label: 'tags this -> BufferSource.t -> unit [@@js.set "label"]
  val create: ?label:BufferSource.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module BigInteger : sig
  type t = Uint8Array.t_0
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module RsaKeyGenParams : sig
  type t = [`Algorithm | `RsaKeyGenParams] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Algorithm | `RsaKeyGenParams]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Algorithm | `RsaKeyGenParams]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RsaKeyGenParams ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_modulusLength: 'tags this -> float [@@js.get "modulusLength"]
  val set_modulusLength: 'tags this -> float -> unit [@@js.set "modulusLength"]
  val get_publicExponent: 'tags this -> BigInteger.t [@@js.get "publicExponent"]
  val set_publicExponent: 'tags this -> BigInteger.t -> unit [@@js.set "publicExponent"]
  val create: modulusLength:float -> publicExponent:BigInteger.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module AlgorithmIdentifier : sig
  type t = ([`String of string | `Other of Algorithm.t] [@js.union on_field "dummy"]) Primitive.t
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module HashAlgorithmIdentifier : sig
  type t = AlgorithmIdentifier.t
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module RsaHashedKeyGenParams : sig
  type t = [`Algorithm | `RsaHashedKeyGenParams | `RsaKeyGenParams] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Algorithm | `RsaHashedKeyGenParams | `RsaKeyGenParams]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Algorithm | `RsaHashedKeyGenParams | `RsaKeyGenParams]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RsaHashedKeyGenParams ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_hash: 'tags this -> HashAlgorithmIdentifier.t [@@js.get "hash"]
  val set_hash: 'tags this -> HashAlgorithmIdentifier.t -> unit [@@js.set "hash"]
  val create: hash:HashAlgorithmIdentifier.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module RsaHashedImportParams : sig
  type t = [`Algorithm | `RsaHashedImportParams] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Algorithm | `RsaHashedImportParams]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Algorithm | `RsaHashedImportParams]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RsaHashedImportParams ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_hash: 'tags this -> HashAlgorithmIdentifier.t [@@js.get "hash"]
  val set_hash: 'tags this -> HashAlgorithmIdentifier.t -> unit [@@js.set "hash"]
  val create: hash:HashAlgorithmIdentifier.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module Pbkdf2Params : sig
  type t = [`Algorithm | `Pbkdf2Params] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Algorithm | `Pbkdf2Params]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Algorithm | `Pbkdf2Params]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `Pbkdf2Params ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_hash: 'tags this -> HashAlgorithmIdentifier.t [@@js.get "hash"]
  val set_hash: 'tags this -> HashAlgorithmIdentifier.t -> unit [@@js.set "hash"]
  val get_iterations: 'tags this -> float [@@js.get "iterations"]
  val set_iterations: 'tags this -> float -> unit [@@js.set "iterations"]
  val get_salt: 'tags this -> BufferSource.t [@@js.get "salt"]
  val set_salt: 'tags this -> BufferSource.t -> unit [@@js.set "salt"]
  val create: hash:HashAlgorithmIdentifier.t -> iterations:float -> salt:BufferSource.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module KeyFormat : sig
  type t = ([`L_s441_jwk[@js "jwk"] | `L_s604_pkcs8[@js "pkcs8"] | `L_s647_raw[@js "raw"] | `L_s747_spki[@js "spki"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module RsaOtherPrimesInfo : sig
  type t = [`RsaOtherPrimesInfo] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`RsaOtherPrimesInfo]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`RsaOtherPrimesInfo]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RsaOtherPrimesInfo ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_d: 'tags this -> string option [@@js.get "d"]
  val set_d: 'tags this -> string -> unit [@@js.set "d"]
  val get_r: 'tags this -> string option [@@js.get "r"]
  val set_r: 'tags this -> string -> unit [@@js.set "r"]
  val get_t: 'tags this -> string option [@@js.get "t"]
  val set_t: 'tags this -> string -> unit [@@js.set "t"]
  val create: ?d:string -> ?r:string -> ?t:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module JsonWebKey : sig
  type t = [`JsonWebKey] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`JsonWebKey]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`JsonWebKey]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `JsonWebKey ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_alg: 'tags this -> string option [@@js.get "alg"]
  val set_alg: 'tags this -> string -> unit [@@js.set "alg"]
  val get_crv: 'tags this -> string option [@@js.get "crv"]
  val set_crv: 'tags this -> string -> unit [@@js.set "crv"]
  val get_d: 'tags this -> string option [@@js.get "d"]
  val set_d: 'tags this -> string -> unit [@@js.set "d"]
  val get_dp: 'tags this -> string option [@@js.get "dp"]
  val set_dp: 'tags this -> string -> unit [@@js.set "dp"]
  val get_dq: 'tags this -> string option [@@js.get "dq"]
  val set_dq: 'tags this -> string -> unit [@@js.set "dq"]
  val get_e: 'tags this -> string option [@@js.get "e"]
  val set_e: 'tags this -> string -> unit [@@js.set "e"]
  val get_ext: 'tags this -> bool option [@@js.get "ext"]
  val set_ext: 'tags this -> bool -> unit [@@js.set "ext"]
  val get_k: 'tags this -> string option [@@js.get "k"]
  val set_k: 'tags this -> string -> unit [@@js.set "k"]
  val get_key_ops: 'tags this -> string list option [@@js.get "key_ops"]
  val set_key_ops: 'tags this -> string list -> unit [@@js.set "key_ops"]
  val get_kty: 'tags this -> string option [@@js.get "kty"]
  val set_kty: 'tags this -> string -> unit [@@js.set "kty"]
  val get_n: 'tags this -> string option [@@js.get "n"]
  val set_n: 'tags this -> string -> unit [@@js.set "n"]
  val get_oth: 'tags this -> RsaOtherPrimesInfo.t list option [@@js.get "oth"]
  val set_oth: 'tags this -> RsaOtherPrimesInfo.t list -> unit [@@js.set "oth"]
  val get_p: 'tags this -> string option [@@js.get "p"]
  val set_p: 'tags this -> string -> unit [@@js.set "p"]
  val get_q: 'tags this -> string option [@@js.get "q"]
  val set_q: 'tags this -> string -> unit [@@js.set "q"]
  val get_qi: 'tags this -> string option [@@js.get "qi"]
  val set_qi: 'tags this -> string -> unit [@@js.set "qi"]
  val get_use: 'tags this -> string option [@@js.get "use"]
  val set_use: 'tags this -> string -> unit [@@js.set "use"]
  val get_x: 'tags this -> string option [@@js.get "x"]
  val set_x: 'tags this -> string -> unit [@@js.set "x"]
  val get_y: 'tags this -> string option [@@js.get "y"]
  val set_y: 'tags this -> string -> unit [@@js.set "y"]
  val create: ?alg:string -> ?crv:string -> ?d:string -> ?dp:string -> ?dq:string -> ?e:string -> ?ext:bool -> ?k:string -> ?key_ops:string list -> ?kty:string -> ?n:string -> ?oth:RsaOtherPrimesInfo.t list -> ?p:string -> ?q:string -> ?qi:string -> ?use:string -> ?x:string -> ?y:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module HmacKeyGenParams : sig
  type t = [`Algorithm | `HmacKeyGenParams] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Algorithm | `HmacKeyGenParams]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Algorithm | `HmacKeyGenParams]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HmacKeyGenParams ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_hash: 'tags this -> HashAlgorithmIdentifier.t [@@js.get "hash"]
  val set_hash: 'tags this -> HashAlgorithmIdentifier.t -> unit [@@js.set "hash"]
  val get_length: 'tags this -> float option [@@js.get "length"]
  val set_length: 'tags this -> float -> unit [@@js.set "length"]
  val create: hash:HashAlgorithmIdentifier.t -> ?length:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module HmacImportParams : sig
  type t = [`Algorithm | `HmacImportParams] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Algorithm | `HmacImportParams]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Algorithm | `HmacImportParams]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HmacImportParams ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_hash: 'tags this -> HashAlgorithmIdentifier.t [@@js.get "hash"]
  val set_hash: 'tags this -> HashAlgorithmIdentifier.t -> unit [@@js.set "hash"]
  val get_length: 'tags this -> float option [@@js.get "length"]
  val set_length: 'tags this -> float -> unit [@@js.set "length"]
  val create: hash:HashAlgorithmIdentifier.t -> ?length:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module HkdfParams : sig
  type t = [`Algorithm | `HkdfParams] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Algorithm | `HkdfParams]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Algorithm | `HkdfParams]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HkdfParams ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_hash: 'tags this -> HashAlgorithmIdentifier.t [@@js.get "hash"]
  val set_hash: 'tags this -> HashAlgorithmIdentifier.t -> unit [@@js.set "hash"]
  val get_info: 'tags this -> BufferSource.t [@@js.get "info"]
  val set_info: 'tags this -> BufferSource.t -> unit [@@js.set "info"]
  val get_salt: 'tags this -> BufferSource.t [@@js.get "salt"]
  val set_salt: 'tags this -> BufferSource.t -> unit [@@js.set "salt"]
  val create: hash:HashAlgorithmIdentifier.t -> info:BufferSource.t -> salt:BufferSource.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module EcdsaParams : sig
  type t = [`Algorithm | `EcdsaParams] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Algorithm | `EcdsaParams]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Algorithm | `EcdsaParams]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `EcdsaParams ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_hash: 'tags this -> HashAlgorithmIdentifier.t [@@js.get "hash"]
  val set_hash: 'tags this -> HashAlgorithmIdentifier.t -> unit [@@js.set "hash"]
  val create: hash:HashAlgorithmIdentifier.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module KeyUsage : sig
  type t = ([`L_s240_decrypt[@js "decrypt"] | `L_s245_deriveBits[@js "deriveBits"] | `L_s246_deriveKey[@js "deriveKey"] | `L_s288_encrypt[@js "encrypt"] | `L_s722_sign[@js "sign"] | `L_s834_unwrapKey[@js "unwrapKey"] | `L_s848_verify[@js "verify"] | `L_s874_wrapKey[@js "wrapKey"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module KeyType : sig
  type t = ([`L_s636_private[@js "private"] | `L_s641_public[@js "public"] | `L_s700_secret[@js "secret"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module KeyAlgorithm : sig
  type t = [`KeyAlgorithm] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`KeyAlgorithm]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`KeyAlgorithm]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `KeyAlgorithm ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_name: 'tags this -> string [@@js.get "name"]
  val set_name: 'tags this -> string -> unit [@@js.set "name"]
  val create: name:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(**
  The CryptoKey dictionary of the Web Crypto API represents a cryptographic key.
  Available only in secure contexts.
*)
module[@js.scope "CryptoKey"] CryptoKey : sig
  type t = [`CryptoKey] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`CryptoKey]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`CryptoKey]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `CryptoKey ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_algorithm: 'tags this -> KeyAlgorithm.t [@@js.get "algorithm"]
  val get_extractable: 'tags this -> bool [@@js.get "extractable"]
  val get_type: 'tags this -> KeyType.t [@@js.get "type"]
  val get_usages: 'tags this -> KeyUsage.t list [@@js.get "usages"]
  val create: algorithm:KeyAlgorithm.t -> extractable:bool -> type_:(KeyType.t[@js "type"]) -> usages:KeyUsage.t list -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end
module EcdhKeyDeriveParams : sig
  type t = [`Algorithm | `EcdhKeyDeriveParams] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Algorithm | `EcdhKeyDeriveParams]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Algorithm | `EcdhKeyDeriveParams]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `EcdhKeyDeriveParams ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_public: 'tags this -> CryptoKey.t [@@js.get "public"]
  val set_public: 'tags this -> CryptoKey.t -> unit [@@js.set "public"]
  val create: public:CryptoKey.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module NamedCurve : sig
  type t = string
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module EcKeyImportParams : sig
  type t = [`Algorithm | `EcKeyImportParams] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Algorithm | `EcKeyImportParams]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Algorithm | `EcKeyImportParams]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `EcKeyImportParams ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_namedCurve: 'tags this -> NamedCurve.t [@@js.get "namedCurve"]
  val set_namedCurve: 'tags this -> NamedCurve.t -> unit [@@js.set "namedCurve"]
  val create: namedCurve:NamedCurve.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module EcKeyGenParams : sig
  type t = [`Algorithm | `EcKeyGenParams] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Algorithm | `EcKeyGenParams]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Algorithm | `EcKeyGenParams]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `EcKeyGenParams ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_namedCurve: 'tags this -> NamedCurve.t [@@js.get "namedCurve"]
  val set_namedCurve: 'tags this -> NamedCurve.t -> unit [@@js.set "namedCurve"]
  val create: namedCurve:NamedCurve.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module CryptoKeyPair : sig
  type t = [`CryptoKeyPair] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`CryptoKeyPair]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`CryptoKeyPair]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `CryptoKeyPair ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_privateKey: 'tags this -> CryptoKey.t [@@js.get "privateKey"]
  val set_privateKey: 'tags this -> CryptoKey.t -> unit [@@js.set "privateKey"]
  val get_publicKey: 'tags this -> CryptoKey.t [@@js.get "publicKey"]
  val set_publicKey: 'tags this -> CryptoKey.t -> unit [@@js.set "publicKey"]
  val create: privateKey:CryptoKey.t -> publicKey:CryptoKey.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module AesKeyGenParams : sig
  type t = [`AesKeyGenParams | `Algorithm] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AesKeyGenParams | `Algorithm]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AesKeyGenParams | `Algorithm]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `AesKeyGenParams ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_length: 'tags this -> float [@@js.get "length"]
  val set_length: 'tags this -> float -> unit [@@js.set "length"]
  val create: length:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module AesKeyAlgorithm : sig
  type t = [`AesKeyAlgorithm | `KeyAlgorithm] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AesKeyAlgorithm | `KeyAlgorithm]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AesKeyAlgorithm | `KeyAlgorithm]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `AesKeyAlgorithm ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_length: 'tags this -> float [@@js.get "length"]
  val set_length: 'tags this -> float -> unit [@@js.set "length"]
  val create: length:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module AesGcmParams : sig
  type t = [`AesGcmParams | `Algorithm] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AesGcmParams | `Algorithm]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AesGcmParams | `Algorithm]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `AesGcmParams ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_additionalData: 'tags this -> BufferSource.t option [@@js.get "additionalData"]
  val set_additionalData: 'tags this -> BufferSource.t -> unit [@@js.set "additionalData"]
  val get_iv: 'tags this -> BufferSource.t [@@js.get "iv"]
  val set_iv: 'tags this -> BufferSource.t -> unit [@@js.set "iv"]
  val get_tagLength: 'tags this -> float option [@@js.get "tagLength"]
  val set_tagLength: 'tags this -> float -> unit [@@js.set "tagLength"]
  val create: ?additionalData:BufferSource.t -> iv:BufferSource.t -> ?tagLength:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module AesDerivedKeyParams : sig
  type t = [`AesDerivedKeyParams | `Algorithm] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AesDerivedKeyParams | `Algorithm]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AesDerivedKeyParams | `Algorithm]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `AesDerivedKeyParams ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_length: 'tags this -> float [@@js.get "length"]
  val set_length: 'tags this -> float -> unit [@@js.set "length"]
  val create: length:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module AesCtrParams : sig
  type t = [`AesCtrParams | `Algorithm] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AesCtrParams | `Algorithm]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AesCtrParams | `Algorithm]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `AesCtrParams ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_counter: 'tags this -> BufferSource.t [@@js.get "counter"]
  val set_counter: 'tags this -> BufferSource.t -> unit [@@js.set "counter"]
  val get_length: 'tags this -> float [@@js.get "length"]
  val set_length: 'tags this -> float -> unit [@@js.set "length"]
  val create: counter:BufferSource.t -> length:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module AesCbcParams : sig
  type t = [`AesCbcParams | `Algorithm] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AesCbcParams | `Algorithm]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AesCbcParams | `Algorithm]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `AesCbcParams ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_iv: 'tags this -> BufferSource.t [@@js.get "iv"]
  val set_iv: 'tags this -> BufferSource.t -> unit [@@js.set "iv"]
  val create: iv:BufferSource.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(**
  This Web Crypto API interface provides a number of low-level cryptographic functions. It is accessed via the Crypto.subtle properties available in a window context (via Window.crypto).
  Available only in secure contexts.
*)
module[@js.scope "SubtleCrypto"] SubtleCrypto : sig
  type t = [`SubtleCrypto] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`SubtleCrypto]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`SubtleCrypto]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SubtleCrypto ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val deriveKey: 'tags this -> algorithm:([`U1 of AlgorithmIdentifier.t | `U2 of EcdhKeyDeriveParams.t | `U3 of HkdfParams.t | `U4 of Pbkdf2Params.t] [@js.union]) -> baseKey:CryptoKey.t -> derivedKeyType:([`U1 of AlgorithmIdentifier.t | `U2 of AesDerivedKeyParams.t | `U3 of HmacImportParams.t | `U4 of HkdfParams.t | `U5 of Pbkdf2Params.t] [@js.union]) -> extractable:bool -> keyUsages:KeyUsage.t Iterable.t_1 -> CryptoKey.t Promise.t_1 [@@js.call "deriveKey"]
  val generateKey: 'tags this -> algorithm:([`U1 of RsaHashedKeyGenParams.t | `U2 of EcKeyGenParams.t] [@js.union]) -> extractable:bool -> keyUsages:KeyUsage.t list -> CryptoKeyPair.t Promise.t_1 [@@js.call "generateKey"]
  val generateKey': 'tags this -> algorithm:([`U1 of AesKeyGenParams.t | `U2 of HmacKeyGenParams.t | `U3 of Pbkdf2Params.t] [@js.union]) -> extractable:bool -> keyUsages:KeyUsage.t list -> CryptoKey.t Promise.t_1 [@@js.call "generateKey"]
  val generateKey'': 'tags this -> algorithm:AlgorithmIdentifier.t -> extractable:bool -> keyUsages:KeyUsage.t Iterable.t_1 -> (CryptoKey.t, CryptoKeyPair.t) union2 Promise.t_1 [@@js.call "generateKey"]
  val importKey: 'tags this -> format:([`L_s441_jwk[@js "jwk"]] [@js.enum]) -> keyData:JsonWebKey.t -> algorithm:([`U1 of AlgorithmIdentifier.t | `U2 of RsaHashedImportParams.t | `U3 of EcKeyImportParams.t | `U4 of HmacImportParams.t | `U5 of AesKeyAlgorithm.t] [@js.union]) -> extractable:bool -> keyUsages:KeyUsage.t list -> CryptoKey.t Promise.t_1 [@@js.call "importKey"]
  val importKey': 'tags this -> format:(KeyFormat.t, ([`L_s441_jwk[@js "jwk"]] [@js.enum])) Exclude.t_2 -> keyData:BufferSource.t -> algorithm:([`U1 of AlgorithmIdentifier.t | `U2 of RsaHashedImportParams.t | `U3 of EcKeyImportParams.t | `U4 of HmacImportParams.t | `U5 of AesKeyAlgorithm.t] [@js.union]) -> extractable:bool -> keyUsages:KeyUsage.t Iterable.t_1 -> CryptoKey.t Promise.t_1 [@@js.call "importKey"]
  val unwrapKey: 'tags this -> format:KeyFormat.t -> wrappedKey:BufferSource.t -> unwrappingKey:CryptoKey.t -> unwrapAlgorithm:([`U1 of AlgorithmIdentifier.t | `U2 of RsaOaepParams.t | `U3 of AesCtrParams.t | `U4 of AesCbcParams.t | `U5 of AesGcmParams.t] [@js.union]) -> unwrappedKeyAlgorithm:([`U1 of AlgorithmIdentifier.t | `U2 of RsaHashedImportParams.t | `U3 of EcKeyImportParams.t | `U4 of HmacImportParams.t | `U5 of AesKeyAlgorithm.t] [@js.union]) -> extractable:bool -> keyUsages:KeyUsage.t Iterable.t_1 -> CryptoKey.t Promise.t_1 [@@js.call "unwrapKey"]
  val decrypt: 'tags this -> algorithm:([`U1 of AlgorithmIdentifier.t | `U2 of RsaOaepParams.t | `U3 of AesCtrParams.t | `U4 of AesCbcParams.t | `U5 of AesGcmParams.t] [@js.union]) -> key:CryptoKey.t -> data:BufferSource.t -> any Promise.t_1 [@@js.call "decrypt"]
  val deriveBits: 'tags this -> algorithm:([`U1 of AlgorithmIdentifier.t | `U2 of EcdhKeyDeriveParams.t | `U3 of HkdfParams.t | `U4 of Pbkdf2Params.t] [@js.union]) -> baseKey:CryptoKey.t -> length:float -> ArrayBuffer.t_0 Promise.t_1 [@@js.call "deriveBits"]
  val deriveKey': 'tags this -> algorithm:([`U1 of AlgorithmIdentifier.t | `U2 of EcdhKeyDeriveParams.t | `U3 of HkdfParams.t | `U4 of Pbkdf2Params.t] [@js.union]) -> baseKey:CryptoKey.t -> derivedKeyType:([`U1 of AlgorithmIdentifier.t | `U2 of AesDerivedKeyParams.t | `U3 of HmacImportParams.t | `U4 of HkdfParams.t | `U5 of Pbkdf2Params.t] [@js.union]) -> extractable:bool -> keyUsages:KeyUsage.t list -> CryptoKey.t Promise.t_1 [@@js.call "deriveKey"]
  val digest: 'tags this -> algorithm:AlgorithmIdentifier.t -> data:BufferSource.t -> ArrayBuffer.t_0 Promise.t_1 [@@js.call "digest"]
  val encrypt: 'tags this -> algorithm:([`U1 of AlgorithmIdentifier.t | `U2 of RsaOaepParams.t | `U3 of AesCtrParams.t | `U4 of AesCbcParams.t | `U5 of AesGcmParams.t] [@js.union]) -> key:CryptoKey.t -> data:BufferSource.t -> any Promise.t_1 [@@js.call "encrypt"]
  val exportKey: 'tags this -> format:([`L_s441_jwk[@js "jwk"]] [@js.enum]) -> key:CryptoKey.t -> JsonWebKey.t Promise.t_1 [@@js.call "exportKey"]
  val exportKey': 'tags this -> format:(KeyFormat.t, ([`L_s441_jwk[@js "jwk"]] [@js.enum])) Exclude.t_2 -> key:CryptoKey.t -> ArrayBuffer.t_0 Promise.t_1 [@@js.call "exportKey"]
  val generateKey''': 'tags this -> algorithm:([`U1 of RsaHashedKeyGenParams.t | `U2 of EcKeyGenParams.t] [@js.union]) -> extractable:bool -> keyUsages:KeyUsage.t list -> CryptoKeyPair.t Promise.t_1 [@@js.call "generateKey"]
  val generateKey'''': 'tags this -> algorithm:([`U1 of AesKeyGenParams.t | `U2 of HmacKeyGenParams.t | `U3 of Pbkdf2Params.t] [@js.union]) -> extractable:bool -> keyUsages:KeyUsage.t list -> CryptoKey.t Promise.t_1 [@@js.call "generateKey"]
  val generateKey''''': 'tags this -> algorithm:AlgorithmIdentifier.t -> extractable:bool -> keyUsages:KeyUsage.t list -> (CryptoKey.t, CryptoKeyPair.t) union2 Promise.t_1 [@@js.call "generateKey"]
  val importKey'': 'tags this -> format:([`L_s441_jwk[@js "jwk"]] [@js.enum]) -> keyData:JsonWebKey.t -> algorithm:([`U1 of AlgorithmIdentifier.t | `U2 of RsaHashedImportParams.t | `U3 of EcKeyImportParams.t | `U4 of HmacImportParams.t | `U5 of AesKeyAlgorithm.t] [@js.union]) -> extractable:bool -> keyUsages:KeyUsage.t list -> CryptoKey.t Promise.t_1 [@@js.call "importKey"]
  val importKey''': 'tags this -> format:(KeyFormat.t, ([`L_s441_jwk[@js "jwk"]] [@js.enum])) Exclude.t_2 -> keyData:BufferSource.t -> algorithm:([`U1 of AlgorithmIdentifier.t | `U2 of RsaHashedImportParams.t | `U3 of EcKeyImportParams.t | `U4 of HmacImportParams.t | `U5 of AesKeyAlgorithm.t] [@js.union]) -> extractable:bool -> keyUsages:KeyUsage.t list -> CryptoKey.t Promise.t_1 [@@js.call "importKey"]
  val sign: 'tags this -> algorithm:([`U1 of AlgorithmIdentifier.t | `U2 of RsaPssParams.t | `U3 of EcdsaParams.t] [@js.union]) -> key:CryptoKey.t -> data:BufferSource.t -> ArrayBuffer.t_0 Promise.t_1 [@@js.call "sign"]
  val unwrapKey': 'tags this -> format:KeyFormat.t -> wrappedKey:BufferSource.t -> unwrappingKey:CryptoKey.t -> unwrapAlgorithm:([`U1 of AlgorithmIdentifier.t | `U2 of RsaOaepParams.t | `U3 of AesCtrParams.t | `U4 of AesCbcParams.t | `U5 of AesGcmParams.t] [@js.union]) -> unwrappedKeyAlgorithm:([`U1 of AlgorithmIdentifier.t | `U2 of RsaHashedImportParams.t | `U3 of EcKeyImportParams.t | `U4 of HmacImportParams.t | `U5 of AesKeyAlgorithm.t] [@js.union]) -> extractable:bool -> keyUsages:KeyUsage.t list -> CryptoKey.t Promise.t_1 [@@js.call "unwrapKey"]
  val verify: 'tags this -> algorithm:([`U1 of AlgorithmIdentifier.t | `U2 of RsaPssParams.t | `U3 of EcdsaParams.t] [@js.union]) -> key:CryptoKey.t -> signature:BufferSource.t -> data:BufferSource.t -> bool Promise.t_1 [@@js.call "verify"]
  val wrapKey: 'tags this -> format:KeyFormat.t -> key:CryptoKey.t -> wrappingKey:CryptoKey.t -> wrapAlgorithm:([`U1 of AlgorithmIdentifier.t | `U2 of RsaOaepParams.t | `U3 of AesCtrParams.t | `U4 of AesCbcParams.t | `U5 of AesGcmParams.t] [@js.union]) -> ArrayBuffer.t_0 Promise.t_1 [@@js.call "wrapKey"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Basic cryptography features available in the current context. It allows access to a cryptographically strong random number generator and to cryptographic primitives. *)
module[@js.scope "Crypto"] Crypto : sig
  type t = [`Crypto] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Crypto]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Crypto]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `Crypto ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Available only in secure contexts. *)
  val get_subtle: 'tags this -> SubtleCrypto.t [@@js.get "subtle"]
  val getRandomValues: 'tags this -> array:'T -> 'T [@@js.call "getRandomValues"]
  
  (** Available only in secure contexts. *)
  val randomUUID: 'tags this -> string [@@js.call "randomUUID"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module CacheQueryOptions : sig
  type t = [`CacheQueryOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`CacheQueryOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`CacheQueryOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `CacheQueryOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_ignoreMethod: 'tags this -> bool option [@@js.get "ignoreMethod"]
  val set_ignoreMethod: 'tags this -> bool -> unit [@@js.set "ignoreMethod"]
  val get_ignoreSearch: 'tags this -> bool option [@@js.get "ignoreSearch"]
  val set_ignoreSearch: 'tags this -> bool -> unit [@@js.set "ignoreSearch"]
  val get_ignoreVary: 'tags this -> bool option [@@js.get "ignoreVary"]
  val set_ignoreVary: 'tags this -> bool -> unit [@@js.set "ignoreVary"]
  val create: ?ignoreMethod:bool -> ?ignoreSearch:bool -> ?ignoreVary:bool -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module MultiCacheQueryOptions : sig
  type t = [`CacheQueryOptions | `MultiCacheQueryOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`CacheQueryOptions | `MultiCacheQueryOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`CacheQueryOptions | `MultiCacheQueryOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MultiCacheQueryOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_cacheName: 'tags this -> string option [@@js.get "cacheName"]
  val set_cacheName: 'tags this -> string -> unit [@@js.set "cacheName"]
  val create: ?cacheName:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module ResponseType : sig
  type t = ([`L_s150_basic[@js "basic"] | `L_s225_cors[@js "cors"] | `L_s241_default[@js "default"] | `L_s298_error[@js "error"] | `L_s562_opaque[@js "opaque"] | `L_s563_opaqueredirect[@js "opaqueredirect"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end

(** This Fetch API interface allows you to perform various actions on HTTP request and response headers. These actions include retrieving, setting, adding to, and removing. A Headers object has an associated header list, which is initially empty and consists of zero or more name and value pairs.  You can add to this using methods like append() (see Examples.) In all methods of this interface, header names are matched by case-insensitive byte sequence. *)
module[@js.scope "Headers"] rec Headers : sig
  type t = [`Headers | (string * string) IterableIterator.tags_1] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Headers | (string * string) IterableIterator.tags_1]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Headers | (string * string) IterableIterator.tags_1]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `Headers ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  (* [Symbol.iterator]: unit -> (string * string) IterableIterator.t_1 *)
  
  (** Returns an iterator allowing to go through all key/value pairs contained in this object. *)
  val entries: 'tags this -> (string * string) IterableIterator.t_1 [@@js.call "entries"]
  
  (** Returns an iterator allowing to go through all keys of the key/value pairs contained in this object. *)
  val keys: 'tags this -> string IterableIterator.t_1 [@@js.call "keys"]
  
  (** Returns an iterator allowing to go through all values of the key/value pairs contained in this object. *)
  val values: 'tags this -> string IterableIterator.t_1 [@@js.call "values"]
  val append: 'tags this -> name:string -> value:string -> unit [@@js.call "append"]
  val delete: 'tags this -> name:string -> unit [@@js.call "delete"]
  val get_: 'tags this -> name:string -> string option [@@js.call "get"]
  val has: 'tags this -> name:string -> bool [@@js.call "has"]
  val set_: 'tags this -> name:string -> value:string -> unit [@@js.call "set"]
  val forEach: 'tags this -> callbackfn:(value:string -> key:string -> parent:t -> unit) -> ?thisArg:any -> unit -> unit [@@js.call "forEach"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: ?init:HeadersInit.t -> unit -> t [@@js.create]
end
and HeadersInit : sig
  type t = (string list list, Headers.t, (string, string) Record.t_2) union3
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module ResponseInit : sig
  type t = [`ResponseInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ResponseInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ResponseInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ResponseInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_headers: 'tags this -> HeadersInit.t option [@@js.get "headers"]
  val set_headers: 'tags this -> HeadersInit.t -> unit [@@js.set "headers"]
  val get_status: 'tags this -> float option [@@js.get "status"]
  val set_status: 'tags this -> float -> unit [@@js.set "status"]
  val get_statusText: 'tags this -> string option [@@js.get "statusText"]
  val set_statusText: 'tags this -> string -> unit [@@js.set "statusText"]
  val create: ?headers:HeadersInit.t -> ?status:float -> ?statusText:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module RequestRedirect : sig
  type t = ([`L_s298_error[@js "error"] | `L_s351_follow[@js "follow"] | `L_s495_manual[@js "manual"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module RequestMode : sig
  type t = ([`L_s225_cors[@js "cors"] | `L_s534_navigate[@js "navigate"] | `L_s544_no_cors[@js "no-cors"] | `L_s692_same_origin[@js "same-origin"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module RequestDestination : sig
  type t = ([`L_s0[@js ""] | `L_s133_audio[@js "audio"] | `L_s139_audioworklet[@js "audioworklet"] | `L_s272_document[@js "document"] | `L_s286_embed[@js "embed"] | `L_s352_font[@js "font"] | `L_s360_frame[@js "frame"] | `L_s415_iframe[@js "iframe"] | `L_s416_image[@js "image"] | `L_s494_manifest[@js "manifest"] | `L_s555_object[@js "object"] | `L_s584_paintworklet[@js "paintworklet"] | `L_s671_report[@js "report"] | `L_s698_script[@js "script"] | `L_s719_sharedworker[@js "sharedworker"] | `L_s764_style[@js "style"] | `L_s811_track[@js "track"] | `L_s852_video[@js "video"] | `L_s873_worker[@js "worker"] | `L_s879_xslt[@js "xslt"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module RequestCredentials : sig
  type t = ([`L_s423_include[@js "include"] | `L_s559_omit[@js "omit"] | `L_s692_same_origin[@js "same-origin"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module RequestCache : sig
  type t = ([`L_s241_default[@js "default"] | `L_s354_force_cache[@js "force-cache"] | `L_s543_no_cache[@js "no-cache"] | `L_s547_no_store[@js "no-store"] | `L_s561_only_if_cached[@js "only-if-cached"] | `L_s662_reload[@js "reload"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module ReferrerPolicy : sig
  type t = ([`L_s0[@js ""] | `L_s545_no_referrer[@js "no-referrer"] | `L_s546_no_referrer_when_downgrade[@js "no-referrer-when-downgrade"] | `L_s571_origin[@js "origin"] | `L_s572_origin_when_cross_origin[@js "origin-when-cross-origin"] | `L_s692_same_origin[@js "same-origin"] | `L_s761_strict_origin[@js "strict-origin"] | `L_s762_strict_origin_when_cross_origin[@js "strict-origin-when-cross-origin"] | `L_s832_unsafe_url[@js "unsafe-url"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module WindowLocalStorage : sig
  type t = [`WindowLocalStorage] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`WindowLocalStorage]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`WindowLocalStorage]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `WindowLocalStorage ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_localStorage: 'tags this -> Storage.t [@@js.get "localStorage"]
  val create: localStorage:Storage.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module StorageEventInit : sig
  type t = [`EventInit | `StorageEventInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventInit | `StorageEventInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventInit | `StorageEventInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `StorageEventInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_key: 'tags this -> string option option [@@js.get "key"]
  val set_key: 'tags this -> string option -> unit [@@js.set "key"]
  val get_newValue: 'tags this -> string option option [@@js.get "newValue"]
  val set_newValue: 'tags this -> string option -> unit [@@js.set "newValue"]
  val get_oldValue: 'tags this -> string option option [@@js.get "oldValue"]
  val set_oldValue: 'tags this -> string option -> unit [@@js.set "oldValue"]
  val get_storageArea: 'tags this -> Storage.t option option [@@js.get "storageArea"]
  val set_storageArea: 'tags this -> Storage.t option -> unit [@@js.set "storageArea"]
  val get_url: 'tags this -> string option [@@js.get "url"]
  val set_url: 'tags this -> string -> unit [@@js.set "url"]
  val create: ?key:string -> ?newValue:string -> ?oldValue:string -> ?storageArea:Storage.t -> ?url:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** A StorageEvent is sent to a window when a storage area it has access to is changed within the context of another document. *)
module[@js.scope "StorageEvent"] StorageEvent : sig
  type t = [`Event | `StorageEvent] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Event | `StorageEvent]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Event | `StorageEvent]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `StorageEvent ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Returns the key of the storage item being changed. *)
  val get_key: 'tags this -> string option [@@js.get "key"]
  
  (** Returns the new value of the key of the storage item whose value is being changed. *)
  val get_newValue: 'tags this -> string option [@@js.get "newValue"]
  
  (** Returns the old value of the key of the storage item whose value is being changed. *)
  val get_oldValue: 'tags this -> string option [@@js.get "oldValue"]
  
  (** Returns the Storage object that was affected. *)
  val get_storageArea: 'tags this -> Storage.t option [@@js.get "storageArea"]
  
  (** Returns the URL of the document whose storage item changed. *)
  val get_url: 'tags this -> string [@@js.get "url"]
  val initStorageEvent: 'tags this -> type_:string -> ?bubbles:bool -> ?cancelable:bool -> ?key:string option -> ?oldValue:string option -> ?newValue:string option -> ?url:([`U1 of string | `U2 of URL.t] [@js.union]) -> ?storageArea:Storage.t option -> unit -> unit [@@js.call "initStorageEvent"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: type_:string -> ?eventInitDict:StorageEventInit.t -> unit -> t [@@js.create]
end
module PromiseRejectionEventInit : sig
  type t = [`EventInit | `PromiseRejectionEventInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventInit | `PromiseRejectionEventInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventInit | `PromiseRejectionEventInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PromiseRejectionEventInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_promise: 'tags this -> any Promise.t_1 [@@js.get "promise"]
  val set_promise: 'tags this -> any Promise.t_1 -> unit [@@js.set "promise"]
  val get_reason: 'tags this -> any option [@@js.get "reason"]
  val set_reason: 'tags this -> any -> unit [@@js.set "reason"]
  val create: promise:any Promise.t_1 -> ?reason:any -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module[@js.scope "PromiseRejectionEvent"] PromiseRejectionEvent : sig
  type t = [`Event | `PromiseRejectionEvent] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Event | `PromiseRejectionEvent]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Event | `PromiseRejectionEvent]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PromiseRejectionEvent ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_promise: 'tags this -> any Promise.t_1 [@@js.get "promise"]
  val get_reason: 'tags this -> any [@@js.get "reason"]
  val create: promise:any Promise.t_1 -> reason:any -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': type_:string -> eventInitDict:PromiseRejectionEventInit.t -> t [@@js.create]
end
module PopStateEventInit : sig
  type t = [`EventInit | `PopStateEventInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventInit | `PopStateEventInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventInit | `PopStateEventInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PopStateEventInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_state: 'tags this -> any option [@@js.get "state"]
  val set_state: 'tags this -> any -> unit [@@js.set "state"]
  val create: ?state:any -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** PopStateEvent is an event handler for the popstate event on the window. *)
module[@js.scope "PopStateEvent"] PopStateEvent : sig
  type t = [`Event | `PopStateEvent] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Event | `PopStateEvent]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Event | `PopStateEvent]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PopStateEvent ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Returns a copy of the information that was provided to pushState() or replaceState(). *)
  val get_state: 'tags this -> any [@@js.get "state"]
  val create: state:any -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': type_:string -> ?eventInitDict:PopStateEventInit.t -> unit -> t [@@js.create]
end
module PageTransitionEventInit : sig
  type t = [`EventInit | `PageTransitionEventInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventInit | `PageTransitionEventInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventInit | `PageTransitionEventInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PageTransitionEventInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_persisted: 'tags this -> bool option [@@js.get "persisted"]
  val set_persisted: 'tags this -> bool -> unit [@@js.set "persisted"]
  val create: ?persisted:bool -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** The PageTransitionEvent is fired when a document is being loaded or unloaded. *)
module[@js.scope "PageTransitionEvent"] PageTransitionEvent : sig
  type t = [`Event | `PageTransitionEvent] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Event | `PageTransitionEvent]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Event | `PageTransitionEvent]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PageTransitionEvent ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    For the pageshow event, returns false if the page is newly being loaded (and the load event will fire). Otherwise, returns true.
    
    For the pagehide event, returns false if the page is going away for the last time. Otherwise, returns true, meaning that (if nothing conspires to make the page unsalvageable) the page might be reused if the user navigates back to this page.
    
    Things that can cause the page to be unsalvageable include:
    
    The user agent decided to not keep the Document alive in a session history entry after unload
    Having iframes that are not salvageable
    Active WebSocket objects
    Aborting a Document
  *)
  val get_persisted: 'tags this -> bool [@@js.get "persisted"]
  val create: persisted:bool -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': type_:string -> ?eventInitDict:PageTransitionEventInit.t -> unit -> t [@@js.create]
end
module HashChangeEventInit : sig
  type t = [`EventInit | `HashChangeEventInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventInit | `HashChangeEventInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventInit | `HashChangeEventInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HashChangeEventInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_newURL: 'tags this -> string option [@@js.get "newURL"]
  val set_newURL: 'tags this -> string -> unit [@@js.set "newURL"]
  val get_oldURL: 'tags this -> string option [@@js.get "oldURL"]
  val set_oldURL: 'tags this -> string -> unit [@@js.set "oldURL"]
  val create: ?newURL:string -> ?oldURL:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** Events that fire when the fragment identifier of the URL has changed. *)
module[@js.scope "HashChangeEvent"] HashChangeEvent : sig
  type t = [`Event | `HashChangeEvent] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Event | `HashChangeEvent]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Event | `HashChangeEvent]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HashChangeEvent ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Returns the URL of the session history entry that is now current. *)
  val get_newURL: 'tags this -> string [@@js.get "newURL"]
  
  (** Returns the URL of the session history entry that was previously current. *)
  val get_oldURL: 'tags this -> string [@@js.get "oldURL"]
  val create: newURL:string -> oldURL:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': type_:string -> ?eventInitDict:HashChangeEventInit.t -> unit -> t [@@js.create]
end
module GamepadMappingType : sig
  type t = ([`L_s0[@js ""] | `L_s753_standard[@js "standard"] | `L_s878_xr_standard[@js "xr-standard"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module GamepadHapticActuatorType : sig
  type t = ([`L_s851_vibration[@js "vibration"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end

(** This Gamepad API interface represents hardware in the controller designed to provide haptic feedback to the user (if available), most commonly vibration hardware. *)
module[@js.scope "GamepadHapticActuator"] GamepadHapticActuator : sig
  type t = [`GamepadHapticActuator] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`GamepadHapticActuator]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`GamepadHapticActuator]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `GamepadHapticActuator ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_type: 'tags this -> GamepadHapticActuatorType.t [@@js.get "type"]
  val create: type_:(GamepadHapticActuatorType.t[@js "type"]) -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end

(**
  An individual button of a gamepad or other controller, allowing access to the current state of different types of buttons available on the control device.
  Available only in secure contexts.
*)
module[@js.scope "GamepadButton"] GamepadButton : sig
  type t = [`GamepadButton] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`GamepadButton]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`GamepadButton]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `GamepadButton ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_pressed: 'tags this -> bool [@@js.get "pressed"]
  val get_touched: 'tags this -> bool [@@js.get "touched"]
  val get_value: 'tags this -> float [@@js.get "value"]
  val create: pressed:bool -> touched:bool -> value:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end

(**
  This Gamepad API interface defines an individual gamepad or other controller, allowing access to information such as button presses, axis positions, and id.
  Available only in secure contexts.
*)
module[@js.scope "Gamepad"] Gamepad : sig
  type t = [`Gamepad] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Gamepad]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Gamepad]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `Gamepad ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_axes: 'tags this -> float list [@@js.get "axes"]
  val get_buttons: 'tags this -> GamepadButton.t list [@@js.get "buttons"]
  val get_connected: 'tags this -> bool [@@js.get "connected"]
  val get_hapticActuators: 'tags this -> GamepadHapticActuator.t list [@@js.get "hapticActuators"]
  val get_id: 'tags this -> string [@@js.get "id"]
  val get_index: 'tags this -> float [@@js.get "index"]
  val get_mapping: 'tags this -> GamepadMappingType.t [@@js.get "mapping"]
  val get_timestamp: 'tags this -> DOMHighResTimeStamp.t [@@js.get "timestamp"]
  val create: axes:float list -> buttons:GamepadButton.t list -> connected:bool -> hapticActuators:GamepadHapticActuator.t list -> id:string -> index:float -> mapping:GamepadMappingType.t -> timestamp:DOMHighResTimeStamp.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end
module GamepadEventInit : sig
  type t = [`EventInit | `GamepadEventInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventInit | `GamepadEventInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventInit | `GamepadEventInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `GamepadEventInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_gamepad: 'tags this -> Gamepad.t [@@js.get "gamepad"]
  val set_gamepad: 'tags this -> Gamepad.t -> unit [@@js.set "gamepad"]
  val create: gamepad:Gamepad.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(**
  This Gamepad API interface contains references to gamepads connected to the system, which is what the gamepad events Window.gamepadconnected and Window.gamepaddisconnected are fired in response to.
  Available only in secure contexts.
*)
module[@js.scope "GamepadEvent"] GamepadEvent : sig
  type t = [`Event | `GamepadEvent] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Event | `GamepadEvent]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Event | `GamepadEvent]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `GamepadEvent ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_gamepad: 'tags this -> Gamepad.t [@@js.get "gamepad"]
  val create: gamepad:Gamepad.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': type_:string -> eventInitDict:GamepadEventInit.t -> t [@@js.create]
end

(** The beforeunload event is fired when the window, the document and its resources are about to be unloaded. *)
module[@js.scope "BeforeUnloadEvent"] BeforeUnloadEvent : sig
  type t = [`BeforeUnloadEvent | `Event] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`BeforeUnloadEvent | `Event]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`BeforeUnloadEvent | `Event]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `BeforeUnloadEvent ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_returnValue: 'tags this -> any [@@js.get "returnValue"]
  val set_returnValue: 'tags this -> any -> unit [@@js.set "returnValue"]
  val create: returnValue:any -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end
module ScrollToOptions : sig
  type t = [`ScrollOptions | `ScrollToOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ScrollOptions | `ScrollToOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ScrollOptions | `ScrollToOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ScrollToOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_left: 'tags this -> float option [@@js.get "left"]
  val set_left: 'tags this -> float -> unit [@@js.set "left"]
  val get_top: 'tags this -> float option [@@js.get "top"]
  val set_top: 'tags this -> float -> unit [@@js.set "top"]
  val create: ?left:float -> ?top:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** A screen, usually the one on which the current window is being rendered, and is obtained using window.screen. *)
module[@js.scope "Screen"] Screen : sig
  type t = [`Screen] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Screen]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Screen]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `Screen ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_availHeight: 'tags this -> float [@@js.get "availHeight"]
  val get_availWidth: 'tags this -> float [@@js.get "availWidth"]
  val get_colorDepth: 'tags this -> float [@@js.get "colorDepth"]
  val get_height: 'tags this -> float [@@js.get "height"]
  val get_orientation: 'tags this -> ScreenOrientation.t [@@js.get "orientation"]
  val get_pixelDepth: 'tags this -> float [@@js.get "pixelDepth"]
  val get_width: 'tags this -> float [@@js.get "width"]
  val create: availHeight:float -> availWidth:float -> colorDepth:float -> height:float -> orientation:ScreenOrientation.t -> pixelDepth:float -> width:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end
module FilePropertyBag : sig
  type t = [`BlobPropertyBag | `FilePropertyBag] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`BlobPropertyBag | `FilePropertyBag]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`BlobPropertyBag | `FilePropertyBag]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `FilePropertyBag ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_lastModified: 'tags this -> float option [@@js.get "lastModified"]
  val set_lastModified: 'tags this -> float -> unit [@@js.set "lastModified"]
  val create: ?lastModified:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** Provides information about files and allows JavaScript in a web page to access their content. *)
module[@js.scope "File"] File : sig
  type t = [`Blob | `File] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Blob | `File]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Blob | `File]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `File ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_lastModified: 'tags this -> float [@@js.get "lastModified"]
  val get_name: 'tags this -> string [@@js.get "name"]
  val get_webkitRelativePath: 'tags this -> string [@@js.get "webkitRelativePath"]
  val create: lastModified:float -> name:string -> webkitRelativePath:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': fileBits:BlobPart.t list -> fileName:string -> ?options:FilePropertyBag.t -> unit -> t [@@js.create]
end
module ShareData : sig
  type t = [`ShareData] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ShareData]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ShareData]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ShareData ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_files: 'tags this -> File.t list option [@@js.get "files"]
  val set_files: 'tags this -> File.t list -> unit [@@js.set "files"]
  val get_text: 'tags this -> string option [@@js.get "text"]
  val set_text: 'tags this -> string -> unit [@@js.set "text"]
  val get_title: 'tags this -> string option [@@js.get "title"]
  val set_title: 'tags this -> string -> unit [@@js.set "title"]
  val get_url: 'tags this -> string option [@@js.get "url"]
  val set_url: 'tags this -> string -> unit [@@js.set "url"]
  val create: ?files:File.t list -> ?text:string -> ?title:string -> ?url:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module PushSubscriptionOptionsInit : sig
  type t = [`PushSubscriptionOptionsInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`PushSubscriptionOptionsInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`PushSubscriptionOptionsInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PushSubscriptionOptionsInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_applicationServerKey: 'tags this -> ([`String of string | `Null | `Other of BufferSource.t] [@js.union on_field "dummy"]) Primitive.t option [@@js.get "applicationServerKey"]
  val set_applicationServerKey: 'tags this -> ([`Null | `U1 of BufferSource.t | `U2 of string] [@js.union]) -> unit [@@js.set "applicationServerKey"]
  val get_userVisibleOnly: 'tags this -> bool option [@@js.get "userVisibleOnly"]
  val set_userVisibleOnly: 'tags this -> bool -> unit [@@js.set "userVisibleOnly"]
  val create: ?applicationServerKey:([`String of string | `Other of BufferSource.t] [@js.union on_field "dummy"]) Primitive.t -> ?userVisibleOnly:bool -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** Available only in secure contexts. *)
module[@js.scope "PushSubscriptionOptions"] PushSubscriptionOptions : sig
  type t = [`PushSubscriptionOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`PushSubscriptionOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`PushSubscriptionOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PushSubscriptionOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_applicationServerKey: 'tags this -> ArrayBuffer.t_0 option [@@js.get "applicationServerKey"]
  val create: ?applicationServerKey:ArrayBuffer.t_0 -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end
module EpochTimeStamp : sig
  type t = float
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module PushSubscriptionJSON : sig
  type t = [`PushSubscriptionJSON] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`PushSubscriptionJSON]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`PushSubscriptionJSON]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PushSubscriptionJSON ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_endpoint: 'tags this -> string option [@@js.get "endpoint"]
  val set_endpoint: 'tags this -> string -> unit [@@js.set "endpoint"]
  val get_expirationTime: 'tags this -> EpochTimeStamp.t option option [@@js.get "expirationTime"]
  val set_expirationTime: 'tags this -> EpochTimeStamp.t option -> unit [@@js.set "expirationTime"]
  val get_keys: 'tags this -> (string, string) Record.t_2 option [@@js.get "keys"]
  val set_keys: 'tags this -> (string, string) Record.t_2 -> unit [@@js.set "keys"]
  val create: ?endpoint:string -> ?expirationTime:EpochTimeStamp.t -> ?keys:(string, string) Record.t_2 -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module PushEncryptionKeyName : sig
  type t = ([`L_s140_auth[@js "auth"] | `L_s580_p256dh[@js "p256dh"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end

(**
  This Push API interface provides a subcription's URL endpoint and allows unsubscription from a push service.
  Available only in secure contexts.
*)
module[@js.scope "PushSubscription"] PushSubscription : sig
  type t = [`PushSubscription] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`PushSubscription]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`PushSubscription]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PushSubscription ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_endpoint: 'tags this -> string [@@js.get "endpoint"]
  val get_options: 'tags this -> PushSubscriptionOptions.t [@@js.get "options"]
  val getKey: 'tags this -> name:PushEncryptionKeyName.t -> ArrayBuffer.t_0 option [@@js.call "getKey"]
  val toJSON: 'tags this -> PushSubscriptionJSON.t [@@js.call "toJSON"]
  val unsubscribe: 'tags this -> bool Promise.t_1 [@@js.call "unsubscribe"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module PermissionState : sig
  type t = ([`L_s244_denied[@js "denied"] | `L_s374_granted[@js "granted"] | `L_s640_prompt[@js "prompt"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end

(**
  This Push API interface provides a way to receive notifications from third-party servers as well as request URLs for push notifications.
  Available only in secure contexts.
*)
module[@js.scope "PushManager"] PushManager : sig
  type t = [`PushManager] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`PushManager]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`PushManager]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PushManager ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val getSubscription: 'tags this -> PushSubscription.t option Promise.t_1 [@@js.call "getSubscription"]
  val permissionState: 'tags this -> ?options:PushSubscriptionOptionsInit.t -> unit -> PermissionState.t Promise.t_1 [@@js.call "permissionState"]
  val subscribe: 'tags this -> ?options:PushSubscriptionOptionsInit.t -> unit -> PushSubscription.t Promise.t_1 [@@js.call "subscribe"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
  val supportedContentEncodings: unit -> string list [@@js.get "supportedContentEncodings"]
end
module NotificationPermission : sig
  type t = ([`L_s241_default[@js "default"] | `L_s244_denied[@js "denied"] | `L_s374_granted[@js "granted"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module NotificationPermissionCallback : sig
  type t = [`NotificationPermissionCallback] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`NotificationPermissionCallback]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`NotificationPermissionCallback]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `NotificationPermissionCallback ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val apply: 'tags this -> permission:NotificationPermission.t -> unit [@@js.apply]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module VibratePattern : sig
  type t = ([`Number of float | `Other of float list] [@js.union on_field "dummy"]) Primitive.t
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module NotificationAction : sig
  type t = [`NotificationAction] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`NotificationAction]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`NotificationAction]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `NotificationAction ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_action: 'tags this -> string [@@js.get "action"]
  val set_action: 'tags this -> string -> unit [@@js.set "action"]
  val get_icon: 'tags this -> string option [@@js.get "icon"]
  val set_icon: 'tags this -> string -> unit [@@js.set "icon"]
  val get_title: 'tags this -> string [@@js.get "title"]
  val set_title: 'tags this -> string -> unit [@@js.set "title"]
  val create: action:string -> ?icon:string -> title:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module NotificationDirection : sig
  type t = ([`L_s141_auto[@js "auto"] | `L_s489_ltr[@js "ltr"] | `L_s687_rtl[@js "rtl"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module NotificationOptions : sig
  type t = [`NotificationOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`NotificationOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`NotificationOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `NotificationOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_actions: 'tags this -> NotificationAction.t list option [@@js.get "actions"]
  val set_actions: 'tags this -> NotificationAction.t list -> unit [@@js.set "actions"]
  val get_badge: 'tags this -> string option [@@js.get "badge"]
  val set_badge: 'tags this -> string -> unit [@@js.set "badge"]
  val get_body: 'tags this -> string option [@@js.get "body"]
  val set_body: 'tags this -> string -> unit [@@js.set "body"]
  val get_data: 'tags this -> any option [@@js.get "data"]
  val set_data: 'tags this -> any -> unit [@@js.set "data"]
  val get_dir: 'tags this -> NotificationDirection.t option [@@js.get "dir"]
  val set_dir: 'tags this -> NotificationDirection.t -> unit [@@js.set "dir"]
  val get_icon: 'tags this -> string option [@@js.get "icon"]
  val set_icon: 'tags this -> string -> unit [@@js.set "icon"]
  val get_image: 'tags this -> string option [@@js.get "image"]
  val set_image: 'tags this -> string -> unit [@@js.set "image"]
  val get_lang: 'tags this -> string option [@@js.get "lang"]
  val set_lang: 'tags this -> string -> unit [@@js.set "lang"]
  val get_renotify: 'tags this -> bool option [@@js.get "renotify"]
  val set_renotify: 'tags this -> bool -> unit [@@js.set "renotify"]
  val get_requireInteraction: 'tags this -> bool option [@@js.get "requireInteraction"]
  val set_requireInteraction: 'tags this -> bool -> unit [@@js.set "requireInteraction"]
  val get_silent: 'tags this -> bool option [@@js.get "silent"]
  val set_silent: 'tags this -> bool -> unit [@@js.set "silent"]
  val get_tag: 'tags this -> string option [@@js.get "tag"]
  val set_tag: 'tags this -> string -> unit [@@js.set "tag"]
  val get_timestamp: 'tags this -> EpochTimeStamp.t option [@@js.get "timestamp"]
  val set_timestamp: 'tags this -> EpochTimeStamp.t -> unit [@@js.set "timestamp"]
  val get_vibrate: 'tags this -> VibratePattern.t option [@@js.get "vibrate"]
  val set_vibrate: 'tags this -> VibratePattern.t -> unit [@@js.set "vibrate"]
  val create: ?actions:NotificationAction.t list -> ?badge:string -> ?body:string -> ?data:any -> ?dir:NotificationDirection.t -> ?icon:string -> ?image:string -> ?lang:string -> ?renotify:bool -> ?requireInteraction:bool -> ?silent:bool -> ?tag:string -> ?timestamp:EpochTimeStamp.t -> ?vibrate:VibratePattern.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** This Notifications API interface is used to configure and display desktop notifications to the user. *)
module[@js.scope "Notification"] Notification : sig
  type t = [`EventTarget | `Notification] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventTarget | `Notification]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventTarget | `Notification]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `Notification ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_body: 'tags this -> string [@@js.get "body"]
  val get_data: 'tags this -> any [@@js.get "data"]
  val get_dir: 'tags this -> NotificationDirection.t [@@js.get "dir"]
  val get_icon: 'tags this -> string [@@js.get "icon"]
  val get_lang: 'tags this -> string [@@js.get "lang"]
  val get_onclick: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onclick"]
  val set_onclick: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onclick"]
  val get_onclose: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onclose"]
  val set_onclose: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onclose"]
  val get_onerror: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onerror"]
  val set_onerror: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onerror"]
  val get_onshow: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onshow"]
  val set_onshow: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onshow"]
  val get_tag: 'tags this -> string [@@js.get "tag"]
  val get_title: 'tags this -> string [@@js.get "title"]
  val close: 'tags this -> unit [@@js.call "close"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'NotificationEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'NotificationEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: title:string -> ?options:NotificationOptions.t -> unit -> t [@@js.create]
  val permission: unit -> NotificationPermission.t [@@js.get "permission"]
  val requestPermission: ?deprecatedCallback:NotificationPermissionCallback.t -> unit -> NotificationPermission.t Promise.t_1 [@@js.global "requestPermission"]
end
module GetNotificationOptions : sig
  type t = [`GetNotificationOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`GetNotificationOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`GetNotificationOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `GetNotificationOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_tag: 'tags this -> string option [@@js.get "tag"]
  val set_tag: 'tags this -> string -> unit [@@js.set "tag"]
  val create: ?tag:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module WorkerType : sig
  type t = ([`L_s195_classic[@js "classic"] | `L_s517_module[@js "module"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module ServiceWorkerUpdateViaCache : sig
  type t = ([`L_s106_all[@js "all"] | `L_s419_imports[@js "imports"] | `L_s548_none[@js "none"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module RegistrationOptions : sig
  type t = [`RegistrationOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`RegistrationOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`RegistrationOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RegistrationOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_scope: 'tags this -> string option [@@js.get "scope"]
  val set_scope: 'tags this -> string -> unit [@@js.set "scope"]
  val get_type: 'tags this -> WorkerType.t option [@@js.get "type"]
  val set_type: 'tags this -> WorkerType.t -> unit [@@js.set "type"]
  val get_updateViaCache: 'tags this -> ServiceWorkerUpdateViaCache.t option [@@js.get "updateViaCache"]
  val set_updateViaCache: 'tags this -> ServiceWorkerUpdateViaCache.t -> unit [@@js.set "updateViaCache"]
  val create: ?scope:string -> ?type_:(WorkerType.t[@js "type"]) -> ?updateViaCache:ServiceWorkerUpdateViaCache.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module ServiceWorkerState : sig
  type t = ([`L_s431_installed[@js "installed"] | `L_s432_installing[@js "installing"] | `L_s586_parsed[@js "parsed"] | `L_s656_redundant[@js "redundant"] | `L_s96_activated[@js "activated"] | `L_s97_activating[@js "activating"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module ErrorEventInit : sig
  type t = [`ErrorEventInit | `EventInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ErrorEventInit | `EventInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ErrorEventInit | `EventInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ErrorEventInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_colno: 'tags this -> float option [@@js.get "colno"]
  val set_colno: 'tags this -> float -> unit [@@js.set "colno"]
  val get_error: 'tags this -> any option [@@js.get "error"]
  val set_error: 'tags this -> any -> unit [@@js.set "error"]
  val get_filename: 'tags this -> string option [@@js.get "filename"]
  val set_filename: 'tags this -> string -> unit [@@js.set "filename"]
  val get_lineno: 'tags this -> float option [@@js.get "lineno"]
  val set_lineno: 'tags this -> float -> unit [@@js.set "lineno"]
  val get_message: 'tags this -> string option [@@js.get "message"]
  val set_message: 'tags this -> string -> unit [@@js.set "message"]
  val create: ?colno:float -> ?error:any -> ?filename:string -> ?lineno:float -> ?message:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** Events providing information related to errors in scripts or in files. *)
module[@js.scope "ErrorEvent"] ErrorEvent : sig
  type t = [`ErrorEvent | `Event] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ErrorEvent | `Event]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ErrorEvent | `Event]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ErrorEvent ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_colno: 'tags this -> float [@@js.get "colno"]
  val get_error: 'tags this -> any [@@js.get "error"]
  val get_filename: 'tags this -> string [@@js.get "filename"]
  val get_lineno: 'tags this -> float [@@js.get "lineno"]
  val get_message: 'tags this -> string [@@js.get "message"]
  val create: colno:float -> error:any -> filename:string -> lineno:float -> message:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': type_:string -> ?eventInitDict:ErrorEventInit.t -> unit -> t [@@js.create]
end
module AbstractWorker : sig
  type t = [`AbstractWorker] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AbstractWorker]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AbstractWorker]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `AbstractWorker ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_onerror: 'tags this -> (this:t -> ev:ErrorEvent.t -> any) option [@@js.get "onerror"]
  val set_onerror: 'tags this -> (this:t -> ev:ErrorEvent.t -> any) option -> unit [@@js.set "onerror"]
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'AbstractWorkerEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'AbstractWorkerEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module[@js.scope "ImageBitmap"] ImageBitmap : sig
  type t = [`ImageBitmap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ImageBitmap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ImageBitmap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ImageBitmap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Returns the intrinsic height of the image, in CSS pixels. *)
  val get_height: 'tags this -> float [@@js.get "height"]
  
  (** Returns the intrinsic width of the image, in CSS pixels. *)
  val get_width: 'tags this -> float [@@js.get "width"]
  
  (** Releases imageBitmap's underlying bitmap data. *)
  val close: 'tags this -> unit [@@js.call "close"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module[@js.scope "PermissionStatus"] PermissionStatus : sig
  type t = [`EventTarget | `PermissionStatus] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventTarget | `PermissionStatus]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventTarget | `PermissionStatus]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PermissionStatus ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_onchange: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onchange"]
  val set_onchange: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onchange"]
  val get_state: 'tags this -> PermissionState.t [@@js.get "state"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'PermissionStatusEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'PermissionStatusEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module PermissionName : sig
  type t = ([`L_s370_geolocation[@js "geolocation"] | `L_s554_notifications[@js "notifications"] | `L_s600_persistent_storage[@js "persistent-storage"] | `L_s643_push[@js "push"] | `L_s697_screen_wake_lock[@js "screen-wake-lock"] | `L_s877_xr_spatial_tracking[@js "xr-spatial-tracking"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module PermissionDescriptor : sig
  type t = [`PermissionDescriptor] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`PermissionDescriptor]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`PermissionDescriptor]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PermissionDescriptor ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_name: 'tags this -> PermissionName.t [@@js.get "name"]
  val set_name: 'tags this -> PermissionName.t -> unit [@@js.set "name"]
  val create: name:PermissionName.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module[@js.scope "Permissions"] Permissions : sig
  type t = [`Permissions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Permissions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Permissions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `Permissions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val query: 'tags this -> permissionDesc:PermissionDescriptor.t -> PermissionStatus.t Promise.t_1 [@@js.call "query"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module StorageEstimate : sig
  type t = [`StorageEstimate] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`StorageEstimate]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`StorageEstimate]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `StorageEstimate ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_quota: 'tags this -> float option [@@js.get "quota"]
  val set_quota: 'tags this -> float -> unit [@@js.set "quota"]
  val get_usage: 'tags this -> float option [@@js.get "usage"]
  val set_usage: 'tags this -> float -> unit [@@js.set "usage"]
  val create: ?quota:float -> ?usage:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module FileSystemRemoveOptions : sig
  type t = [`FileSystemRemoveOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`FileSystemRemoveOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`FileSystemRemoveOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `FileSystemRemoveOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_recursive: 'tags this -> bool option [@@js.get "recursive"]
  val set_recursive: 'tags this -> bool -> unit [@@js.set "recursive"]
  val create: ?recursive:bool -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module FileSystemGetFileOptions : sig
  type t = [`FileSystemGetFileOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`FileSystemGetFileOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`FileSystemGetFileOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `FileSystemGetFileOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_create: 'tags this -> bool option [@@js.get "create"]
  val set_create: 'tags this -> bool -> unit [@@js.set "create"]
  val create: ?create_:(bool[@js "create"]) -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module FileSystemGetDirectoryOptions : sig
  type t = [`FileSystemGetDirectoryOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`FileSystemGetDirectoryOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`FileSystemGetDirectoryOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `FileSystemGetDirectoryOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_create: 'tags this -> bool option [@@js.get "create"]
  val set_create: 'tags this -> bool -> unit [@@js.set "create"]
  val create: ?create_:(bool[@js "create"]) -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module FileSystemHandleKind : sig
  type t = ([`L_s263_directory[@js "directory"] | `L_s343_file[@js "file"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end

(** Available only in secure contexts. *)
module[@js.scope "FileSystemHandle"] FileSystemHandle : sig
  type t = [`FileSystemHandle] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`FileSystemHandle]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`FileSystemHandle]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `FileSystemHandle ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_kind: 'tags this -> FileSystemHandleKind.t [@@js.get "kind"]
  val get_name: 'tags this -> string [@@js.get "name"]
  val isSameEntry: 'tags this -> other:t -> bool Promise.t_1 [@@js.call "isSameEntry"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Available only in secure contexts. *)
module[@js.scope "FileSystemFileHandle"] FileSystemFileHandle : sig
  type t = [`FileSystemFileHandle | `FileSystemHandle] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`FileSystemFileHandle | `FileSystemHandle]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`FileSystemFileHandle | `FileSystemHandle]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `FileSystemFileHandle ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_kind: 'tags this -> ([`L_s343_file[@js "file"]] [@js.enum]) [@@js.get "kind"]
  val getFile: 'tags this -> File.t Promise.t_1 [@@js.call "getFile"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Available only in secure contexts. *)
module[@js.scope "FileSystemDirectoryHandle"] FileSystemDirectoryHandle : sig
  type t = [`FileSystemDirectoryHandle | `FileSystemHandle] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`FileSystemDirectoryHandle | `FileSystemHandle]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`FileSystemDirectoryHandle | `FileSystemHandle]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `FileSystemDirectoryHandle ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_kind: 'tags this -> ([`L_s263_directory[@js "directory"]] [@js.enum]) [@@js.get "kind"]
  val getDirectoryHandle: 'tags this -> name:string -> ?options:FileSystemGetDirectoryOptions.t -> unit -> t Promise.t_1 [@@js.call "getDirectoryHandle"]
  val getFileHandle: 'tags this -> name:string -> ?options:FileSystemGetFileOptions.t -> unit -> FileSystemFileHandle.t Promise.t_1 [@@js.call "getFileHandle"]
  val removeEntry: 'tags this -> name:string -> ?options:FileSystemRemoveOptions.t -> unit -> unit Promise.t_1 [@@js.call "removeEntry"]
  val resolve: 'tags this -> possibleDescendant:FileSystemHandle.t -> string list option Promise.t_1 [@@js.call "resolve"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Available only in secure contexts. *)
module[@js.scope "StorageManager"] StorageManager : sig
  type t = [`StorageManager] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`StorageManager]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`StorageManager]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `StorageManager ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val estimate: 'tags this -> StorageEstimate.t Promise.t_1 [@@js.call "estimate"]
  val getDirectory: 'tags this -> FileSystemDirectoryHandle.t Promise.t_1 [@@js.call "getDirectory"]
  val persist: 'tags this -> bool Promise.t_1 [@@js.call "persist"]
  val persisted: 'tags this -> bool Promise.t_1 [@@js.call "persisted"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Available only in secure contexts. *)
module NavigatorStorage : sig
  type t = [`NavigatorStorage] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`NavigatorStorage]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`NavigatorStorage]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `NavigatorStorage ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_storage: 'tags this -> StorageManager.t [@@js.get "storage"]
  val create: storage:StorageManager.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** Provides contains information about a MIME type associated with a particular plugin. NavigatorPlugins.mimeTypes returns an array of this object. *)
module[@js.scope "MimeType"] rec MimeType : sig
  type t = [`MimeType] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`MimeType]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`MimeType]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MimeType ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    Returns the MIME type's description.
    @deprecated 
  *)
  val get_description: 'tags this -> string [@@js.get "description"]
  
  (**
    Returns the Plugin object that implements this MIME type.
    @deprecated 
  *)
  val get_enabledPlugin: 'tags this -> Plugin.t [@@js.get "enabledPlugin"]
  
  (**
    Returns the MIME type's typical file extensions, in a comma-separated list.
    @deprecated 
  *)
  val get_suffixes: 'tags this -> string [@@js.get "suffixes"]
  
  (**
    Returns the MIME type.
    @deprecated 
  *)
  val get_type: 'tags this -> string [@@js.get "type"]
  val create: description:string -> enabledPlugin:Plugin.t -> suffixes:string -> type_:(string[@js "type"]) -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end

(** Provides information about a browser plugin. *)
and[@js.scope "Plugin"] Plugin : sig
  type t = [`Plugin | MimeType.t ArrayLike.tags_1 | MimeType.t IterableIterator.tags_1] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Plugin | MimeType.t ArrayLike.tags_1 | MimeType.t IterableIterator.tags_1]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Plugin | MimeType.t ArrayLike.tags_1 | MimeType.t IterableIterator.tags_1]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `Plugin ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  (* [Symbol.iterator]: unit -> MimeType.t IterableIterator.t_1 *)
  
  (**
    Returns the plugin's description.
    @deprecated 
  *)
  val get_description: 'tags this -> string [@@js.get "description"]
  
  (**
    Returns the plugin library's filename, if applicable on the current platform.
    @deprecated 
  *)
  val get_filename: 'tags this -> string [@@js.get "filename"]
  
  (**
    Returns the number of MIME types, represented by MimeType objects, supported by the plugin.
    @deprecated 
  *)
  val get_length: 'tags this -> float [@@js.get "length"]
  
  (**
    Returns the plugin's name.
    @deprecated 
  *)
  val get_name: 'tags this -> string [@@js.get "name"]
  
  (**
    Returns the specified MimeType object.
    @deprecated 
  *)
  val item: 'tags this -> index:float -> MimeType.t option [@@js.call "item"]
  
  (** @deprecated  *)
  val namedItem: 'tags this -> name:string -> MimeType.t option [@@js.call "namedItem"]
  val get: 'tags this -> float -> MimeType.t [@@js.index_get]
  val set: 'tags this -> float -> MimeType.t -> unit [@@js.index_set]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Used to store a list of Plugin objects describing the available plugins; it's returned by the window.navigator.plugins property. The PluginArray is not a JavaScript array, but has the length property and supports accessing individual items using bracket notation (plugins\[2\]), as well as via item(index) and namedItem("name") methods. *)
module[@js.scope "PluginArray"] PluginArray : sig
  type t = [`PluginArray | Plugin.t ArrayLike.tags_1 | Plugin.t IterableIterator.tags_1] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`PluginArray | Plugin.t ArrayLike.tags_1 | Plugin.t IterableIterator.tags_1]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`PluginArray | Plugin.t ArrayLike.tags_1 | Plugin.t IterableIterator.tags_1]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PluginArray ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  (* [Symbol.iterator]: unit -> Plugin.t IterableIterator.t_1 *)
  
  (** @deprecated  *)
  val get_length: 'tags this -> float [@@js.get "length"]
  
  (** @deprecated  *)
  val item: 'tags this -> index:float -> Plugin.t option [@@js.call "item"]
  
  (** @deprecated  *)
  val namedItem: 'tags this -> name:string -> Plugin.t option [@@js.call "namedItem"]
  
  (** @deprecated  *)
  val refresh: 'tags this -> unit [@@js.call "refresh"]
  val get: 'tags this -> float -> Plugin.t [@@js.index_get]
  val set: 'tags this -> float -> Plugin.t -> unit [@@js.index_set]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Returns an array of MimeType instances, each of which contains information about a supported browser plugins. This object is returned by NavigatorPlugins.mimeTypes. *)
module[@js.scope "MimeTypeArray"] MimeTypeArray : sig
  type t = [`MimeTypeArray | MimeType.t ArrayLike.tags_1 | MimeType.t IterableIterator.tags_1] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`MimeTypeArray | MimeType.t ArrayLike.tags_1 | MimeType.t IterableIterator.tags_1]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`MimeTypeArray | MimeType.t ArrayLike.tags_1 | MimeType.t IterableIterator.tags_1]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MimeTypeArray ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  (* [Symbol.iterator]: unit -> MimeType.t IterableIterator.t_1 *)
  
  (** @deprecated  *)
  val get_length: 'tags this -> float [@@js.get "length"]
  
  (** @deprecated  *)
  val item: 'tags this -> index:float -> MimeType.t option [@@js.call "item"]
  
  (** @deprecated  *)
  val namedItem: 'tags this -> name:string -> MimeType.t option [@@js.call "namedItem"]
  val get: 'tags this -> float -> MimeType.t [@@js.index_get]
  val set: 'tags this -> float -> MimeType.t -> unit [@@js.index_set]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module NavigatorPlugins : sig
  type t = [`NavigatorPlugins] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`NavigatorPlugins]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`NavigatorPlugins]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `NavigatorPlugins ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** @deprecated  *)
  val get_mimeTypes: 'tags this -> MimeTypeArray.t [@@js.get "mimeTypes"]
  
  (** @deprecated  *)
  val get_plugins: 'tags this -> PluginArray.t [@@js.get "plugins"]
  
  (** @deprecated  *)
  val javaEnabled: 'tags this -> bool [@@js.call "javaEnabled"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module NavigatorOnLine : sig
  type t = [`NavigatorOnLine] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`NavigatorOnLine]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`NavigatorOnLine]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `NavigatorOnLine ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_onLine: 'tags this -> bool [@@js.get "onLine"]
  val create: onLine:bool -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module ConnectionType : sig
  type t = ([`L_s164_bluetooth[@js "bluetooth"] | `L_s184_cellular[@js "cellular"] | `L_s299_ethernet[@js "ethernet"] | `L_s516_mixed[@js "mixed"] | `L_s548_none[@js "none"] | `L_s573_other[@js "other"] | `L_s828_unknown[@js "unknown"] | `L_s871_wifi[@js "wifi"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module[@js.scope "NetworkInformation"] NetworkInformation : sig
  type t = [`EventTarget | `NetworkInformation] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventTarget | `NetworkInformation]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventTarget | `NetworkInformation]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `NetworkInformation ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_type: 'tags this -> ConnectionType.t [@@js.get "type"]
  val create: type_:(ConnectionType.t[@js "type"]) -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end
module NavigatorNetworkInformation : sig
  type t = [`NavigatorNetworkInformation] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`NavigatorNetworkInformation]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`NavigatorNetworkInformation]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `NavigatorNetworkInformation ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_connection: 'tags this -> NetworkInformation.t [@@js.get "connection"]
  val create: connection:NetworkInformation.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module NavigatorLanguage : sig
  type t = [`NavigatorLanguage] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`NavigatorLanguage]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`NavigatorLanguage]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `NavigatorLanguage ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_language: 'tags this -> string [@@js.get "language"]
  val get_languages: 'tags this -> string list [@@js.get "languages"]
  val create: language:string -> languages:string list -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module NavigatorID : sig
  type t = [`NavigatorID] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`NavigatorID]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`NavigatorID]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `NavigatorID ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** @deprecated  *)
  val get_appCodeName: 'tags this -> string [@@js.get "appCodeName"]
  
  (** @deprecated  *)
  val get_appName: 'tags this -> string [@@js.get "appName"]
  
  (** @deprecated  *)
  val get_appVersion: 'tags this -> string [@@js.get "appVersion"]
  
  (** @deprecated  *)
  val get_platform: 'tags this -> string [@@js.get "platform"]
  
  (** @deprecated  *)
  val get_product: 'tags this -> string [@@js.get "product"]
  
  (** @deprecated  *)
  val get_productSub: 'tags this -> string [@@js.get "productSub"]
  val get_userAgent: 'tags this -> string [@@js.get "userAgent"]
  val get_vendor: 'tags this -> string [@@js.get "vendor"]
  
  (** @deprecated  *)
  val get_vendorSub: 'tags this -> string [@@js.get "vendorSub"]
  val create: appCodeName:string -> appName:string -> appVersion:string -> platform:string -> product:string -> productSub:string -> userAgent:string -> vendor:string -> vendorSub:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module NavigatorCookies : sig
  type t = [`NavigatorCookies] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`NavigatorCookies]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`NavigatorCookies]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `NavigatorCookies ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_cookieEnabled: 'tags this -> bool [@@js.get "cookieEnabled"]
  val create: cookieEnabled:bool -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module NavigatorContentUtils : sig
  type t = [`NavigatorContentUtils] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`NavigatorContentUtils]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`NavigatorContentUtils]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `NavigatorContentUtils ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Available only in secure contexts. *)
  val registerProtocolHandler: 'tags this -> scheme:string -> url:([`U1 of string | `U2 of URL.t] [@js.union]) -> unit [@@js.call "registerProtocolHandler"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module NavigatorConcurrentHardware : sig
  type t = [`NavigatorConcurrentHardware] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`NavigatorConcurrentHardware]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`NavigatorConcurrentHardware]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `NavigatorConcurrentHardware ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_hardwareConcurrency: 'tags this -> float [@@js.get "hardwareConcurrency"]
  val create: hardwareConcurrency:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module NavigatorAutomationInformation : sig
  type t = [`NavigatorAutomationInformation] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`NavigatorAutomationInformation]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`NavigatorAutomationInformation]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `NavigatorAutomationInformation ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_webdriver: 'tags this -> bool [@@js.get "webdriver"]
  val create: webdriver:bool -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module MediaSessionPlaybackState : sig
  type t = ([`L_s548_none[@js "none"] | `L_s593_paused[@js "paused"] | `L_s608_playing[@js "playing"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module MediaSessionAction : sig
  type t = ([`L_s382_hangup[@js "hangup"] | `L_s540_nexttrack[@js "nexttrack"] | `L_s592_pause[@js "pause"] | `L_s606_play[@js "play"] | `L_s633_previoustrack[@js "previoustrack"] | `L_s703_seekbackward[@js "seekbackward"] | `L_s705_seekforward[@js "seekforward"] | `L_s707_seekto[@js "seekto"] | `L_s726_skipad[@js "skipad"] | `L_s757_stop[@js "stop"] | `L_s802_togglecamera[@js "togglecamera"] | `L_s803_togglemicrophone[@js "togglemicrophone"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module MediaSessionActionDetails : sig
  type t = [`MediaSessionActionDetails] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`MediaSessionActionDetails]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`MediaSessionActionDetails]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MediaSessionActionDetails ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_action: 'tags this -> MediaSessionAction.t [@@js.get "action"]
  val set_action: 'tags this -> MediaSessionAction.t -> unit [@@js.set "action"]
  val get_fastSeek: 'tags this -> bool option option [@@js.get "fastSeek"]
  val set_fastSeek: 'tags this -> bool option -> unit [@@js.set "fastSeek"]
  val get_seekOffset: 'tags this -> float option option [@@js.get "seekOffset"]
  val set_seekOffset: 'tags this -> float option -> unit [@@js.set "seekOffset"]
  val get_seekTime: 'tags this -> float option option [@@js.get "seekTime"]
  val set_seekTime: 'tags this -> float option -> unit [@@js.set "seekTime"]
  val create: action:MediaSessionAction.t -> ?fastSeek:bool -> ?seekOffset:float -> ?seekTime:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module MediaSessionActionHandler : sig
  type t = [`MediaSessionActionHandler] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`MediaSessionActionHandler]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`MediaSessionActionHandler]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MediaSessionActionHandler ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val apply: 'tags this -> details:MediaSessionActionDetails.t -> unit [@@js.apply]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module MediaPositionState : sig
  type t = [`MediaPositionState] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`MediaPositionState]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`MediaPositionState]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MediaPositionState ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_duration: 'tags this -> float option [@@js.get "duration"]
  val set_duration: 'tags this -> float -> unit [@@js.set "duration"]
  val get_playbackRate: 'tags this -> float option [@@js.get "playbackRate"]
  val set_playbackRate: 'tags this -> float -> unit [@@js.set "playbackRate"]
  val get_position: 'tags this -> float option [@@js.get "position"]
  val set_position: 'tags this -> float -> unit [@@js.set "position"]
  val create: ?duration:float -> ?playbackRate:float -> ?position:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module MediaImage : sig
  type t = [`MediaImage] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`MediaImage]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`MediaImage]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MediaImage ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_sizes: 'tags this -> string option [@@js.get "sizes"]
  val set_sizes: 'tags this -> string -> unit [@@js.set "sizes"]
  val get_src: 'tags this -> string [@@js.get "src"]
  val set_src: 'tags this -> string -> unit [@@js.set "src"]
  val get_type: 'tags this -> string option [@@js.get "type"]
  val set_type: 'tags this -> string -> unit [@@js.set "type"]
  val create: ?sizes:string -> src:string -> ?type_:(string[@js "type"]) -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module MediaMetadataInit : sig
  type t = [`MediaMetadataInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`MediaMetadataInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`MediaMetadataInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MediaMetadataInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_album: 'tags this -> string option [@@js.get "album"]
  val set_album: 'tags this -> string -> unit [@@js.set "album"]
  val get_artist: 'tags this -> string option [@@js.get "artist"]
  val set_artist: 'tags this -> string -> unit [@@js.set "artist"]
  val get_artwork: 'tags this -> MediaImage.t list option [@@js.get "artwork"]
  val set_artwork: 'tags this -> MediaImage.t list -> unit [@@js.set "artwork"]
  val get_title: 'tags this -> string option [@@js.get "title"]
  val set_title: 'tags this -> string -> unit [@@js.set "title"]
  val create: ?album:string -> ?artist:string -> ?artwork:MediaImage.t list -> ?title:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module[@js.scope "MediaMetadata"] MediaMetadata : sig
  type t = [`MediaMetadata] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`MediaMetadata]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`MediaMetadata]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MediaMetadata ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_album: 'tags this -> string [@@js.get "album"]
  val set_album: 'tags this -> string -> unit [@@js.set "album"]
  val get_artist: 'tags this -> string [@@js.get "artist"]
  val set_artist: 'tags this -> string -> unit [@@js.set "artist"]
  val get_artwork: 'tags this -> MediaImage.t list [@@js.get "artwork"]
  val set_artwork: 'tags this -> MediaImage.t list -> unit [@@js.set "artwork"]
  val get_title: 'tags this -> string [@@js.get "title"]
  val set_title: 'tags this -> string -> unit [@@js.set "title"]
  val create: album:string -> artist:string -> artwork:MediaImage.t list -> title:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': ?init:MediaMetadataInit.t -> unit -> t [@@js.create]
end
module[@js.scope "MediaSession"] MediaSession : sig
  type t = [`MediaSession] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`MediaSession]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`MediaSession]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MediaSession ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_metadata: 'tags this -> MediaMetadata.t option [@@js.get "metadata"]
  val set_metadata: 'tags this -> MediaMetadata.t option -> unit [@@js.set "metadata"]
  val get_playbackState: 'tags this -> MediaSessionPlaybackState.t [@@js.get "playbackState"]
  val set_playbackState: 'tags this -> MediaSessionPlaybackState.t -> unit [@@js.set "playbackState"]
  val setActionHandler: 'tags this -> action:MediaSessionAction.t -> handler:MediaSessionActionHandler.t option -> unit [@@js.call "setActionHandler"]
  val setPositionState: 'tags this -> ?state:MediaPositionState.t -> unit -> unit [@@js.call "setPositionState"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module MediaKeySessionType : sig
  type t = ([`L_s599_persistent_license[@js "persistent-license"] | `L_s786_temporary[@js "temporary"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module MediaKeyStatus : sig
  type t = ([`L_s305_expired[@js "expired"] | `L_s435_internal_error[@js "internal-error"] | `L_s576_output_downscaled[@js "output-downscaled"] | `L_s577_output_restricted[@js "output-restricted"] | `L_s661_released[@js "released"] | `L_s756_status_pending[@js "status-pending"] | `L_s841_usable[@js "usable"] | `L_s842_usable_in_future[@js "usable-in-future"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end

(**
  This EncryptedMediaExtensions API interface is a read-only map of media key statuses by key IDs.
  Available only in secure contexts.
*)
module[@js.scope "MediaKeyStatusMap"] MediaKeyStatusMap : sig
  type t = [`MediaKeyStatusMap | (BufferSource.t * MediaKeyStatus.t) IterableIterator.tags_1] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`MediaKeyStatusMap | (BufferSource.t * MediaKeyStatus.t) IterableIterator.tags_1]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`MediaKeyStatusMap | (BufferSource.t * MediaKeyStatus.t) IterableIterator.tags_1]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MediaKeyStatusMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  (* [Symbol.iterator]: unit -> (BufferSource.t * MediaKeyStatus.t) IterableIterator.t_1 *)
  val entries: 'tags this -> (BufferSource.t * MediaKeyStatus.t) IterableIterator.t_1 [@@js.call "entries"]
  val keys: 'tags this -> BufferSource.t IterableIterator.t_1 [@@js.call "keys"]
  val values: 'tags this -> MediaKeyStatus.t IterableIterator.t_1 [@@js.call "values"]
  val get_size: 'tags this -> float [@@js.get "size"]
  val get_: 'tags this -> keyId:BufferSource.t -> MediaKeyStatus.t option [@@js.call "get"]
  val has: 'tags this -> keyId:BufferSource.t -> bool [@@js.call "has"]
  val forEach: 'tags this -> callbackfn:(value:MediaKeyStatus.t -> key:BufferSource.t -> parent:t -> unit) -> ?thisArg:any -> unit -> unit [@@js.call "forEach"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module MediaKeySessionClosedReason : sig
  type t = ([`L_s200_closed_by_application[@js "closed-by-application"] | `L_s384_hardware_context_reset[@js "hardware-context-reset"] | `L_s435_internal_error[@js "internal-error"] | `L_s660_release_acknowledged[@js "release-acknowledged"] | `L_s676_resource_evicted[@js "resource-evicted"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module MediaKeyMessageType : sig
  type t = ([`L_s425_individualization_request[@js "individualization-request"] | `L_s459_license_release[@js "license-release"] | `L_s460_license_renewal[@js "license-renewal"] | `L_s461_license_request[@js "license-request"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module MediaKeyMessageEventInit : sig
  type t = [`EventInit | `MediaKeyMessageEventInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventInit | `MediaKeyMessageEventInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventInit | `MediaKeyMessageEventInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MediaKeyMessageEventInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_message: 'tags this -> ArrayBuffer.t_0 [@@js.get "message"]
  val set_message: 'tags this -> ArrayBuffer.t_0 -> unit [@@js.set "message"]
  val get_messageType: 'tags this -> MediaKeyMessageType.t [@@js.get "messageType"]
  val set_messageType: 'tags this -> MediaKeyMessageType.t -> unit [@@js.set "messageType"]
  val create: message:ArrayBuffer.t_0 -> messageType:MediaKeyMessageType.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(**
  This EncryptedMediaExtensions API interface contains the content and related data when the content decryption module generates a message for the session.
  Available only in secure contexts.
*)
module[@js.scope "MediaKeyMessageEvent"] MediaKeyMessageEvent : sig
  type t = [`Event | `MediaKeyMessageEvent] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Event | `MediaKeyMessageEvent]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Event | `MediaKeyMessageEvent]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MediaKeyMessageEvent ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_message: 'tags this -> ArrayBuffer.t_0 [@@js.get "message"]
  val get_messageType: 'tags this -> MediaKeyMessageType.t [@@js.get "messageType"]
  val create: message:ArrayBuffer.t_0 -> messageType:MediaKeyMessageType.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': type_:string -> eventInitDict:MediaKeyMessageEventInit.t -> t [@@js.create]
end

(**
  This EncryptedMediaExtensions API interface represents a context for message exchange with a content decryption module (CDM).
  Available only in secure contexts.
*)
module[@js.scope "MediaKeySession"] MediaKeySession : sig
  type t = [`EventTarget | `MediaKeySession] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventTarget | `MediaKeySession]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventTarget | `MediaKeySession]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MediaKeySession ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_closed: 'tags this -> MediaKeySessionClosedReason.t Promise.t_1 [@@js.get "closed"]
  val get_expiration: 'tags this -> float [@@js.get "expiration"]
  val get_keyStatuses: 'tags this -> MediaKeyStatusMap.t [@@js.get "keyStatuses"]
  val get_onkeystatuseschange: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onkeystatuseschange"]
  val set_onkeystatuseschange: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onkeystatuseschange"]
  val get_onmessage: 'tags this -> (this:t -> ev:MediaKeyMessageEvent.t -> any) option [@@js.get "onmessage"]
  val set_onmessage: 'tags this -> (this:t -> ev:MediaKeyMessageEvent.t -> any) option -> unit [@@js.set "onmessage"]
  val get_sessionId: 'tags this -> string [@@js.get "sessionId"]
  val close: 'tags this -> unit Promise.t_1 [@@js.call "close"]
  val generateRequest: 'tags this -> initDataType:string -> initData:BufferSource.t -> unit Promise.t_1 [@@js.call "generateRequest"]
  val load: 'tags this -> sessionId:string -> bool Promise.t_1 [@@js.call "load"]
  val remove: 'tags this -> unit Promise.t_1 [@@js.call "remove"]
  val update: 'tags this -> response:BufferSource.t -> unit Promise.t_1 [@@js.call "update"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'MediaKeySessionEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'MediaKeySessionEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(**
  This EncryptedMediaExtensions API interface the represents a set of keys that an associated HTMLMediaElement can use for decryption of media data during playback.
  Available only in secure contexts.
*)
module[@js.scope "MediaKeys"] MediaKeys : sig
  type t = [`MediaKeys] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`MediaKeys]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`MediaKeys]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MediaKeys ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val createSession: 'tags this -> ?sessionType:MediaKeySessionType.t -> unit -> MediaKeySession.t [@@js.call "createSession"]
  val setServerCertificate: 'tags this -> serverCertificate:BufferSource.t -> bool Promise.t_1 [@@js.call "setServerCertificate"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module MediaKeysRequirement : sig
  type t = ([`L_s552_not_allowed[@js "not-allowed"] | `L_s569_optional[@js "optional"] | `L_s673_required[@js "required"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module MediaKeySystemMediaCapability : sig
  type t = [`MediaKeySystemMediaCapability] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`MediaKeySystemMediaCapability]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`MediaKeySystemMediaCapability]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MediaKeySystemMediaCapability ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_contentType: 'tags this -> string option [@@js.get "contentType"]
  val set_contentType: 'tags this -> string -> unit [@@js.set "contentType"]
  val get_encryptionScheme: 'tags this -> string option option [@@js.get "encryptionScheme"]
  val set_encryptionScheme: 'tags this -> string option -> unit [@@js.set "encryptionScheme"]
  val get_robustness: 'tags this -> string option [@@js.get "robustness"]
  val set_robustness: 'tags this -> string -> unit [@@js.set "robustness"]
  val create: ?contentType:string -> ?encryptionScheme:string -> ?robustness:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module MediaKeySystemConfiguration : sig
  type t = [`MediaKeySystemConfiguration] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`MediaKeySystemConfiguration]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`MediaKeySystemConfiguration]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MediaKeySystemConfiguration ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_audioCapabilities: 'tags this -> MediaKeySystemMediaCapability.t list option [@@js.get "audioCapabilities"]
  val set_audioCapabilities: 'tags this -> MediaKeySystemMediaCapability.t list -> unit [@@js.set "audioCapabilities"]
  val get_distinctiveIdentifier: 'tags this -> MediaKeysRequirement.t option [@@js.get "distinctiveIdentifier"]
  val set_distinctiveIdentifier: 'tags this -> MediaKeysRequirement.t -> unit [@@js.set "distinctiveIdentifier"]
  val get_initDataTypes: 'tags this -> string list option [@@js.get "initDataTypes"]
  val set_initDataTypes: 'tags this -> string list -> unit [@@js.set "initDataTypes"]
  val get_label: 'tags this -> string option [@@js.get "label"]
  val set_label: 'tags this -> string -> unit [@@js.set "label"]
  val get_persistentState: 'tags this -> MediaKeysRequirement.t option [@@js.get "persistentState"]
  val set_persistentState: 'tags this -> MediaKeysRequirement.t -> unit [@@js.set "persistentState"]
  val get_sessionTypes: 'tags this -> string list option [@@js.get "sessionTypes"]
  val set_sessionTypes: 'tags this -> string list -> unit [@@js.set "sessionTypes"]
  val get_videoCapabilities: 'tags this -> MediaKeySystemMediaCapability.t list option [@@js.get "videoCapabilities"]
  val set_videoCapabilities: 'tags this -> MediaKeySystemMediaCapability.t list -> unit [@@js.set "videoCapabilities"]
  val create: ?audioCapabilities:MediaKeySystemMediaCapability.t list -> ?distinctiveIdentifier:MediaKeysRequirement.t -> ?initDataTypes:string list -> ?label:string -> ?persistentState:MediaKeysRequirement.t -> ?sessionTypes:string list -> ?videoCapabilities:MediaKeySystemMediaCapability.t list -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(**
  This EncryptedMediaExtensions API interface provides access to a Key System for decryption and/or a content protection provider. You can request an instance of this object using the Navigator.requestMediaKeySystemAccess method.
  Available only in secure contexts.
*)
module[@js.scope "MediaKeySystemAccess"] MediaKeySystemAccess : sig
  type t = [`MediaKeySystemAccess] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`MediaKeySystemAccess]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`MediaKeySystemAccess]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MediaKeySystemAccess ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_keySystem: 'tags this -> string [@@js.get "keySystem"]
  val createMediaKeys: 'tags this -> MediaKeys.t Promise.t_1 [@@js.call "createMediaKeys"]
  val getConfiguration: 'tags this -> MediaKeySystemConfiguration.t [@@js.call "getConfiguration"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module MediaTrackSupportedConstraints : sig
  type t = [`MediaTrackSupportedConstraints] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`MediaTrackSupportedConstraints]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`MediaTrackSupportedConstraints]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MediaTrackSupportedConstraints ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_aspectRatio: 'tags this -> bool option [@@js.get "aspectRatio"]
  val set_aspectRatio: 'tags this -> bool -> unit [@@js.set "aspectRatio"]
  val get_autoGainControl: 'tags this -> bool option [@@js.get "autoGainControl"]
  val set_autoGainControl: 'tags this -> bool -> unit [@@js.set "autoGainControl"]
  val get_deviceId: 'tags this -> bool option [@@js.get "deviceId"]
  val set_deviceId: 'tags this -> bool -> unit [@@js.set "deviceId"]
  val get_echoCancellation: 'tags this -> bool option [@@js.get "echoCancellation"]
  val set_echoCancellation: 'tags this -> bool -> unit [@@js.set "echoCancellation"]
  val get_facingMode: 'tags this -> bool option [@@js.get "facingMode"]
  val set_facingMode: 'tags this -> bool -> unit [@@js.set "facingMode"]
  val get_frameRate: 'tags this -> bool option [@@js.get "frameRate"]
  val set_frameRate: 'tags this -> bool -> unit [@@js.set "frameRate"]
  val get_groupId: 'tags this -> bool option [@@js.get "groupId"]
  val set_groupId: 'tags this -> bool -> unit [@@js.set "groupId"]
  val get_height: 'tags this -> bool option [@@js.get "height"]
  val set_height: 'tags this -> bool -> unit [@@js.set "height"]
  val get_noiseSuppression: 'tags this -> bool option [@@js.get "noiseSuppression"]
  val set_noiseSuppression: 'tags this -> bool -> unit [@@js.set "noiseSuppression"]
  val get_sampleRate: 'tags this -> bool option [@@js.get "sampleRate"]
  val set_sampleRate: 'tags this -> bool -> unit [@@js.set "sampleRate"]
  val get_sampleSize: 'tags this -> bool option [@@js.get "sampleSize"]
  val set_sampleSize: 'tags this -> bool -> unit [@@js.set "sampleSize"]
  val get_suppressLocalAudioPlayback: 'tags this -> bool option [@@js.get "suppressLocalAudioPlayback"]
  val set_suppressLocalAudioPlayback: 'tags this -> bool -> unit [@@js.set "suppressLocalAudioPlayback"]
  val get_width: 'tags this -> bool option [@@js.get "width"]
  val set_width: 'tags this -> bool -> unit [@@js.set "width"]
  val create: ?aspectRatio:bool -> ?autoGainControl:bool -> ?deviceId:bool -> ?echoCancellation:bool -> ?facingMode:bool -> ?frameRate:bool -> ?groupId:bool -> ?height:bool -> ?noiseSuppression:bool -> ?sampleRate:bool -> ?sampleSize:bool -> ?suppressLocalAudioPlayback:bool -> ?width:bool -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module MediaStreamConstraints : sig
  type t = [`MediaStreamConstraints] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`MediaStreamConstraints]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`MediaStreamConstraints]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MediaStreamConstraints ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_audio: 'tags this -> ([`Boolean of bool | `Other of MediaTrackConstraints.t] [@js.union on_field "dummy"]) Primitive.t option [@@js.get "audio"]
  val set_audio: 'tags this -> ([`U1 of bool | `U2 of MediaTrackConstraints.t] [@js.union]) -> unit [@@js.set "audio"]
  val get_peerIdentity: 'tags this -> string option [@@js.get "peerIdentity"]
  val set_peerIdentity: 'tags this -> string -> unit [@@js.set "peerIdentity"]
  val get_preferCurrentTab: 'tags this -> bool option [@@js.get "preferCurrentTab"]
  val set_preferCurrentTab: 'tags this -> bool -> unit [@@js.set "preferCurrentTab"]
  val get_video: 'tags this -> ([`Boolean of bool | `Other of MediaTrackConstraints.t] [@js.union on_field "dummy"]) Primitive.t option [@@js.get "video"]
  val set_video: 'tags this -> ([`U1 of bool | `U2 of MediaTrackConstraints.t] [@js.union]) -> unit [@@js.set "video"]
  val create: ?audio:([`Boolean of bool | `Other of MediaTrackConstraints.t] [@js.union on_field "dummy"]) Primitive.t -> ?peerIdentity:string -> ?preferCurrentTab:bool -> ?video:([`Boolean of bool | `Other of MediaTrackConstraints.t] [@js.union on_field "dummy"]) Primitive.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module MediaDeviceKind : sig
  type t = ([`L_s136_audioinput[@js "audioinput"] | `L_s137_audiooutput[@js "audiooutput"] | `L_s853_videoinput[@js "videoinput"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end

(**
  The MediaDevicesInfo interface contains information that describes a single media input or output device.
  Available only in secure contexts.
*)
module[@js.scope "MediaDeviceInfo"] MediaDeviceInfo : sig
  type t = [`MediaDeviceInfo] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`MediaDeviceInfo]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`MediaDeviceInfo]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MediaDeviceInfo ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_deviceId: 'tags this -> string [@@js.get "deviceId"]
  val get_groupId: 'tags this -> string [@@js.get "groupId"]
  val get_kind: 'tags this -> MediaDeviceKind.t [@@js.get "kind"]
  val get_label: 'tags this -> string [@@js.get "label"]
  val toJSON: 'tags this -> any [@@js.call "toJSON"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module DisplayMediaStreamConstraints : sig
  type t = [`DisplayMediaStreamConstraints] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`DisplayMediaStreamConstraints]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`DisplayMediaStreamConstraints]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `DisplayMediaStreamConstraints ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_audio: 'tags this -> ([`Boolean of bool | `Other of MediaTrackConstraints.t] [@js.union on_field "dummy"]) Primitive.t option [@@js.get "audio"]
  val set_audio: 'tags this -> ([`U1 of bool | `U2 of MediaTrackConstraints.t] [@js.union]) -> unit [@@js.set "audio"]
  val get_video: 'tags this -> ([`Boolean of bool | `Other of MediaTrackConstraints.t] [@js.union on_field "dummy"]) Primitive.t option [@@js.get "video"]
  val set_video: 'tags this -> ([`U1 of bool | `U2 of MediaTrackConstraints.t] [@js.union]) -> unit [@@js.set "video"]
  val create: ?audio:([`Boolean of bool | `Other of MediaTrackConstraints.t] [@js.union on_field "dummy"]) Primitive.t -> ?video:([`Boolean of bool | `Other of MediaTrackConstraints.t] [@js.union on_field "dummy"]) Primitive.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(**
  Provides access to connected media input devices like cameras and microphones, as well as screen sharing. In essence, it lets you obtain access to any hardware source of media data.
  Available only in secure contexts.
*)
module[@js.scope "MediaDevices"] MediaDevices : sig
  type t = [`EventTarget | `MediaDevices] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventTarget | `MediaDevices]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventTarget | `MediaDevices]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MediaDevices ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_ondevicechange: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "ondevicechange"]
  val set_ondevicechange: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "ondevicechange"]
  val enumerateDevices: 'tags this -> MediaDeviceInfo.t list Promise.t_1 [@@js.call "enumerateDevices"]
  val getDisplayMedia: 'tags this -> ?constraints:DisplayMediaStreamConstraints.t -> unit -> MediaStream.t Promise.t_1 [@@js.call "getDisplayMedia"]
  val getSupportedConstraints: 'tags this -> MediaTrackSupportedConstraints.t [@@js.call "getSupportedConstraints"]
  val getUserMedia: 'tags this -> ?constraints:MediaStreamConstraints.t -> unit -> MediaStream.t Promise.t_1 [@@js.call "getUserMedia"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'MediaDevicesEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'MediaDevicesEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module MediaEncodingType : sig
  type t = ([`L_s652_record[@js "record"] | `L_s869_webrtc[@js "webrtc"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module TransferFunction : sig
  type t = ([`L_s399_hlg[@js "hlg"] | `L_s625_pq[@js "pq"] | `L_s750_srgb[@js "srgb"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module HdrMetadataType : sig
  type t = ([`L_s732_smpteSt2086[@js "smpteSt2086"] | `L_s733_smpteSt2094_10[@js "smpteSt2094-10"] | `L_s734_smpteSt2094_40[@js "smpteSt2094-40"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module ColorGamut : sig
  type t = ([`L_s581_p3[@js "p3"] | `L_s651_rec2020[@js "rec2020"] | `L_s750_srgb[@js "srgb"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module VideoConfiguration : sig
  type t = [`VideoConfiguration] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`VideoConfiguration]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`VideoConfiguration]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `VideoConfiguration ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_bitrate: 'tags this -> float [@@js.get "bitrate"]
  val set_bitrate: 'tags this -> float -> unit [@@js.set "bitrate"]
  val get_colorGamut: 'tags this -> ColorGamut.t option [@@js.get "colorGamut"]
  val set_colorGamut: 'tags this -> ColorGamut.t -> unit [@@js.set "colorGamut"]
  val get_contentType: 'tags this -> string [@@js.get "contentType"]
  val set_contentType: 'tags this -> string -> unit [@@js.set "contentType"]
  val get_framerate: 'tags this -> float [@@js.get "framerate"]
  val set_framerate: 'tags this -> float -> unit [@@js.set "framerate"]
  val get_hdrMetadataType: 'tags this -> HdrMetadataType.t option [@@js.get "hdrMetadataType"]
  val set_hdrMetadataType: 'tags this -> HdrMetadataType.t -> unit [@@js.set "hdrMetadataType"]
  val get_height: 'tags this -> float [@@js.get "height"]
  val set_height: 'tags this -> float -> unit [@@js.set "height"]
  val get_scalabilityMode: 'tags this -> string option [@@js.get "scalabilityMode"]
  val set_scalabilityMode: 'tags this -> string -> unit [@@js.set "scalabilityMode"]
  val get_transferFunction: 'tags this -> TransferFunction.t option [@@js.get "transferFunction"]
  val set_transferFunction: 'tags this -> TransferFunction.t -> unit [@@js.set "transferFunction"]
  val get_width: 'tags this -> float [@@js.get "width"]
  val set_width: 'tags this -> float -> unit [@@js.set "width"]
  val create: bitrate:float -> ?colorGamut:ColorGamut.t -> contentType:string -> framerate:float -> ?hdrMetadataType:HdrMetadataType.t -> height:float -> ?scalabilityMode:string -> ?transferFunction:TransferFunction.t -> width:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module AudioConfiguration : sig
  type t = [`AudioConfiguration] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AudioConfiguration]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AudioConfiguration]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `AudioConfiguration ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_bitrate: 'tags this -> float option [@@js.get "bitrate"]
  val set_bitrate: 'tags this -> float -> unit [@@js.set "bitrate"]
  val get_channels: 'tags this -> string option [@@js.get "channels"]
  val set_channels: 'tags this -> string -> unit [@@js.set "channels"]
  val get_contentType: 'tags this -> string [@@js.get "contentType"]
  val set_contentType: 'tags this -> string -> unit [@@js.set "contentType"]
  val get_samplerate: 'tags this -> float option [@@js.get "samplerate"]
  val set_samplerate: 'tags this -> float -> unit [@@js.set "samplerate"]
  val get_spatialRendering: 'tags this -> bool option [@@js.get "spatialRendering"]
  val set_spatialRendering: 'tags this -> bool -> unit [@@js.set "spatialRendering"]
  val create: ?bitrate:float -> ?channels:string -> contentType:string -> ?samplerate:float -> ?spatialRendering:bool -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module MediaConfiguration : sig
  type t = [`MediaConfiguration] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`MediaConfiguration]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`MediaConfiguration]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MediaConfiguration ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_audio: 'tags this -> AudioConfiguration.t option [@@js.get "audio"]
  val set_audio: 'tags this -> AudioConfiguration.t -> unit [@@js.set "audio"]
  val get_video: 'tags this -> VideoConfiguration.t option [@@js.get "video"]
  val set_video: 'tags this -> VideoConfiguration.t -> unit [@@js.set "video"]
  val create: ?audio:AudioConfiguration.t -> ?video:VideoConfiguration.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module MediaEncodingConfiguration : sig
  type t = [`MediaConfiguration | `MediaEncodingConfiguration] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`MediaConfiguration | `MediaEncodingConfiguration]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`MediaConfiguration | `MediaEncodingConfiguration]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MediaEncodingConfiguration ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_type: 'tags this -> MediaEncodingType.t [@@js.get "type"]
  val set_type: 'tags this -> MediaEncodingType.t -> unit [@@js.set "type"]
  val create: type_:(MediaEncodingType.t[@js "type"]) -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module MediaCapabilitiesInfo : sig
  type t = [`MediaCapabilitiesInfo] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`MediaCapabilitiesInfo]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`MediaCapabilitiesInfo]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MediaCapabilitiesInfo ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_powerEfficient: 'tags this -> bool [@@js.get "powerEfficient"]
  val set_powerEfficient: 'tags this -> bool -> unit [@@js.set "powerEfficient"]
  val get_smooth: 'tags this -> bool [@@js.get "smooth"]
  val set_smooth: 'tags this -> bool -> unit [@@js.set "smooth"]
  val get_supported: 'tags this -> bool [@@js.get "supported"]
  val set_supported: 'tags this -> bool -> unit [@@js.set "supported"]
  val create: powerEfficient:bool -> smooth:bool -> supported:bool -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module MediaCapabilitiesEncodingInfo : sig
  type t = [`MediaCapabilitiesEncodingInfo | `MediaCapabilitiesInfo] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`MediaCapabilitiesEncodingInfo | `MediaCapabilitiesInfo]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`MediaCapabilitiesEncodingInfo | `MediaCapabilitiesInfo]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MediaCapabilitiesEncodingInfo ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_configuration: 'tags this -> MediaEncodingConfiguration.t option [@@js.get "configuration"]
  val set_configuration: 'tags this -> MediaEncodingConfiguration.t -> unit [@@js.set "configuration"]
  val create: ?configuration:MediaEncodingConfiguration.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module MediaDecodingType : sig
  type t = ([`L_s343_file[@js "file"] | `L_s505_media_source[@js "media-source"] | `L_s869_webrtc[@js "webrtc"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module MediaDecodingConfiguration : sig
  type t = [`MediaConfiguration | `MediaDecodingConfiguration] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`MediaConfiguration | `MediaDecodingConfiguration]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`MediaConfiguration | `MediaDecodingConfiguration]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MediaDecodingConfiguration ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_type: 'tags this -> MediaDecodingType.t [@@js.get "type"]
  val set_type: 'tags this -> MediaDecodingType.t -> unit [@@js.set "type"]
  val create: type_:(MediaDecodingType.t[@js "type"]) -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module MediaCapabilitiesDecodingInfo : sig
  type t = [`MediaCapabilitiesDecodingInfo | `MediaCapabilitiesInfo] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`MediaCapabilitiesDecodingInfo | `MediaCapabilitiesInfo]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`MediaCapabilitiesDecodingInfo | `MediaCapabilitiesInfo]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MediaCapabilitiesDecodingInfo ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_configuration: 'tags this -> MediaDecodingConfiguration.t option [@@js.get "configuration"]
  val set_configuration: 'tags this -> MediaDecodingConfiguration.t -> unit [@@js.set "configuration"]
  val create: ?configuration:MediaDecodingConfiguration.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module[@js.scope "MediaCapabilities"] MediaCapabilities : sig
  type t = [`MediaCapabilities] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`MediaCapabilities]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`MediaCapabilities]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MediaCapabilities ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val decodingInfo: 'tags this -> configuration:MediaDecodingConfiguration.t -> MediaCapabilitiesDecodingInfo.t Promise.t_1 [@@js.call "decodingInfo"]
  val encodingInfo: 'tags this -> configuration:MediaEncodingConfiguration.t -> MediaCapabilitiesEncodingInfo.t Promise.t_1 [@@js.call "encodingInfo"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module PositionOptions : sig
  type t = [`PositionOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`PositionOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`PositionOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PositionOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_enableHighAccuracy: 'tags this -> bool option [@@js.get "enableHighAccuracy"]
  val set_enableHighAccuracy: 'tags this -> bool -> unit [@@js.set "enableHighAccuracy"]
  val get_maximumAge: 'tags this -> float option [@@js.get "maximumAge"]
  val set_maximumAge: 'tags this -> float -> unit [@@js.set "maximumAge"]
  val get_timeout: 'tags this -> float option [@@js.get "timeout"]
  val set_timeout: 'tags this -> float -> unit [@@js.set "timeout"]
  val create: ?enableHighAccuracy:bool -> ?maximumAge:float -> ?timeout:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module[@js.scope "GeolocationPositionError"] GeolocationPositionError : sig
  type t = [`GeolocationPositionError] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`GeolocationPositionError]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`GeolocationPositionError]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `GeolocationPositionError ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_code: 'tags this -> float [@@js.get "code"]
  val get_message: 'tags this -> string [@@js.get "message"]
  val get_PERMISSION_DENIED: 'tags this -> float [@@js.get "PERMISSION_DENIED"]
  val get_POSITION_UNAVAILABLE: 'tags this -> float [@@js.get "POSITION_UNAVAILABLE"]
  val get_TIMEOUT: 'tags this -> float [@@js.get "TIMEOUT"]
  val create: code:float -> message:string -> permission_denied:(float[@js "PERMISSION_DENIED"]) -> position_unavailable:(float[@js "POSITION_UNAVAILABLE"]) -> timeout:(float[@js "TIMEOUT"]) -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
  val permission_denied: unit -> float [@@js.get "PERMISSION_DENIED"]
  val position_unavailable: unit -> float [@@js.get "POSITION_UNAVAILABLE"]
  val timeout: unit -> float [@@js.get "TIMEOUT"]
end
module PositionErrorCallback : sig
  type t = [`PositionErrorCallback] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`PositionErrorCallback]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`PositionErrorCallback]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PositionErrorCallback ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val apply: 'tags this -> positionError:GeolocationPositionError.t -> unit [@@js.apply]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** Available only in secure contexts. *)
module[@js.scope "GeolocationCoordinates"] GeolocationCoordinates : sig
  type t = [`GeolocationCoordinates] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`GeolocationCoordinates]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`GeolocationCoordinates]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `GeolocationCoordinates ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_accuracy: 'tags this -> float [@@js.get "accuracy"]
  val get_altitude: 'tags this -> float option [@@js.get "altitude"]
  val get_altitudeAccuracy: 'tags this -> float option [@@js.get "altitudeAccuracy"]
  val get_heading: 'tags this -> float option [@@js.get "heading"]
  val get_latitude: 'tags this -> float [@@js.get "latitude"]
  val get_longitude: 'tags this -> float [@@js.get "longitude"]
  val get_speed: 'tags this -> float option [@@js.get "speed"]
  val create: accuracy:float -> ?altitude:float -> ?altitudeAccuracy:float -> ?heading:float -> latitude:float -> longitude:float -> ?speed:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end

(** Available only in secure contexts. *)
module[@js.scope "GeolocationPosition"] GeolocationPosition : sig
  type t = [`GeolocationPosition] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`GeolocationPosition]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`GeolocationPosition]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `GeolocationPosition ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_coords: 'tags this -> GeolocationCoordinates.t [@@js.get "coords"]
  val get_timestamp: 'tags this -> EpochTimeStamp.t [@@js.get "timestamp"]
  val create: coords:GeolocationCoordinates.t -> timestamp:EpochTimeStamp.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end
module PositionCallback : sig
  type t = [`PositionCallback] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`PositionCallback]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`PositionCallback]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PositionCallback ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val apply: 'tags this -> position:GeolocationPosition.t -> unit [@@js.apply]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** An object able to programmatically obtain the position of the device. It gives Web content access to the location of the device. This allows a Web site or app to offer customized results based on the user's location. *)
module[@js.scope "Geolocation"] Geolocation : sig
  type t = [`Geolocation] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Geolocation]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Geolocation]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `Geolocation ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val clearWatch: 'tags this -> watchId:float -> unit [@@js.call "clearWatch"]
  val getCurrentPosition: 'tags this -> successCallback:PositionCallback.t -> ?errorCallback:PositionErrorCallback.t option -> ?options:PositionOptions.t -> unit -> unit [@@js.call "getCurrentPosition"]
  val watchPosition: 'tags this -> successCallback:PositionCallback.t -> ?errorCallback:PositionErrorCallback.t option -> ?options:PositionOptions.t -> unit -> float [@@js.call "watchPosition"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module PublicKeyCredentialType : sig
  type t = ([`L_s642_public_key[@js "public-key"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module AuthenticatorTransport : sig
  type t = ([`L_s160_ble[@js "ble"] | `L_s434_internal[@js "internal"] | `L_s542_nfc[@js "nfc"] | `L_s843_usb[@js "usb"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module PublicKeyCredentialDescriptor : sig
  type t = [`PublicKeyCredentialDescriptor] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`PublicKeyCredentialDescriptor]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`PublicKeyCredentialDescriptor]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PublicKeyCredentialDescriptor ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_id: 'tags this -> BufferSource.t [@@js.get "id"]
  val set_id: 'tags this -> BufferSource.t -> unit [@@js.set "id"]
  val get_transports: 'tags this -> AuthenticatorTransport.t list option [@@js.get "transports"]
  val set_transports: 'tags this -> AuthenticatorTransport.t list -> unit [@@js.set "transports"]
  val get_type: 'tags this -> PublicKeyCredentialType.t [@@js.get "type"]
  val set_type: 'tags this -> PublicKeyCredentialType.t -> unit [@@js.set "type"]
  val create: id:BufferSource.t -> ?transports:AuthenticatorTransport.t list -> type_:(PublicKeyCredentialType.t[@js "type"]) -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module UserVerificationRequirement : sig
  type t = ([`L_s267_discouraged[@js "discouraged"] | `L_s628_preferred[@js "preferred"] | `L_s673_required[@js "required"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module AuthenticationExtensionsClientInputs : sig
  type t = [`AuthenticationExtensionsClientInputs] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AuthenticationExtensionsClientInputs]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AuthenticationExtensionsClientInputs]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `AuthenticationExtensionsClientInputs ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_appid: 'tags this -> string option [@@js.get "appid"]
  val set_appid: 'tags this -> string -> unit [@@js.set "appid"]
  val get_appidExclude: 'tags this -> string option [@@js.get "appidExclude"]
  val set_appidExclude: 'tags this -> string -> unit [@@js.set "appidExclude"]
  val get_credProps: 'tags this -> bool option [@@js.get "credProps"]
  val set_credProps: 'tags this -> bool -> unit [@@js.set "credProps"]
  val get_uvm: 'tags this -> bool option [@@js.get "uvm"]
  val set_uvm: 'tags this -> bool -> unit [@@js.set "uvm"]
  val create: ?appid:string -> ?appidExclude:string -> ?credProps:bool -> ?uvm:bool -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module PublicKeyCredentialRequestOptions : sig
  type t = [`PublicKeyCredentialRequestOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`PublicKeyCredentialRequestOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`PublicKeyCredentialRequestOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PublicKeyCredentialRequestOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_allowCredentials: 'tags this -> PublicKeyCredentialDescriptor.t list option [@@js.get "allowCredentials"]
  val set_allowCredentials: 'tags this -> PublicKeyCredentialDescriptor.t list -> unit [@@js.set "allowCredentials"]
  val get_challenge: 'tags this -> BufferSource.t [@@js.get "challenge"]
  val set_challenge: 'tags this -> BufferSource.t -> unit [@@js.set "challenge"]
  val get_extensions: 'tags this -> AuthenticationExtensionsClientInputs.t option [@@js.get "extensions"]
  val set_extensions: 'tags this -> AuthenticationExtensionsClientInputs.t -> unit [@@js.set "extensions"]
  val get_rpId: 'tags this -> string option [@@js.get "rpId"]
  val set_rpId: 'tags this -> string -> unit [@@js.set "rpId"]
  val get_timeout: 'tags this -> float option [@@js.get "timeout"]
  val set_timeout: 'tags this -> float -> unit [@@js.set "timeout"]
  val get_userVerification: 'tags this -> UserVerificationRequirement.t option [@@js.get "userVerification"]
  val set_userVerification: 'tags this -> UserVerificationRequirement.t -> unit [@@js.set "userVerification"]
  val create: ?allowCredentials:PublicKeyCredentialDescriptor.t list -> challenge:BufferSource.t -> ?extensions:AuthenticationExtensionsClientInputs.t -> ?rpId:string -> ?timeout:float -> ?userVerification:UserVerificationRequirement.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module CredentialMediationRequirement : sig
  type t = ([`L_s569_optional[@js "optional"] | `L_s673_required[@js "required"] | `L_s724_silent[@js "silent"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module CredentialRequestOptions : sig
  type t = [`CredentialRequestOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`CredentialRequestOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`CredentialRequestOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `CredentialRequestOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_mediation: 'tags this -> CredentialMediationRequirement.t option [@@js.get "mediation"]
  val set_mediation: 'tags this -> CredentialMediationRequirement.t -> unit [@@js.set "mediation"]
  val get_publicKey: 'tags this -> PublicKeyCredentialRequestOptions.t option [@@js.get "publicKey"]
  val set_publicKey: 'tags this -> PublicKeyCredentialRequestOptions.t -> unit [@@js.set "publicKey"]
  val get_signal: 'tags this -> AbortSignal.t option [@@js.get "signal"]
  val set_signal: 'tags this -> AbortSignal.t -> unit [@@js.set "signal"]
  val create: ?mediation:CredentialMediationRequirement.t -> ?publicKey:PublicKeyCredentialRequestOptions.t -> ?signal:AbortSignal.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module PublicKeyCredentialEntity : sig
  type t = [`PublicKeyCredentialEntity] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`PublicKeyCredentialEntity]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`PublicKeyCredentialEntity]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PublicKeyCredentialEntity ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_name: 'tags this -> string [@@js.get "name"]
  val set_name: 'tags this -> string -> unit [@@js.set "name"]
  val create: name:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module PublicKeyCredentialUserEntity : sig
  type t = [`PublicKeyCredentialEntity | `PublicKeyCredentialUserEntity] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`PublicKeyCredentialEntity | `PublicKeyCredentialUserEntity]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`PublicKeyCredentialEntity | `PublicKeyCredentialUserEntity]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PublicKeyCredentialUserEntity ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_displayName: 'tags this -> string [@@js.get "displayName"]
  val set_displayName: 'tags this -> string -> unit [@@js.set "displayName"]
  val get_id: 'tags this -> BufferSource.t [@@js.get "id"]
  val set_id: 'tags this -> BufferSource.t -> unit [@@js.set "id"]
  val create: displayName:string -> id:BufferSource.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module PublicKeyCredentialRpEntity : sig
  type t = [`PublicKeyCredentialEntity | `PublicKeyCredentialRpEntity] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`PublicKeyCredentialEntity | `PublicKeyCredentialRpEntity]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`PublicKeyCredentialEntity | `PublicKeyCredentialRpEntity]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PublicKeyCredentialRpEntity ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_id: 'tags this -> string option [@@js.get "id"]
  val set_id: 'tags this -> string -> unit [@@js.set "id"]
  val create: ?id:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module COSEAlgorithmIdentifier : sig
  type t = float
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module PublicKeyCredentialParameters : sig
  type t = [`PublicKeyCredentialParameters] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`PublicKeyCredentialParameters]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`PublicKeyCredentialParameters]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PublicKeyCredentialParameters ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_alg: 'tags this -> COSEAlgorithmIdentifier.t [@@js.get "alg"]
  val set_alg: 'tags this -> COSEAlgorithmIdentifier.t -> unit [@@js.set "alg"]
  val get_type: 'tags this -> PublicKeyCredentialType.t [@@js.get "type"]
  val set_type: 'tags this -> PublicKeyCredentialType.t -> unit [@@js.set "type"]
  val create: alg:COSEAlgorithmIdentifier.t -> type_:(PublicKeyCredentialType.t[@js "type"]) -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module ResidentKeyRequirement : sig
  type t = ([`L_s267_discouraged[@js "discouraged"] | `L_s628_preferred[@js "preferred"] | `L_s673_required[@js "required"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module AuthenticatorAttachment : sig
  type t = ([`L_s226_cross_platform[@js "cross-platform"] | `L_s605_platform[@js "platform"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module AuthenticatorSelectionCriteria : sig
  type t = [`AuthenticatorSelectionCriteria] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AuthenticatorSelectionCriteria]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AuthenticatorSelectionCriteria]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `AuthenticatorSelectionCriteria ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_authenticatorAttachment: 'tags this -> AuthenticatorAttachment.t option [@@js.get "authenticatorAttachment"]
  val set_authenticatorAttachment: 'tags this -> AuthenticatorAttachment.t -> unit [@@js.set "authenticatorAttachment"]
  val get_requireResidentKey: 'tags this -> bool option [@@js.get "requireResidentKey"]
  val set_requireResidentKey: 'tags this -> bool -> unit [@@js.set "requireResidentKey"]
  val get_residentKey: 'tags this -> ResidentKeyRequirement.t option [@@js.get "residentKey"]
  val set_residentKey: 'tags this -> ResidentKeyRequirement.t -> unit [@@js.set "residentKey"]
  val get_userVerification: 'tags this -> UserVerificationRequirement.t option [@@js.get "userVerification"]
  val set_userVerification: 'tags this -> UserVerificationRequirement.t -> unit [@@js.set "userVerification"]
  val create: ?authenticatorAttachment:AuthenticatorAttachment.t -> ?requireResidentKey:bool -> ?residentKey:ResidentKeyRequirement.t -> ?userVerification:UserVerificationRequirement.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module AttestationConveyancePreference : sig
  type t = ([`L_s262_direct[@js "direct"] | `L_s295_enterprise[@js "enterprise"] | `L_s424_indirect[@js "indirect"] | `L_s548_none[@js "none"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module PublicKeyCredentialCreationOptions : sig
  type t = [`PublicKeyCredentialCreationOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`PublicKeyCredentialCreationOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`PublicKeyCredentialCreationOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PublicKeyCredentialCreationOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_attestation: 'tags this -> AttestationConveyancePreference.t option [@@js.get "attestation"]
  val set_attestation: 'tags this -> AttestationConveyancePreference.t -> unit [@@js.set "attestation"]
  val get_authenticatorSelection: 'tags this -> AuthenticatorSelectionCriteria.t option [@@js.get "authenticatorSelection"]
  val set_authenticatorSelection: 'tags this -> AuthenticatorSelectionCriteria.t -> unit [@@js.set "authenticatorSelection"]
  val get_challenge: 'tags this -> BufferSource.t [@@js.get "challenge"]
  val set_challenge: 'tags this -> BufferSource.t -> unit [@@js.set "challenge"]
  val get_excludeCredentials: 'tags this -> PublicKeyCredentialDescriptor.t list option [@@js.get "excludeCredentials"]
  val set_excludeCredentials: 'tags this -> PublicKeyCredentialDescriptor.t list -> unit [@@js.set "excludeCredentials"]
  val get_extensions: 'tags this -> AuthenticationExtensionsClientInputs.t option [@@js.get "extensions"]
  val set_extensions: 'tags this -> AuthenticationExtensionsClientInputs.t -> unit [@@js.set "extensions"]
  val get_pubKeyCredParams: 'tags this -> PublicKeyCredentialParameters.t list [@@js.get "pubKeyCredParams"]
  val set_pubKeyCredParams: 'tags this -> PublicKeyCredentialParameters.t list -> unit [@@js.set "pubKeyCredParams"]
  val get_rp: 'tags this -> PublicKeyCredentialRpEntity.t [@@js.get "rp"]
  val set_rp: 'tags this -> PublicKeyCredentialRpEntity.t -> unit [@@js.set "rp"]
  val get_timeout: 'tags this -> float option [@@js.get "timeout"]
  val set_timeout: 'tags this -> float -> unit [@@js.set "timeout"]
  val get_user: 'tags this -> PublicKeyCredentialUserEntity.t [@@js.get "user"]
  val set_user: 'tags this -> PublicKeyCredentialUserEntity.t -> unit [@@js.set "user"]
  val create: ?attestation:AttestationConveyancePreference.t -> ?authenticatorSelection:AuthenticatorSelectionCriteria.t -> challenge:BufferSource.t -> ?excludeCredentials:PublicKeyCredentialDescriptor.t list -> ?extensions:AuthenticationExtensionsClientInputs.t -> pubKeyCredParams:PublicKeyCredentialParameters.t list -> rp:PublicKeyCredentialRpEntity.t -> ?timeout:float -> user:PublicKeyCredentialUserEntity.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module CredentialCreationOptions : sig
  type t = [`CredentialCreationOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`CredentialCreationOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`CredentialCreationOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `CredentialCreationOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_publicKey: 'tags this -> PublicKeyCredentialCreationOptions.t option [@@js.get "publicKey"]
  val set_publicKey: 'tags this -> PublicKeyCredentialCreationOptions.t -> unit [@@js.set "publicKey"]
  val get_signal: 'tags this -> AbortSignal.t option [@@js.get "signal"]
  val set_signal: 'tags this -> AbortSignal.t -> unit [@@js.set "signal"]
  val create: ?publicKey:PublicKeyCredentialCreationOptions.t -> ?signal:AbortSignal.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** Available only in secure contexts. *)
module[@js.scope "Credential"] Credential : sig
  type t = [`Credential] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Credential]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Credential]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `Credential ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_id: 'tags this -> string [@@js.get "id"]
  val get_type: 'tags this -> string [@@js.get "type"]
  val create: id:string -> type_:(string[@js "type"]) -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end

(** Available only in secure contexts. *)
module[@js.scope "CredentialsContainer"] CredentialsContainer : sig
  type t = [`CredentialsContainer] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`CredentialsContainer]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`CredentialsContainer]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `CredentialsContainer ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val create_: 'tags this -> ?options:CredentialCreationOptions.t -> unit -> Credential.t option Promise.t_1 [@@js.call "create"]
  val get_: 'tags this -> ?options:CredentialRequestOptions.t -> unit -> Credential.t option Promise.t_1 [@@js.call "get"]
  val preventSilentAccess: 'tags this -> unit Promise.t_1 [@@js.call "preventSilentAccess"]
  val store: 'tags this -> credential:Credential.t -> Credential.t Promise.t_1 [@@js.call "store"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module PresentationStyle : sig
  type t = ([`L_s131_attachment[@js "attachment"] | `L_s427_inline[@js "inline"] | `L_s833_unspecified[@js "unspecified"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module ClipboardItemOptions : sig
  type t = [`ClipboardItemOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ClipboardItemOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ClipboardItemOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ClipboardItemOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_presentationStyle: 'tags this -> PresentationStyle.t option [@@js.get "presentationStyle"]
  val set_presentationStyle: 'tags this -> PresentationStyle.t -> unit [@@js.set "presentationStyle"]
  val create: ?presentationStyle:PresentationStyle.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module ClipboardItemDataType : sig
  type t = ([`String of string | `Other of Blob.t] [@js.union on_field "dummy"]) Primitive.t
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module[@js.scope "ClipboardItem"] ClipboardItem : sig
  type t = [`ClipboardItem] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ClipboardItem]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ClipboardItem]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ClipboardItem ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_types: 'tags this -> string list [@@js.get "types"]
  val getType: 'tags this -> type_:string -> Blob.t Promise.t_1 [@@js.call "getType"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: items:(string, ([`U1 of ClipboardItemDataType.t | `U2 of ClipboardItemDataType.t PromiseLike.t_1] [@js.union])) Record.t_2 -> ?options:ClipboardItemOptions.t -> unit -> t [@@js.create]
end
module ClipboardItems : sig
  type t = ClipboardItem.t list
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end

(** Available only in secure contexts. *)
module[@js.scope "Clipboard"] Clipboard : sig
  type t = [`Clipboard | `EventTarget] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Clipboard | `EventTarget]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Clipboard | `EventTarget]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `Clipboard ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val read: 'tags this -> ClipboardItems.t Promise.t_1 [@@js.call "read"]
  val readText: 'tags this -> string Promise.t_1 [@@js.call "readText"]
  val write: 'tags this -> data:ClipboardItems.t -> unit Promise.t_1 [@@js.call "write"]
  val writeText: 'tags this -> data:string -> unit Promise.t_1 [@@js.call "writeText"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module FormDataEntryValue : sig
  type t = ([`String of string | `Other of File.t] [@js.union on_field "dummy"]) Primitive.t
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module MediaQueryListEventInit : sig
  type t = [`EventInit | `MediaQueryListEventInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventInit | `MediaQueryListEventInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventInit | `MediaQueryListEventInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MediaQueryListEventInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_matches: 'tags this -> bool option [@@js.get "matches"]
  val set_matches: 'tags this -> bool -> unit [@@js.set "matches"]
  val get_media: 'tags this -> string option [@@js.get "media"]
  val set_media: 'tags this -> string -> unit [@@js.set "media"]
  val create: ?matches:bool -> ?media:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module[@js.scope "MediaQueryListEvent"] MediaQueryListEvent : sig
  type t = [`Event | `MediaQueryListEvent] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Event | `MediaQueryListEvent]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Event | `MediaQueryListEvent]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MediaQueryListEvent ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_matches: 'tags this -> bool [@@js.get "matches"]
  val get_media: 'tags this -> string [@@js.get "media"]
  val create: matches:bool -> media:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': type_:string -> ?eventInitDict:MediaQueryListEventInit.t -> unit -> t [@@js.create]
end

(** Stores information on a media query applied to a document, and handles sending notifications to listeners when the media query state change (i.e. when the media query test starts or stops evaluating to true). *)
module[@js.scope "MediaQueryList"] MediaQueryList : sig
  type t = [`EventTarget | `MediaQueryList] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventTarget | `MediaQueryList]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventTarget | `MediaQueryList]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MediaQueryList ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_matches: 'tags this -> bool [@@js.get "matches"]
  val get_media: 'tags this -> string [@@js.get "media"]
  val get_onchange: 'tags this -> (this:t -> ev:MediaQueryListEvent.t -> any) option [@@js.get "onchange"]
  val set_onchange: 'tags this -> (this:t -> ev:MediaQueryListEvent.t -> any) option -> unit [@@js.set "onchange"]
  
  (** @deprecated  *)
  val addListener: 'tags this -> callback:(this:t -> ev:MediaQueryListEvent.t -> any) option -> unit [@@js.call "addListener"]
  
  (** @deprecated  *)
  val removeListener: 'tags this -> callback:(this:t -> ev:MediaQueryListEvent.t -> any) option -> unit [@@js.call "removeListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'MediaQueryListEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'MediaQueryListEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** The location (URL) of the object it is linked to. Changes done on it are reflected on the object it relates to. Both the Document and Window interface have such a linked Location, accessible via Document.location and Window.location respectively. *)
module[@js.scope "Location"] Location : sig
  type t = [`Location] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Location]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Location]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `Location ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Returns a DOMStringList object listing the origins of the ancestor browsing contexts, from the parent browsing context to the top-level browsing context. *)
  val get_ancestorOrigins: 'tags this -> DOMStringList.t [@@js.get "ancestorOrigins"]
  
  (**
    Returns the Location object's URL's fragment (includes leading "#" if non-empty).
    
    Can be set, to navigate to the same URL with a changed fragment (ignores leading "#").
  *)
  val get_hash: 'tags this -> string [@@js.get "hash"]
  
  (**
    Returns the Location object's URL's fragment (includes leading "#" if non-empty).
    
    Can be set, to navigate to the same URL with a changed fragment (ignores leading "#").
  *)
  val set_hash: 'tags this -> string -> unit [@@js.set "hash"]
  
  (**
    Returns the Location object's URL's host and port (if different from the default port for the scheme).
    
    Can be set, to navigate to the same URL with a changed host and port.
  *)
  val get_host: 'tags this -> string [@@js.get "host"]
  
  (**
    Returns the Location object's URL's host and port (if different from the default port for the scheme).
    
    Can be set, to navigate to the same URL with a changed host and port.
  *)
  val set_host: 'tags this -> string -> unit [@@js.set "host"]
  
  (**
    Returns the Location object's URL's host.
    
    Can be set, to navigate to the same URL with a changed host.
  *)
  val get_hostname: 'tags this -> string [@@js.get "hostname"]
  
  (**
    Returns the Location object's URL's host.
    
    Can be set, to navigate to the same URL with a changed host.
  *)
  val set_hostname: 'tags this -> string -> unit [@@js.set "hostname"]
  
  (**
    Returns the Location object's URL.
    
    Can be set, to navigate to the given URL.
  *)
  val get_href: 'tags this -> string [@@js.get "href"]
  
  (**
    Returns the Location object's URL.
    
    Can be set, to navigate to the given URL.
  *)
  val set_href: 'tags this -> string -> unit [@@js.set "href"]
  val toString: 'tags this -> string [@@js.call "toString"]
  
  (** Returns the Location object's URL's origin. *)
  val get_origin: 'tags this -> string [@@js.get "origin"]
  
  (**
    Returns the Location object's URL's path.
    
    Can be set, to navigate to the same URL with a changed path.
  *)
  val get_pathname: 'tags this -> string [@@js.get "pathname"]
  
  (**
    Returns the Location object's URL's path.
    
    Can be set, to navigate to the same URL with a changed path.
  *)
  val set_pathname: 'tags this -> string -> unit [@@js.set "pathname"]
  
  (**
    Returns the Location object's URL's port.
    
    Can be set, to navigate to the same URL with a changed port.
  *)
  val get_port: 'tags this -> string [@@js.get "port"]
  
  (**
    Returns the Location object's URL's port.
    
    Can be set, to navigate to the same URL with a changed port.
  *)
  val set_port: 'tags this -> string -> unit [@@js.set "port"]
  
  (**
    Returns the Location object's URL's scheme.
    
    Can be set, to navigate to the same URL with a changed scheme.
  *)
  val get_protocol: 'tags this -> string [@@js.get "protocol"]
  
  (**
    Returns the Location object's URL's scheme.
    
    Can be set, to navigate to the same URL with a changed scheme.
  *)
  val set_protocol: 'tags this -> string -> unit [@@js.set "protocol"]
  
  (**
    Returns the Location object's URL's query (includes leading "?" if non-empty).
    
    Can be set, to navigate to the same URL with a changed query (ignores leading "?").
  *)
  val get_search: 'tags this -> string [@@js.get "search"]
  
  (**
    Returns the Location object's URL's query (includes leading "?" if non-empty).
    
    Can be set, to navigate to the same URL with a changed query (ignores leading "?").
  *)
  val set_search: 'tags this -> string -> unit [@@js.set "search"]
  
  (** Navigates to the given URL. *)
  val assign: 'tags this -> url:([`U1 of string | `U2 of URL.t] [@js.union]) -> unit [@@js.call "assign"]
  
  (** Reloads the current page. *)
  val reload: 'tags this -> unit [@@js.call "reload"]
  
  (** Removes the current page from the session history and navigates to the given URL. *)
  val replace: 'tags this -> url:([`U1 of string | `U2 of URL.t] [@js.union]) -> unit [@@js.call "replace"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module IdleRequestOptions : sig
  type t = [`IdleRequestOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`IdleRequestOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`IdleRequestOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `IdleRequestOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_timeout: 'tags this -> float option [@@js.get "timeout"]
  val set_timeout: 'tags this -> float -> unit [@@js.set "timeout"]
  val create: ?timeout:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module[@js.scope "IdleDeadline"] IdleDeadline : sig
  type t = [`IdleDeadline] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`IdleDeadline]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`IdleDeadline]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `IdleDeadline ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_didTimeout: 'tags this -> bool [@@js.get "didTimeout"]
  val timeRemaining: 'tags this -> DOMHighResTimeStamp.t [@@js.call "timeRemaining"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module IdleRequestCallback : sig
  type t = [`IdleRequestCallback] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`IdleRequestCallback]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`IdleRequestCallback]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `IdleRequestCallback ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val apply: 'tags this -> deadline:IdleDeadline.t -> unit [@@js.apply]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module ScrollRestoration : sig
  type t = ([`L_s141_auto[@js "auto"] | `L_s495_manual[@js "manual"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end

(** Allows manipulation of the browser session history, that is the pages visited in the tab or frame that the current page is loaded in. *)
module[@js.scope "History"] History : sig
  type t = [`History] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`History]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`History]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `History ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_length: 'tags this -> float [@@js.get "length"]
  val get_scrollRestoration: 'tags this -> ScrollRestoration.t [@@js.get "scrollRestoration"]
  val set_scrollRestoration: 'tags this -> ScrollRestoration.t -> unit [@@js.set "scrollRestoration"]
  val get_state: 'tags this -> any [@@js.get "state"]
  val back: 'tags this -> unit [@@js.call "back"]
  val forward: 'tags this -> unit [@@js.call "forward"]
  val go: 'tags this -> ?delta:float -> unit -> unit [@@js.call "go"]
  val pushState: 'tags this -> data:any -> unused:string -> ?url:([`Null | `U1 of string | `U2 of URL.t] [@js.union]) -> unit -> unit [@@js.call "pushState"]
  val replaceState: 'tags this -> data:any -> unused:string -> ?url:([`Null | `U1 of string | `U2 of URL.t] [@js.union]) -> unit -> unit [@@js.call "replaceState"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** @deprecated  *)
module[@js.scope "External"] External : sig
  type t = [`External] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`External]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`External]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `External ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** @deprecated  *)
  val addSearchProvider: 'tags this -> unit [@@js.call "AddSearchProvider"]
  
  (** @deprecated  *)
  val isSearchProviderInstalled: 'tags this -> unit [@@js.call "IsSearchProviderInstalled"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module DeviceOrientationEventInit : sig
  type t = [`DeviceOrientationEventInit | `EventInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`DeviceOrientationEventInit | `EventInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`DeviceOrientationEventInit | `EventInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `DeviceOrientationEventInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_absolute: 'tags this -> bool option [@@js.get "absolute"]
  val set_absolute: 'tags this -> bool -> unit [@@js.set "absolute"]
  val get_alpha: 'tags this -> float option option [@@js.get "alpha"]
  val set_alpha: 'tags this -> float option -> unit [@@js.set "alpha"]
  val get_beta: 'tags this -> float option option [@@js.get "beta"]
  val set_beta: 'tags this -> float option -> unit [@@js.set "beta"]
  val get_gamma: 'tags this -> float option option [@@js.get "gamma"]
  val set_gamma: 'tags this -> float option -> unit [@@js.set "gamma"]
  val create: ?absolute:bool -> ?alpha:float -> ?beta:float -> ?gamma:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(**
  The DeviceOrientationEvent provides web developers with information from the physical orientation of the device running the web page.
  Available only in secure contexts.
*)
module[@js.scope "DeviceOrientationEvent"] DeviceOrientationEvent : sig
  type t = [`DeviceOrientationEvent | `Event] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`DeviceOrientationEvent | `Event]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`DeviceOrientationEvent | `Event]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `DeviceOrientationEvent ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_absolute: 'tags this -> bool [@@js.get "absolute"]
  val get_alpha: 'tags this -> float option [@@js.get "alpha"]
  val get_beta: 'tags this -> float option [@@js.get "beta"]
  val get_gamma: 'tags this -> float option [@@js.get "gamma"]
  val create: absolute:bool -> ?alpha:float -> ?beta:float -> ?gamma:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': type_:string -> ?eventInitDict:DeviceOrientationEventInit.t -> unit -> t [@@js.create]
end

(** Available only in secure contexts. *)
module DeviceMotionEventRotationRate : sig
  type t = [`DeviceMotionEventRotationRate] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`DeviceMotionEventRotationRate]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`DeviceMotionEventRotationRate]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `DeviceMotionEventRotationRate ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_alpha: 'tags this -> float option [@@js.get "alpha"]
  val get_beta: 'tags this -> float option [@@js.get "beta"]
  val get_gamma: 'tags this -> float option [@@js.get "gamma"]
  val create: ?alpha:float -> ?beta:float -> ?gamma:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module DeviceMotionEventRotationRateInit : sig
  type t = [`DeviceMotionEventRotationRateInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`DeviceMotionEventRotationRateInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`DeviceMotionEventRotationRateInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `DeviceMotionEventRotationRateInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_alpha: 'tags this -> float option option [@@js.get "alpha"]
  val set_alpha: 'tags this -> float option -> unit [@@js.set "alpha"]
  val get_beta: 'tags this -> float option option [@@js.get "beta"]
  val set_beta: 'tags this -> float option -> unit [@@js.set "beta"]
  val get_gamma: 'tags this -> float option option [@@js.get "gamma"]
  val set_gamma: 'tags this -> float option -> unit [@@js.set "gamma"]
  val create: ?alpha:float -> ?beta:float -> ?gamma:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module DeviceMotionEventAccelerationInit : sig
  type t = [`DeviceMotionEventAccelerationInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`DeviceMotionEventAccelerationInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`DeviceMotionEventAccelerationInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `DeviceMotionEventAccelerationInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_x: 'tags this -> float option option [@@js.get "x"]
  val set_x: 'tags this -> float option -> unit [@@js.set "x"]
  val get_y: 'tags this -> float option option [@@js.get "y"]
  val set_y: 'tags this -> float option -> unit [@@js.set "y"]
  val get_z: 'tags this -> float option option [@@js.get "z"]
  val set_z: 'tags this -> float option -> unit [@@js.set "z"]
  val create: ?x:float -> ?y:float -> ?z:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module DeviceMotionEventInit : sig
  type t = [`DeviceMotionEventInit | `EventInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`DeviceMotionEventInit | `EventInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`DeviceMotionEventInit | `EventInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `DeviceMotionEventInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_acceleration: 'tags this -> DeviceMotionEventAccelerationInit.t option [@@js.get "acceleration"]
  val set_acceleration: 'tags this -> DeviceMotionEventAccelerationInit.t -> unit [@@js.set "acceleration"]
  val get_accelerationIncludingGravity: 'tags this -> DeviceMotionEventAccelerationInit.t option [@@js.get "accelerationIncludingGravity"]
  val set_accelerationIncludingGravity: 'tags this -> DeviceMotionEventAccelerationInit.t -> unit [@@js.set "accelerationIncludingGravity"]
  val get_interval: 'tags this -> float option [@@js.get "interval"]
  val set_interval: 'tags this -> float -> unit [@@js.set "interval"]
  val get_rotationRate: 'tags this -> DeviceMotionEventRotationRateInit.t option [@@js.get "rotationRate"]
  val set_rotationRate: 'tags this -> DeviceMotionEventRotationRateInit.t -> unit [@@js.set "rotationRate"]
  val create: ?acceleration:DeviceMotionEventAccelerationInit.t -> ?accelerationIncludingGravity:DeviceMotionEventAccelerationInit.t -> ?interval:float -> ?rotationRate:DeviceMotionEventRotationRateInit.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** Available only in secure contexts. *)
module DeviceMotionEventAcceleration : sig
  type t = [`DeviceMotionEventAcceleration] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`DeviceMotionEventAcceleration]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`DeviceMotionEventAcceleration]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `DeviceMotionEventAcceleration ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_x: 'tags this -> float option [@@js.get "x"]
  val get_y: 'tags this -> float option [@@js.get "y"]
  val get_z: 'tags this -> float option [@@js.get "z"]
  val create: ?x:float -> ?y:float -> ?z:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(**
  The DeviceMotionEvent provides web developers with information about the speed of changes for the device's position and orientation.
  Available only in secure contexts.
*)
module[@js.scope "DeviceMotionEvent"] DeviceMotionEvent : sig
  type t = [`DeviceMotionEvent | `Event] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`DeviceMotionEvent | `Event]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`DeviceMotionEvent | `Event]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `DeviceMotionEvent ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_acceleration: 'tags this -> DeviceMotionEventAcceleration.t option [@@js.get "acceleration"]
  val get_accelerationIncludingGravity: 'tags this -> DeviceMotionEventAcceleration.t option [@@js.get "accelerationIncludingGravity"]
  val get_interval: 'tags this -> float [@@js.get "interval"]
  val get_rotationRate: 'tags this -> DeviceMotionEventRotationRate.t option [@@js.get "rotationRate"]
  val create: ?acceleration:DeviceMotionEventAcceleration.t -> ?accelerationIncludingGravity:DeviceMotionEventAcceleration.t -> interval:float -> ?rotationRate:DeviceMotionEventRotationRate.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': type_:string -> ?eventInitDict:DeviceMotionEventInit.t -> unit -> t [@@js.create]
end
module ElementDefinitionOptions : sig
  type t = [`ElementDefinitionOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ElementDefinitionOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ElementDefinitionOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ElementDefinitionOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_extends: 'tags this -> string option [@@js.get "extends"]
  val set_extends: 'tags this -> string -> unit [@@js.set "extends"]
  val create: ?extends:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module[@js.scope "BarProp"] BarProp : sig
  type t = [`BarProp] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`BarProp]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`BarProp]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `BarProp ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_visible: 'tags this -> bool [@@js.get "visible"]
  val create: visible:bool -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end
module FrameRequestCallback : sig
  type t = [`FrameRequestCallback] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`FrameRequestCallback]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`FrameRequestCallback]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `FrameRequestCallback ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val apply: 'tags this -> time:DOMHighResTimeStamp.t -> unit [@@js.apply]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module AnimationFrameProvider : sig
  type t = [`AnimationFrameProvider] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AnimationFrameProvider]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AnimationFrameProvider]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `AnimationFrameProvider ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val cancelAnimationFrame: 'tags this -> handle:float -> unit [@@js.call "cancelAnimationFrame"]
  val requestAnimationFrame: 'tags this -> callback:FrameRequestCallback.t -> float [@@js.call "requestAnimationFrame"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module InnerHTML : sig
  type t = [`InnerHTML] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`InnerHTML]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`InnerHTML]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `InnerHTML ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_innerHTML: 'tags this -> string [@@js.get "innerHTML"]
  val set_innerHTML: 'tags this -> string -> unit [@@js.set "innerHTML"]
  val create: innerHTML:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module ElementContentEditable : sig
  type t = [`ElementContentEditable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ElementContentEditable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ElementContentEditable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ElementContentEditable ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_contentEditable: 'tags this -> string [@@js.get "contentEditable"]
  val set_contentEditable: 'tags this -> string -> unit [@@js.set "contentEditable"]
  val get_enterKeyHint: 'tags this -> string [@@js.get "enterKeyHint"]
  val set_enterKeyHint: 'tags this -> string -> unit [@@js.set "enterKeyHint"]
  val get_inputMode: 'tags this -> string [@@js.get "inputMode"]
  val set_inputMode: 'tags this -> string -> unit [@@js.set "inputMode"]
  val get_isContentEditable: 'tags this -> bool [@@js.get "isContentEditable"]
  val create: contentEditable:string -> enterKeyHint:string -> inputMode:string -> isContentEditable:bool -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module[@js.scope "MediaList"] MediaList : sig
  type t = [`MediaList | string ArrayLike.tags_1 | string IterableIterator.tags_1] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`MediaList | string ArrayLike.tags_1 | string IterableIterator.tags_1]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`MediaList | string ArrayLike.tags_1 | string IterableIterator.tags_1]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MediaList ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  (* [Symbol.iterator]: unit -> string IterableIterator.t_1 *)
  val get_length: 'tags this -> float [@@js.get "length"]
  val get_mediaText: 'tags this -> string [@@js.get "mediaText"]
  val set_mediaText: 'tags this -> string -> unit [@@js.set "mediaText"]
  val toString: 'tags this -> string [@@js.call "toString"]
  val appendMedium: 'tags this -> medium:string -> unit [@@js.call "appendMedium"]
  val deleteMedium: 'tags this -> medium:string -> unit [@@js.call "deleteMedium"]
  val item: 'tags this -> index:float -> string option [@@js.call "item"]
  val get: 'tags this -> float -> string [@@js.index_get]
  val set: 'tags this -> float -> string -> unit [@@js.index_set]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module CSSStyleSheetInit : sig
  type t = [`CSSStyleSheetInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`CSSStyleSheetInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`CSSStyleSheetInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `CSSStyleSheetInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_baseURL: 'tags this -> string option [@@js.get "baseURL"]
  val set_baseURL: 'tags this -> string -> unit [@@js.set "baseURL"]
  val get_disabled: 'tags this -> bool option [@@js.get "disabled"]
  val set_disabled: 'tags this -> bool -> unit [@@js.set "disabled"]
  val get_media: 'tags this -> ([`String of string | `Other of MediaList.t] [@js.union on_field "dummy"]) Primitive.t option [@@js.get "media"]
  val set_media: 'tags this -> ([`U1 of MediaList.t | `U2 of string] [@js.union]) -> unit [@@js.set "media"]
  val create: ?baseURL:string -> ?disabled:bool -> ?media:([`String of string | `Other of MediaList.t] [@js.union on_field "dummy"]) Primitive.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** An object of this type is returned by the files property of the HTML <input> element; this lets you access the list of files selected with the <input type="file"> element. It's also used for a list of files dropped into web content when using the drag and drop API; see the DataTransfer object for details on this usage. *)
module[@js.scope "FileList"] FileList : sig
  type t = [`FileList | File.t ArrayLike.tags_1 | File.t IterableIterator.tags_1] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`FileList | File.t ArrayLike.tags_1 | File.t IterableIterator.tags_1]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`FileList | File.t ArrayLike.tags_1 | File.t IterableIterator.tags_1]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `FileList ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  (* [Symbol.iterator]: unit -> File.t IterableIterator.t_1 *)
  val get_length: 'tags this -> float [@@js.get "length"]
  val item: 'tags this -> index:float -> File.t option [@@js.call "item"]
  val get: 'tags this -> float -> File.t [@@js.index_get]
  val set: 'tags this -> float -> File.t -> unit [@@js.index_set]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module FunctionStringCallback : sig
  type t = [`FunctionStringCallback] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`FunctionStringCallback]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`FunctionStringCallback]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `FunctionStringCallback ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val apply: 'tags this -> data:string -> unit [@@js.apply]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module FileSystemFlags : sig
  type t = [`FileSystemFlags] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`FileSystemFlags]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`FileSystemFlags]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `FileSystemFlags ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_create: 'tags this -> bool option [@@js.get "create"]
  val set_create: 'tags this -> bool -> unit [@@js.set "create"]
  val get_exclusive: 'tags this -> bool option [@@js.get "exclusive"]
  val set_exclusive: 'tags this -> bool -> unit [@@js.set "exclusive"]
  val create: ?create_:(bool[@js "create"]) -> ?exclusive:bool -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module ErrorCallback : sig
  type t = [`ErrorCallback] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ErrorCallback]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ErrorCallback]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ErrorCallback ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val apply: 'tags this -> err:DOMException.t -> unit [@@js.apply]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module[@js.scope "FileSystem"] rec FileSystem : sig
  type t = [`FileSystem] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`FileSystem]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`FileSystem]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `FileSystem ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_name: 'tags this -> string [@@js.get "name"]
  val get_root: 'tags this -> FileSystemDirectoryEntry.t [@@js.get "root"]
  val create: name:string -> root:FileSystemDirectoryEntry.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end
and[@js.scope "FileSystemDirectoryEntry"] FileSystemDirectoryEntry : sig
  type t = [`FileSystemDirectoryEntry | `FileSystemEntry] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`FileSystemDirectoryEntry | `FileSystemEntry]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`FileSystemDirectoryEntry | `FileSystemEntry]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `FileSystemDirectoryEntry ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val createReader: 'tags this -> FileSystemDirectoryReader.t [@@js.call "createReader"]
  val getDirectory: 'tags this -> ?path:string option -> ?options:FileSystemFlags.t -> ?successCallback:FileSystemEntryCallback.t -> ?errorCallback:ErrorCallback.t -> unit -> unit [@@js.call "getDirectory"]
  val getFile: 'tags this -> ?path:string option -> ?options:FileSystemFlags.t -> ?successCallback:FileSystemEntryCallback.t -> ?errorCallback:ErrorCallback.t -> unit -> unit [@@js.call "getFile"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
and[@js.scope "FileSystemDirectoryReader"] FileSystemDirectoryReader : sig
  type t = [`FileSystemDirectoryReader] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`FileSystemDirectoryReader]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`FileSystemDirectoryReader]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `FileSystemDirectoryReader ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val readEntries: 'tags this -> successCallback:FileSystemEntriesCallback.t -> ?errorCallback:ErrorCallback.t -> unit -> unit [@@js.call "readEntries"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
and FileSystemEntriesCallback : sig
  type t = [`FileSystemEntriesCallback] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`FileSystemEntriesCallback]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`FileSystemEntriesCallback]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `FileSystemEntriesCallback ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val apply: 'tags this -> entries:FileSystemEntry.t list -> unit [@@js.apply]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
and[@js.scope "FileSystemEntry"] FileSystemEntry : sig
  type t = [`FileSystemEntry] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`FileSystemEntry]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`FileSystemEntry]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `FileSystemEntry ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_filesystem: 'tags this -> FileSystem.t [@@js.get "filesystem"]
  val get_fullPath: 'tags this -> string [@@js.get "fullPath"]
  val get_isDirectory: 'tags this -> bool [@@js.get "isDirectory"]
  val get_isFile: 'tags this -> bool [@@js.get "isFile"]
  val get_name: 'tags this -> string [@@js.get "name"]
  val getParent: 'tags this -> ?successCallback:FileSystemEntryCallback.t -> ?errorCallback:ErrorCallback.t -> unit -> unit [@@js.call "getParent"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
and FileSystemEntryCallback : sig
  type t = [`FileSystemEntryCallback] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`FileSystemEntryCallback]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`FileSystemEntryCallback]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `FileSystemEntryCallback ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val apply: 'tags this -> entry:FileSystemEntry.t -> unit [@@js.apply]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** One drag data item. During a drag operation, each drag event has a dataTransfer property which contains a list of drag data items. Each item in the list is a DataTransferItem object. *)
module[@js.scope "DataTransferItem"] DataTransferItem : sig
  type t = [`DataTransferItem] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`DataTransferItem]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`DataTransferItem]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `DataTransferItem ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Returns the drag data item kind, one of: "string", "file". *)
  val get_kind: 'tags this -> string [@@js.get "kind"]
  
  (** Returns the drag data item type string. *)
  val get_type: 'tags this -> string [@@js.get "type"]
  
  (** Returns a File object, if the drag data item kind is File. *)
  val getAsFile: 'tags this -> File.t option [@@js.call "getAsFile"]
  
  (** Invokes the callback with the string data as the argument, if the drag data item kind is text. *)
  val getAsString: 'tags this -> callback:FunctionStringCallback.t option -> unit [@@js.call "getAsString"]
  val webkitGetAsEntry: 'tags this -> FileSystemEntry.t option [@@js.call "webkitGetAsEntry"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** A list of DataTransferItem objects representing items being dragged. During a drag operation, each DragEvent has a dataTransfer property and that property is a DataTransferItemList. *)
module[@js.scope "DataTransferItemList"] DataTransferItemList : sig
  type t = [`DataTransferItemList | DataTransferItem.t ArrayLike.tags_1 | DataTransferItem.t IterableIterator.tags_1] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`DataTransferItemList | DataTransferItem.t ArrayLike.tags_1 | DataTransferItem.t IterableIterator.tags_1]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`DataTransferItemList | DataTransferItem.t ArrayLike.tags_1 | DataTransferItem.t IterableIterator.tags_1]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `DataTransferItemList ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  (* [Symbol.iterator]: unit -> DataTransferItem.t IterableIterator.t_1 *)
  
  (** Returns the number of items in the drag data store. *)
  val get_length: 'tags this -> float [@@js.get "length"]
  
  (** Adds a new entry for the given data to the drag data store. If the data is plain text then a type string has to be provided also. *)
  val add: 'tags this -> data:string -> type_:string -> DataTransferItem.t option [@@js.call "add"]
  
  (** Adds a new entry for the given data to the drag data store. If the data is plain text then a type string has to be provided also. *)
  val add': 'tags this -> data:File.t -> DataTransferItem.t option [@@js.call "add"]
  
  (** Removes all the entries in the drag data store. *)
  val clear: 'tags this -> unit [@@js.call "clear"]
  
  (** Removes the indexth entry in the drag data store. *)
  val remove: 'tags this -> index:float -> unit [@@js.call "remove"]
  val get: 'tags this -> float -> DataTransferItem.t [@@js.index_get]
  val set: 'tags this -> float -> DataTransferItem.t -> unit [@@js.index_set]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module FullscreenNavigationUI : sig
  type t = ([`L_s141_auto[@js "auto"] | `L_s394_hide[@js "hide"] | `L_s720_show[@js "show"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module FullscreenOptions : sig
  type t = [`FullscreenOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`FullscreenOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`FullscreenOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `FullscreenOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_navigationUI: 'tags this -> FullscreenNavigationUI.t option [@@js.get "navigationUI"]
  val set_navigationUI: 'tags this -> FullscreenNavigationUI.t -> unit [@@js.set "navigationUI"]
  val create: ?navigationUI:FullscreenNavigationUI.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** A set of space-separated tokens. Such a set is returned by Element.classList, HTMLLinkElement.relList, HTMLAnchorElement.relList, HTMLAreaElement.relList, HTMLIframeElement.sandbox, or HTMLOutputElement.htmlFor. It is indexed beginning with 0 as with JavaScript Array objects. DOMTokenList is always case-sensitive. *)
module[@js.scope "DOMTokenList"] DOMTokenList : sig
  type t = [`DOMTokenList | string ArrayLike.tags_1 | string IterableIterator.tags_1] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`DOMTokenList | string ArrayLike.tags_1 | string IterableIterator.tags_1]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`DOMTokenList | string ArrayLike.tags_1 | string IterableIterator.tags_1]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `DOMTokenList ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  (* [Symbol.iterator]: unit -> string IterableIterator.t_1 *)
  val entries: 'tags this -> (float * string) IterableIterator.t_1 [@@js.call "entries"]
  val keys: 'tags this -> float IterableIterator.t_1 [@@js.call "keys"]
  val values: 'tags this -> string IterableIterator.t_1 [@@js.call "values"]
  
  (** Returns the number of tokens. *)
  val get_length: 'tags this -> float [@@js.get "length"]
  
  (**
    Returns the associated set as string.
    
    Can be set, to change the associated attribute.
  *)
  val get_value: 'tags this -> string [@@js.get "value"]
  
  (**
    Returns the associated set as string.
    
    Can be set, to change the associated attribute.
  *)
  val set_value: 'tags this -> string -> unit [@@js.set "value"]
  val toString: 'tags this -> string [@@js.call "toString"]
  
  (**
    Adds all arguments passed, except those already present.
    
    Throws a "SyntaxError" DOMException if one of the arguments is the empty string.
    
    Throws an "InvalidCharacterError" DOMException if one of the arguments contains any ASCII whitespace.
  *)
  val add: 'tags this -> tokens:(string list [@js.variadic]) -> unit [@@js.call "add"]
  
  (** Returns true if token is present, and false otherwise. *)
  val contains: 'tags this -> token:string -> bool [@@js.call "contains"]
  
  (** Returns the token with index index. *)
  val item: 'tags this -> index:float -> string option [@@js.call "item"]
  
  (**
    Removes arguments passed, if they are present.
    
    Throws a "SyntaxError" DOMException if one of the arguments is the empty string.
    
    Throws an "InvalidCharacterError" DOMException if one of the arguments contains any ASCII whitespace.
  *)
  val remove: 'tags this -> tokens:(string list [@js.variadic]) -> unit [@@js.call "remove"]
  
  (**
    Replaces token with newToken.
    
    Returns true if token was replaced with newToken, and false otherwise.
    
    Throws a "SyntaxError" DOMException if one of the arguments is the empty string.
    
    Throws an "InvalidCharacterError" DOMException if one of the arguments contains any ASCII whitespace.
  *)
  val replace: 'tags this -> token:string -> newToken:string -> bool [@@js.call "replace"]
  
  (**
    Returns true if token is in the associated attribute's supported tokens. Returns false otherwise.
    
    Throws a TypeError if the associated attribute has no supported tokens defined.
  *)
  val supports: 'tags this -> token:string -> bool [@@js.call "supports"]
  
  (**
    If force is not given, "toggles" token, removing it if it's present and adding it if it's not present. If force is true, adds token (same as add()). If force is false, removes token (same as remove()).
    
    Returns true if token is now present, and false otherwise.
    
    Throws a "SyntaxError" DOMException if token is empty.
    
    Throws an "InvalidCharacterError" DOMException if token contains any spaces.
  *)
  val toggle: 'tags this -> token:string -> ?force:bool -> unit -> bool [@@js.call "toggle"]
  val forEach: 'tags this -> callbackfn:(value:string -> key:float -> parent:t -> unit) -> ?thisArg:any -> unit -> unit [@@js.call "forEach"]
  val get: 'tags this -> float -> string [@@js.index_get]
  val set: 'tags this -> float -> string -> unit [@@js.index_set]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module[@js.scope "DOMRectList"] DOMRectList : sig
  type t = [`DOMRectList | DOMRect.t ArrayLike.tags_1 | DOMRect.t IterableIterator.tags_1] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`DOMRectList | DOMRect.t ArrayLike.tags_1 | DOMRect.t IterableIterator.tags_1]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`DOMRectList | DOMRect.t ArrayLike.tags_1 | DOMRect.t IterableIterator.tags_1]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `DOMRectList ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  (* [Symbol.iterator]: unit -> DOMRect.t IterableIterator.t_1 *)
  val get_length: 'tags this -> float [@@js.get "length"]
  val item: 'tags this -> index:float -> DOMRect.t option [@@js.call "item"]
  val get: 'tags this -> float -> DOMRect.t [@@js.index_get]
  val set: 'tags this -> float -> DOMRect.t -> unit [@@js.index_set]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module CompositeOperationOrAuto : sig
  type t = ([`L_s141_auto[@js "auto"] | `L_s670_replace[@js "replace"] | `L_s95_accumulate[@js "accumulate"] | `L_s99_add[@js "add"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module PropertyIndexedKeyframes : sig
  type t = [`PropertyIndexedKeyframes] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`PropertyIndexedKeyframes]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`PropertyIndexedKeyframes]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PropertyIndexedKeyframes ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_composite: 'tags this -> (CompositeOperationOrAuto.t list, CompositeOperationOrAuto.t) union2 option [@@js.get "composite"]
  val set_composite: 'tags this -> ([`U1 of CompositeOperationOrAuto.t | `U2 of CompositeOperationOrAuto.t list] [@js.union]) -> unit [@@js.set "composite"]
  val get_easing: 'tags this -> ([`String of string | `Other of string list] [@js.union on_field "dummy"]) Primitive.t option [@@js.get "easing"]
  val set_easing: 'tags this -> ([`U1 of string | `U2 of string list] [@js.union]) -> unit [@@js.set "easing"]
  val get_offset: 'tags this -> ([`Number of float | `Other of float option list] [@js.union on_field "dummy"]) Primitive.t option [@@js.get "offset"]
  val set_offset: 'tags this -> ([`U1 of float | `U2 of float option list] [@js.union]) -> unit [@@js.set "offset"]
  val get: 'tags this -> string -> ([`Number of float | `String of string | `Null | `Undefined | `Other of ([`String of string | `Other of float option] [@js.union on_field "dummy"]) Primitive.t list] [@js.union on_field "dummy"]) Primitive.t [@@js.index_get]
  val set: 'tags this -> string -> ([`Null | `Undefined of undefined | `U1 of string | `U2 of string list | `U3 of float | `U4 of float option list] [@js.union]) -> unit [@@js.index_set]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module IterationCompositeOperation : sig
  type t = ([`L_s670_replace[@js "replace"] | `L_s95_accumulate[@js "accumulate"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module CompositeOperation : sig
  type t = ([`L_s670_replace[@js "replace"] | `L_s95_accumulate[@js "accumulate"] | `L_s99_add[@js "add"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module PlaybackDirection : sig
  type t = ([`L_s111_alternate[@js "alternate"] | `L_s112_alternate_reverse[@js "alternate-reverse"] | `L_s550_normal[@js "normal"] | `L_s679_reverse[@js "reverse"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module FillMode : sig
  type t = ([`L_s141_auto[@js "auto"] | `L_s146_backwards[@js "backwards"] | `L_s168_both[@js "both"] | `L_s359_forwards[@js "forwards"] | `L_s548_none[@js "none"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module EffectTiming : sig
  type t = [`EffectTiming] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EffectTiming]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EffectTiming]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `EffectTiming ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_delay: 'tags this -> float option [@@js.get "delay"]
  val set_delay: 'tags this -> float -> unit [@@js.set "delay"]
  val get_direction: 'tags this -> PlaybackDirection.t option [@@js.get "direction"]
  val set_direction: 'tags this -> PlaybackDirection.t -> unit [@@js.set "direction"]
  val get_duration: 'tags this -> ([`Number of float | `String of string] [@js.union on_field "dummy"]) Primitive.t option [@@js.get "duration"]
  val set_duration: 'tags this -> ([`U1 of float | `U2 of string] [@js.union]) -> unit [@@js.set "duration"]
  val get_easing: 'tags this -> string option [@@js.get "easing"]
  val set_easing: 'tags this -> string -> unit [@@js.set "easing"]
  val get_endDelay: 'tags this -> float option [@@js.get "endDelay"]
  val set_endDelay: 'tags this -> float -> unit [@@js.set "endDelay"]
  val get_fill: 'tags this -> FillMode.t option [@@js.get "fill"]
  val set_fill: 'tags this -> FillMode.t -> unit [@@js.set "fill"]
  val get_iterationStart: 'tags this -> float option [@@js.get "iterationStart"]
  val set_iterationStart: 'tags this -> float -> unit [@@js.set "iterationStart"]
  val get_iterations: 'tags this -> float option [@@js.get "iterations"]
  val set_iterations: 'tags this -> float -> unit [@@js.set "iterations"]
  val get_playbackRate: 'tags this -> float option [@@js.get "playbackRate"]
  val set_playbackRate: 'tags this -> float -> unit [@@js.set "playbackRate"]
  val create: ?delay:float -> ?direction:PlaybackDirection.t -> ?duration:([`Number of float | `String of string] [@js.union on_field "dummy"]) Primitive.t -> ?easing:string -> ?endDelay:float -> ?fill:FillMode.t -> ?iterationStart:float -> ?iterations:float -> ?playbackRate:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module KeyframeEffectOptions : sig
  type t = [`EffectTiming | `KeyframeEffectOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EffectTiming | `KeyframeEffectOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EffectTiming | `KeyframeEffectOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `KeyframeEffectOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_composite: 'tags this -> CompositeOperation.t option [@@js.get "composite"]
  val set_composite: 'tags this -> CompositeOperation.t -> unit [@@js.set "composite"]
  val get_iterationComposite: 'tags this -> IterationCompositeOperation.t option [@@js.get "iterationComposite"]
  val set_iterationComposite: 'tags this -> IterationCompositeOperation.t -> unit [@@js.set "iterationComposite"]
  val get_pseudoElement: 'tags this -> string option option [@@js.get "pseudoElement"]
  val set_pseudoElement: 'tags this -> string option -> unit [@@js.set "pseudoElement"]
  val create: ?composite:CompositeOperation.t -> ?iterationComposite:IterationCompositeOperation.t -> ?pseudoElement:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module KeyframeAnimationOptions : sig
  type t = [`EffectTiming | `KeyframeAnimationOptions | `KeyframeEffectOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EffectTiming | `KeyframeAnimationOptions | `KeyframeEffectOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EffectTiming | `KeyframeAnimationOptions | `KeyframeEffectOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `KeyframeAnimationOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_id: 'tags this -> string option [@@js.get "id"]
  val set_id: 'tags this -> string -> unit [@@js.set "id"]
  val create: ?id:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module Keyframe : sig
  type t = [`Keyframe] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Keyframe]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Keyframe]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `Keyframe ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_composite: 'tags this -> CompositeOperationOrAuto.t option [@@js.get "composite"]
  val set_composite: 'tags this -> CompositeOperationOrAuto.t -> unit [@@js.set "composite"]
  val get_easing: 'tags this -> string option [@@js.get "easing"]
  val set_easing: 'tags this -> string -> unit [@@js.set "easing"]
  val get_offset: 'tags this -> float option option [@@js.get "offset"]
  val set_offset: 'tags this -> float option -> unit [@@js.set "offset"]
  val get: 'tags this -> string -> ([`Number of float | `String of string | `Null | `Undefined] [@js.union on_field "dummy"]) Primitive.t [@@js.index_get]
  val set: 'tags this -> string -> ([`Null | `Undefined of undefined | `U1 of string | `U2 of float] [@js.union]) -> unit [@@js.index_set]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module GetAnimationsOptions : sig
  type t = [`GetAnimationsOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`GetAnimationsOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`GetAnimationsOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `GetAnimationsOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_subtree: 'tags this -> bool option [@@js.get "subtree"]
  val set_subtree: 'tags this -> bool -> unit [@@js.set "subtree"]
  val create: ?subtree:bool -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module AnimationReplaceState : sig
  type t = ([`L_s598_persisted[@js "persisted"] | `L_s667_removed[@js "removed"] | `L_s98_active[@js "active"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module AnimationPlayState : sig
  type t = ([`L_s346_finished[@js "finished"] | `L_s414_idle[@js "idle"] | `L_s593_paused[@js "paused"] | `L_s690_running[@js "running"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module OptionalEffectTiming : sig
  type t = [`OptionalEffectTiming] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`OptionalEffectTiming]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`OptionalEffectTiming]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `OptionalEffectTiming ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_delay: 'tags this -> float option [@@js.get "delay"]
  val set_delay: 'tags this -> float -> unit [@@js.set "delay"]
  val get_direction: 'tags this -> PlaybackDirection.t option [@@js.get "direction"]
  val set_direction: 'tags this -> PlaybackDirection.t -> unit [@@js.set "direction"]
  val get_duration: 'tags this -> ([`Number of float | `String of string] [@js.union on_field "dummy"]) Primitive.t option [@@js.get "duration"]
  val set_duration: 'tags this -> ([`U1 of float | `U2 of string] [@js.union]) -> unit [@@js.set "duration"]
  val get_easing: 'tags this -> string option [@@js.get "easing"]
  val set_easing: 'tags this -> string -> unit [@@js.set "easing"]
  val get_endDelay: 'tags this -> float option [@@js.get "endDelay"]
  val set_endDelay: 'tags this -> float -> unit [@@js.set "endDelay"]
  val get_fill: 'tags this -> FillMode.t option [@@js.get "fill"]
  val set_fill: 'tags this -> FillMode.t -> unit [@@js.set "fill"]
  val get_iterationStart: 'tags this -> float option [@@js.get "iterationStart"]
  val set_iterationStart: 'tags this -> float -> unit [@@js.set "iterationStart"]
  val get_iterations: 'tags this -> float option [@@js.get "iterations"]
  val set_iterations: 'tags this -> float -> unit [@@js.set "iterations"]
  val get_playbackRate: 'tags this -> float option [@@js.get "playbackRate"]
  val set_playbackRate: 'tags this -> float -> unit [@@js.set "playbackRate"]
  val create: ?delay:float -> ?direction:PlaybackDirection.t -> ?duration:([`Number of float | `String of string] [@js.union on_field "dummy"]) Primitive.t -> ?easing:string -> ?endDelay:float -> ?fill:FillMode.t -> ?iterationStart:float -> ?iterations:float -> ?playbackRate:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module CSSNumberish : sig
  type t = float
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module ComputedEffectTiming : sig
  type t = [`ComputedEffectTiming | `EffectTiming] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ComputedEffectTiming | `EffectTiming]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ComputedEffectTiming | `EffectTiming]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ComputedEffectTiming ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_activeDuration: 'tags this -> CSSNumberish.t option [@@js.get "activeDuration"]
  val set_activeDuration: 'tags this -> CSSNumberish.t -> unit [@@js.set "activeDuration"]
  val get_currentIteration: 'tags this -> float option option [@@js.get "currentIteration"]
  val set_currentIteration: 'tags this -> float option -> unit [@@js.set "currentIteration"]
  val get_endTime: 'tags this -> CSSNumberish.t option [@@js.get "endTime"]
  val set_endTime: 'tags this -> CSSNumberish.t -> unit [@@js.set "endTime"]
  val get_localTime: 'tags this -> CSSNumberish.t option option [@@js.get "localTime"]
  val set_localTime: 'tags this -> CSSNumberish.t option -> unit [@@js.set "localTime"]
  val get_progress: 'tags this -> float option option [@@js.get "progress"]
  val set_progress: 'tags this -> float option -> unit [@@js.set "progress"]
  val get_startTime: 'tags this -> CSSNumberish.t option [@@js.get "startTime"]
  val set_startTime: 'tags this -> CSSNumberish.t -> unit [@@js.set "startTime"]
  val create: ?activeDuration:CSSNumberish.t -> ?currentIteration:float -> ?endTime:CSSNumberish.t -> ?localTime:CSSNumberish.t -> ?progress:float -> ?startTime:CSSNumberish.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module[@js.scope "AnimationEffect"] AnimationEffect : sig
  type t = [`AnimationEffect] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AnimationEffect]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AnimationEffect]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `AnimationEffect ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val getComputedTiming: 'tags this -> ComputedEffectTiming.t [@@js.call "getComputedTiming"]
  val getTiming: 'tags this -> EffectTiming.t [@@js.call "getTiming"]
  val updateTiming: 'tags this -> ?timing:OptionalEffectTiming.t -> unit -> unit [@@js.call "updateTiming"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module AnimationPlaybackEventInit : sig
  type t = [`AnimationPlaybackEventInit | `EventInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AnimationPlaybackEventInit | `EventInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AnimationPlaybackEventInit | `EventInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `AnimationPlaybackEventInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_currentTime: 'tags this -> CSSNumberish.t option option [@@js.get "currentTime"]
  val set_currentTime: 'tags this -> CSSNumberish.t option -> unit [@@js.set "currentTime"]
  val get_timelineTime: 'tags this -> CSSNumberish.t option option [@@js.get "timelineTime"]
  val set_timelineTime: 'tags this -> CSSNumberish.t option -> unit [@@js.set "timelineTime"]
  val create: ?currentTime:CSSNumberish.t -> ?timelineTime:CSSNumberish.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module[@js.scope "AnimationPlaybackEvent"] AnimationPlaybackEvent : sig
  type t = [`AnimationPlaybackEvent | `Event] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AnimationPlaybackEvent | `Event]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AnimationPlaybackEvent | `Event]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `AnimationPlaybackEvent ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_currentTime: 'tags this -> CSSNumberish.t option [@@js.get "currentTime"]
  val get_timelineTime: 'tags this -> CSSNumberish.t option [@@js.get "timelineTime"]
  val create: ?currentTime:CSSNumberish.t -> ?timelineTime:CSSNumberish.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': type_:string -> ?eventInitDict:AnimationPlaybackEventInit.t -> unit -> t [@@js.create]
end
module[@js.scope "Animation"] Animation : sig
  type t = [`Animation | `EventTarget] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Animation | `EventTarget]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Animation | `EventTarget]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `Animation ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_currentTime: 'tags this -> CSSNumberish.t option [@@js.get "currentTime"]
  val set_currentTime: 'tags this -> CSSNumberish.t option -> unit [@@js.set "currentTime"]
  val get_effect: 'tags this -> AnimationEffect.t option [@@js.get "effect"]
  val set_effect: 'tags this -> AnimationEffect.t option -> unit [@@js.set "effect"]
  val get_finished: 'tags this -> t Promise.t_1 [@@js.get "finished"]
  val get_id: 'tags this -> string [@@js.get "id"]
  val set_id: 'tags this -> string -> unit [@@js.set "id"]
  val get_oncancel: 'tags this -> (this:t -> ev:AnimationPlaybackEvent.t -> any) option [@@js.get "oncancel"]
  val set_oncancel: 'tags this -> (this:t -> ev:AnimationPlaybackEvent.t -> any) option -> unit [@@js.set "oncancel"]
  val get_onfinish: 'tags this -> (this:t -> ev:AnimationPlaybackEvent.t -> any) option [@@js.get "onfinish"]
  val set_onfinish: 'tags this -> (this:t -> ev:AnimationPlaybackEvent.t -> any) option -> unit [@@js.set "onfinish"]
  val get_onremove: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onremove"]
  val set_onremove: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onremove"]
  val get_pending: 'tags this -> bool [@@js.get "pending"]
  val get_playState: 'tags this -> AnimationPlayState.t [@@js.get "playState"]
  val get_playbackRate: 'tags this -> float [@@js.get "playbackRate"]
  val set_playbackRate: 'tags this -> float -> unit [@@js.set "playbackRate"]
  val get_ready: 'tags this -> t Promise.t_1 [@@js.get "ready"]
  val get_replaceState: 'tags this -> AnimationReplaceState.t [@@js.get "replaceState"]
  val get_startTime: 'tags this -> CSSNumberish.t option [@@js.get "startTime"]
  val set_startTime: 'tags this -> CSSNumberish.t option -> unit [@@js.set "startTime"]
  val get_timeline: 'tags this -> AnimationTimeline.t option [@@js.get "timeline"]
  val set_timeline: 'tags this -> AnimationTimeline.t option -> unit [@@js.set "timeline"]
  val cancel: 'tags this -> unit [@@js.call "cancel"]
  val commitStyles: 'tags this -> unit [@@js.call "commitStyles"]
  val finish: 'tags this -> unit [@@js.call "finish"]
  val pause: 'tags this -> unit [@@js.call "pause"]
  val persist: 'tags this -> unit [@@js.call "persist"]
  val play: 'tags this -> unit [@@js.call "play"]
  val reverse: 'tags this -> unit [@@js.call "reverse"]
  val updatePlaybackRate: 'tags this -> playbackRate:float -> unit [@@js.call "updatePlaybackRate"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'AnimationEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'AnimationEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: ?effect:AnimationEffect.t option -> ?timeline:AnimationTimeline.t option -> unit -> t [@@js.create]
end
module Animatable : sig
  type t = [`Animatable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Animatable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Animatable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `Animatable ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val animate: 'tags this -> keyframes:([`Null | `U1 of Keyframe.t list | `U2 of PropertyIndexedKeyframes.t] [@js.union]) -> ?options:([`U1 of float | `U2 of KeyframeAnimationOptions.t] [@js.union]) -> unit -> Animation.t [@@js.call "animate"]
  val getAnimations: 'tags this -> ?options:GetAnimationsOptions.t -> unit -> Animation.t list [@@js.call "getAnimations"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module AnimationEventInit : sig
  type t = [`AnimationEventInit | `EventInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AnimationEventInit | `EventInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AnimationEventInit | `EventInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `AnimationEventInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_animationName: 'tags this -> string option [@@js.get "animationName"]
  val set_animationName: 'tags this -> string -> unit [@@js.set "animationName"]
  val get_elapsedTime: 'tags this -> float option [@@js.get "elapsedTime"]
  val set_elapsedTime: 'tags this -> float -> unit [@@js.set "elapsedTime"]
  val get_pseudoElement: 'tags this -> string option [@@js.get "pseudoElement"]
  val set_pseudoElement: 'tags this -> string -> unit [@@js.set "pseudoElement"]
  val create: ?animationName:string -> ?elapsedTime:float -> ?pseudoElement:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** Events providing information related to animations. *)
module[@js.scope "AnimationEvent"] AnimationEvent : sig
  type t = [`AnimationEvent | `Event] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AnimationEvent | `Event]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AnimationEvent | `Event]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `AnimationEvent ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_animationName: 'tags this -> string [@@js.get "animationName"]
  val get_elapsedTime: 'tags this -> float [@@js.get "elapsedTime"]
  val get_pseudoElement: 'tags this -> string [@@js.get "pseudoElement"]
  val create: animationName:string -> elapsedTime:float -> pseudoElement:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': type_:string -> ?animationEventInitDict:AnimationEventInit.t -> unit -> t [@@js.create]
end
module ARIAMixin : sig
  type t = [`ARIAMixin] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ARIAMixin ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_ariaAtomic: 'tags this -> string option [@@js.get "ariaAtomic"]
  val set_ariaAtomic: 'tags this -> string option -> unit [@@js.set "ariaAtomic"]
  val get_ariaAutoComplete: 'tags this -> string option [@@js.get "ariaAutoComplete"]
  val set_ariaAutoComplete: 'tags this -> string option -> unit [@@js.set "ariaAutoComplete"]
  val get_ariaBusy: 'tags this -> string option [@@js.get "ariaBusy"]
  val set_ariaBusy: 'tags this -> string option -> unit [@@js.set "ariaBusy"]
  val get_ariaChecked: 'tags this -> string option [@@js.get "ariaChecked"]
  val set_ariaChecked: 'tags this -> string option -> unit [@@js.set "ariaChecked"]
  val get_ariaColCount: 'tags this -> string option [@@js.get "ariaColCount"]
  val set_ariaColCount: 'tags this -> string option -> unit [@@js.set "ariaColCount"]
  val get_ariaColIndex: 'tags this -> string option [@@js.get "ariaColIndex"]
  val set_ariaColIndex: 'tags this -> string option -> unit [@@js.set "ariaColIndex"]
  val get_ariaColSpan: 'tags this -> string option [@@js.get "ariaColSpan"]
  val set_ariaColSpan: 'tags this -> string option -> unit [@@js.set "ariaColSpan"]
  val get_ariaCurrent: 'tags this -> string option [@@js.get "ariaCurrent"]
  val set_ariaCurrent: 'tags this -> string option -> unit [@@js.set "ariaCurrent"]
  val get_ariaDisabled: 'tags this -> string option [@@js.get "ariaDisabled"]
  val set_ariaDisabled: 'tags this -> string option -> unit [@@js.set "ariaDisabled"]
  val get_ariaExpanded: 'tags this -> string option [@@js.get "ariaExpanded"]
  val set_ariaExpanded: 'tags this -> string option -> unit [@@js.set "ariaExpanded"]
  val get_ariaHasPopup: 'tags this -> string option [@@js.get "ariaHasPopup"]
  val set_ariaHasPopup: 'tags this -> string option -> unit [@@js.set "ariaHasPopup"]
  val get_ariaHidden: 'tags this -> string option [@@js.get "ariaHidden"]
  val set_ariaHidden: 'tags this -> string option -> unit [@@js.set "ariaHidden"]
  val get_ariaKeyShortcuts: 'tags this -> string option [@@js.get "ariaKeyShortcuts"]
  val set_ariaKeyShortcuts: 'tags this -> string option -> unit [@@js.set "ariaKeyShortcuts"]
  val get_ariaLabel: 'tags this -> string option [@@js.get "ariaLabel"]
  val set_ariaLabel: 'tags this -> string option -> unit [@@js.set "ariaLabel"]
  val get_ariaLevel: 'tags this -> string option [@@js.get "ariaLevel"]
  val set_ariaLevel: 'tags this -> string option -> unit [@@js.set "ariaLevel"]
  val get_ariaLive: 'tags this -> string option [@@js.get "ariaLive"]
  val set_ariaLive: 'tags this -> string option -> unit [@@js.set "ariaLive"]
  val get_ariaModal: 'tags this -> string option [@@js.get "ariaModal"]
  val set_ariaModal: 'tags this -> string option -> unit [@@js.set "ariaModal"]
  val get_ariaMultiLine: 'tags this -> string option [@@js.get "ariaMultiLine"]
  val set_ariaMultiLine: 'tags this -> string option -> unit [@@js.set "ariaMultiLine"]
  val get_ariaMultiSelectable: 'tags this -> string option [@@js.get "ariaMultiSelectable"]
  val set_ariaMultiSelectable: 'tags this -> string option -> unit [@@js.set "ariaMultiSelectable"]
  val get_ariaOrientation: 'tags this -> string option [@@js.get "ariaOrientation"]
  val set_ariaOrientation: 'tags this -> string option -> unit [@@js.set "ariaOrientation"]
  val get_ariaPlaceholder: 'tags this -> string option [@@js.get "ariaPlaceholder"]
  val set_ariaPlaceholder: 'tags this -> string option -> unit [@@js.set "ariaPlaceholder"]
  val get_ariaPosInSet: 'tags this -> string option [@@js.get "ariaPosInSet"]
  val set_ariaPosInSet: 'tags this -> string option -> unit [@@js.set "ariaPosInSet"]
  val get_ariaPressed: 'tags this -> string option [@@js.get "ariaPressed"]
  val set_ariaPressed: 'tags this -> string option -> unit [@@js.set "ariaPressed"]
  val get_ariaReadOnly: 'tags this -> string option [@@js.get "ariaReadOnly"]
  val set_ariaReadOnly: 'tags this -> string option -> unit [@@js.set "ariaReadOnly"]
  val get_ariaRequired: 'tags this -> string option [@@js.get "ariaRequired"]
  val set_ariaRequired: 'tags this -> string option -> unit [@@js.set "ariaRequired"]
  val get_ariaRoleDescription: 'tags this -> string option [@@js.get "ariaRoleDescription"]
  val set_ariaRoleDescription: 'tags this -> string option -> unit [@@js.set "ariaRoleDescription"]
  val get_ariaRowCount: 'tags this -> string option [@@js.get "ariaRowCount"]
  val set_ariaRowCount: 'tags this -> string option -> unit [@@js.set "ariaRowCount"]
  val get_ariaRowIndex: 'tags this -> string option [@@js.get "ariaRowIndex"]
  val set_ariaRowIndex: 'tags this -> string option -> unit [@@js.set "ariaRowIndex"]
  val get_ariaRowSpan: 'tags this -> string option [@@js.get "ariaRowSpan"]
  val set_ariaRowSpan: 'tags this -> string option -> unit [@@js.set "ariaRowSpan"]
  val get_ariaSelected: 'tags this -> string option [@@js.get "ariaSelected"]
  val set_ariaSelected: 'tags this -> string option -> unit [@@js.set "ariaSelected"]
  val get_ariaSetSize: 'tags this -> string option [@@js.get "ariaSetSize"]
  val set_ariaSetSize: 'tags this -> string option -> unit [@@js.set "ariaSetSize"]
  val get_ariaSort: 'tags this -> string option [@@js.get "ariaSort"]
  val set_ariaSort: 'tags this -> string option -> unit [@@js.set "ariaSort"]
  val get_ariaValueMax: 'tags this -> string option [@@js.get "ariaValueMax"]
  val set_ariaValueMax: 'tags this -> string option -> unit [@@js.set "ariaValueMax"]
  val get_ariaValueMin: 'tags this -> string option [@@js.get "ariaValueMin"]
  val set_ariaValueMin: 'tags this -> string option -> unit [@@js.set "ariaValueMin"]
  val get_ariaValueNow: 'tags this -> string option [@@js.get "ariaValueNow"]
  val set_ariaValueNow: 'tags this -> string option -> unit [@@js.set "ariaValueNow"]
  val get_ariaValueText: 'tags this -> string option [@@js.get "ariaValueText"]
  val set_ariaValueText: 'tags this -> string option -> unit [@@js.set "ariaValueText"]
  val create: ?ariaAtomic:string -> ?ariaAutoComplete:string -> ?ariaBusy:string -> ?ariaChecked:string -> ?ariaColCount:string -> ?ariaColIndex:string -> ?ariaColSpan:string -> ?ariaCurrent:string -> ?ariaDisabled:string -> ?ariaExpanded:string -> ?ariaHasPopup:string -> ?ariaHidden:string -> ?ariaKeyShortcuts:string -> ?ariaLabel:string -> ?ariaLevel:string -> ?ariaLive:string -> ?ariaModal:string -> ?ariaMultiLine:string -> ?ariaMultiSelectable:string -> ?ariaOrientation:string -> ?ariaPlaceholder:string -> ?ariaPosInSet:string -> ?ariaPressed:string -> ?ariaReadOnly:string -> ?ariaRequired:string -> ?ariaRoleDescription:string -> ?ariaRowCount:string -> ?ariaRowIndex:string -> ?ariaRowSpan:string -> ?ariaSelected:string -> ?ariaSetSize:string -> ?ariaSort:string -> ?ariaValueMax:string -> ?ariaValueMin:string -> ?ariaValueNow:string -> ?ariaValueText:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module GLintptr : sig
  type t = float
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end

(** The ANGLE_instanced_arrays extension is part of the WebGL API and allows to draw the same object, or groups of similar objects multiple times, if they share the same vertex data, primitive count and type. *)
module ANGLE_instanced_arrays : sig
  type t = [`ANGLE_instanced_arrays] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ANGLE_instanced_arrays]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ANGLE_instanced_arrays]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ANGLE_instanced_arrays ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val drawArraysInstancedANGLE: 'tags this -> mode:GLenum.t -> first:GLint.t -> count:GLsizei.t -> primcount:GLsizei.t -> unit [@@js.call "drawArraysInstancedANGLE"]
  val drawElementsInstancedANGLE: 'tags this -> mode:GLenum.t -> count:GLsizei.t -> type_:GLenum.t -> offset:GLintptr.t -> primcount:GLsizei.t -> unit [@@js.call "drawElementsInstancedANGLE"]
  val vertexAttribDivisorANGLE: 'tags this -> index:GLuint.t -> divisor:GLuint.t -> unit [@@js.call "vertexAttribDivisorANGLE"]
  val get_VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE: 'tags this -> GLenum.t [@@js.get "VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module[@js.scope "AbstractRange"] rec AbstractRange : sig
  type t = [`AbstractRange] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AbstractRange]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AbstractRange]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `AbstractRange ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Returns true if range is collapsed, and false otherwise. *)
  val get_collapsed: 'tags this -> bool [@@js.get "collapsed"]
  
  (** Returns range's end node. *)
  val get_endContainer: 'tags this -> Node.t [@@js.get "endContainer"]
  
  (** Returns range's end offset. *)
  val get_endOffset: 'tags this -> float [@@js.get "endOffset"]
  
  (** Returns range's start node. *)
  val get_startContainer: 'tags this -> Node.t [@@js.get "startContainer"]
  
  (** Returns range's start offset. *)
  val get_startOffset: 'tags this -> float [@@js.get "startOffset"]
  val create: collapsed:bool -> endContainer:Node.t -> endOffset:float -> startContainer:Node.t -> startOffset:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end

(** A DOM element's attribute as an object. In most DOM methods, you will probably directly retrieve the attribute as a string (e.g., Element.getAttribute(), but certain functions (e.g., Element.getAttributeNode()) or means of iterating give Attr types. *)
and[@js.scope "Attr"] Attr : sig
  type t = [`Attr | `EventTarget | `Node] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Attr | `EventTarget | `Node]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Attr | `EventTarget | `Node]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `Attr ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_localName: 'tags this -> string [@@js.get "localName"]
  val get_name: 'tags this -> string [@@js.get "name"]
  val get_namespaceURI: 'tags this -> string option [@@js.get "namespaceURI"]
  
  (** Returns the node document. Returns null for documents. *)
  val get_ownerDocument: 'tags this -> Document.t [@@js.get "ownerDocument"]
  val get_ownerElement: 'tags this -> Element.t option [@@js.get "ownerElement"]
  val get_prefix: 'tags this -> string option [@@js.get "prefix"]
  val get_specified: 'tags this -> bool [@@js.get "specified"]
  val get_value: 'tags this -> string [@@js.get "value"]
  val set_value: 'tags this -> string -> unit [@@js.set "value"]
  val create: localName:string -> name:string -> ?namespaceURI:string -> ownerDocument:Document.t -> ?ownerElement:Element.t -> ?prefix:string -> specified:bool -> value:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end
and Body : sig
  type t = [`Body] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Body]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Body]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `Body ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_body: 'tags this -> Uint8Array.t_0 ReadableStream.t option [@@js.get "body"]
  val get_bodyUsed: 'tags this -> bool [@@js.get "bodyUsed"]
  val arrayBuffer: 'tags this -> ArrayBuffer.t_0 Promise.t_1 [@@js.call "arrayBuffer"]
  val blob: 'tags this -> Blob.t Promise.t_1 [@@js.call "blob"]
  val formData: 'tags this -> FormData.t Promise.t_1 [@@js.call "formData"]
  val json: 'tags this -> any Promise.t_1 [@@js.call "json"]
  val text: 'tags this -> string Promise.t_1 [@@js.call "text"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
and BodyInit : sig
  type t = (ReadableStream.t_0, XMLHttpRequestBodyInit.t) union2
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end

(** A CDATA section that can be used within XML to include extended portions of unescaped text. The symbols < and & don’t need escaping as they normally do when inside a CDATA section. *)
and[@js.scope "CDATASection"] CDATASection : sig
  type t = [`CDATASection | `CharacterData | `ChildNode | `EventTarget | `Node | `NonDocumentTypeChildNode | `Slottable | `Text] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`CDATASection | `CharacterData | `ChildNode | `EventTarget | `Node | `NonDocumentTypeChildNode | `Slottable | `Text]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`CDATASection | `CharacterData | `ChildNode | `EventTarget | `Node | `NonDocumentTypeChildNode | `Slottable | `Text]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `CDATASection ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** A single CSS rule. There are several types of rules, listed in the Type constants section below. *)
and[@js.scope "CSSRule"] CSSRule : sig
  type t = [`CSSRule] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`CSSRule]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`CSSRule]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `CSSRule ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_cssText: 'tags this -> string [@@js.get "cssText"]
  val set_cssText: 'tags this -> string -> unit [@@js.set "cssText"]
  val get_parentRule: 'tags this -> t option [@@js.get "parentRule"]
  val get_parentStyleSheet: 'tags this -> CSSStyleSheet.t option [@@js.get "parentStyleSheet"]
  
  (** @deprecated  *)
  val get_type: 'tags this -> float [@@js.get "type"]
  val get_CHARSET_RULE: 'tags this -> float [@@js.get "CHARSET_RULE"]
  val get_FONT_FACE_RULE: 'tags this -> float [@@js.get "FONT_FACE_RULE"]
  val get_IMPORT_RULE: 'tags this -> float [@@js.get "IMPORT_RULE"]
  val get_KEYFRAMES_RULE: 'tags this -> float [@@js.get "KEYFRAMES_RULE"]
  val get_KEYFRAME_RULE: 'tags this -> float [@@js.get "KEYFRAME_RULE"]
  val get_MEDIA_RULE: 'tags this -> float [@@js.get "MEDIA_RULE"]
  val get_NAMESPACE_RULE: 'tags this -> float [@@js.get "NAMESPACE_RULE"]
  val get_PAGE_RULE: 'tags this -> float [@@js.get "PAGE_RULE"]
  val get_STYLE_RULE: 'tags this -> float [@@js.get "STYLE_RULE"]
  val get_SUPPORTS_RULE: 'tags this -> float [@@js.get "SUPPORTS_RULE"]
  val create: cssText:string -> ?parentRule:t -> ?parentStyleSheet:CSSStyleSheet.t -> type_:(float[@js "type"]) -> charset_rule:(float[@js "CHARSET_RULE"]) -> font_face_rule:(float[@js "FONT_FACE_RULE"]) -> import_rule:(float[@js "IMPORT_RULE"]) -> keyframes_rule:(float[@js "KEYFRAMES_RULE"]) -> keyframe_rule:(float[@js "KEYFRAME_RULE"]) -> media_rule:(float[@js "MEDIA_RULE"]) -> namespace_rule:(float[@js "NAMESPACE_RULE"]) -> page_rule:(float[@js "PAGE_RULE"]) -> style_rule:(float[@js "STYLE_RULE"]) -> supports_rule:(float[@js "SUPPORTS_RULE"]) -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
  val charset_rule: unit -> float [@@js.get "CHARSET_RULE"]
  val font_face_rule: unit -> float [@@js.get "FONT_FACE_RULE"]
  val import_rule: unit -> float [@@js.get "IMPORT_RULE"]
  val keyframes_rule: unit -> float [@@js.get "KEYFRAMES_RULE"]
  val keyframe_rule: unit -> float [@@js.get "KEYFRAME_RULE"]
  val media_rule: unit -> float [@@js.get "MEDIA_RULE"]
  val namespace_rule: unit -> float [@@js.get "NAMESPACE_RULE"]
  val page_rule: unit -> float [@@js.get "PAGE_RULE"]
  val style_rule: unit -> float [@@js.get "STYLE_RULE"]
  val supports_rule: unit -> float [@@js.get "SUPPORTS_RULE"]
end

(** A CSSRuleList is an (indirect-modify only) array-like object containing an ordered collection of CSSRule objects. *)
and[@js.scope "CSSRuleList"] CSSRuleList : sig
  type t = [`CSSRuleList | CSSRule.t ArrayLike.tags_1 | CSSRule.t IterableIterator.tags_1] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`CSSRuleList | CSSRule.t ArrayLike.tags_1 | CSSRule.t IterableIterator.tags_1]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`CSSRuleList | CSSRule.t ArrayLike.tags_1 | CSSRule.t IterableIterator.tags_1]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `CSSRuleList ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  (* [Symbol.iterator]: unit -> CSSRule.t IterableIterator.t_1 *)
  val get_length: 'tags this -> float [@@js.get "length"]
  val item: 'tags this -> index:float -> CSSRule.t option [@@js.call "item"]
  val get: 'tags this -> float -> CSSRule.t [@@js.index_get]
  val set: 'tags this -> float -> CSSRule.t -> unit [@@js.index_set]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** An object that is a CSS declaration block, and exposes style information and various style-related methods and properties. *)
and[@js.scope "CSSStyleDeclaration"] CSSStyleDeclaration : sig
  type t = [`CSSStyleDeclaration | string ArrayLike.tags_1 | string IterableIterator.tags_1] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`CSSStyleDeclaration | string ArrayLike.tags_1 | string IterableIterator.tags_1]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`CSSStyleDeclaration | string ArrayLike.tags_1 | string IterableIterator.tags_1]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `CSSStyleDeclaration ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  (* [Symbol.iterator]: unit -> string IterableIterator.t_1 *)
  val get_accentColor: 'tags this -> string [@@js.get "accentColor"]
  val set_accentColor: 'tags this -> string -> unit [@@js.set "accentColor"]
  val get_alignContent: 'tags this -> string [@@js.get "alignContent"]
  val set_alignContent: 'tags this -> string -> unit [@@js.set "alignContent"]
  val get_alignItems: 'tags this -> string [@@js.get "alignItems"]
  val set_alignItems: 'tags this -> string -> unit [@@js.set "alignItems"]
  val get_alignSelf: 'tags this -> string [@@js.get "alignSelf"]
  val set_alignSelf: 'tags this -> string -> unit [@@js.set "alignSelf"]
  val get_alignmentBaseline: 'tags this -> string [@@js.get "alignmentBaseline"]
  val set_alignmentBaseline: 'tags this -> string -> unit [@@js.set "alignmentBaseline"]
  val get_all: 'tags this -> string [@@js.get "all"]
  val set_all: 'tags this -> string -> unit [@@js.set "all"]
  val get_animation: 'tags this -> string [@@js.get "animation"]
  val set_animation: 'tags this -> string -> unit [@@js.set "animation"]
  val get_animationDelay: 'tags this -> string [@@js.get "animationDelay"]
  val set_animationDelay: 'tags this -> string -> unit [@@js.set "animationDelay"]
  val get_animationDirection: 'tags this -> string [@@js.get "animationDirection"]
  val set_animationDirection: 'tags this -> string -> unit [@@js.set "animationDirection"]
  val get_animationDuration: 'tags this -> string [@@js.get "animationDuration"]
  val set_animationDuration: 'tags this -> string -> unit [@@js.set "animationDuration"]
  val get_animationFillMode: 'tags this -> string [@@js.get "animationFillMode"]
  val set_animationFillMode: 'tags this -> string -> unit [@@js.set "animationFillMode"]
  val get_animationIterationCount: 'tags this -> string [@@js.get "animationIterationCount"]
  val set_animationIterationCount: 'tags this -> string -> unit [@@js.set "animationIterationCount"]
  val get_animationName: 'tags this -> string [@@js.get "animationName"]
  val set_animationName: 'tags this -> string -> unit [@@js.set "animationName"]
  val get_animationPlayState: 'tags this -> string [@@js.get "animationPlayState"]
  val set_animationPlayState: 'tags this -> string -> unit [@@js.set "animationPlayState"]
  val get_animationTimingFunction: 'tags this -> string [@@js.get "animationTimingFunction"]
  val set_animationTimingFunction: 'tags this -> string -> unit [@@js.set "animationTimingFunction"]
  val get_appearance: 'tags this -> string [@@js.get "appearance"]
  val set_appearance: 'tags this -> string -> unit [@@js.set "appearance"]
  val get_aspectRatio: 'tags this -> string [@@js.get "aspectRatio"]
  val set_aspectRatio: 'tags this -> string -> unit [@@js.set "aspectRatio"]
  val get_backfaceVisibility: 'tags this -> string [@@js.get "backfaceVisibility"]
  val set_backfaceVisibility: 'tags this -> string -> unit [@@js.set "backfaceVisibility"]
  val get_background: 'tags this -> string [@@js.get "background"]
  val set_background: 'tags this -> string -> unit [@@js.set "background"]
  val get_backgroundAttachment: 'tags this -> string [@@js.get "backgroundAttachment"]
  val set_backgroundAttachment: 'tags this -> string -> unit [@@js.set "backgroundAttachment"]
  val get_backgroundBlendMode: 'tags this -> string [@@js.get "backgroundBlendMode"]
  val set_backgroundBlendMode: 'tags this -> string -> unit [@@js.set "backgroundBlendMode"]
  val get_backgroundClip: 'tags this -> string [@@js.get "backgroundClip"]
  val set_backgroundClip: 'tags this -> string -> unit [@@js.set "backgroundClip"]
  val get_backgroundColor: 'tags this -> string [@@js.get "backgroundColor"]
  val set_backgroundColor: 'tags this -> string -> unit [@@js.set "backgroundColor"]
  val get_backgroundImage: 'tags this -> string [@@js.get "backgroundImage"]
  val set_backgroundImage: 'tags this -> string -> unit [@@js.set "backgroundImage"]
  val get_backgroundOrigin: 'tags this -> string [@@js.get "backgroundOrigin"]
  val set_backgroundOrigin: 'tags this -> string -> unit [@@js.set "backgroundOrigin"]
  val get_backgroundPosition: 'tags this -> string [@@js.get "backgroundPosition"]
  val set_backgroundPosition: 'tags this -> string -> unit [@@js.set "backgroundPosition"]
  val get_backgroundPositionX: 'tags this -> string [@@js.get "backgroundPositionX"]
  val set_backgroundPositionX: 'tags this -> string -> unit [@@js.set "backgroundPositionX"]
  val get_backgroundPositionY: 'tags this -> string [@@js.get "backgroundPositionY"]
  val set_backgroundPositionY: 'tags this -> string -> unit [@@js.set "backgroundPositionY"]
  val get_backgroundRepeat: 'tags this -> string [@@js.get "backgroundRepeat"]
  val set_backgroundRepeat: 'tags this -> string -> unit [@@js.set "backgroundRepeat"]
  val get_backgroundSize: 'tags this -> string [@@js.get "backgroundSize"]
  val set_backgroundSize: 'tags this -> string -> unit [@@js.set "backgroundSize"]
  val get_baselineShift: 'tags this -> string [@@js.get "baselineShift"]
  val set_baselineShift: 'tags this -> string -> unit [@@js.set "baselineShift"]
  val get_blockSize: 'tags this -> string [@@js.get "blockSize"]
  val set_blockSize: 'tags this -> string -> unit [@@js.set "blockSize"]
  val get_border: 'tags this -> string [@@js.get "border"]
  val set_border: 'tags this -> string -> unit [@@js.set "border"]
  val get_borderBlock: 'tags this -> string [@@js.get "borderBlock"]
  val set_borderBlock: 'tags this -> string -> unit [@@js.set "borderBlock"]
  val get_borderBlockColor: 'tags this -> string [@@js.get "borderBlockColor"]
  val set_borderBlockColor: 'tags this -> string -> unit [@@js.set "borderBlockColor"]
  val get_borderBlockEnd: 'tags this -> string [@@js.get "borderBlockEnd"]
  val set_borderBlockEnd: 'tags this -> string -> unit [@@js.set "borderBlockEnd"]
  val get_borderBlockEndColor: 'tags this -> string [@@js.get "borderBlockEndColor"]
  val set_borderBlockEndColor: 'tags this -> string -> unit [@@js.set "borderBlockEndColor"]
  val get_borderBlockEndStyle: 'tags this -> string [@@js.get "borderBlockEndStyle"]
  val set_borderBlockEndStyle: 'tags this -> string -> unit [@@js.set "borderBlockEndStyle"]
  val get_borderBlockEndWidth: 'tags this -> string [@@js.get "borderBlockEndWidth"]
  val set_borderBlockEndWidth: 'tags this -> string -> unit [@@js.set "borderBlockEndWidth"]
  val get_borderBlockStart: 'tags this -> string [@@js.get "borderBlockStart"]
  val set_borderBlockStart: 'tags this -> string -> unit [@@js.set "borderBlockStart"]
  val get_borderBlockStartColor: 'tags this -> string [@@js.get "borderBlockStartColor"]
  val set_borderBlockStartColor: 'tags this -> string -> unit [@@js.set "borderBlockStartColor"]
  val get_borderBlockStartStyle: 'tags this -> string [@@js.get "borderBlockStartStyle"]
  val set_borderBlockStartStyle: 'tags this -> string -> unit [@@js.set "borderBlockStartStyle"]
  val get_borderBlockStartWidth: 'tags this -> string [@@js.get "borderBlockStartWidth"]
  val set_borderBlockStartWidth: 'tags this -> string -> unit [@@js.set "borderBlockStartWidth"]
  val get_borderBlockStyle: 'tags this -> string [@@js.get "borderBlockStyle"]
  val set_borderBlockStyle: 'tags this -> string -> unit [@@js.set "borderBlockStyle"]
  val get_borderBlockWidth: 'tags this -> string [@@js.get "borderBlockWidth"]
  val set_borderBlockWidth: 'tags this -> string -> unit [@@js.set "borderBlockWidth"]
  val get_borderBottom: 'tags this -> string [@@js.get "borderBottom"]
  val set_borderBottom: 'tags this -> string -> unit [@@js.set "borderBottom"]
  val get_borderBottomColor: 'tags this -> string [@@js.get "borderBottomColor"]
  val set_borderBottomColor: 'tags this -> string -> unit [@@js.set "borderBottomColor"]
  val get_borderBottomLeftRadius: 'tags this -> string [@@js.get "borderBottomLeftRadius"]
  val set_borderBottomLeftRadius: 'tags this -> string -> unit [@@js.set "borderBottomLeftRadius"]
  val get_borderBottomRightRadius: 'tags this -> string [@@js.get "borderBottomRightRadius"]
  val set_borderBottomRightRadius: 'tags this -> string -> unit [@@js.set "borderBottomRightRadius"]
  val get_borderBottomStyle: 'tags this -> string [@@js.get "borderBottomStyle"]
  val set_borderBottomStyle: 'tags this -> string -> unit [@@js.set "borderBottomStyle"]
  val get_borderBottomWidth: 'tags this -> string [@@js.get "borderBottomWidth"]
  val set_borderBottomWidth: 'tags this -> string -> unit [@@js.set "borderBottomWidth"]
  val get_borderCollapse: 'tags this -> string [@@js.get "borderCollapse"]
  val set_borderCollapse: 'tags this -> string -> unit [@@js.set "borderCollapse"]
  val get_borderColor: 'tags this -> string [@@js.get "borderColor"]
  val set_borderColor: 'tags this -> string -> unit [@@js.set "borderColor"]
  val get_borderEndEndRadius: 'tags this -> string [@@js.get "borderEndEndRadius"]
  val set_borderEndEndRadius: 'tags this -> string -> unit [@@js.set "borderEndEndRadius"]
  val get_borderEndStartRadius: 'tags this -> string [@@js.get "borderEndStartRadius"]
  val set_borderEndStartRadius: 'tags this -> string -> unit [@@js.set "borderEndStartRadius"]
  val get_borderImage: 'tags this -> string [@@js.get "borderImage"]
  val set_borderImage: 'tags this -> string -> unit [@@js.set "borderImage"]
  val get_borderImageOutset: 'tags this -> string [@@js.get "borderImageOutset"]
  val set_borderImageOutset: 'tags this -> string -> unit [@@js.set "borderImageOutset"]
  val get_borderImageRepeat: 'tags this -> string [@@js.get "borderImageRepeat"]
  val set_borderImageRepeat: 'tags this -> string -> unit [@@js.set "borderImageRepeat"]
  val get_borderImageSlice: 'tags this -> string [@@js.get "borderImageSlice"]
  val set_borderImageSlice: 'tags this -> string -> unit [@@js.set "borderImageSlice"]
  val get_borderImageSource: 'tags this -> string [@@js.get "borderImageSource"]
  val set_borderImageSource: 'tags this -> string -> unit [@@js.set "borderImageSource"]
  val get_borderImageWidth: 'tags this -> string [@@js.get "borderImageWidth"]
  val set_borderImageWidth: 'tags this -> string -> unit [@@js.set "borderImageWidth"]
  val get_borderInline: 'tags this -> string [@@js.get "borderInline"]
  val set_borderInline: 'tags this -> string -> unit [@@js.set "borderInline"]
  val get_borderInlineColor: 'tags this -> string [@@js.get "borderInlineColor"]
  val set_borderInlineColor: 'tags this -> string -> unit [@@js.set "borderInlineColor"]
  val get_borderInlineEnd: 'tags this -> string [@@js.get "borderInlineEnd"]
  val set_borderInlineEnd: 'tags this -> string -> unit [@@js.set "borderInlineEnd"]
  val get_borderInlineEndColor: 'tags this -> string [@@js.get "borderInlineEndColor"]
  val set_borderInlineEndColor: 'tags this -> string -> unit [@@js.set "borderInlineEndColor"]
  val get_borderInlineEndStyle: 'tags this -> string [@@js.get "borderInlineEndStyle"]
  val set_borderInlineEndStyle: 'tags this -> string -> unit [@@js.set "borderInlineEndStyle"]
  val get_borderInlineEndWidth: 'tags this -> string [@@js.get "borderInlineEndWidth"]
  val set_borderInlineEndWidth: 'tags this -> string -> unit [@@js.set "borderInlineEndWidth"]
  val get_borderInlineStart: 'tags this -> string [@@js.get "borderInlineStart"]
  val set_borderInlineStart: 'tags this -> string -> unit [@@js.set "borderInlineStart"]
  val get_borderInlineStartColor: 'tags this -> string [@@js.get "borderInlineStartColor"]
  val set_borderInlineStartColor: 'tags this -> string -> unit [@@js.set "borderInlineStartColor"]
  val get_borderInlineStartStyle: 'tags this -> string [@@js.get "borderInlineStartStyle"]
  val set_borderInlineStartStyle: 'tags this -> string -> unit [@@js.set "borderInlineStartStyle"]
  val get_borderInlineStartWidth: 'tags this -> string [@@js.get "borderInlineStartWidth"]
  val set_borderInlineStartWidth: 'tags this -> string -> unit [@@js.set "borderInlineStartWidth"]
  val get_borderInlineStyle: 'tags this -> string [@@js.get "borderInlineStyle"]
  val set_borderInlineStyle: 'tags this -> string -> unit [@@js.set "borderInlineStyle"]
  val get_borderInlineWidth: 'tags this -> string [@@js.get "borderInlineWidth"]
  val set_borderInlineWidth: 'tags this -> string -> unit [@@js.set "borderInlineWidth"]
  val get_borderLeft: 'tags this -> string [@@js.get "borderLeft"]
  val set_borderLeft: 'tags this -> string -> unit [@@js.set "borderLeft"]
  val get_borderLeftColor: 'tags this -> string [@@js.get "borderLeftColor"]
  val set_borderLeftColor: 'tags this -> string -> unit [@@js.set "borderLeftColor"]
  val get_borderLeftStyle: 'tags this -> string [@@js.get "borderLeftStyle"]
  val set_borderLeftStyle: 'tags this -> string -> unit [@@js.set "borderLeftStyle"]
  val get_borderLeftWidth: 'tags this -> string [@@js.get "borderLeftWidth"]
  val set_borderLeftWidth: 'tags this -> string -> unit [@@js.set "borderLeftWidth"]
  val get_borderRadius: 'tags this -> string [@@js.get "borderRadius"]
  val set_borderRadius: 'tags this -> string -> unit [@@js.set "borderRadius"]
  val get_borderRight: 'tags this -> string [@@js.get "borderRight"]
  val set_borderRight: 'tags this -> string -> unit [@@js.set "borderRight"]
  val get_borderRightColor: 'tags this -> string [@@js.get "borderRightColor"]
  val set_borderRightColor: 'tags this -> string -> unit [@@js.set "borderRightColor"]
  val get_borderRightStyle: 'tags this -> string [@@js.get "borderRightStyle"]
  val set_borderRightStyle: 'tags this -> string -> unit [@@js.set "borderRightStyle"]
  val get_borderRightWidth: 'tags this -> string [@@js.get "borderRightWidth"]
  val set_borderRightWidth: 'tags this -> string -> unit [@@js.set "borderRightWidth"]
  val get_borderSpacing: 'tags this -> string [@@js.get "borderSpacing"]
  val set_borderSpacing: 'tags this -> string -> unit [@@js.set "borderSpacing"]
  val get_borderStartEndRadius: 'tags this -> string [@@js.get "borderStartEndRadius"]
  val set_borderStartEndRadius: 'tags this -> string -> unit [@@js.set "borderStartEndRadius"]
  val get_borderStartStartRadius: 'tags this -> string [@@js.get "borderStartStartRadius"]
  val set_borderStartStartRadius: 'tags this -> string -> unit [@@js.set "borderStartStartRadius"]
  val get_borderStyle: 'tags this -> string [@@js.get "borderStyle"]
  val set_borderStyle: 'tags this -> string -> unit [@@js.set "borderStyle"]
  val get_borderTop: 'tags this -> string [@@js.get "borderTop"]
  val set_borderTop: 'tags this -> string -> unit [@@js.set "borderTop"]
  val get_borderTopColor: 'tags this -> string [@@js.get "borderTopColor"]
  val set_borderTopColor: 'tags this -> string -> unit [@@js.set "borderTopColor"]
  val get_borderTopLeftRadius: 'tags this -> string [@@js.get "borderTopLeftRadius"]
  val set_borderTopLeftRadius: 'tags this -> string -> unit [@@js.set "borderTopLeftRadius"]
  val get_borderTopRightRadius: 'tags this -> string [@@js.get "borderTopRightRadius"]
  val set_borderTopRightRadius: 'tags this -> string -> unit [@@js.set "borderTopRightRadius"]
  val get_borderTopStyle: 'tags this -> string [@@js.get "borderTopStyle"]
  val set_borderTopStyle: 'tags this -> string -> unit [@@js.set "borderTopStyle"]
  val get_borderTopWidth: 'tags this -> string [@@js.get "borderTopWidth"]
  val set_borderTopWidth: 'tags this -> string -> unit [@@js.set "borderTopWidth"]
  val get_borderWidth: 'tags this -> string [@@js.get "borderWidth"]
  val set_borderWidth: 'tags this -> string -> unit [@@js.set "borderWidth"]
  val get_bottom: 'tags this -> string [@@js.get "bottom"]
  val set_bottom: 'tags this -> string -> unit [@@js.set "bottom"]
  val get_boxShadow: 'tags this -> string [@@js.get "boxShadow"]
  val set_boxShadow: 'tags this -> string -> unit [@@js.set "boxShadow"]
  val get_boxSizing: 'tags this -> string [@@js.get "boxSizing"]
  val set_boxSizing: 'tags this -> string -> unit [@@js.set "boxSizing"]
  val get_breakAfter: 'tags this -> string [@@js.get "breakAfter"]
  val set_breakAfter: 'tags this -> string -> unit [@@js.set "breakAfter"]
  val get_breakBefore: 'tags this -> string [@@js.get "breakBefore"]
  val set_breakBefore: 'tags this -> string -> unit [@@js.set "breakBefore"]
  val get_breakInside: 'tags this -> string [@@js.get "breakInside"]
  val set_breakInside: 'tags this -> string -> unit [@@js.set "breakInside"]
  val get_captionSide: 'tags this -> string [@@js.get "captionSide"]
  val set_captionSide: 'tags this -> string -> unit [@@js.set "captionSide"]
  val get_caretColor: 'tags this -> string [@@js.get "caretColor"]
  val set_caretColor: 'tags this -> string -> unit [@@js.set "caretColor"]
  val get_clear: 'tags this -> string [@@js.get "clear"]
  val set_clear: 'tags this -> string -> unit [@@js.set "clear"]
  
  (** @deprecated  *)
  val get_clip: 'tags this -> string [@@js.get "clip"]
  
  (** @deprecated  *)
  val set_clip: 'tags this -> string -> unit [@@js.set "clip"]
  val get_clipPath: 'tags this -> string [@@js.get "clipPath"]
  val set_clipPath: 'tags this -> string -> unit [@@js.set "clipPath"]
  val get_clipRule: 'tags this -> string [@@js.get "clipRule"]
  val set_clipRule: 'tags this -> string -> unit [@@js.set "clipRule"]
  val get_color: 'tags this -> string [@@js.get "color"]
  val set_color: 'tags this -> string -> unit [@@js.set "color"]
  val get_colorInterpolation: 'tags this -> string [@@js.get "colorInterpolation"]
  val set_colorInterpolation: 'tags this -> string -> unit [@@js.set "colorInterpolation"]
  val get_colorInterpolationFilters: 'tags this -> string [@@js.get "colorInterpolationFilters"]
  val set_colorInterpolationFilters: 'tags this -> string -> unit [@@js.set "colorInterpolationFilters"]
  val get_colorScheme: 'tags this -> string [@@js.get "colorScheme"]
  val set_colorScheme: 'tags this -> string -> unit [@@js.set "colorScheme"]
  val get_columnCount: 'tags this -> string [@@js.get "columnCount"]
  val set_columnCount: 'tags this -> string -> unit [@@js.set "columnCount"]
  val get_columnFill: 'tags this -> string [@@js.get "columnFill"]
  val set_columnFill: 'tags this -> string -> unit [@@js.set "columnFill"]
  val get_columnGap: 'tags this -> string [@@js.get "columnGap"]
  val set_columnGap: 'tags this -> string -> unit [@@js.set "columnGap"]
  val get_columnRule: 'tags this -> string [@@js.get "columnRule"]
  val set_columnRule: 'tags this -> string -> unit [@@js.set "columnRule"]
  val get_columnRuleColor: 'tags this -> string [@@js.get "columnRuleColor"]
  val set_columnRuleColor: 'tags this -> string -> unit [@@js.set "columnRuleColor"]
  val get_columnRuleStyle: 'tags this -> string [@@js.get "columnRuleStyle"]
  val set_columnRuleStyle: 'tags this -> string -> unit [@@js.set "columnRuleStyle"]
  val get_columnRuleWidth: 'tags this -> string [@@js.get "columnRuleWidth"]
  val set_columnRuleWidth: 'tags this -> string -> unit [@@js.set "columnRuleWidth"]
  val get_columnSpan: 'tags this -> string [@@js.get "columnSpan"]
  val set_columnSpan: 'tags this -> string -> unit [@@js.set "columnSpan"]
  val get_columnWidth: 'tags this -> string [@@js.get "columnWidth"]
  val set_columnWidth: 'tags this -> string -> unit [@@js.set "columnWidth"]
  val get_columns: 'tags this -> string [@@js.get "columns"]
  val set_columns: 'tags this -> string -> unit [@@js.set "columns"]
  val get_contain: 'tags this -> string [@@js.get "contain"]
  val set_contain: 'tags this -> string -> unit [@@js.set "contain"]
  val get_content: 'tags this -> string [@@js.get "content"]
  val set_content: 'tags this -> string -> unit [@@js.set "content"]
  val get_counterIncrement: 'tags this -> string [@@js.get "counterIncrement"]
  val set_counterIncrement: 'tags this -> string -> unit [@@js.set "counterIncrement"]
  val get_counterReset: 'tags this -> string [@@js.get "counterReset"]
  val set_counterReset: 'tags this -> string -> unit [@@js.set "counterReset"]
  val get_counterSet: 'tags this -> string [@@js.get "counterSet"]
  val set_counterSet: 'tags this -> string -> unit [@@js.set "counterSet"]
  val get_cssFloat: 'tags this -> string [@@js.get "cssFloat"]
  val set_cssFloat: 'tags this -> string -> unit [@@js.set "cssFloat"]
  val get_cssText: 'tags this -> string [@@js.get "cssText"]
  val set_cssText: 'tags this -> string -> unit [@@js.set "cssText"]
  val get_cursor: 'tags this -> string [@@js.get "cursor"]
  val set_cursor: 'tags this -> string -> unit [@@js.set "cursor"]
  val get_direction: 'tags this -> string [@@js.get "direction"]
  val set_direction: 'tags this -> string -> unit [@@js.set "direction"]
  val get_display: 'tags this -> string [@@js.get "display"]
  val set_display: 'tags this -> string -> unit [@@js.set "display"]
  val get_dominantBaseline: 'tags this -> string [@@js.get "dominantBaseline"]
  val set_dominantBaseline: 'tags this -> string -> unit [@@js.set "dominantBaseline"]
  val get_emptyCells: 'tags this -> string [@@js.get "emptyCells"]
  val set_emptyCells: 'tags this -> string -> unit [@@js.set "emptyCells"]
  val get_fill: 'tags this -> string [@@js.get "fill"]
  val set_fill: 'tags this -> string -> unit [@@js.set "fill"]
  val get_fillOpacity: 'tags this -> string [@@js.get "fillOpacity"]
  val set_fillOpacity: 'tags this -> string -> unit [@@js.set "fillOpacity"]
  val get_fillRule: 'tags this -> string [@@js.get "fillRule"]
  val set_fillRule: 'tags this -> string -> unit [@@js.set "fillRule"]
  val get_filter: 'tags this -> string [@@js.get "filter"]
  val set_filter: 'tags this -> string -> unit [@@js.set "filter"]
  val get_flex: 'tags this -> string [@@js.get "flex"]
  val set_flex: 'tags this -> string -> unit [@@js.set "flex"]
  val get_flexBasis: 'tags this -> string [@@js.get "flexBasis"]
  val set_flexBasis: 'tags this -> string -> unit [@@js.set "flexBasis"]
  val get_flexDirection: 'tags this -> string [@@js.get "flexDirection"]
  val set_flexDirection: 'tags this -> string -> unit [@@js.set "flexDirection"]
  val get_flexFlow: 'tags this -> string [@@js.get "flexFlow"]
  val set_flexFlow: 'tags this -> string -> unit [@@js.set "flexFlow"]
  val get_flexGrow: 'tags this -> string [@@js.get "flexGrow"]
  val set_flexGrow: 'tags this -> string -> unit [@@js.set "flexGrow"]
  val get_flexShrink: 'tags this -> string [@@js.get "flexShrink"]
  val set_flexShrink: 'tags this -> string -> unit [@@js.set "flexShrink"]
  val get_flexWrap: 'tags this -> string [@@js.get "flexWrap"]
  val set_flexWrap: 'tags this -> string -> unit [@@js.set "flexWrap"]
  val get_float: 'tags this -> string [@@js.get "float"]
  val set_float: 'tags this -> string -> unit [@@js.set "float"]
  val get_floodColor: 'tags this -> string [@@js.get "floodColor"]
  val set_floodColor: 'tags this -> string -> unit [@@js.set "floodColor"]
  val get_floodOpacity: 'tags this -> string [@@js.get "floodOpacity"]
  val set_floodOpacity: 'tags this -> string -> unit [@@js.set "floodOpacity"]
  val get_font: 'tags this -> string [@@js.get "font"]
  val set_font: 'tags this -> string -> unit [@@js.set "font"]
  val get_fontFamily: 'tags this -> string [@@js.get "fontFamily"]
  val set_fontFamily: 'tags this -> string -> unit [@@js.set "fontFamily"]
  val get_fontFeatureSettings: 'tags this -> string [@@js.get "fontFeatureSettings"]
  val set_fontFeatureSettings: 'tags this -> string -> unit [@@js.set "fontFeatureSettings"]
  val get_fontKerning: 'tags this -> string [@@js.get "fontKerning"]
  val set_fontKerning: 'tags this -> string -> unit [@@js.set "fontKerning"]
  val get_fontOpticalSizing: 'tags this -> string [@@js.get "fontOpticalSizing"]
  val set_fontOpticalSizing: 'tags this -> string -> unit [@@js.set "fontOpticalSizing"]
  val get_fontSize: 'tags this -> string [@@js.get "fontSize"]
  val set_fontSize: 'tags this -> string -> unit [@@js.set "fontSize"]
  val get_fontSizeAdjust: 'tags this -> string [@@js.get "fontSizeAdjust"]
  val set_fontSizeAdjust: 'tags this -> string -> unit [@@js.set "fontSizeAdjust"]
  val get_fontStretch: 'tags this -> string [@@js.get "fontStretch"]
  val set_fontStretch: 'tags this -> string -> unit [@@js.set "fontStretch"]
  val get_fontStyle: 'tags this -> string [@@js.get "fontStyle"]
  val set_fontStyle: 'tags this -> string -> unit [@@js.set "fontStyle"]
  val get_fontSynthesis: 'tags this -> string [@@js.get "fontSynthesis"]
  val set_fontSynthesis: 'tags this -> string -> unit [@@js.set "fontSynthesis"]
  val get_fontVariant: 'tags this -> string [@@js.get "fontVariant"]
  val set_fontVariant: 'tags this -> string -> unit [@@js.set "fontVariant"]
  
  (** @deprecated  *)
  val get_fontVariantAlternates: 'tags this -> string [@@js.get "fontVariantAlternates"]
  
  (** @deprecated  *)
  val set_fontVariantAlternates: 'tags this -> string -> unit [@@js.set "fontVariantAlternates"]
  val get_fontVariantCaps: 'tags this -> string [@@js.get "fontVariantCaps"]
  val set_fontVariantCaps: 'tags this -> string -> unit [@@js.set "fontVariantCaps"]
  val get_fontVariantEastAsian: 'tags this -> string [@@js.get "fontVariantEastAsian"]
  val set_fontVariantEastAsian: 'tags this -> string -> unit [@@js.set "fontVariantEastAsian"]
  val get_fontVariantLigatures: 'tags this -> string [@@js.get "fontVariantLigatures"]
  val set_fontVariantLigatures: 'tags this -> string -> unit [@@js.set "fontVariantLigatures"]
  val get_fontVariantNumeric: 'tags this -> string [@@js.get "fontVariantNumeric"]
  val set_fontVariantNumeric: 'tags this -> string -> unit [@@js.set "fontVariantNumeric"]
  val get_fontVariantPosition: 'tags this -> string [@@js.get "fontVariantPosition"]
  val set_fontVariantPosition: 'tags this -> string -> unit [@@js.set "fontVariantPosition"]
  val get_fontVariationSettings: 'tags this -> string [@@js.get "fontVariationSettings"]
  val set_fontVariationSettings: 'tags this -> string -> unit [@@js.set "fontVariationSettings"]
  val get_fontWeight: 'tags this -> string [@@js.get "fontWeight"]
  val set_fontWeight: 'tags this -> string -> unit [@@js.set "fontWeight"]
  val get_gap: 'tags this -> string [@@js.get "gap"]
  val set_gap: 'tags this -> string -> unit [@@js.set "gap"]
  val get_grid: 'tags this -> string [@@js.get "grid"]
  val set_grid: 'tags this -> string -> unit [@@js.set "grid"]
  val get_gridArea: 'tags this -> string [@@js.get "gridArea"]
  val set_gridArea: 'tags this -> string -> unit [@@js.set "gridArea"]
  val get_gridAutoColumns: 'tags this -> string [@@js.get "gridAutoColumns"]
  val set_gridAutoColumns: 'tags this -> string -> unit [@@js.set "gridAutoColumns"]
  val get_gridAutoFlow: 'tags this -> string [@@js.get "gridAutoFlow"]
  val set_gridAutoFlow: 'tags this -> string -> unit [@@js.set "gridAutoFlow"]
  val get_gridAutoRows: 'tags this -> string [@@js.get "gridAutoRows"]
  val set_gridAutoRows: 'tags this -> string -> unit [@@js.set "gridAutoRows"]
  val get_gridColumn: 'tags this -> string [@@js.get "gridColumn"]
  val set_gridColumn: 'tags this -> string -> unit [@@js.set "gridColumn"]
  val get_gridColumnEnd: 'tags this -> string [@@js.get "gridColumnEnd"]
  val set_gridColumnEnd: 'tags this -> string -> unit [@@js.set "gridColumnEnd"]
  
  (** @deprecated This is a legacy alias of `columnGap`. *)
  val get_gridColumnGap: 'tags this -> string [@@js.get "gridColumnGap"]
  
  (** @deprecated This is a legacy alias of `columnGap`. *)
  val set_gridColumnGap: 'tags this -> string -> unit [@@js.set "gridColumnGap"]
  val get_gridColumnStart: 'tags this -> string [@@js.get "gridColumnStart"]
  val set_gridColumnStart: 'tags this -> string -> unit [@@js.set "gridColumnStart"]
  
  (** @deprecated This is a legacy alias of `gap`. *)
  val get_gridGap: 'tags this -> string [@@js.get "gridGap"]
  
  (** @deprecated This is a legacy alias of `gap`. *)
  val set_gridGap: 'tags this -> string -> unit [@@js.set "gridGap"]
  val get_gridRow: 'tags this -> string [@@js.get "gridRow"]
  val set_gridRow: 'tags this -> string -> unit [@@js.set "gridRow"]
  val get_gridRowEnd: 'tags this -> string [@@js.get "gridRowEnd"]
  val set_gridRowEnd: 'tags this -> string -> unit [@@js.set "gridRowEnd"]
  
  (** @deprecated This is a legacy alias of `rowGap`. *)
  val get_gridRowGap: 'tags this -> string [@@js.get "gridRowGap"]
  
  (** @deprecated This is a legacy alias of `rowGap`. *)
  val set_gridRowGap: 'tags this -> string -> unit [@@js.set "gridRowGap"]
  val get_gridRowStart: 'tags this -> string [@@js.get "gridRowStart"]
  val set_gridRowStart: 'tags this -> string -> unit [@@js.set "gridRowStart"]
  val get_gridTemplate: 'tags this -> string [@@js.get "gridTemplate"]
  val set_gridTemplate: 'tags this -> string -> unit [@@js.set "gridTemplate"]
  val get_gridTemplateAreas: 'tags this -> string [@@js.get "gridTemplateAreas"]
  val set_gridTemplateAreas: 'tags this -> string -> unit [@@js.set "gridTemplateAreas"]
  val get_gridTemplateColumns: 'tags this -> string [@@js.get "gridTemplateColumns"]
  val set_gridTemplateColumns: 'tags this -> string -> unit [@@js.set "gridTemplateColumns"]
  val get_gridTemplateRows: 'tags this -> string [@@js.get "gridTemplateRows"]
  val set_gridTemplateRows: 'tags this -> string -> unit [@@js.set "gridTemplateRows"]
  val get_height: 'tags this -> string [@@js.get "height"]
  val set_height: 'tags this -> string -> unit [@@js.set "height"]
  val get_hyphens: 'tags this -> string [@@js.get "hyphens"]
  val set_hyphens: 'tags this -> string -> unit [@@js.set "hyphens"]
  
  (** @deprecated  *)
  val get_imageOrientation: 'tags this -> string [@@js.get "imageOrientation"]
  
  (** @deprecated  *)
  val set_imageOrientation: 'tags this -> string -> unit [@@js.set "imageOrientation"]
  val get_imageRendering: 'tags this -> string [@@js.get "imageRendering"]
  val set_imageRendering: 'tags this -> string -> unit [@@js.set "imageRendering"]
  val get_inlineSize: 'tags this -> string [@@js.get "inlineSize"]
  val set_inlineSize: 'tags this -> string -> unit [@@js.set "inlineSize"]
  val get_inset: 'tags this -> string [@@js.get "inset"]
  val set_inset: 'tags this -> string -> unit [@@js.set "inset"]
  val get_insetBlock: 'tags this -> string [@@js.get "insetBlock"]
  val set_insetBlock: 'tags this -> string -> unit [@@js.set "insetBlock"]
  val get_insetBlockEnd: 'tags this -> string [@@js.get "insetBlockEnd"]
  val set_insetBlockEnd: 'tags this -> string -> unit [@@js.set "insetBlockEnd"]
  val get_insetBlockStart: 'tags this -> string [@@js.get "insetBlockStart"]
  val set_insetBlockStart: 'tags this -> string -> unit [@@js.set "insetBlockStart"]
  val get_insetInline: 'tags this -> string [@@js.get "insetInline"]
  val set_insetInline: 'tags this -> string -> unit [@@js.set "insetInline"]
  val get_insetInlineEnd: 'tags this -> string [@@js.get "insetInlineEnd"]
  val set_insetInlineEnd: 'tags this -> string -> unit [@@js.set "insetInlineEnd"]
  val get_insetInlineStart: 'tags this -> string [@@js.get "insetInlineStart"]
  val set_insetInlineStart: 'tags this -> string -> unit [@@js.set "insetInlineStart"]
  val get_isolation: 'tags this -> string [@@js.get "isolation"]
  val set_isolation: 'tags this -> string -> unit [@@js.set "isolation"]
  val get_justifyContent: 'tags this -> string [@@js.get "justifyContent"]
  val set_justifyContent: 'tags this -> string -> unit [@@js.set "justifyContent"]
  val get_justifyItems: 'tags this -> string [@@js.get "justifyItems"]
  val set_justifyItems: 'tags this -> string -> unit [@@js.set "justifyItems"]
  val get_justifySelf: 'tags this -> string [@@js.get "justifySelf"]
  val set_justifySelf: 'tags this -> string -> unit [@@js.set "justifySelf"]
  val get_left: 'tags this -> string [@@js.get "left"]
  val set_left: 'tags this -> string -> unit [@@js.set "left"]
  val get_length: 'tags this -> float [@@js.get "length"]
  val get_letterSpacing: 'tags this -> string [@@js.get "letterSpacing"]
  val set_letterSpacing: 'tags this -> string -> unit [@@js.set "letterSpacing"]
  val get_lightingColor: 'tags this -> string [@@js.get "lightingColor"]
  val set_lightingColor: 'tags this -> string -> unit [@@js.set "lightingColor"]
  val get_lineBreak: 'tags this -> string [@@js.get "lineBreak"]
  val set_lineBreak: 'tags this -> string -> unit [@@js.set "lineBreak"]
  val get_lineHeight: 'tags this -> string [@@js.get "lineHeight"]
  val set_lineHeight: 'tags this -> string -> unit [@@js.set "lineHeight"]
  val get_listStyle: 'tags this -> string [@@js.get "listStyle"]
  val set_listStyle: 'tags this -> string -> unit [@@js.set "listStyle"]
  val get_listStyleImage: 'tags this -> string [@@js.get "listStyleImage"]
  val set_listStyleImage: 'tags this -> string -> unit [@@js.set "listStyleImage"]
  val get_listStylePosition: 'tags this -> string [@@js.get "listStylePosition"]
  val set_listStylePosition: 'tags this -> string -> unit [@@js.set "listStylePosition"]
  val get_listStyleType: 'tags this -> string [@@js.get "listStyleType"]
  val set_listStyleType: 'tags this -> string -> unit [@@js.set "listStyleType"]
  val get_margin: 'tags this -> string [@@js.get "margin"]
  val set_margin: 'tags this -> string -> unit [@@js.set "margin"]
  val get_marginBlock: 'tags this -> string [@@js.get "marginBlock"]
  val set_marginBlock: 'tags this -> string -> unit [@@js.set "marginBlock"]
  val get_marginBlockEnd: 'tags this -> string [@@js.get "marginBlockEnd"]
  val set_marginBlockEnd: 'tags this -> string -> unit [@@js.set "marginBlockEnd"]
  val get_marginBlockStart: 'tags this -> string [@@js.get "marginBlockStart"]
  val set_marginBlockStart: 'tags this -> string -> unit [@@js.set "marginBlockStart"]
  val get_marginBottom: 'tags this -> string [@@js.get "marginBottom"]
  val set_marginBottom: 'tags this -> string -> unit [@@js.set "marginBottom"]
  val get_marginInline: 'tags this -> string [@@js.get "marginInline"]
  val set_marginInline: 'tags this -> string -> unit [@@js.set "marginInline"]
  val get_marginInlineEnd: 'tags this -> string [@@js.get "marginInlineEnd"]
  val set_marginInlineEnd: 'tags this -> string -> unit [@@js.set "marginInlineEnd"]
  val get_marginInlineStart: 'tags this -> string [@@js.get "marginInlineStart"]
  val set_marginInlineStart: 'tags this -> string -> unit [@@js.set "marginInlineStart"]
  val get_marginLeft: 'tags this -> string [@@js.get "marginLeft"]
  val set_marginLeft: 'tags this -> string -> unit [@@js.set "marginLeft"]
  val get_marginRight: 'tags this -> string [@@js.get "marginRight"]
  val set_marginRight: 'tags this -> string -> unit [@@js.set "marginRight"]
  val get_marginTop: 'tags this -> string [@@js.get "marginTop"]
  val set_marginTop: 'tags this -> string -> unit [@@js.set "marginTop"]
  val get_marker: 'tags this -> string [@@js.get "marker"]
  val set_marker: 'tags this -> string -> unit [@@js.set "marker"]
  val get_markerEnd: 'tags this -> string [@@js.get "markerEnd"]
  val set_markerEnd: 'tags this -> string -> unit [@@js.set "markerEnd"]
  val get_markerMid: 'tags this -> string [@@js.get "markerMid"]
  val set_markerMid: 'tags this -> string -> unit [@@js.set "markerMid"]
  val get_markerStart: 'tags this -> string [@@js.get "markerStart"]
  val set_markerStart: 'tags this -> string -> unit [@@js.set "markerStart"]
  val get_mask: 'tags this -> string [@@js.get "mask"]
  val set_mask: 'tags this -> string -> unit [@@js.set "mask"]
  val get_maskType: 'tags this -> string [@@js.get "maskType"]
  val set_maskType: 'tags this -> string -> unit [@@js.set "maskType"]
  val get_maxBlockSize: 'tags this -> string [@@js.get "maxBlockSize"]
  val set_maxBlockSize: 'tags this -> string -> unit [@@js.set "maxBlockSize"]
  val get_maxHeight: 'tags this -> string [@@js.get "maxHeight"]
  val set_maxHeight: 'tags this -> string -> unit [@@js.set "maxHeight"]
  val get_maxInlineSize: 'tags this -> string [@@js.get "maxInlineSize"]
  val set_maxInlineSize: 'tags this -> string -> unit [@@js.set "maxInlineSize"]
  val get_maxWidth: 'tags this -> string [@@js.get "maxWidth"]
  val set_maxWidth: 'tags this -> string -> unit [@@js.set "maxWidth"]
  val get_minBlockSize: 'tags this -> string [@@js.get "minBlockSize"]
  val set_minBlockSize: 'tags this -> string -> unit [@@js.set "minBlockSize"]
  val get_minHeight: 'tags this -> string [@@js.get "minHeight"]
  val set_minHeight: 'tags this -> string -> unit [@@js.set "minHeight"]
  val get_minInlineSize: 'tags this -> string [@@js.get "minInlineSize"]
  val set_minInlineSize: 'tags this -> string -> unit [@@js.set "minInlineSize"]
  val get_minWidth: 'tags this -> string [@@js.get "minWidth"]
  val set_minWidth: 'tags this -> string -> unit [@@js.set "minWidth"]
  val get_mixBlendMode: 'tags this -> string [@@js.get "mixBlendMode"]
  val set_mixBlendMode: 'tags this -> string -> unit [@@js.set "mixBlendMode"]
  val get_objectFit: 'tags this -> string [@@js.get "objectFit"]
  val set_objectFit: 'tags this -> string -> unit [@@js.set "objectFit"]
  val get_objectPosition: 'tags this -> string [@@js.get "objectPosition"]
  val set_objectPosition: 'tags this -> string -> unit [@@js.set "objectPosition"]
  val get_offset: 'tags this -> string [@@js.get "offset"]
  val set_offset: 'tags this -> string -> unit [@@js.set "offset"]
  val get_offsetAnchor: 'tags this -> string [@@js.get "offsetAnchor"]
  val set_offsetAnchor: 'tags this -> string -> unit [@@js.set "offsetAnchor"]
  val get_offsetDistance: 'tags this -> string [@@js.get "offsetDistance"]
  val set_offsetDistance: 'tags this -> string -> unit [@@js.set "offsetDistance"]
  val get_offsetPath: 'tags this -> string [@@js.get "offsetPath"]
  val set_offsetPath: 'tags this -> string -> unit [@@js.set "offsetPath"]
  val get_offsetRotate: 'tags this -> string [@@js.get "offsetRotate"]
  val set_offsetRotate: 'tags this -> string -> unit [@@js.set "offsetRotate"]
  val get_opacity: 'tags this -> string [@@js.get "opacity"]
  val set_opacity: 'tags this -> string -> unit [@@js.set "opacity"]
  val get_order: 'tags this -> string [@@js.get "order"]
  val set_order: 'tags this -> string -> unit [@@js.set "order"]
  val get_orphans: 'tags this -> string [@@js.get "orphans"]
  val set_orphans: 'tags this -> string -> unit [@@js.set "orphans"]
  val get_outline: 'tags this -> string [@@js.get "outline"]
  val set_outline: 'tags this -> string -> unit [@@js.set "outline"]
  val get_outlineColor: 'tags this -> string [@@js.get "outlineColor"]
  val set_outlineColor: 'tags this -> string -> unit [@@js.set "outlineColor"]
  val get_outlineOffset: 'tags this -> string [@@js.get "outlineOffset"]
  val set_outlineOffset: 'tags this -> string -> unit [@@js.set "outlineOffset"]
  val get_outlineStyle: 'tags this -> string [@@js.get "outlineStyle"]
  val set_outlineStyle: 'tags this -> string -> unit [@@js.set "outlineStyle"]
  val get_outlineWidth: 'tags this -> string [@@js.get "outlineWidth"]
  val set_outlineWidth: 'tags this -> string -> unit [@@js.set "outlineWidth"]
  val get_overflow: 'tags this -> string [@@js.get "overflow"]
  val set_overflow: 'tags this -> string -> unit [@@js.set "overflow"]
  val get_overflowAnchor: 'tags this -> string [@@js.get "overflowAnchor"]
  val set_overflowAnchor: 'tags this -> string -> unit [@@js.set "overflowAnchor"]
  val get_overflowWrap: 'tags this -> string [@@js.get "overflowWrap"]
  val set_overflowWrap: 'tags this -> string -> unit [@@js.set "overflowWrap"]
  val get_overflowX: 'tags this -> string [@@js.get "overflowX"]
  val set_overflowX: 'tags this -> string -> unit [@@js.set "overflowX"]
  val get_overflowY: 'tags this -> string [@@js.get "overflowY"]
  val set_overflowY: 'tags this -> string -> unit [@@js.set "overflowY"]
  val get_overscrollBehavior: 'tags this -> string [@@js.get "overscrollBehavior"]
  val set_overscrollBehavior: 'tags this -> string -> unit [@@js.set "overscrollBehavior"]
  val get_overscrollBehaviorBlock: 'tags this -> string [@@js.get "overscrollBehaviorBlock"]
  val set_overscrollBehaviorBlock: 'tags this -> string -> unit [@@js.set "overscrollBehaviorBlock"]
  val get_overscrollBehaviorInline: 'tags this -> string [@@js.get "overscrollBehaviorInline"]
  val set_overscrollBehaviorInline: 'tags this -> string -> unit [@@js.set "overscrollBehaviorInline"]
  val get_overscrollBehaviorX: 'tags this -> string [@@js.get "overscrollBehaviorX"]
  val set_overscrollBehaviorX: 'tags this -> string -> unit [@@js.set "overscrollBehaviorX"]
  val get_overscrollBehaviorY: 'tags this -> string [@@js.get "overscrollBehaviorY"]
  val set_overscrollBehaviorY: 'tags this -> string -> unit [@@js.set "overscrollBehaviorY"]
  val get_padding: 'tags this -> string [@@js.get "padding"]
  val set_padding: 'tags this -> string -> unit [@@js.set "padding"]
  val get_paddingBlock: 'tags this -> string [@@js.get "paddingBlock"]
  val set_paddingBlock: 'tags this -> string -> unit [@@js.set "paddingBlock"]
  val get_paddingBlockEnd: 'tags this -> string [@@js.get "paddingBlockEnd"]
  val set_paddingBlockEnd: 'tags this -> string -> unit [@@js.set "paddingBlockEnd"]
  val get_paddingBlockStart: 'tags this -> string [@@js.get "paddingBlockStart"]
  val set_paddingBlockStart: 'tags this -> string -> unit [@@js.set "paddingBlockStart"]
  val get_paddingBottom: 'tags this -> string [@@js.get "paddingBottom"]
  val set_paddingBottom: 'tags this -> string -> unit [@@js.set "paddingBottom"]
  val get_paddingInline: 'tags this -> string [@@js.get "paddingInline"]
  val set_paddingInline: 'tags this -> string -> unit [@@js.set "paddingInline"]
  val get_paddingInlineEnd: 'tags this -> string [@@js.get "paddingInlineEnd"]
  val set_paddingInlineEnd: 'tags this -> string -> unit [@@js.set "paddingInlineEnd"]
  val get_paddingInlineStart: 'tags this -> string [@@js.get "paddingInlineStart"]
  val set_paddingInlineStart: 'tags this -> string -> unit [@@js.set "paddingInlineStart"]
  val get_paddingLeft: 'tags this -> string [@@js.get "paddingLeft"]
  val set_paddingLeft: 'tags this -> string -> unit [@@js.set "paddingLeft"]
  val get_paddingRight: 'tags this -> string [@@js.get "paddingRight"]
  val set_paddingRight: 'tags this -> string -> unit [@@js.set "paddingRight"]
  val get_paddingTop: 'tags this -> string [@@js.get "paddingTop"]
  val set_paddingTop: 'tags this -> string -> unit [@@js.set "paddingTop"]
  val get_pageBreakAfter: 'tags this -> string [@@js.get "pageBreakAfter"]
  val set_pageBreakAfter: 'tags this -> string -> unit [@@js.set "pageBreakAfter"]
  val get_pageBreakBefore: 'tags this -> string [@@js.get "pageBreakBefore"]
  val set_pageBreakBefore: 'tags this -> string -> unit [@@js.set "pageBreakBefore"]
  val get_pageBreakInside: 'tags this -> string [@@js.get "pageBreakInside"]
  val set_pageBreakInside: 'tags this -> string -> unit [@@js.set "pageBreakInside"]
  val get_paintOrder: 'tags this -> string [@@js.get "paintOrder"]
  val set_paintOrder: 'tags this -> string -> unit [@@js.set "paintOrder"]
  val get_parentRule: 'tags this -> CSSRule.t option [@@js.get "parentRule"]
  val get_perspective: 'tags this -> string [@@js.get "perspective"]
  val set_perspective: 'tags this -> string -> unit [@@js.set "perspective"]
  val get_perspectiveOrigin: 'tags this -> string [@@js.get "perspectiveOrigin"]
  val set_perspectiveOrigin: 'tags this -> string -> unit [@@js.set "perspectiveOrigin"]
  val get_placeContent: 'tags this -> string [@@js.get "placeContent"]
  val set_placeContent: 'tags this -> string -> unit [@@js.set "placeContent"]
  val get_placeItems: 'tags this -> string [@@js.get "placeItems"]
  val set_placeItems: 'tags this -> string -> unit [@@js.set "placeItems"]
  val get_placeSelf: 'tags this -> string [@@js.get "placeSelf"]
  val set_placeSelf: 'tags this -> string -> unit [@@js.set "placeSelf"]
  val get_pointerEvents: 'tags this -> string [@@js.get "pointerEvents"]
  val set_pointerEvents: 'tags this -> string -> unit [@@js.set "pointerEvents"]
  val get_position: 'tags this -> string [@@js.get "position"]
  val set_position: 'tags this -> string -> unit [@@js.set "position"]
  val get_quotes: 'tags this -> string [@@js.get "quotes"]
  val set_quotes: 'tags this -> string -> unit [@@js.set "quotes"]
  val get_resize: 'tags this -> string [@@js.get "resize"]
  val set_resize: 'tags this -> string -> unit [@@js.set "resize"]
  val get_right: 'tags this -> string [@@js.get "right"]
  val set_right: 'tags this -> string -> unit [@@js.set "right"]
  val get_rotate: 'tags this -> string [@@js.get "rotate"]
  val set_rotate: 'tags this -> string -> unit [@@js.set "rotate"]
  val get_rowGap: 'tags this -> string [@@js.get "rowGap"]
  val set_rowGap: 'tags this -> string -> unit [@@js.set "rowGap"]
  val get_rubyPosition: 'tags this -> string [@@js.get "rubyPosition"]
  val set_rubyPosition: 'tags this -> string -> unit [@@js.set "rubyPosition"]
  val get_scale: 'tags this -> string [@@js.get "scale"]
  val set_scale: 'tags this -> string -> unit [@@js.set "scale"]
  val get_scrollBehavior: 'tags this -> string [@@js.get "scrollBehavior"]
  val set_scrollBehavior: 'tags this -> string -> unit [@@js.set "scrollBehavior"]
  val get_scrollMargin: 'tags this -> string [@@js.get "scrollMargin"]
  val set_scrollMargin: 'tags this -> string -> unit [@@js.set "scrollMargin"]
  val get_scrollMarginBlock: 'tags this -> string [@@js.get "scrollMarginBlock"]
  val set_scrollMarginBlock: 'tags this -> string -> unit [@@js.set "scrollMarginBlock"]
  val get_scrollMarginBlockEnd: 'tags this -> string [@@js.get "scrollMarginBlockEnd"]
  val set_scrollMarginBlockEnd: 'tags this -> string -> unit [@@js.set "scrollMarginBlockEnd"]
  val get_scrollMarginBlockStart: 'tags this -> string [@@js.get "scrollMarginBlockStart"]
  val set_scrollMarginBlockStart: 'tags this -> string -> unit [@@js.set "scrollMarginBlockStart"]
  val get_scrollMarginBottom: 'tags this -> string [@@js.get "scrollMarginBottom"]
  val set_scrollMarginBottom: 'tags this -> string -> unit [@@js.set "scrollMarginBottom"]
  val get_scrollMarginInline: 'tags this -> string [@@js.get "scrollMarginInline"]
  val set_scrollMarginInline: 'tags this -> string -> unit [@@js.set "scrollMarginInline"]
  val get_scrollMarginInlineEnd: 'tags this -> string [@@js.get "scrollMarginInlineEnd"]
  val set_scrollMarginInlineEnd: 'tags this -> string -> unit [@@js.set "scrollMarginInlineEnd"]
  val get_scrollMarginInlineStart: 'tags this -> string [@@js.get "scrollMarginInlineStart"]
  val set_scrollMarginInlineStart: 'tags this -> string -> unit [@@js.set "scrollMarginInlineStart"]
  val get_scrollMarginLeft: 'tags this -> string [@@js.get "scrollMarginLeft"]
  val set_scrollMarginLeft: 'tags this -> string -> unit [@@js.set "scrollMarginLeft"]
  val get_scrollMarginRight: 'tags this -> string [@@js.get "scrollMarginRight"]
  val set_scrollMarginRight: 'tags this -> string -> unit [@@js.set "scrollMarginRight"]
  val get_scrollMarginTop: 'tags this -> string [@@js.get "scrollMarginTop"]
  val set_scrollMarginTop: 'tags this -> string -> unit [@@js.set "scrollMarginTop"]
  val get_scrollPadding: 'tags this -> string [@@js.get "scrollPadding"]
  val set_scrollPadding: 'tags this -> string -> unit [@@js.set "scrollPadding"]
  val get_scrollPaddingBlock: 'tags this -> string [@@js.get "scrollPaddingBlock"]
  val set_scrollPaddingBlock: 'tags this -> string -> unit [@@js.set "scrollPaddingBlock"]
  val get_scrollPaddingBlockEnd: 'tags this -> string [@@js.get "scrollPaddingBlockEnd"]
  val set_scrollPaddingBlockEnd: 'tags this -> string -> unit [@@js.set "scrollPaddingBlockEnd"]
  val get_scrollPaddingBlockStart: 'tags this -> string [@@js.get "scrollPaddingBlockStart"]
  val set_scrollPaddingBlockStart: 'tags this -> string -> unit [@@js.set "scrollPaddingBlockStart"]
  val get_scrollPaddingBottom: 'tags this -> string [@@js.get "scrollPaddingBottom"]
  val set_scrollPaddingBottom: 'tags this -> string -> unit [@@js.set "scrollPaddingBottom"]
  val get_scrollPaddingInline: 'tags this -> string [@@js.get "scrollPaddingInline"]
  val set_scrollPaddingInline: 'tags this -> string -> unit [@@js.set "scrollPaddingInline"]
  val get_scrollPaddingInlineEnd: 'tags this -> string [@@js.get "scrollPaddingInlineEnd"]
  val set_scrollPaddingInlineEnd: 'tags this -> string -> unit [@@js.set "scrollPaddingInlineEnd"]
  val get_scrollPaddingInlineStart: 'tags this -> string [@@js.get "scrollPaddingInlineStart"]
  val set_scrollPaddingInlineStart: 'tags this -> string -> unit [@@js.set "scrollPaddingInlineStart"]
  val get_scrollPaddingLeft: 'tags this -> string [@@js.get "scrollPaddingLeft"]
  val set_scrollPaddingLeft: 'tags this -> string -> unit [@@js.set "scrollPaddingLeft"]
  val get_scrollPaddingRight: 'tags this -> string [@@js.get "scrollPaddingRight"]
  val set_scrollPaddingRight: 'tags this -> string -> unit [@@js.set "scrollPaddingRight"]
  val get_scrollPaddingTop: 'tags this -> string [@@js.get "scrollPaddingTop"]
  val set_scrollPaddingTop: 'tags this -> string -> unit [@@js.set "scrollPaddingTop"]
  val get_scrollSnapAlign: 'tags this -> string [@@js.get "scrollSnapAlign"]
  val set_scrollSnapAlign: 'tags this -> string -> unit [@@js.set "scrollSnapAlign"]
  val get_scrollSnapStop: 'tags this -> string [@@js.get "scrollSnapStop"]
  val set_scrollSnapStop: 'tags this -> string -> unit [@@js.set "scrollSnapStop"]
  val get_scrollSnapType: 'tags this -> string [@@js.get "scrollSnapType"]
  val set_scrollSnapType: 'tags this -> string -> unit [@@js.set "scrollSnapType"]
  val get_scrollbarGutter: 'tags this -> string [@@js.get "scrollbarGutter"]
  val set_scrollbarGutter: 'tags this -> string -> unit [@@js.set "scrollbarGutter"]
  val get_shapeImageThreshold: 'tags this -> string [@@js.get "shapeImageThreshold"]
  val set_shapeImageThreshold: 'tags this -> string -> unit [@@js.set "shapeImageThreshold"]
  val get_shapeMargin: 'tags this -> string [@@js.get "shapeMargin"]
  val set_shapeMargin: 'tags this -> string -> unit [@@js.set "shapeMargin"]
  val get_shapeOutside: 'tags this -> string [@@js.get "shapeOutside"]
  val set_shapeOutside: 'tags this -> string -> unit [@@js.set "shapeOutside"]
  val get_shapeRendering: 'tags this -> string [@@js.get "shapeRendering"]
  val set_shapeRendering: 'tags this -> string -> unit [@@js.set "shapeRendering"]
  val get_stopColor: 'tags this -> string [@@js.get "stopColor"]
  val set_stopColor: 'tags this -> string -> unit [@@js.set "stopColor"]
  val get_stopOpacity: 'tags this -> string [@@js.get "stopOpacity"]
  val set_stopOpacity: 'tags this -> string -> unit [@@js.set "stopOpacity"]
  val get_stroke: 'tags this -> string [@@js.get "stroke"]
  val set_stroke: 'tags this -> string -> unit [@@js.set "stroke"]
  val get_strokeDasharray: 'tags this -> string [@@js.get "strokeDasharray"]
  val set_strokeDasharray: 'tags this -> string -> unit [@@js.set "strokeDasharray"]
  val get_strokeDashoffset: 'tags this -> string [@@js.get "strokeDashoffset"]
  val set_strokeDashoffset: 'tags this -> string -> unit [@@js.set "strokeDashoffset"]
  val get_strokeLinecap: 'tags this -> string [@@js.get "strokeLinecap"]
  val set_strokeLinecap: 'tags this -> string -> unit [@@js.set "strokeLinecap"]
  val get_strokeLinejoin: 'tags this -> string [@@js.get "strokeLinejoin"]
  val set_strokeLinejoin: 'tags this -> string -> unit [@@js.set "strokeLinejoin"]
  val get_strokeMiterlimit: 'tags this -> string [@@js.get "strokeMiterlimit"]
  val set_strokeMiterlimit: 'tags this -> string -> unit [@@js.set "strokeMiterlimit"]
  val get_strokeOpacity: 'tags this -> string [@@js.get "strokeOpacity"]
  val set_strokeOpacity: 'tags this -> string -> unit [@@js.set "strokeOpacity"]
  val get_strokeWidth: 'tags this -> string [@@js.get "strokeWidth"]
  val set_strokeWidth: 'tags this -> string -> unit [@@js.set "strokeWidth"]
  val get_tabSize: 'tags this -> string [@@js.get "tabSize"]
  val set_tabSize: 'tags this -> string -> unit [@@js.set "tabSize"]
  val get_tableLayout: 'tags this -> string [@@js.get "tableLayout"]
  val set_tableLayout: 'tags this -> string -> unit [@@js.set "tableLayout"]
  val get_textAlign: 'tags this -> string [@@js.get "textAlign"]
  val set_textAlign: 'tags this -> string -> unit [@@js.set "textAlign"]
  val get_textAlignLast: 'tags this -> string [@@js.get "textAlignLast"]
  val set_textAlignLast: 'tags this -> string -> unit [@@js.set "textAlignLast"]
  val get_textAnchor: 'tags this -> string [@@js.get "textAnchor"]
  val set_textAnchor: 'tags this -> string -> unit [@@js.set "textAnchor"]
  val get_textCombineUpright: 'tags this -> string [@@js.get "textCombineUpright"]
  val set_textCombineUpright: 'tags this -> string -> unit [@@js.set "textCombineUpright"]
  val get_textDecoration: 'tags this -> string [@@js.get "textDecoration"]
  val set_textDecoration: 'tags this -> string -> unit [@@js.set "textDecoration"]
  val get_textDecorationColor: 'tags this -> string [@@js.get "textDecorationColor"]
  val set_textDecorationColor: 'tags this -> string -> unit [@@js.set "textDecorationColor"]
  val get_textDecorationLine: 'tags this -> string [@@js.get "textDecorationLine"]
  val set_textDecorationLine: 'tags this -> string -> unit [@@js.set "textDecorationLine"]
  val get_textDecorationSkipInk: 'tags this -> string [@@js.get "textDecorationSkipInk"]
  val set_textDecorationSkipInk: 'tags this -> string -> unit [@@js.set "textDecorationSkipInk"]
  val get_textDecorationStyle: 'tags this -> string [@@js.get "textDecorationStyle"]
  val set_textDecorationStyle: 'tags this -> string -> unit [@@js.set "textDecorationStyle"]
  val get_textDecorationThickness: 'tags this -> string [@@js.get "textDecorationThickness"]
  val set_textDecorationThickness: 'tags this -> string -> unit [@@js.set "textDecorationThickness"]
  val get_textEmphasis: 'tags this -> string [@@js.get "textEmphasis"]
  val set_textEmphasis: 'tags this -> string -> unit [@@js.set "textEmphasis"]
  val get_textEmphasisColor: 'tags this -> string [@@js.get "textEmphasisColor"]
  val set_textEmphasisColor: 'tags this -> string -> unit [@@js.set "textEmphasisColor"]
  val get_textEmphasisPosition: 'tags this -> string [@@js.get "textEmphasisPosition"]
  val set_textEmphasisPosition: 'tags this -> string -> unit [@@js.set "textEmphasisPosition"]
  val get_textEmphasisStyle: 'tags this -> string [@@js.get "textEmphasisStyle"]
  val set_textEmphasisStyle: 'tags this -> string -> unit [@@js.set "textEmphasisStyle"]
  val get_textIndent: 'tags this -> string [@@js.get "textIndent"]
  val set_textIndent: 'tags this -> string -> unit [@@js.set "textIndent"]
  val get_textOrientation: 'tags this -> string [@@js.get "textOrientation"]
  val set_textOrientation: 'tags this -> string -> unit [@@js.set "textOrientation"]
  val get_textOverflow: 'tags this -> string [@@js.get "textOverflow"]
  val set_textOverflow: 'tags this -> string -> unit [@@js.set "textOverflow"]
  val get_textRendering: 'tags this -> string [@@js.get "textRendering"]
  val set_textRendering: 'tags this -> string -> unit [@@js.set "textRendering"]
  val get_textShadow: 'tags this -> string [@@js.get "textShadow"]
  val set_textShadow: 'tags this -> string -> unit [@@js.set "textShadow"]
  val get_textTransform: 'tags this -> string [@@js.get "textTransform"]
  val set_textTransform: 'tags this -> string -> unit [@@js.set "textTransform"]
  val get_textUnderlineOffset: 'tags this -> string [@@js.get "textUnderlineOffset"]
  val set_textUnderlineOffset: 'tags this -> string -> unit [@@js.set "textUnderlineOffset"]
  val get_textUnderlinePosition: 'tags this -> string [@@js.get "textUnderlinePosition"]
  val set_textUnderlinePosition: 'tags this -> string -> unit [@@js.set "textUnderlinePosition"]
  val get_top: 'tags this -> string [@@js.get "top"]
  val set_top: 'tags this -> string -> unit [@@js.set "top"]
  val get_touchAction: 'tags this -> string [@@js.get "touchAction"]
  val set_touchAction: 'tags this -> string -> unit [@@js.set "touchAction"]
  val get_transform: 'tags this -> string [@@js.get "transform"]
  val set_transform: 'tags this -> string -> unit [@@js.set "transform"]
  val get_transformBox: 'tags this -> string [@@js.get "transformBox"]
  val set_transformBox: 'tags this -> string -> unit [@@js.set "transformBox"]
  val get_transformOrigin: 'tags this -> string [@@js.get "transformOrigin"]
  val set_transformOrigin: 'tags this -> string -> unit [@@js.set "transformOrigin"]
  val get_transformStyle: 'tags this -> string [@@js.get "transformStyle"]
  val set_transformStyle: 'tags this -> string -> unit [@@js.set "transformStyle"]
  val get_transition: 'tags this -> string [@@js.get "transition"]
  val set_transition: 'tags this -> string -> unit [@@js.set "transition"]
  val get_transitionDelay: 'tags this -> string [@@js.get "transitionDelay"]
  val set_transitionDelay: 'tags this -> string -> unit [@@js.set "transitionDelay"]
  val get_transitionDuration: 'tags this -> string [@@js.get "transitionDuration"]
  val set_transitionDuration: 'tags this -> string -> unit [@@js.set "transitionDuration"]
  val get_transitionProperty: 'tags this -> string [@@js.get "transitionProperty"]
  val set_transitionProperty: 'tags this -> string -> unit [@@js.set "transitionProperty"]
  val get_transitionTimingFunction: 'tags this -> string [@@js.get "transitionTimingFunction"]
  val set_transitionTimingFunction: 'tags this -> string -> unit [@@js.set "transitionTimingFunction"]
  val get_translate: 'tags this -> string [@@js.get "translate"]
  val set_translate: 'tags this -> string -> unit [@@js.set "translate"]
  val get_unicodeBidi: 'tags this -> string [@@js.get "unicodeBidi"]
  val set_unicodeBidi: 'tags this -> string -> unit [@@js.set "unicodeBidi"]
  val get_userSelect: 'tags this -> string [@@js.get "userSelect"]
  val set_userSelect: 'tags this -> string -> unit [@@js.set "userSelect"]
  val get_verticalAlign: 'tags this -> string [@@js.get "verticalAlign"]
  val set_verticalAlign: 'tags this -> string -> unit [@@js.set "verticalAlign"]
  val get_visibility: 'tags this -> string [@@js.get "visibility"]
  val set_visibility: 'tags this -> string -> unit [@@js.set "visibility"]
  
  (** @deprecated This is a legacy alias of `alignContent`. *)
  val get_webkitAlignContent: 'tags this -> string [@@js.get "webkitAlignContent"]
  
  (** @deprecated This is a legacy alias of `alignContent`. *)
  val set_webkitAlignContent: 'tags this -> string -> unit [@@js.set "webkitAlignContent"]
  
  (** @deprecated This is a legacy alias of `alignItems`. *)
  val get_webkitAlignItems: 'tags this -> string [@@js.get "webkitAlignItems"]
  
  (** @deprecated This is a legacy alias of `alignItems`. *)
  val set_webkitAlignItems: 'tags this -> string -> unit [@@js.set "webkitAlignItems"]
  
  (** @deprecated This is a legacy alias of `alignSelf`. *)
  val get_webkitAlignSelf: 'tags this -> string [@@js.get "webkitAlignSelf"]
  
  (** @deprecated This is a legacy alias of `alignSelf`. *)
  val set_webkitAlignSelf: 'tags this -> string -> unit [@@js.set "webkitAlignSelf"]
  
  (** @deprecated This is a legacy alias of `animation`. *)
  val get_webkitAnimation: 'tags this -> string [@@js.get "webkitAnimation"]
  
  (** @deprecated This is a legacy alias of `animation`. *)
  val set_webkitAnimation: 'tags this -> string -> unit [@@js.set "webkitAnimation"]
  
  (** @deprecated This is a legacy alias of `animationDelay`. *)
  val get_webkitAnimationDelay: 'tags this -> string [@@js.get "webkitAnimationDelay"]
  
  (** @deprecated This is a legacy alias of `animationDelay`. *)
  val set_webkitAnimationDelay: 'tags this -> string -> unit [@@js.set "webkitAnimationDelay"]
  
  (** @deprecated This is a legacy alias of `animationDirection`. *)
  val get_webkitAnimationDirection: 'tags this -> string [@@js.get "webkitAnimationDirection"]
  
  (** @deprecated This is a legacy alias of `animationDirection`. *)
  val set_webkitAnimationDirection: 'tags this -> string -> unit [@@js.set "webkitAnimationDirection"]
  
  (** @deprecated This is a legacy alias of `animationDuration`. *)
  val get_webkitAnimationDuration: 'tags this -> string [@@js.get "webkitAnimationDuration"]
  
  (** @deprecated This is a legacy alias of `animationDuration`. *)
  val set_webkitAnimationDuration: 'tags this -> string -> unit [@@js.set "webkitAnimationDuration"]
  
  (** @deprecated This is a legacy alias of `animationFillMode`. *)
  val get_webkitAnimationFillMode: 'tags this -> string [@@js.get "webkitAnimationFillMode"]
  
  (** @deprecated This is a legacy alias of `animationFillMode`. *)
  val set_webkitAnimationFillMode: 'tags this -> string -> unit [@@js.set "webkitAnimationFillMode"]
  
  (** @deprecated This is a legacy alias of `animationIterationCount`. *)
  val get_webkitAnimationIterationCount: 'tags this -> string [@@js.get "webkitAnimationIterationCount"]
  
  (** @deprecated This is a legacy alias of `animationIterationCount`. *)
  val set_webkitAnimationIterationCount: 'tags this -> string -> unit [@@js.set "webkitAnimationIterationCount"]
  
  (** @deprecated This is a legacy alias of `animationName`. *)
  val get_webkitAnimationName: 'tags this -> string [@@js.get "webkitAnimationName"]
  
  (** @deprecated This is a legacy alias of `animationName`. *)
  val set_webkitAnimationName: 'tags this -> string -> unit [@@js.set "webkitAnimationName"]
  
  (** @deprecated This is a legacy alias of `animationPlayState`. *)
  val get_webkitAnimationPlayState: 'tags this -> string [@@js.get "webkitAnimationPlayState"]
  
  (** @deprecated This is a legacy alias of `animationPlayState`. *)
  val set_webkitAnimationPlayState: 'tags this -> string -> unit [@@js.set "webkitAnimationPlayState"]
  
  (** @deprecated This is a legacy alias of `animationTimingFunction`. *)
  val get_webkitAnimationTimingFunction: 'tags this -> string [@@js.get "webkitAnimationTimingFunction"]
  
  (** @deprecated This is a legacy alias of `animationTimingFunction`. *)
  val set_webkitAnimationTimingFunction: 'tags this -> string -> unit [@@js.set "webkitAnimationTimingFunction"]
  
  (** @deprecated This is a legacy alias of `appearance`. *)
  val get_webkitAppearance: 'tags this -> string [@@js.get "webkitAppearance"]
  
  (** @deprecated This is a legacy alias of `appearance`. *)
  val set_webkitAppearance: 'tags this -> string -> unit [@@js.set "webkitAppearance"]
  
  (** @deprecated This is a legacy alias of `backfaceVisibility`. *)
  val get_webkitBackfaceVisibility: 'tags this -> string [@@js.get "webkitBackfaceVisibility"]
  
  (** @deprecated This is a legacy alias of `backfaceVisibility`. *)
  val set_webkitBackfaceVisibility: 'tags this -> string -> unit [@@js.set "webkitBackfaceVisibility"]
  
  (** @deprecated This is a legacy alias of `backgroundClip`. *)
  val get_webkitBackgroundClip: 'tags this -> string [@@js.get "webkitBackgroundClip"]
  
  (** @deprecated This is a legacy alias of `backgroundClip`. *)
  val set_webkitBackgroundClip: 'tags this -> string -> unit [@@js.set "webkitBackgroundClip"]
  
  (** @deprecated This is a legacy alias of `backgroundOrigin`. *)
  val get_webkitBackgroundOrigin: 'tags this -> string [@@js.get "webkitBackgroundOrigin"]
  
  (** @deprecated This is a legacy alias of `backgroundOrigin`. *)
  val set_webkitBackgroundOrigin: 'tags this -> string -> unit [@@js.set "webkitBackgroundOrigin"]
  
  (** @deprecated This is a legacy alias of `backgroundSize`. *)
  val get_webkitBackgroundSize: 'tags this -> string [@@js.get "webkitBackgroundSize"]
  
  (** @deprecated This is a legacy alias of `backgroundSize`. *)
  val set_webkitBackgroundSize: 'tags this -> string -> unit [@@js.set "webkitBackgroundSize"]
  
  (** @deprecated This is a legacy alias of `borderBottomLeftRadius`. *)
  val get_webkitBorderBottomLeftRadius: 'tags this -> string [@@js.get "webkitBorderBottomLeftRadius"]
  
  (** @deprecated This is a legacy alias of `borderBottomLeftRadius`. *)
  val set_webkitBorderBottomLeftRadius: 'tags this -> string -> unit [@@js.set "webkitBorderBottomLeftRadius"]
  
  (** @deprecated This is a legacy alias of `borderBottomRightRadius`. *)
  val get_webkitBorderBottomRightRadius: 'tags this -> string [@@js.get "webkitBorderBottomRightRadius"]
  
  (** @deprecated This is a legacy alias of `borderBottomRightRadius`. *)
  val set_webkitBorderBottomRightRadius: 'tags this -> string -> unit [@@js.set "webkitBorderBottomRightRadius"]
  
  (** @deprecated This is a legacy alias of `borderRadius`. *)
  val get_webkitBorderRadius: 'tags this -> string [@@js.get "webkitBorderRadius"]
  
  (** @deprecated This is a legacy alias of `borderRadius`. *)
  val set_webkitBorderRadius: 'tags this -> string -> unit [@@js.set "webkitBorderRadius"]
  
  (** @deprecated This is a legacy alias of `borderTopLeftRadius`. *)
  val get_webkitBorderTopLeftRadius: 'tags this -> string [@@js.get "webkitBorderTopLeftRadius"]
  
  (** @deprecated This is a legacy alias of `borderTopLeftRadius`. *)
  val set_webkitBorderTopLeftRadius: 'tags this -> string -> unit [@@js.set "webkitBorderTopLeftRadius"]
  
  (** @deprecated This is a legacy alias of `borderTopRightRadius`. *)
  val get_webkitBorderTopRightRadius: 'tags this -> string [@@js.get "webkitBorderTopRightRadius"]
  
  (** @deprecated This is a legacy alias of `borderTopRightRadius`. *)
  val set_webkitBorderTopRightRadius: 'tags this -> string -> unit [@@js.set "webkitBorderTopRightRadius"]
  
  (** @deprecated This is a legacy alias of `boxAlign`. *)
  val get_webkitBoxAlign: 'tags this -> string [@@js.get "webkitBoxAlign"]
  
  (** @deprecated This is a legacy alias of `boxAlign`. *)
  val set_webkitBoxAlign: 'tags this -> string -> unit [@@js.set "webkitBoxAlign"]
  
  (** @deprecated This is a legacy alias of `boxFlex`. *)
  val get_webkitBoxFlex: 'tags this -> string [@@js.get "webkitBoxFlex"]
  
  (** @deprecated This is a legacy alias of `boxFlex`. *)
  val set_webkitBoxFlex: 'tags this -> string -> unit [@@js.set "webkitBoxFlex"]
  
  (** @deprecated This is a legacy alias of `boxOrdinalGroup`. *)
  val get_webkitBoxOrdinalGroup: 'tags this -> string [@@js.get "webkitBoxOrdinalGroup"]
  
  (** @deprecated This is a legacy alias of `boxOrdinalGroup`. *)
  val set_webkitBoxOrdinalGroup: 'tags this -> string -> unit [@@js.set "webkitBoxOrdinalGroup"]
  
  (** @deprecated This is a legacy alias of `boxOrient`. *)
  val get_webkitBoxOrient: 'tags this -> string [@@js.get "webkitBoxOrient"]
  
  (** @deprecated This is a legacy alias of `boxOrient`. *)
  val set_webkitBoxOrient: 'tags this -> string -> unit [@@js.set "webkitBoxOrient"]
  
  (** @deprecated This is a legacy alias of `boxPack`. *)
  val get_webkitBoxPack: 'tags this -> string [@@js.get "webkitBoxPack"]
  
  (** @deprecated This is a legacy alias of `boxPack`. *)
  val set_webkitBoxPack: 'tags this -> string -> unit [@@js.set "webkitBoxPack"]
  
  (** @deprecated This is a legacy alias of `boxShadow`. *)
  val get_webkitBoxShadow: 'tags this -> string [@@js.get "webkitBoxShadow"]
  
  (** @deprecated This is a legacy alias of `boxShadow`. *)
  val set_webkitBoxShadow: 'tags this -> string -> unit [@@js.set "webkitBoxShadow"]
  
  (** @deprecated This is a legacy alias of `boxSizing`. *)
  val get_webkitBoxSizing: 'tags this -> string [@@js.get "webkitBoxSizing"]
  
  (** @deprecated This is a legacy alias of `boxSizing`. *)
  val set_webkitBoxSizing: 'tags this -> string -> unit [@@js.set "webkitBoxSizing"]
  
  (** @deprecated This is a legacy alias of `filter`. *)
  val get_webkitFilter: 'tags this -> string [@@js.get "webkitFilter"]
  
  (** @deprecated This is a legacy alias of `filter`. *)
  val set_webkitFilter: 'tags this -> string -> unit [@@js.set "webkitFilter"]
  
  (** @deprecated This is a legacy alias of `flex`. *)
  val get_webkitFlex: 'tags this -> string [@@js.get "webkitFlex"]
  
  (** @deprecated This is a legacy alias of `flex`. *)
  val set_webkitFlex: 'tags this -> string -> unit [@@js.set "webkitFlex"]
  
  (** @deprecated This is a legacy alias of `flexBasis`. *)
  val get_webkitFlexBasis: 'tags this -> string [@@js.get "webkitFlexBasis"]
  
  (** @deprecated This is a legacy alias of `flexBasis`. *)
  val set_webkitFlexBasis: 'tags this -> string -> unit [@@js.set "webkitFlexBasis"]
  
  (** @deprecated This is a legacy alias of `flexDirection`. *)
  val get_webkitFlexDirection: 'tags this -> string [@@js.get "webkitFlexDirection"]
  
  (** @deprecated This is a legacy alias of `flexDirection`. *)
  val set_webkitFlexDirection: 'tags this -> string -> unit [@@js.set "webkitFlexDirection"]
  
  (** @deprecated This is a legacy alias of `flexFlow`. *)
  val get_webkitFlexFlow: 'tags this -> string [@@js.get "webkitFlexFlow"]
  
  (** @deprecated This is a legacy alias of `flexFlow`. *)
  val set_webkitFlexFlow: 'tags this -> string -> unit [@@js.set "webkitFlexFlow"]
  
  (** @deprecated This is a legacy alias of `flexGrow`. *)
  val get_webkitFlexGrow: 'tags this -> string [@@js.get "webkitFlexGrow"]
  
  (** @deprecated This is a legacy alias of `flexGrow`. *)
  val set_webkitFlexGrow: 'tags this -> string -> unit [@@js.set "webkitFlexGrow"]
  
  (** @deprecated This is a legacy alias of `flexShrink`. *)
  val get_webkitFlexShrink: 'tags this -> string [@@js.get "webkitFlexShrink"]
  
  (** @deprecated This is a legacy alias of `flexShrink`. *)
  val set_webkitFlexShrink: 'tags this -> string -> unit [@@js.set "webkitFlexShrink"]
  
  (** @deprecated This is a legacy alias of `flexWrap`. *)
  val get_webkitFlexWrap: 'tags this -> string [@@js.get "webkitFlexWrap"]
  
  (** @deprecated This is a legacy alias of `flexWrap`. *)
  val set_webkitFlexWrap: 'tags this -> string -> unit [@@js.set "webkitFlexWrap"]
  
  (** @deprecated This is a legacy alias of `justifyContent`. *)
  val get_webkitJustifyContent: 'tags this -> string [@@js.get "webkitJustifyContent"]
  
  (** @deprecated This is a legacy alias of `justifyContent`. *)
  val set_webkitJustifyContent: 'tags this -> string -> unit [@@js.set "webkitJustifyContent"]
  val get_webkitLineClamp: 'tags this -> string [@@js.get "webkitLineClamp"]
  val set_webkitLineClamp: 'tags this -> string -> unit [@@js.set "webkitLineClamp"]
  
  (** @deprecated This is a legacy alias of `mask`. *)
  val get_webkitMask: 'tags this -> string [@@js.get "webkitMask"]
  
  (** @deprecated This is a legacy alias of `mask`. *)
  val set_webkitMask: 'tags this -> string -> unit [@@js.set "webkitMask"]
  
  (** @deprecated This is a legacy alias of `maskBorder`. *)
  val get_webkitMaskBoxImage: 'tags this -> string [@@js.get "webkitMaskBoxImage"]
  
  (** @deprecated This is a legacy alias of `maskBorder`. *)
  val set_webkitMaskBoxImage: 'tags this -> string -> unit [@@js.set "webkitMaskBoxImage"]
  
  (** @deprecated This is a legacy alias of `maskBorderOutset`. *)
  val get_webkitMaskBoxImageOutset: 'tags this -> string [@@js.get "webkitMaskBoxImageOutset"]
  
  (** @deprecated This is a legacy alias of `maskBorderOutset`. *)
  val set_webkitMaskBoxImageOutset: 'tags this -> string -> unit [@@js.set "webkitMaskBoxImageOutset"]
  
  (** @deprecated This is a legacy alias of `maskBorderRepeat`. *)
  val get_webkitMaskBoxImageRepeat: 'tags this -> string [@@js.get "webkitMaskBoxImageRepeat"]
  
  (** @deprecated This is a legacy alias of `maskBorderRepeat`. *)
  val set_webkitMaskBoxImageRepeat: 'tags this -> string -> unit [@@js.set "webkitMaskBoxImageRepeat"]
  
  (** @deprecated This is a legacy alias of `maskBorderSlice`. *)
  val get_webkitMaskBoxImageSlice: 'tags this -> string [@@js.get "webkitMaskBoxImageSlice"]
  
  (** @deprecated This is a legacy alias of `maskBorderSlice`. *)
  val set_webkitMaskBoxImageSlice: 'tags this -> string -> unit [@@js.set "webkitMaskBoxImageSlice"]
  
  (** @deprecated This is a legacy alias of `maskBorderSource`. *)
  val get_webkitMaskBoxImageSource: 'tags this -> string [@@js.get "webkitMaskBoxImageSource"]
  
  (** @deprecated This is a legacy alias of `maskBorderSource`. *)
  val set_webkitMaskBoxImageSource: 'tags this -> string -> unit [@@js.set "webkitMaskBoxImageSource"]
  
  (** @deprecated This is a legacy alias of `maskBorderWidth`. *)
  val get_webkitMaskBoxImageWidth: 'tags this -> string [@@js.get "webkitMaskBoxImageWidth"]
  
  (** @deprecated This is a legacy alias of `maskBorderWidth`. *)
  val set_webkitMaskBoxImageWidth: 'tags this -> string -> unit [@@js.set "webkitMaskBoxImageWidth"]
  
  (** @deprecated This is a legacy alias of `maskClip`. *)
  val get_webkitMaskClip: 'tags this -> string [@@js.get "webkitMaskClip"]
  
  (** @deprecated This is a legacy alias of `maskClip`. *)
  val set_webkitMaskClip: 'tags this -> string -> unit [@@js.set "webkitMaskClip"]
  val get_webkitMaskComposite: 'tags this -> string [@@js.get "webkitMaskComposite"]
  val set_webkitMaskComposite: 'tags this -> string -> unit [@@js.set "webkitMaskComposite"]
  
  (** @deprecated This is a legacy alias of `maskImage`. *)
  val get_webkitMaskImage: 'tags this -> string [@@js.get "webkitMaskImage"]
  
  (** @deprecated This is a legacy alias of `maskImage`. *)
  val set_webkitMaskImage: 'tags this -> string -> unit [@@js.set "webkitMaskImage"]
  
  (** @deprecated This is a legacy alias of `maskOrigin`. *)
  val get_webkitMaskOrigin: 'tags this -> string [@@js.get "webkitMaskOrigin"]
  
  (** @deprecated This is a legacy alias of `maskOrigin`. *)
  val set_webkitMaskOrigin: 'tags this -> string -> unit [@@js.set "webkitMaskOrigin"]
  
  (** @deprecated This is a legacy alias of `maskPosition`. *)
  val get_webkitMaskPosition: 'tags this -> string [@@js.get "webkitMaskPosition"]
  
  (** @deprecated This is a legacy alias of `maskPosition`. *)
  val set_webkitMaskPosition: 'tags this -> string -> unit [@@js.set "webkitMaskPosition"]
  
  (** @deprecated This is a legacy alias of `maskRepeat`. *)
  val get_webkitMaskRepeat: 'tags this -> string [@@js.get "webkitMaskRepeat"]
  
  (** @deprecated This is a legacy alias of `maskRepeat`. *)
  val set_webkitMaskRepeat: 'tags this -> string -> unit [@@js.set "webkitMaskRepeat"]
  
  (** @deprecated This is a legacy alias of `maskSize`. *)
  val get_webkitMaskSize: 'tags this -> string [@@js.get "webkitMaskSize"]
  
  (** @deprecated This is a legacy alias of `maskSize`. *)
  val set_webkitMaskSize: 'tags this -> string -> unit [@@js.set "webkitMaskSize"]
  
  (** @deprecated This is a legacy alias of `order`. *)
  val get_webkitOrder: 'tags this -> string [@@js.get "webkitOrder"]
  
  (** @deprecated This is a legacy alias of `order`. *)
  val set_webkitOrder: 'tags this -> string -> unit [@@js.set "webkitOrder"]
  
  (** @deprecated This is a legacy alias of `perspective`. *)
  val get_webkitPerspective: 'tags this -> string [@@js.get "webkitPerspective"]
  
  (** @deprecated This is a legacy alias of `perspective`. *)
  val set_webkitPerspective: 'tags this -> string -> unit [@@js.set "webkitPerspective"]
  
  (** @deprecated This is a legacy alias of `perspectiveOrigin`. *)
  val get_webkitPerspectiveOrigin: 'tags this -> string [@@js.get "webkitPerspectiveOrigin"]
  
  (** @deprecated This is a legacy alias of `perspectiveOrigin`. *)
  val set_webkitPerspectiveOrigin: 'tags this -> string -> unit [@@js.set "webkitPerspectiveOrigin"]
  val get_webkitTextFillColor: 'tags this -> string [@@js.get "webkitTextFillColor"]
  val set_webkitTextFillColor: 'tags this -> string -> unit [@@js.set "webkitTextFillColor"]
  val get_webkitTextStroke: 'tags this -> string [@@js.get "webkitTextStroke"]
  val set_webkitTextStroke: 'tags this -> string -> unit [@@js.set "webkitTextStroke"]
  val get_webkitTextStrokeColor: 'tags this -> string [@@js.get "webkitTextStrokeColor"]
  val set_webkitTextStrokeColor: 'tags this -> string -> unit [@@js.set "webkitTextStrokeColor"]
  val get_webkitTextStrokeWidth: 'tags this -> string [@@js.get "webkitTextStrokeWidth"]
  val set_webkitTextStrokeWidth: 'tags this -> string -> unit [@@js.set "webkitTextStrokeWidth"]
  
  (** @deprecated This is a legacy alias of `transform`. *)
  val get_webkitTransform: 'tags this -> string [@@js.get "webkitTransform"]
  
  (** @deprecated This is a legacy alias of `transform`. *)
  val set_webkitTransform: 'tags this -> string -> unit [@@js.set "webkitTransform"]
  
  (** @deprecated This is a legacy alias of `transformOrigin`. *)
  val get_webkitTransformOrigin: 'tags this -> string [@@js.get "webkitTransformOrigin"]
  
  (** @deprecated This is a legacy alias of `transformOrigin`. *)
  val set_webkitTransformOrigin: 'tags this -> string -> unit [@@js.set "webkitTransformOrigin"]
  
  (** @deprecated This is a legacy alias of `transformStyle`. *)
  val get_webkitTransformStyle: 'tags this -> string [@@js.get "webkitTransformStyle"]
  
  (** @deprecated This is a legacy alias of `transformStyle`. *)
  val set_webkitTransformStyle: 'tags this -> string -> unit [@@js.set "webkitTransformStyle"]
  
  (** @deprecated This is a legacy alias of `transition`. *)
  val get_webkitTransition: 'tags this -> string [@@js.get "webkitTransition"]
  
  (** @deprecated This is a legacy alias of `transition`. *)
  val set_webkitTransition: 'tags this -> string -> unit [@@js.set "webkitTransition"]
  
  (** @deprecated This is a legacy alias of `transitionDelay`. *)
  val get_webkitTransitionDelay: 'tags this -> string [@@js.get "webkitTransitionDelay"]
  
  (** @deprecated This is a legacy alias of `transitionDelay`. *)
  val set_webkitTransitionDelay: 'tags this -> string -> unit [@@js.set "webkitTransitionDelay"]
  
  (** @deprecated This is a legacy alias of `transitionDuration`. *)
  val get_webkitTransitionDuration: 'tags this -> string [@@js.get "webkitTransitionDuration"]
  
  (** @deprecated This is a legacy alias of `transitionDuration`. *)
  val set_webkitTransitionDuration: 'tags this -> string -> unit [@@js.set "webkitTransitionDuration"]
  
  (** @deprecated This is a legacy alias of `transitionProperty`. *)
  val get_webkitTransitionProperty: 'tags this -> string [@@js.get "webkitTransitionProperty"]
  
  (** @deprecated This is a legacy alias of `transitionProperty`. *)
  val set_webkitTransitionProperty: 'tags this -> string -> unit [@@js.set "webkitTransitionProperty"]
  
  (** @deprecated This is a legacy alias of `transitionTimingFunction`. *)
  val get_webkitTransitionTimingFunction: 'tags this -> string [@@js.get "webkitTransitionTimingFunction"]
  
  (** @deprecated This is a legacy alias of `transitionTimingFunction`. *)
  val set_webkitTransitionTimingFunction: 'tags this -> string -> unit [@@js.set "webkitTransitionTimingFunction"]
  
  (** @deprecated This is a legacy alias of `userSelect`. *)
  val get_webkitUserSelect: 'tags this -> string [@@js.get "webkitUserSelect"]
  
  (** @deprecated This is a legacy alias of `userSelect`. *)
  val set_webkitUserSelect: 'tags this -> string -> unit [@@js.set "webkitUserSelect"]
  val get_whiteSpace: 'tags this -> string [@@js.get "whiteSpace"]
  val set_whiteSpace: 'tags this -> string -> unit [@@js.set "whiteSpace"]
  val get_widows: 'tags this -> string [@@js.get "widows"]
  val set_widows: 'tags this -> string -> unit [@@js.set "widows"]
  val get_width: 'tags this -> string [@@js.get "width"]
  val set_width: 'tags this -> string -> unit [@@js.set "width"]
  val get_willChange: 'tags this -> string [@@js.get "willChange"]
  val set_willChange: 'tags this -> string -> unit [@@js.set "willChange"]
  val get_wordBreak: 'tags this -> string [@@js.get "wordBreak"]
  val set_wordBreak: 'tags this -> string -> unit [@@js.set "wordBreak"]
  val get_wordSpacing: 'tags this -> string [@@js.get "wordSpacing"]
  val set_wordSpacing: 'tags this -> string -> unit [@@js.set "wordSpacing"]
  
  (** @deprecated  *)
  val get_wordWrap: 'tags this -> string [@@js.get "wordWrap"]
  
  (** @deprecated  *)
  val set_wordWrap: 'tags this -> string -> unit [@@js.set "wordWrap"]
  val get_writingMode: 'tags this -> string [@@js.get "writingMode"]
  val set_writingMode: 'tags this -> string -> unit [@@js.set "writingMode"]
  val get_zIndex: 'tags this -> string [@@js.get "zIndex"]
  val set_zIndex: 'tags this -> string -> unit [@@js.set "zIndex"]
  val getPropertyPriority: 'tags this -> property:string -> string [@@js.call "getPropertyPriority"]
  val getPropertyValue: 'tags this -> property:string -> string [@@js.call "getPropertyValue"]
  val item: 'tags this -> index:float -> string [@@js.call "item"]
  val removeProperty: 'tags this -> property:string -> string [@@js.call "removeProperty"]
  val setProperty: 'tags this -> property:string -> value:string option -> ?priority:string -> unit -> unit [@@js.call "setProperty"]
  val get: 'tags this -> float -> string [@@js.index_get]
  val set: 'tags this -> float -> string -> unit [@@js.index_set]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** A single CSS style sheet. It inherits properties and methods from its parent, StyleSheet. *)
and[@js.scope "CSSStyleSheet"] CSSStyleSheet : sig
  type t = [`CSSStyleSheet | `StyleSheet] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`CSSStyleSheet | `StyleSheet]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`CSSStyleSheet | `StyleSheet]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `CSSStyleSheet ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_cssRules: 'tags this -> CSSRuleList.t [@@js.get "cssRules"]
  val get_ownerRule: 'tags this -> CSSRule.t option [@@js.get "ownerRule"]
  
  (** @deprecated  *)
  val get_rules: 'tags this -> CSSRuleList.t [@@js.get "rules"]
  
  (** @deprecated  *)
  val addRule: 'tags this -> ?selector:string -> ?style:string -> ?index:float -> unit -> float [@@js.call "addRule"]
  val deleteRule: 'tags this -> index:float -> unit [@@js.call "deleteRule"]
  val insertRule: 'tags this -> rule:string -> ?index:float -> unit -> float [@@js.call "insertRule"]
  
  (** @deprecated  *)
  val removeRule: 'tags this -> ?index:float -> unit -> unit [@@js.call "removeRule"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: ?options:CSSStyleSheetInit.t -> unit -> t [@@js.create]
end

(**
  Provides a storage mechanism for Request / Response object pairs that are cached, for example as part of the ServiceWorker life cycle. Note that the Cache interface is exposed to windowed scopes as well as workers. You don't have to use it in conjunction with service workers, even though it is defined in the service worker spec.
  Available only in secure contexts.
*)
and[@js.scope "Cache"] Cache : sig
  type t = [`Cache] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Cache]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Cache]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `Cache ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val addAll: 'tags this -> requests:RequestInfo.t Iterable.t_1 -> unit Promise.t_1 [@@js.call "addAll"]
  val add: 'tags this -> request:RequestInfo.t -> unit Promise.t_1 [@@js.call "add"]
  val addAll': 'tags this -> requests:RequestInfo.t list -> unit Promise.t_1 [@@js.call "addAll"]
  val delete: 'tags this -> request:RequestInfo.t -> ?options:CacheQueryOptions.t -> unit -> bool Promise.t_1 [@@js.call "delete"]
  val keys: 'tags this -> ?request:RequestInfo.t -> ?options:CacheQueryOptions.t -> unit -> Request.t list Promise.t_1 [@@js.call "keys"]
  val match_: 'tags this -> request:RequestInfo.t -> ?options:CacheQueryOptions.t -> unit -> Response.t option Promise.t_1 [@@js.call "match"]
  val matchAll: 'tags this -> ?request:RequestInfo.t -> ?options:CacheQueryOptions.t -> unit -> Response.t list Promise.t_1 [@@js.call "matchAll"]
  val put: 'tags this -> request:RequestInfo.t -> response:Response.t -> unit Promise.t_1 [@@js.call "put"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(**
  The storage for Cache objects.
  Available only in secure contexts.
*)
and[@js.scope "CacheStorage"] CacheStorage : sig
  type t = [`CacheStorage] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`CacheStorage]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`CacheStorage]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `CacheStorage ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val delete: 'tags this -> cacheName:string -> bool Promise.t_1 [@@js.call "delete"]
  val has: 'tags this -> cacheName:string -> bool Promise.t_1 [@@js.call "has"]
  val keys: 'tags this -> string list Promise.t_1 [@@js.call "keys"]
  val match_: 'tags this -> request:RequestInfo.t -> ?options:MultiCacheQueryOptions.t -> unit -> Response.t option Promise.t_1 [@@js.call "match"]
  val open_: 'tags this -> cacheName:string -> Cache.t Promise.t_1 [@@js.call "open"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
and CanvasDrawImage : sig
  type t = [`CanvasDrawImage] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`CanvasDrawImage]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`CanvasDrawImage]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `CanvasDrawImage ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val drawImage: 'tags this -> image:CanvasImageSource.t -> dx:float -> dy:float -> unit [@@js.call "drawImage"]
  val drawImage': 'tags this -> image:CanvasImageSource.t -> dx:float -> dy:float -> dw:float -> dh:float -> unit [@@js.call "drawImage"]
  val drawImage'': 'tags this -> image:CanvasImageSource.t -> sx:float -> sy:float -> sw:float -> sh:float -> dx:float -> dy:float -> dw:float -> dh:float -> unit [@@js.call "drawImage"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
and CanvasFillStrokeStyles : sig
  type t = [`CanvasFillStrokeStyles] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`CanvasFillStrokeStyles]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`CanvasFillStrokeStyles]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `CanvasFillStrokeStyles ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_fillStyle: 'tags this -> ([`String of string | `Other of (CanvasGradient.t, CanvasPattern.t) union2] [@js.union on_field "dummy"]) Primitive.t [@@js.get "fillStyle"]
  val set_fillStyle: 'tags this -> ([`U1 of string | `U2 of CanvasGradient.t | `U3 of CanvasPattern.t] [@js.union]) -> unit [@@js.set "fillStyle"]
  val get_strokeStyle: 'tags this -> ([`String of string | `Other of (CanvasGradient.t, CanvasPattern.t) union2] [@js.union on_field "dummy"]) Primitive.t [@@js.get "strokeStyle"]
  val set_strokeStyle: 'tags this -> ([`U1 of string | `U2 of CanvasGradient.t | `U3 of CanvasPattern.t] [@js.union]) -> unit [@@js.set "strokeStyle"]
  val createConicGradient: 'tags this -> startAngle:float -> x:float -> y:float -> CanvasGradient.t [@@js.call "createConicGradient"]
  val createLinearGradient: 'tags this -> x0:float -> y0:float -> x1:float -> y1:float -> CanvasGradient.t [@@js.call "createLinearGradient"]
  val createPattern: 'tags this -> image:CanvasImageSource.t -> repetition:string option -> CanvasPattern.t option [@@js.call "createPattern"]
  val createRadialGradient: 'tags this -> x0:float -> y0:float -> r0:float -> x1:float -> y1:float -> r1:float -> CanvasGradient.t [@@js.call "createRadialGradient"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
and CanvasImageSource : sig
  type t = (HTMLCanvasElement.t, HTMLOrSVGImageElement.t, HTMLVideoElement.t, ImageBitmap.t) union4
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end

(** The CanvasRenderingContext2D interface, part of the Canvas API, provides the 2D rendering context for the drawing surface of a <canvas> element. It is used for drawing shapes, text, images, and other objects. *)
and[@js.scope "CanvasRenderingContext2D"] CanvasRenderingContext2D : sig
  type t = [`CanvasCompositing | `CanvasDrawImage | `CanvasDrawPath | `CanvasFillStrokeStyles | `CanvasFilters | `CanvasImageData | `CanvasImageSmoothing | `CanvasPath | `CanvasPathDrawingStyles | `CanvasRect | `CanvasRenderingContext2D | `CanvasShadowStyles | `CanvasState | `CanvasText | `CanvasTextDrawingStyles | `CanvasTransform | `CanvasUserInterface] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`CanvasCompositing | `CanvasDrawImage | `CanvasDrawPath | `CanvasFillStrokeStyles | `CanvasFilters | `CanvasImageData | `CanvasImageSmoothing | `CanvasPath | `CanvasPathDrawingStyles | `CanvasRect | `CanvasRenderingContext2D | `CanvasShadowStyles | `CanvasState | `CanvasText | `CanvasTextDrawingStyles | `CanvasTransform | `CanvasUserInterface]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`CanvasCompositing | `CanvasDrawImage | `CanvasDrawPath | `CanvasFillStrokeStyles | `CanvasFilters | `CanvasImageData | `CanvasImageSmoothing | `CanvasPath | `CanvasPathDrawingStyles | `CanvasRect | `CanvasRenderingContext2D | `CanvasShadowStyles | `CanvasState | `CanvasText | `CanvasTextDrawingStyles | `CanvasTransform | `CanvasUserInterface]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `CanvasRenderingContext2D ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_canvas: 'tags this -> HTMLCanvasElement.t [@@js.get "canvas"]
  val getContextAttributes: 'tags this -> CanvasRenderingContext2DSettings.t [@@js.call "getContextAttributes"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
and CanvasUserInterface : sig
  type t = [`CanvasUserInterface] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`CanvasUserInterface]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`CanvasUserInterface]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `CanvasUserInterface ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val drawFocusIfNeeded: 'tags this -> element:Element.t -> unit [@@js.call "drawFocusIfNeeded"]
  val drawFocusIfNeeded': 'tags this -> path:Path2D.t -> element:Element.t -> unit [@@js.call "drawFocusIfNeeded"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** The CharacterData abstract interface represents a Node object that contains characters. This is an abstract interface, meaning there aren't any object of type CharacterData: it is implemented by other interfaces, like Text, Comment, or ProcessingInstruction which aren't abstract. *)
and[@js.scope "CharacterData"] CharacterData : sig
  type t = [`CharacterData | `ChildNode | `EventTarget | `Node | `NonDocumentTypeChildNode] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`CharacterData | `ChildNode | `EventTarget | `Node | `NonDocumentTypeChildNode]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`CharacterData | `ChildNode | `EventTarget | `Node | `NonDocumentTypeChildNode]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `CharacterData ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_data: 'tags this -> string [@@js.get "data"]
  val set_data: 'tags this -> string -> unit [@@js.set "data"]
  val get_length: 'tags this -> float [@@js.get "length"]
  
  (** Returns the node document. Returns null for documents. *)
  val get_ownerDocument: 'tags this -> Document.t [@@js.get "ownerDocument"]
  val appendData: 'tags this -> data:string -> unit [@@js.call "appendData"]
  val deleteData: 'tags this -> offset:float -> count:float -> unit [@@js.call "deleteData"]
  val insertData: 'tags this -> offset:float -> data:string -> unit [@@js.call "insertData"]
  val replaceData: 'tags this -> offset:float -> count:float -> data:string -> unit [@@js.call "replaceData"]
  val substringData: 'tags this -> offset:float -> count:float -> string [@@js.call "substringData"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
and ChildNode : sig
  type t = [`ChildNode | `EventTarget | `Node] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ChildNode | `EventTarget | `Node]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ChildNode | `EventTarget | `Node]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ChildNode ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    Inserts nodes just after node, while replacing strings in nodes with equivalent Text nodes.
    
    Throws a "HierarchyRequestError" DOMException if the constraints of the node tree are violated.
  *)
  val after: 'tags this -> nodes:(([`U1 of Node.t | `U2 of string] [@js.union]) list [@js.variadic]) -> unit [@@js.call "after"]
  
  (**
    Inserts nodes just before node, while replacing strings in nodes with equivalent Text nodes.
    
    Throws a "HierarchyRequestError" DOMException if the constraints of the node tree are violated.
  *)
  val before: 'tags this -> nodes:(([`U1 of Node.t | `U2 of string] [@js.union]) list [@js.variadic]) -> unit [@@js.call "before"]
  
  (** Removes node. *)
  val remove: 'tags this -> unit [@@js.call "remove"]
  
  (**
    Replaces node with nodes, while replacing strings in nodes with equivalent Text nodes.
    
    Throws a "HierarchyRequestError" DOMException if the constraints of the node tree are violated.
  *)
  val replaceWith: 'tags this -> nodes:(([`U1 of Node.t | `U2 of string] [@js.union]) list [@js.variadic]) -> unit [@@js.call "replaceWith"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** Events providing information related to modification of the clipboard, that is cut, copy, and paste events. *)
and[@js.scope "ClipboardEvent"] ClipboardEvent : sig
  type t = [`ClipboardEvent | `Event] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ClipboardEvent | `Event]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ClipboardEvent | `Event]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ClipboardEvent ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_clipboardData: 'tags this -> DataTransfer.t option [@@js.get "clipboardData"]
  val create: ?clipboardData:DataTransfer.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': type_:string -> ?eventInitDict:ClipboardEventInit.t -> unit -> t [@@js.create]
end
and ClipboardEventInit : sig
  type t = [`ClipboardEventInit | `EventInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ClipboardEventInit | `EventInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ClipboardEventInit | `EventInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ClipboardEventInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_clipboardData: 'tags this -> DataTransfer.t option option [@@js.get "clipboardData"]
  val set_clipboardData: 'tags this -> DataTransfer.t option -> unit [@@js.set "clipboardData"]
  val create: ?clipboardData:DataTransfer.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** Textual notations within markup; although it is generally not visually shown, such comments are available to be read in the source view. *)
and[@js.scope "Comment"] Comment : sig
  type t = [`CharacterData | `ChildNode | `Comment | `EventTarget | `Node | `NonDocumentTypeChildNode] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`CharacterData | `ChildNode | `Comment | `EventTarget | `Node | `NonDocumentTypeChildNode]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`CharacterData | `ChildNode | `Comment | `EventTarget | `Node | `NonDocumentTypeChildNode]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `Comment ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: ?data:string -> unit -> t [@@js.create]
end

(** The DOM CompositionEvent represents events that occur due to the user indirectly entering text. *)
and[@js.scope "CompositionEvent"] CompositionEvent : sig
  type t = [`CompositionEvent | `Event | `UIEvent] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`CompositionEvent | `Event | `UIEvent]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`CompositionEvent | `Event | `UIEvent]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `CompositionEvent ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_data: 'tags this -> string [@@js.get "data"]
  
  (** @deprecated  *)
  val initCompositionEvent: 'tags this -> typeArg:string -> ?bubblesArg:bool -> ?cancelableArg:bool -> ?viewArg:WindowProxy.t option -> ?dataArg:string -> unit -> unit [@@js.call "initCompositionEvent"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: type_:string -> ?eventInitDict:CompositionEventInit.t -> unit -> t [@@js.create]
end
and CompositionEventInit : sig
  type t = [`CompositionEventInit | `EventInit | `UIEventInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`CompositionEventInit | `EventInit | `UIEventInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`CompositionEventInit | `EventInit | `UIEventInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `CompositionEventInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_data: 'tags this -> string option [@@js.get "data"]
  val set_data: 'tags this -> string -> unit [@@js.set "data"]
  val create: ?data:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
and CustomElementConstructor : sig
  type t = [`CustomElementConstructor] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`CustomElementConstructor]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`CustomElementConstructor]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `CustomElementConstructor ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val create: 'tags this -> params:(any list [@js.variadic]) -> HTMLElement.t [@@js.apply_newable]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
and[@js.scope "CustomElementRegistry"] CustomElementRegistry : sig
  type t = [`CustomElementRegistry] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`CustomElementRegistry]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`CustomElementRegistry]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `CustomElementRegistry ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val define: 'tags this -> name:string -> constructor:CustomElementConstructor.t -> ?options:ElementDefinitionOptions.t -> unit -> unit [@@js.call "define"]
  val get_: 'tags this -> name:string -> CustomElementConstructor.t option [@@js.call "get"]
  val upgrade: 'tags this -> root:Node.t -> unit [@@js.call "upgrade"]
  val whenDefined: 'tags this -> name:string -> CustomElementConstructor.t Promise.t_1 [@@js.call "whenDefined"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** An object providing methods which are not dependent on any particular document. Such an object is returned by the Document.implementation property. *)
and[@js.scope "DOMImplementation"] DOMImplementation : sig
  type t = [`DOMImplementation] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`DOMImplementation]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`DOMImplementation]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `DOMImplementation ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val createDocument: 'tags this -> namespace:string option -> qualifiedName:string option -> ?doctype:DocumentType.t option -> unit -> XMLDocument.t [@@js.call "createDocument"]
  val createDocumentType: 'tags this -> qualifiedName:string -> publicId:string -> systemId:string -> DocumentType.t [@@js.call "createDocumentType"]
  val createHTMLDocument: 'tags this -> ?title:string -> unit -> Document.t [@@js.call "createHTMLDocument"]
  
  (** @deprecated  *)
  val hasFeature: 'tags this -> args:(any list [@js.variadic]) -> ([`L_b_true[@js true]] [@js.enum]) [@@js.call "hasFeature"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Used to hold the data that is being dragged during a drag and drop operation. It may hold one or more data items, each of one or more data types. For more information about drag and drop, see HTML Drag and Drop API. *)
and[@js.scope "DataTransfer"] DataTransfer : sig
  type t = [`DataTransfer] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`DataTransfer]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`DataTransfer]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `DataTransfer ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    Returns the kind of operation that is currently selected. If the kind of operation isn't one of those that is allowed by the effectAllowed attribute, then the operation will fail.
    
    Can be set, to change the selected operation.
    
    The possible values are "none", "copy", "link", and "move".
  *)
  val get_dropEffect: 'tags this -> ([`L_s222_copy[@js "copy"] | `L_s469_link[@js "link"] | `L_s526_move[@js "move"] | `L_s548_none[@js "none"]] [@js.enum]) [@@js.get "dropEffect"]
  
  (**
    Returns the kind of operation that is currently selected. If the kind of operation isn't one of those that is allowed by the effectAllowed attribute, then the operation will fail.
    
    Can be set, to change the selected operation.
    
    The possible values are "none", "copy", "link", and "move".
  *)
  val set_dropEffect: 'tags this -> ([`U1 of ([`L_s548_none[@js "none"]] [@js.enum]) | `U2 of ([`L_s222_copy[@js "copy"]] [@js.enum]) | `U3 of ([`L_s469_link[@js "link"]] [@js.enum]) | `U4 of ([`L_s526_move[@js "move"]] [@js.enum])] [@js.union]) -> unit [@@js.set "dropEffect"]
  
  (**
    Returns the kinds of operations that are to be allowed.
    
    Can be set (during the dragstart event), to change the allowed operations.
    
    The possible values are "none", "copy", "copyLink", "copyMove", "link", "linkMove", "move", "all", and "uninitialized",
  *)
  val get_effectAllowed: 'tags this -> ([`L_s106_all[@js "all"] | `L_s222_copy[@js "copy"] | `L_s223_copyLink[@js "copyLink"] | `L_s224_copyMove[@js "copyMove"] | `L_s469_link[@js "link"] | `L_s470_linkMove[@js "linkMove"] | `L_s526_move[@js "move"] | `L_s548_none[@js "none"] | `L_s827_uninitialized[@js "uninitialized"]] [@js.enum]) [@@js.get "effectAllowed"]
  
  (**
    Returns the kinds of operations that are to be allowed.
    
    Can be set (during the dragstart event), to change the allowed operations.
    
    The possible values are "none", "copy", "copyLink", "copyMove", "link", "linkMove", "move", "all", and "uninitialized",
  *)
  val set_effectAllowed: 'tags this -> ([`U1 of ([`L_s548_none[@js "none"]] [@js.enum]) | `U2 of ([`L_s222_copy[@js "copy"]] [@js.enum]) | `U3 of ([`L_s223_copyLink[@js "copyLink"]] [@js.enum]) | `U4 of ([`L_s224_copyMove[@js "copyMove"]] [@js.enum]) | `U5 of ([`L_s469_link[@js "link"]] [@js.enum]) | `U6 of ([`L_s470_linkMove[@js "linkMove"]] [@js.enum]) | `U7 of ([`L_s526_move[@js "move"]] [@js.enum]) | `U8 of ([`L_s106_all[@js "all"]] [@js.enum]) | `U9 of ([`L_s827_uninitialized[@js "uninitialized"]] [@js.enum])] [@js.union]) -> unit [@@js.set "effectAllowed"]
  
  (** Returns a FileList of the files being dragged, if any. *)
  val get_files: 'tags this -> FileList.t [@@js.get "files"]
  
  (** Returns a DataTransferItemList object, with the drag data. *)
  val get_items: 'tags this -> DataTransferItemList.t [@@js.get "items"]
  
  (** Returns a frozen array listing the formats that were set in the dragstart event. In addition, if any files are being dragged, then one of the types will be the string "Files". *)
  val get_types: 'tags this -> string list [@@js.get "types"]
  
  (** Removes the data of the specified formats. Removes all data if the argument is omitted. *)
  val clearData: 'tags this -> ?format:string -> unit -> unit [@@js.call "clearData"]
  
  (** Returns the specified data. If there is no such data, returns the empty string. *)
  val getData: 'tags this -> format:string -> string [@@js.call "getData"]
  
  (** Adds the specified data. *)
  val setData: 'tags this -> format:string -> data:string -> unit [@@js.call "setData"]
  
  (** Uses the given element to update the drag feedback, replacing any previously specified feedback. *)
  val setDragImage: 'tags this -> image:Element.t -> x:float -> y:float -> unit [@@js.call "setDragImage"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Any web page loaded in the browser and serves as an entry point into the web page's content, which is the DOM tree. *)
and[@js.scope "Document"] Document : sig
  type t = [`Document | `DocumentAndElementEventHandlers | `DocumentOrShadowRoot | `EventTarget | `FontFaceSource | `GlobalEventHandlers | `Node | `NonElementParentNode | `ParentNode | `XPathEvaluatorBase] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Document | `DocumentAndElementEventHandlers | `DocumentOrShadowRoot | `EventTarget | `FontFaceSource | `GlobalEventHandlers | `Node | `NonElementParentNode | `ParentNode | `XPathEvaluatorBase]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Document | `DocumentAndElementEventHandlers | `DocumentOrShadowRoot | `EventTarget | `FontFaceSource | `GlobalEventHandlers | `Node | `NonElementParentNode | `ParentNode | `XPathEvaluatorBase]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `Document ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Sets or gets the URL for the current document. *)
  val get_URL: 'tags this -> string [@@js.get "URL"]
  
  (**
    Sets or gets the color of all active links in the document.
    @deprecated 
  *)
  val get_alinkColor: 'tags this -> string [@@js.get "alinkColor"]
  
  (**
    Sets or gets the color of all active links in the document.
    @deprecated 
  *)
  val set_alinkColor: 'tags this -> string -> unit [@@js.set "alinkColor"]
  
  (**
    Returns a reference to the collection of elements contained by the object.
    @deprecated 
  *)
  val get_all: 'tags this -> HTMLAllCollection.t [@@js.get "all"]
  
  (**
    Retrieves a collection of all a objects that have a name and/or id property. Objects in this collection are in HTML source order.
    @deprecated 
  *)
  val get_anchors: 'tags this -> HTMLAnchorElement.t HTMLCollectionOf.t [@@js.get "anchors"]
  
  (**
    Retrieves a collection of all applet objects in the document.
    @deprecated 
  *)
  val get_applets: 'tags this -> HTMLCollection.t [@@js.get "applets"]
  
  (**
    Deprecated. Sets or retrieves a value that indicates the background color behind the object.
    @deprecated 
  *)
  val get_bgColor: 'tags this -> string [@@js.get "bgColor"]
  
  (**
    Deprecated. Sets or retrieves a value that indicates the background color behind the object.
    @deprecated 
  *)
  val set_bgColor: 'tags this -> string -> unit [@@js.set "bgColor"]
  
  (** Specifies the beginning and end of the document body. *)
  val get_body: 'tags this -> HTMLElement.t [@@js.get "body"]
  
  (** Specifies the beginning and end of the document body. *)
  val set_body: 'tags this -> HTMLElement.t -> unit [@@js.set "body"]
  
  (** Returns document's encoding. *)
  val get_characterSet: 'tags this -> string [@@js.get "characterSet"]
  
  (**
    Gets or sets the character set used to encode the object.
    @deprecated This is a legacy alias of `characterSet`.
  *)
  val get_charset: 'tags this -> string [@@js.get "charset"]
  
  (** Gets a value that indicates whether standards-compliant mode is switched on for the object. *)
  val get_compatMode: 'tags this -> string [@@js.get "compatMode"]
  
  (** Returns document's content type. *)
  val get_contentType: 'tags this -> string [@@js.get "contentType"]
  
  (**
    Returns the HTTP cookies that apply to the Document. If there are no cookies or cookies can't be applied to this resource, the empty string will be returned.
    
    Can be set, to add a new cookie to the element's set of HTTP cookies.
    
    If the contents are sandboxed into a unique origin (e.g. in an iframe with the sandbox attribute), a "SecurityError" DOMException will be thrown on getting and setting.
  *)
  val get_cookie: 'tags this -> string [@@js.get "cookie"]
  
  (**
    Returns the HTTP cookies that apply to the Document. If there are no cookies or cookies can't be applied to this resource, the empty string will be returned.
    
    Can be set, to add a new cookie to the element's set of HTTP cookies.
    
    If the contents are sandboxed into a unique origin (e.g. in an iframe with the sandbox attribute), a "SecurityError" DOMException will be thrown on getting and setting.
  *)
  val set_cookie: 'tags this -> string -> unit [@@js.set "cookie"]
  
  (**
    Returns the script element, or the SVG script element, that is currently executing, as long as the element represents a classic script. In the case of reentrant script execution, returns the one that most recently started executing amongst those that have not yet finished executing.
    
    Returns null if the Document is not currently executing a script or SVG script element (e.g., because the running script is an event handler, or a timeout), or if the currently executing script or SVG script element represents a module script.
  *)
  val get_currentScript: 'tags this -> HTMLOrSVGScriptElement.t option [@@js.get "currentScript"]
  
  (** Returns the Window object of the active document. *)
  val get_defaultView: 'tags this -> (WindowProxy.t, (* FIXME: unknown type 'typeof globalThis' *)any) intersection2 option [@@js.get "defaultView"]
  
  (** Sets or gets a value that indicates whether the document can be edited. *)
  val get_designMode: 'tags this -> string [@@js.get "designMode"]
  
  (** Sets or gets a value that indicates whether the document can be edited. *)
  val set_designMode: 'tags this -> string -> unit [@@js.set "designMode"]
  
  (** Sets or retrieves a value that indicates the reading order of the object. *)
  val get_dir: 'tags this -> string [@@js.get "dir"]
  
  (** Sets or retrieves a value that indicates the reading order of the object. *)
  val set_dir: 'tags this -> string -> unit [@@js.set "dir"]
  
  (** Gets an object representing the document type declaration associated with the current document. *)
  val get_doctype: 'tags this -> DocumentType.t option [@@js.get "doctype"]
  
  (** Gets a reference to the root node of the document. *)
  val get_documentElement: 'tags this -> HTMLElement.t [@@js.get "documentElement"]
  
  (** Returns document's URL. *)
  val get_documentURI: 'tags this -> string [@@js.get "documentURI"]
  
  (** Sets or gets the security domain of the document. *)
  val get_domain: 'tags this -> string [@@js.get "domain"]
  
  (** Sets or gets the security domain of the document. *)
  val set_domain: 'tags this -> string -> unit [@@js.set "domain"]
  
  (** Retrieves a collection of all embed objects in the document. *)
  val get_embeds: 'tags this -> HTMLEmbedElement.t HTMLCollectionOf.t [@@js.get "embeds"]
  
  (**
    Sets or gets the foreground (text) color of the document.
    @deprecated 
  *)
  val get_fgColor: 'tags this -> string [@@js.get "fgColor"]
  
  (**
    Sets or gets the foreground (text) color of the document.
    @deprecated 
  *)
  val set_fgColor: 'tags this -> string -> unit [@@js.set "fgColor"]
  
  (** Retrieves a collection, in source order, of all form objects in the document. *)
  val get_forms: 'tags this -> HTMLFormElement.t HTMLCollectionOf.t [@@js.get "forms"]
  
  (** @deprecated  *)
  val get_fullscreen: 'tags this -> bool [@@js.get "fullscreen"]
  
  (** Returns true if document has the ability to display elements fullscreen and fullscreen is supported, or false otherwise. *)
  val get_fullscreenEnabled: 'tags this -> bool [@@js.get "fullscreenEnabled"]
  
  (** Returns the head element. *)
  val get_head: 'tags this -> HTMLHeadElement.t [@@js.get "head"]
  val get_hidden: 'tags this -> bool [@@js.get "hidden"]
  
  (** Retrieves a collection, in source order, of img objects in the document. *)
  val get_images: 'tags this -> HTMLImageElement.t HTMLCollectionOf.t [@@js.get "images"]
  
  (** Gets the implementation object of the current document. *)
  val get_implementation: 'tags this -> DOMImplementation.t [@@js.get "implementation"]
  
  (**
    Returns the character encoding used to create the webpage that is loaded into the document object.
    @deprecated This is a legacy alias of `characterSet`.
  *)
  val get_inputEncoding: 'tags this -> string [@@js.get "inputEncoding"]
  
  (** Gets the date that the page was last modified, if the page supplies one. *)
  val get_lastModified: 'tags this -> string [@@js.get "lastModified"]
  
  (**
    Sets or gets the color of the document links.
    @deprecated 
  *)
  val get_linkColor: 'tags this -> string [@@js.get "linkColor"]
  
  (**
    Sets or gets the color of the document links.
    @deprecated 
  *)
  val set_linkColor: 'tags this -> string -> unit [@@js.set "linkColor"]
  
  (** Retrieves a collection of all a objects that specify the href property and all area objects in the document. *)
  val get_links: 'tags this -> (HTMLAnchorElement.t, HTMLAreaElement.t) union2 HTMLCollectionOf.t [@@js.get "links"]
  
  (** Contains information about the current URL. *)
  val get_location: 'tags this -> Location.t [@@js.get "location"]
  
  (** Contains information about the current URL. *)
  val set_location: 'tags this -> ([`U1 of string | `U2 of Location.t] [@js.union]) -> unit [@@js.set "location"]
  val get_onfullscreenchange: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onfullscreenchange"]
  val set_onfullscreenchange: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onfullscreenchange"]
  val get_onfullscreenerror: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onfullscreenerror"]
  val set_onfullscreenerror: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onfullscreenerror"]
  val get_onpointerlockchange: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onpointerlockchange"]
  val set_onpointerlockchange: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onpointerlockchange"]
  val get_onpointerlockerror: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onpointerlockerror"]
  val set_onpointerlockerror: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onpointerlockerror"]
  
  (**
    Fires when the state of the object has changed.
    @param ev The event
  *)
  val get_onreadystatechange: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onreadystatechange"]
  
  (**
    Fires when the state of the object has changed.
    @param ev The event
  *)
  val set_onreadystatechange: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onreadystatechange"]
  val get_onvisibilitychange: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onvisibilitychange"]
  val set_onvisibilitychange: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onvisibilitychange"]
  
  (** Returns the node document. Returns null for documents. *)
  val get_ownerDocument: 'tags this -> null [@@js.get "ownerDocument"]
  val get_pictureInPictureEnabled: 'tags this -> bool [@@js.get "pictureInPictureEnabled"]
  
  (** Return an HTMLCollection of the embed elements in the Document. *)
  val get_plugins: 'tags this -> HTMLEmbedElement.t HTMLCollectionOf.t [@@js.get "plugins"]
  
  (** Retrieves a value that indicates the current state of the object. *)
  val get_readyState: 'tags this -> DocumentReadyState.t [@@js.get "readyState"]
  
  (** Gets the URL of the location that referred the user to the current page. *)
  val get_referrer: 'tags this -> string [@@js.get "referrer"]
  
  (** @deprecated  *)
  val get_rootElement: 'tags this -> SVGSVGElement.t option [@@js.get "rootElement"]
  
  (** Retrieves a collection of all script objects in the document. *)
  val get_scripts: 'tags this -> HTMLScriptElement.t HTMLCollectionOf.t [@@js.get "scripts"]
  val get_scrollingElement: 'tags this -> Element.t option [@@js.get "scrollingElement"]
  val get_timeline: 'tags this -> DocumentTimeline.t [@@js.get "timeline"]
  
  (** Contains the title of the document. *)
  val get_title: 'tags this -> string [@@js.get "title"]
  
  (** Contains the title of the document. *)
  val set_title: 'tags this -> string -> unit [@@js.set "title"]
  val get_visibilityState: 'tags this -> DocumentVisibilityState.t [@@js.get "visibilityState"]
  
  (**
    Sets or gets the color of the links that the user has visited.
    @deprecated 
  *)
  val get_vlinkColor: 'tags this -> string [@@js.get "vlinkColor"]
  
  (**
    Sets or gets the color of the links that the user has visited.
    @deprecated 
  *)
  val set_vlinkColor: 'tags this -> string -> unit [@@js.set "vlinkColor"]
  
  (**
    Moves node from another document and returns it.
    
    If node is a document, throws a "NotSupportedError" DOMException or, if node is a shadow root, throws a "HierarchyRequestError" DOMException.
  *)
  val adoptNode: 'tags this -> node:'T -> 'T [@@js.call "adoptNode"]
  
  (** @deprecated  *)
  val captureEvents: 'tags this -> unit [@@js.call "captureEvents"]
  
  (** @deprecated  *)
  val caretRangeFromPoint: 'tags this -> x:float -> y:float -> Range.t option [@@js.call "caretRangeFromPoint"]
  
  (** @deprecated  *)
  val clear: 'tags this -> unit [@@js.call "clear"]
  
  (** Closes an output stream and forces the sent data to display. *)
  val close: 'tags this -> unit [@@js.call "close"]
  
  (**
    Creates an attribute object with a specified name.
    @param name String that sets the attribute object's name.
  *)
  val createAttribute: 'tags this -> localName:string -> Attr.t [@@js.call "createAttribute"]
  val createAttributeNS: 'tags this -> namespace:string option -> qualifiedName:string -> Attr.t [@@js.call "createAttributeNS"]
  
  (** Returns a CDATASection node whose data is data. *)
  val createCDATASection: 'tags this -> data:string -> CDATASection.t [@@js.call "createCDATASection"]
  
  (**
    Creates a comment object with the specified data.
    @param data Sets the comment object's data.
  *)
  val createComment: 'tags this -> data:string -> Comment.t [@@js.call "createComment"]
  
  (** Creates a new document. *)
  val createDocumentFragment: 'tags this -> DocumentFragment.t [@@js.call "createDocumentFragment"]
  
  (**
    Creates an instance of the element for the specified tag.
    @param tagName The name of an element.
  *)
  val createElement: 'tags this -> tagName:'K -> ?options:ElementCreationOptions.t -> unit -> (* FIXME: unknown type 'HTMLElementTagNameMap[K]' *)any [@@js.call "createElement"]
  
  (** @deprecated  *)
  val createElement': 'tags this -> tagName:'K -> ?options:ElementCreationOptions.t -> unit -> (* FIXME: unknown type 'HTMLElementDeprecatedTagNameMap[K]' *)any [@@js.call "createElement"]
  
  (** Creates an instance of the element for the specified tag. *)
  val createElement'': 'tags this -> tagName:string -> ?options:ElementCreationOptions.t -> unit -> HTMLElement.t [@@js.call "createElement"]
  
  (**
    Returns an element with namespace namespace. Its namespace prefix will be everything before ":" (U+003E) in qualifiedName or null. Its local name will be everything after ":" (U+003E) in qualifiedName or qualifiedName.
    
    If localName does not match the Name production an "InvalidCharacterError" DOMException will be thrown.
    
    If one of the following conditions is true a "NamespaceError" DOMException will be thrown:
    
    localName does not match the QName production.
    Namespace prefix is not null and namespace is the empty string.
    Namespace prefix is "xml" and namespace is not the XML namespace.
    qualifiedName or namespace prefix is "xmlns" and namespace is not the XMLNS namespace.
    namespace is the XMLNS namespace and neither qualifiedName nor namespace prefix is "xmlns".
    
    When supplied, options's is can be used to create a customized built-in element.
  *)
  val createElementNS: 'tags this -> namespaceURI:([`L_s403_http___www_w3_org_1999_xhtml[@js "http://www.w3.org/1999/xhtml"]] [@js.enum]) -> qualifiedName:string -> HTMLElement.t [@@js.call "createElementNS"]
  
  (**
    Returns an element with namespace namespace. Its namespace prefix will be everything before ":" (U+003E) in qualifiedName or null. Its local name will be everything after ":" (U+003E) in qualifiedName or qualifiedName.
    
    If localName does not match the Name production an "InvalidCharacterError" DOMException will be thrown.
    
    If one of the following conditions is true a "NamespaceError" DOMException will be thrown:
    
    localName does not match the QName production.
    Namespace prefix is not null and namespace is the empty string.
    Namespace prefix is "xml" and namespace is not the XML namespace.
    qualifiedName or namespace prefix is "xmlns" and namespace is not the XMLNS namespace.
    namespace is the XMLNS namespace and neither qualifiedName nor namespace prefix is "xmlns".
    
    When supplied, options's is can be used to create a customized built-in element.
  *)
  val createElementNS': 'tags this -> namespaceURI:([`L_s404_http___www_w3_org_2000_svg[@js "http://www.w3.org/2000/svg"]] [@js.enum]) -> qualifiedName:'K -> (* FIXME: unknown type 'SVGElementTagNameMap[K]' *)any [@@js.call "createElementNS"]
  
  (**
    Returns an element with namespace namespace. Its namespace prefix will be everything before ":" (U+003E) in qualifiedName or null. Its local name will be everything after ":" (U+003E) in qualifiedName or qualifiedName.
    
    If localName does not match the Name production an "InvalidCharacterError" DOMException will be thrown.
    
    If one of the following conditions is true a "NamespaceError" DOMException will be thrown:
    
    localName does not match the QName production.
    Namespace prefix is not null and namespace is the empty string.
    Namespace prefix is "xml" and namespace is not the XML namespace.
    qualifiedName or namespace prefix is "xmlns" and namespace is not the XMLNS namespace.
    namespace is the XMLNS namespace and neither qualifiedName nor namespace prefix is "xmlns".
    
    When supplied, options's is can be used to create a customized built-in element.
  *)
  val createElementNS'': 'tags this -> namespaceURI:([`L_s404_http___www_w3_org_2000_svg[@js "http://www.w3.org/2000/svg"]] [@js.enum]) -> qualifiedName:string -> SVGElement.t [@@js.call "createElementNS"]
  
  (**
    Returns an element with namespace namespace. Its namespace prefix will be everything before ":" (U+003E) in qualifiedName or null. Its local name will be everything after ":" (U+003E) in qualifiedName or qualifiedName.
    
    If localName does not match the Name production an "InvalidCharacterError" DOMException will be thrown.
    
    If one of the following conditions is true a "NamespaceError" DOMException will be thrown:
    
    localName does not match the QName production.
    Namespace prefix is not null and namespace is the empty string.
    Namespace prefix is "xml" and namespace is not the XML namespace.
    qualifiedName or namespace prefix is "xmlns" and namespace is not the XMLNS namespace.
    namespace is the XMLNS namespace and neither qualifiedName nor namespace prefix is "xmlns".
    
    When supplied, options's is can be used to create a customized built-in element.
  *)
  val createElementNS''': 'tags this -> namespaceURI:string option -> qualifiedName:string -> ?options:ElementCreationOptions.t -> unit -> Element.t [@@js.call "createElementNS"]
  
  (**
    Returns an element with namespace namespace. Its namespace prefix will be everything before ":" (U+003E) in qualifiedName or null. Its local name will be everything after ":" (U+003E) in qualifiedName or qualifiedName.
    
    If localName does not match the Name production an "InvalidCharacterError" DOMException will be thrown.
    
    If one of the following conditions is true a "NamespaceError" DOMException will be thrown:
    
    localName does not match the QName production.
    Namespace prefix is not null and namespace is the empty string.
    Namespace prefix is "xml" and namespace is not the XML namespace.
    qualifiedName or namespace prefix is "xmlns" and namespace is not the XMLNS namespace.
    namespace is the XMLNS namespace and neither qualifiedName nor namespace prefix is "xmlns".
    
    When supplied, options's is can be used to create a customized built-in element.
  *)
  val createElementNS'''': 'tags this -> namespace:string option -> qualifiedName:string -> ?options:([`U1 of string | `U2 of ElementCreationOptions.t] [@js.union]) -> unit -> Element.t [@@js.call "createElementNS"]
  val createEvent: 'tags this -> eventInterface:([`L_s5_AnimationEvent[@js "AnimationEvent"]] [@js.enum]) -> AnimationEvent.t [@@js.call "createEvent"]
  val createEvent': 'tags this -> eventInterface:([`L_s6_AnimationPlaybackEvent[@js "AnimationPlaybackEvent"]] [@js.enum]) -> AnimationPlaybackEvent.t [@@js.call "createEvent"]
  val createEvent'': 'tags this -> eventInterface:([`L_s7_AudioProcessingEvent[@js "AudioProcessingEvent"]] [@js.enum]) -> AudioProcessingEvent.t [@@js.call "createEvent"]
  val createEvent''': 'tags this -> eventInterface:([`L_s8_BeforeUnloadEvent[@js "BeforeUnloadEvent"]] [@js.enum]) -> BeforeUnloadEvent.t [@@js.call "createEvent"]
  val createEvent'''': 'tags this -> eventInterface:([`L_s9_BlobEvent[@js "BlobEvent"]] [@js.enum]) -> BlobEvent.t [@@js.call "createEvent"]
  val createEvent''''': 'tags this -> eventInterface:([`L_s10_ClipboardEvent[@js "ClipboardEvent"]] [@js.enum]) -> ClipboardEvent.t [@@js.call "createEvent"]
  val createEvent'''''': 'tags this -> eventInterface:([`L_s11_CloseEvent[@js "CloseEvent"]] [@js.enum]) -> CloseEvent.t [@@js.call "createEvent"]
  val createEvent''''''': 'tags this -> eventInterface:([`L_s12_CompositionEvent[@js "CompositionEvent"]] [@js.enum]) -> CompositionEvent.t [@@js.call "createEvent"]
  val createEvent'''''''': 'tags this -> eventInterface:([`L_s13_CustomEvent[@js "CustomEvent"]] [@js.enum]) -> CustomEvent.t_0 [@@js.call "createEvent"]
  val createEvent''''''''': 'tags this -> eventInterface:([`L_s14_DeviceMotionEvent[@js "DeviceMotionEvent"]] [@js.enum]) -> DeviceMotionEvent.t [@@js.call "createEvent"]
  val createEvent'''''''''': 'tags this -> eventInterface:([`L_s15_DeviceOrientationEvent[@js "DeviceOrientationEvent"]] [@js.enum]) -> DeviceOrientationEvent.t [@@js.call "createEvent"]
  val createEvent''''''''''': 'tags this -> eventInterface:([`L_s16_DragEvent[@js "DragEvent"]] [@js.enum]) -> DragEvent.t [@@js.call "createEvent"]
  val createEvent'''''''''''': 'tags this -> eventInterface:([`L_s25_ErrorEvent[@js "ErrorEvent"]] [@js.enum]) -> ErrorEvent.t [@@js.call "createEvent"]
  val createEvent''''''''''''': 'tags this -> eventInterface:([`L_s26_FocusEvent[@js "FocusEvent"]] [@js.enum]) -> FocusEvent.t [@@js.call "createEvent"]
  val createEvent'''''''''''''': 'tags this -> eventInterface:([`L_s27_FontFaceSetLoadEvent[@js "FontFaceSetLoadEvent"]] [@js.enum]) -> FontFaceSetLoadEvent.t [@@js.call "createEvent"]
  val createEvent''''''''''''''': 'tags this -> eventInterface:([`L_s28_FormDataEvent[@js "FormDataEvent"]] [@js.enum]) -> FormDataEvent.t [@@js.call "createEvent"]
  val createEvent'''''''''''''''': 'tags this -> eventInterface:([`L_s29_GamepadEvent[@js "GamepadEvent"]] [@js.enum]) -> GamepadEvent.t [@@js.call "createEvent"]
  val createEvent''''''''''''''''': 'tags this -> eventInterface:([`L_s31_HashChangeEvent[@js "HashChangeEvent"]] [@js.enum]) -> HashChangeEvent.t [@@js.call "createEvent"]
  val createEvent'''''''''''''''''': 'tags this -> eventInterface:([`L_s32_IDBVersionChangeEvent[@js "IDBVersionChangeEvent"]] [@js.enum]) -> IDBVersionChangeEvent.t [@@js.call "createEvent"]
  val createEvent''''''''''''''''''': 'tags this -> eventInterface:([`L_s33_InputEvent[@js "InputEvent"]] [@js.enum]) -> InputEvent.t [@@js.call "createEvent"]
  val createEvent'''''''''''''''''''': 'tags this -> eventInterface:([`L_s35_KeyboardEvent[@js "KeyboardEvent"]] [@js.enum]) -> KeyboardEvent.t [@@js.call "createEvent"]
  val createEvent''''''''''''''''''''': 'tags this -> eventInterface:([`L_s36_MediaEncryptedEvent[@js "MediaEncryptedEvent"]] [@js.enum]) -> MediaEncryptedEvent.t [@@js.call "createEvent"]
  val createEvent'''''''''''''''''''''': 'tags this -> eventInterface:([`L_s37_MediaKeyMessageEvent[@js "MediaKeyMessageEvent"]] [@js.enum]) -> MediaKeyMessageEvent.t [@@js.call "createEvent"]
  val createEvent''''''''''''''''''''''': 'tags this -> eventInterface:([`L_s38_MediaQueryListEvent[@js "MediaQueryListEvent"]] [@js.enum]) -> MediaQueryListEvent.t [@@js.call "createEvent"]
  val createEvent'''''''''''''''''''''''': 'tags this -> eventInterface:([`L_s39_MediaRecorderErrorEvent[@js "MediaRecorderErrorEvent"]] [@js.enum]) -> MediaRecorderErrorEvent.t [@@js.call "createEvent"]
  val createEvent''''''''''''''''''''''''': 'tags this -> eventInterface:([`L_s40_MediaStreamTrackEvent[@js "MediaStreamTrackEvent"]] [@js.enum]) -> MediaStreamTrackEvent.t [@@js.call "createEvent"]
  val createEvent'''''''''''''''''''''''''': 'tags this -> eventInterface:([`L_s41_MessageEvent[@js "MessageEvent"]] [@js.enum]) -> MessageEvent.t_0 [@@js.call "createEvent"]
  val createEvent''''''''''''''''''''''''''': 'tags this -> eventInterface:([`L_s42_MouseEvent[@js "MouseEvent"]] [@js.enum]) -> MouseEvent.t [@@js.call "createEvent"]
  val createEvent'''''''''''''''''''''''''''': 'tags this -> eventInterface:([`L_s43_MouseEvents[@js "MouseEvents"]] [@js.enum]) -> MouseEvent.t [@@js.call "createEvent"]
  val createEvent''''''''''''''''''''''''''''': 'tags this -> eventInterface:([`L_s44_MutationEvent[@js "MutationEvent"]] [@js.enum]) -> MutationEvent.t [@@js.call "createEvent"]
  val createEvent'''''''''''''''''''''''''''''': 'tags this -> eventInterface:([`L_s45_MutationEvents[@js "MutationEvents"]] [@js.enum]) -> MutationEvent.t [@@js.call "createEvent"]
  val createEvent''''''''''''''''''''''''''''''': 'tags this -> eventInterface:([`L_s54_OfflineAudioCompletionEvent[@js "OfflineAudioCompletionEvent"]] [@js.enum]) -> OfflineAudioCompletionEvent.t [@@js.call "createEvent"]
  val createEvent'''''''''''''''''''''''''''''''': 'tags this -> eventInterface:([`L_s55_PageTransitionEvent[@js "PageTransitionEvent"]] [@js.enum]) -> PageTransitionEvent.t [@@js.call "createEvent"]
  val createEvent''''''''''''''''''''''''''''''''': 'tags this -> eventInterface:([`L_s56_PaymentMethodChangeEvent[@js "PaymentMethodChangeEvent"]] [@js.enum]) -> PaymentMethodChangeEvent.t [@@js.call "createEvent"]
  val createEvent'''''''''''''''''''''''''''''''''': 'tags this -> eventInterface:([`L_s57_PaymentRequestUpdateEvent[@js "PaymentRequestUpdateEvent"]] [@js.enum]) -> PaymentRequestUpdateEvent.t [@@js.call "createEvent"]
  val createEvent''''''''''''''''''''''''''''''''''': 'tags this -> eventInterface:([`L_s58_PointerEvent[@js "PointerEvent"]] [@js.enum]) -> PointerEvent.t [@@js.call "createEvent"]
  val createEvent'''''''''''''''''''''''''''''''''''': 'tags this -> eventInterface:([`L_s59_PopStateEvent[@js "PopStateEvent"]] [@js.enum]) -> PopStateEvent.t [@@js.call "createEvent"]
  val createEvent''''''''''''''''''''''''''''''''''''': 'tags this -> eventInterface:([`L_s60_ProgressEvent[@js "ProgressEvent"]] [@js.enum]) -> ProgressEvent.t_0 [@@js.call "createEvent"]
  val createEvent'''''''''''''''''''''''''''''''''''''': 'tags this -> eventInterface:([`L_s61_PromiseRejectionEvent[@js "PromiseRejectionEvent"]] [@js.enum]) -> PromiseRejectionEvent.t [@@js.call "createEvent"]
  val createEvent''''''''''''''''''''''''''''''''''''''': 'tags this -> eventInterface:([`L_s62_RTCDTMFToneChangeEvent[@js "RTCDTMFToneChangeEvent"]] [@js.enum]) -> RTCDTMFToneChangeEvent.t [@@js.call "createEvent"]
  val createEvent'''''''''''''''''''''''''''''''''''''''': 'tags this -> eventInterface:([`L_s63_RTCDataChannelEvent[@js "RTCDataChannelEvent"]] [@js.enum]) -> RTCDataChannelEvent.t [@@js.call "createEvent"]
  val createEvent''''''''''''''''''''''''''''''''''''''''': 'tags this -> eventInterface:([`L_s64_RTCPeerConnectionIceErrorEvent[@js "RTCPeerConnectionIceErrorEvent"]] [@js.enum]) -> RTCPeerConnectionIceErrorEvent.t [@@js.call "createEvent"]
  val createEvent'''''''''''''''''''''''''''''''''''''''''': 'tags this -> eventInterface:([`L_s65_RTCPeerConnectionIceEvent[@js "RTCPeerConnectionIceEvent"]] [@js.enum]) -> RTCPeerConnectionIceEvent.t [@@js.call "createEvent"]
  val createEvent''''''''''''''''''''''''''''''''''''''''''': 'tags this -> eventInterface:([`L_s66_RTCTrackEvent[@js "RTCTrackEvent"]] [@js.enum]) -> RTCTrackEvent.t [@@js.call "createEvent"]
  val createEvent'''''''''''''''''''''''''''''''''''''''''''': 'tags this -> eventInterface:([`L_s67_SecurityPolicyViolationEvent[@js "SecurityPolicyViolationEvent"]] [@js.enum]) -> SecurityPolicyViolationEvent.t [@@js.call "createEvent"]
  val createEvent''''''''''''''''''''''''''''''''''''''''''''': 'tags this -> eventInterface:([`L_s68_SpeechSynthesisErrorEvent[@js "SpeechSynthesisErrorEvent"]] [@js.enum]) -> SpeechSynthesisErrorEvent.t [@@js.call "createEvent"]
  val createEvent'''''''''''''''''''''''''''''''''''''''''''''': 'tags this -> eventInterface:([`L_s69_SpeechSynthesisEvent[@js "SpeechSynthesisEvent"]] [@js.enum]) -> SpeechSynthesisEvent.t [@@js.call "createEvent"]
  val createEvent''''''''''''''''''''''''''''''''''''''''''''''': 'tags this -> eventInterface:([`L_s70_StorageEvent[@js "StorageEvent"]] [@js.enum]) -> StorageEvent.t [@@js.call "createEvent"]
  val createEvent'''''''''''''''''''''''''''''''''''''''''''''''': 'tags this -> eventInterface:([`L_s71_SubmitEvent[@js "SubmitEvent"]] [@js.enum]) -> SubmitEvent.t [@@js.call "createEvent"]
  val createEvent''''''''''''''''''''''''''''''''''''''''''''''''': 'tags this -> eventInterface:([`L_s72_TouchEvent[@js "TouchEvent"]] [@js.enum]) -> TouchEvent.t [@@js.call "createEvent"]
  val createEvent'''''''''''''''''''''''''''''''''''''''''''''''''': 'tags this -> eventInterface:([`L_s73_TrackEvent[@js "TrackEvent"]] [@js.enum]) -> TrackEvent.t [@@js.call "createEvent"]
  val createEvent''''''''''''''''''''''''''''''''''''''''''''''''''': 'tags this -> eventInterface:([`L_s74_TransitionEvent[@js "TransitionEvent"]] [@js.enum]) -> TransitionEvent.t [@@js.call "createEvent"]
  val createEvent'''''''''''''''''''''''''''''''''''''''''''''''''''': 'tags this -> eventInterface:([`L_s75_UIEvent[@js "UIEvent"]] [@js.enum]) -> UIEvent.t [@@js.call "createEvent"]
  val createEvent''''''''''''''''''''''''''''''''''''''''''''''''''''': 'tags this -> eventInterface:([`L_s76_UIEvents[@js "UIEvents"]] [@js.enum]) -> UIEvent.t [@@js.call "createEvent"]
  val createEvent'''''''''''''''''''''''''''''''''''''''''''''''''''''': 'tags this -> eventInterface:([`L_s89_WebGLContextEvent[@js "WebGLContextEvent"]] [@js.enum]) -> WebGLContextEvent.t [@@js.call "createEvent"]
  val createEvent''''''''''''''''''''''''''''''''''''''''''''''''''''''': 'tags this -> eventInterface:([`L_s90_WheelEvent[@js "WheelEvent"]] [@js.enum]) -> WheelEvent.t [@@js.call "createEvent"]
  val createEvent'''''''''''''''''''''''''''''''''''''''''''''''''''''''': 'tags this -> eventInterface:string -> Event.t [@@js.call "createEvent"]
  
  (**
    Creates a NodeIterator object that you can use to traverse filtered lists of nodes or elements in a document.
    @param root The root element or node to start traversing on.
    @param whatToShow The type of nodes or elements to appear in the node list
    @param filter A custom NodeFilter function to use. For more information, see filter. Use null for no filter.
  *)
  val createNodeIterator: 'tags this -> root:Node.t -> ?whatToShow:float -> ?filter:NodeFilter.t option -> unit -> NodeIterator.t [@@js.call "createNodeIterator"]
  
  (** Returns a ProcessingInstruction node whose target is target and data is data. If target does not match the Name production an "InvalidCharacterError" DOMException will be thrown. If data contains "?>" an "InvalidCharacterError" DOMException will be thrown. *)
  val createProcessingInstruction: 'tags this -> target:string -> data:string -> ProcessingInstruction.t [@@js.call "createProcessingInstruction"]
  
  (** Returns an empty range object that has both of its boundary points positioned at the beginning of the document. *)
  val createRange: 'tags this -> Range.t [@@js.call "createRange"]
  
  (**
    Creates a text string from the specified value.
    @param data String that specifies the nodeValue property of the text node.
  *)
  val createTextNode: 'tags this -> data:string -> Text.t [@@js.call "createTextNode"]
  
  (**
    Creates a TreeWalker object that you can use to traverse filtered lists of nodes or elements in a document.
    @param root The root element or node to start traversing on.
    @param whatToShow The type of nodes or elements to appear in the node list. For more information, see whatToShow.
    @param filter A custom NodeFilter function to use.
  *)
  val createTreeWalker: 'tags this -> root:Node.t -> ?whatToShow:float -> ?filter:NodeFilter.t option -> unit -> TreeWalker.t [@@js.call "createTreeWalker"]
  
  (**
    Executes a command on the current document, current selection, or the given range.
    @param commandId String that specifies the command to execute. This command can be any of the command identifiers that can be executed in script.
    @param showUI Display the user interface, defaults to false.
    @param value Value to assign.
    @deprecated 
  *)
  val execCommand: 'tags this -> commandId:string -> ?showUI:bool -> ?value:string -> unit -> bool [@@js.call "execCommand"]
  
  (** Stops document's fullscreen element from being displayed fullscreen and resolves promise when done. *)
  val exitFullscreen: 'tags this -> unit Promise.t_1 [@@js.call "exitFullscreen"]
  val exitPictureInPicture: 'tags this -> unit Promise.t_1 [@@js.call "exitPictureInPicture"]
  val exitPointerLock: 'tags this -> unit [@@js.call "exitPointerLock"]
  
  (**
    Returns a reference to the first object with the specified value of the ID attribute.
    @param elementId String that specifies the ID value.
  *)
  val getElementById: 'tags this -> elementId:string -> HTMLElement.t option [@@js.call "getElementById"]
  
  (** Returns a HTMLCollection of the elements in the object on which the method was invoked (a document or an element) that have all the classes given by classNames. The classNames argument is interpreted as a space-separated list of classes. *)
  val getElementsByClassName: 'tags this -> classNames:string -> Element.t HTMLCollectionOf.t [@@js.call "getElementsByClassName"]
  
  (**
    Gets a collection of objects based on the value of the NAME or ID attribute.
    @param elementName Gets a collection of objects based on the value of the NAME or ID attribute.
  *)
  val getElementsByName: 'tags this -> elementName:string -> HTMLElement.t NodeListOf.t [@@js.call "getElementsByName"]
  
  (**
    Retrieves a collection of objects based on the specified element name.
    @param name Specifies the name of an element.
  *)
  val getElementsByTagName: 'tags this -> qualifiedName:'K -> (* FIXME: unknown type 'HTMLElementTagNameMap[K]' *)any HTMLCollectionOf.t [@@js.call "getElementsByTagName"]
  
  (** Retrieves a collection of objects based on the specified element name. *)
  val getElementsByTagName': 'tags this -> qualifiedName:'K -> (* FIXME: unknown type 'SVGElementTagNameMap[K]' *)any HTMLCollectionOf.t [@@js.call "getElementsByTagName"]
  
  (** Retrieves a collection of objects based on the specified element name. *)
  val getElementsByTagName'': 'tags this -> qualifiedName:string -> Element.t HTMLCollectionOf.t [@@js.call "getElementsByTagName"]
  
  (**
    If namespace and localName are "*" returns a HTMLCollection of all descendant elements.
    
    If only namespace is "*" returns a HTMLCollection of all descendant elements whose local name is localName.
    
    If only localName is "*" returns a HTMLCollection of all descendant elements whose namespace is namespace.
    
    Otherwise, returns a HTMLCollection of all descendant elements whose namespace is namespace and local name is localName.
  *)
  val getElementsByTagNameNS: 'tags this -> namespaceURI:([`L_s403_http___www_w3_org_1999_xhtml[@js "http://www.w3.org/1999/xhtml"]] [@js.enum]) -> localName:string -> HTMLElement.t HTMLCollectionOf.t [@@js.call "getElementsByTagNameNS"]
  
  (**
    If namespace and localName are "*" returns a HTMLCollection of all descendant elements.
    
    If only namespace is "*" returns a HTMLCollection of all descendant elements whose local name is localName.
    
    If only localName is "*" returns a HTMLCollection of all descendant elements whose namespace is namespace.
    
    Otherwise, returns a HTMLCollection of all descendant elements whose namespace is namespace and local name is localName.
  *)
  val getElementsByTagNameNS': 'tags this -> namespaceURI:([`L_s404_http___www_w3_org_2000_svg[@js "http://www.w3.org/2000/svg"]] [@js.enum]) -> localName:string -> SVGElement.t HTMLCollectionOf.t [@@js.call "getElementsByTagNameNS"]
  
  (**
    If namespace and localName are "*" returns a HTMLCollection of all descendant elements.
    
    If only namespace is "*" returns a HTMLCollection of all descendant elements whose local name is localName.
    
    If only localName is "*" returns a HTMLCollection of all descendant elements whose namespace is namespace.
    
    Otherwise, returns a HTMLCollection of all descendant elements whose namespace is namespace and local name is localName.
  *)
  val getElementsByTagNameNS'': 'tags this -> namespace:string option -> localName:string -> Element.t HTMLCollectionOf.t [@@js.call "getElementsByTagNameNS"]
  
  (** Returns an object representing the current selection of the document that is loaded into the object displaying a webpage. *)
  val getSelection: 'tags this -> Selection.t option [@@js.call "getSelection"]
  
  (** Gets a value indicating whether the object currently has focus. *)
  val hasFocus: 'tags this -> bool [@@js.call "hasFocus"]
  val hasStorageAccess: 'tags this -> bool Promise.t_1 [@@js.call "hasStorageAccess"]
  
  (**
    Returns a copy of node. If deep is true, the copy also includes the node's descendants.
    
    If node is a document or a shadow root, throws a "NotSupportedError" DOMException.
  *)
  val importNode: 'tags this -> node:'T -> ?deep:bool -> unit -> 'T [@@js.call "importNode"]
  
  (**
    Opens a new window and loads a document specified by a given URL. Also, opens a new window that uses the url parameter and the name parameter to collect the output of the write method and the writeln method.
    @param url Specifies a MIME type for the document.
    @param name Specifies the name of the window. This name is used as the value for the TARGET attribute on a form or an anchor element.
    @param features Contains a list of items separated by commas. Each item consists of an option and a value, separated by an equals sign (for example, "fullscreen=yes, toolbar=yes"). The following values are supported.
    @param replace Specifies whether the existing entry for the document is replaced in the history list.
  *)
  val open_: 'tags this -> ?unused1:string -> ?unused2:string -> unit -> t [@@js.call "open"]
  
  (** Opens a new window and loads a document specified by a given URL. Also, opens a new window that uses the url parameter and the name parameter to collect the output of the write method and the writeln method. *)
  val open_': 'tags this -> url:([`U1 of string | `U2 of URL.t] [@js.union]) -> name:string -> features:string -> WindowProxy.t option [@@js.call "open"]
  
  (**
    Returns a Boolean value that indicates whether a specified command can be successfully executed using execCommand, given the current state of the document.
    @param commandId Specifies a command identifier.
    @deprecated 
  *)
  val queryCommandEnabled: 'tags this -> commandId:string -> bool [@@js.call "queryCommandEnabled"]
  
  (**
    Returns a Boolean value that indicates whether the specified command is in the indeterminate state.
    @param commandId String that specifies a command identifier.
  *)
  val queryCommandIndeterm: 'tags this -> commandId:string -> bool [@@js.call "queryCommandIndeterm"]
  
  (**
    Returns a Boolean value that indicates the current state of the command.
    @param commandId String that specifies a command identifier.
    @deprecated 
  *)
  val queryCommandState: 'tags this -> commandId:string -> bool [@@js.call "queryCommandState"]
  
  (**
    Returns a Boolean value that indicates whether the current command is supported on the current range.
    @param commandId Specifies a command identifier.
    @deprecated 
  *)
  val queryCommandSupported: 'tags this -> commandId:string -> bool [@@js.call "queryCommandSupported"]
  
  (**
    Returns the current value of the document, range, or current selection for the given command.
    @param commandId String that specifies a command identifier.
  *)
  val queryCommandValue: 'tags this -> commandId:string -> string [@@js.call "queryCommandValue"]
  
  (** @deprecated  *)
  val releaseEvents: 'tags this -> unit [@@js.call "releaseEvents"]
  val requestStorageAccess: 'tags this -> unit Promise.t_1 [@@js.call "requestStorageAccess"]
  
  (**
    Writes one or more HTML expressions to a document in the specified window.
    @param content Specifies the text and HTML tags to write.
  *)
  val write: 'tags this -> text:(string list [@js.variadic]) -> unit [@@js.call "write"]
  
  (**
    Writes one or more HTML expressions, followed by a carriage return, to a document in the specified window.
    @param content The text and HTML tags to write.
  *)
  val writeln: 'tags this -> text:(string list [@js.variadic]) -> unit [@@js.call "writeln"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'DocumentEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'DocumentEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
and DocumentAndElementEventHandlers : sig
  type t = [`DocumentAndElementEventHandlers] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`DocumentAndElementEventHandlers]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`DocumentAndElementEventHandlers]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `DocumentAndElementEventHandlers ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_oncopy: 'tags this -> (this:t -> ev:ClipboardEvent.t -> any) option [@@js.get "oncopy"]
  val set_oncopy: 'tags this -> (this:t -> ev:ClipboardEvent.t -> any) option -> unit [@@js.set "oncopy"]
  val get_oncut: 'tags this -> (this:t -> ev:ClipboardEvent.t -> any) option [@@js.get "oncut"]
  val set_oncut: 'tags this -> (this:t -> ev:ClipboardEvent.t -> any) option -> unit [@@js.set "oncut"]
  val get_onpaste: 'tags this -> (this:t -> ev:ClipboardEvent.t -> any) option [@@js.get "onpaste"]
  val set_onpaste: 'tags this -> (this:t -> ev:ClipboardEvent.t -> any) option -> unit [@@js.set "onpaste"]
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'DocumentAndElementEventHandlersEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'DocumentAndElementEventHandlersEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** A minimal document object that has no parent. It is used as a lightweight version of Document that stores a segment of a document structure comprised of nodes just like a standard document. The key difference is that because the document fragment isn't part of the active document tree structure, changes made to the fragment don't affect the document, cause reflow, or incur any performance impact that can occur when changes are made. *)
and[@js.scope "DocumentFragment"] DocumentFragment : sig
  type t = [`DocumentFragment | `EventTarget | `Node | `NonElementParentNode | `ParentNode] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`DocumentFragment | `EventTarget | `Node | `NonElementParentNode | `ParentNode]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`DocumentFragment | `EventTarget | `Node | `NonElementParentNode | `ParentNode]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `DocumentFragment ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Returns the node document. Returns null for documents. *)
  val get_ownerDocument: 'tags this -> Document.t [@@js.get "ownerDocument"]
  
  (** Returns the first element within node's descendants whose ID is elementId. *)
  val getElementById: 'tags this -> elementId:string -> HTMLElement.t option [@@js.call "getElementById"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
and DocumentOrShadowRoot : sig
  type t = [`DocumentOrShadowRoot] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`DocumentOrShadowRoot]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`DocumentOrShadowRoot]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `DocumentOrShadowRoot ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    Returns the deepest element in the document through which or to which key events are being routed. This is, roughly speaking, the focused element in the document.
    
    For the purposes of this API, when a child browsing context is focused, its container is focused in the parent browsing context. For example, if the user moves the focus to a text control in an iframe, the iframe is the element returned by the activeElement API in the iframe's node document.
    
    Similarly, when the focused element is in a different node tree than documentOrShadowRoot, the element returned will be the host that's located in the same node tree as documentOrShadowRoot if documentOrShadowRoot is a shadow-including inclusive ancestor of the focused element, and null if not.
  *)
  val get_activeElement: 'tags this -> Element.t option [@@js.get "activeElement"]
  
  (** Returns document's fullscreen element. *)
  val get_fullscreenElement: 'tags this -> Element.t option [@@js.get "fullscreenElement"]
  val get_pictureInPictureElement: 'tags this -> Element.t option [@@js.get "pictureInPictureElement"]
  val get_pointerLockElement: 'tags this -> Element.t option [@@js.get "pointerLockElement"]
  
  (** Retrieves a collection of styleSheet objects representing the style sheets that correspond to each instance of a link or style object in the document. *)
  val get_styleSheets: 'tags this -> StyleSheetList.t [@@js.get "styleSheets"]
  
  (**
    Returns the element for the specified x coordinate and the specified y coordinate.
    @param x The x-offset
    @param y The y-offset
  *)
  val elementFromPoint: 'tags this -> x:float -> y:float -> Element.t option [@@js.call "elementFromPoint"]
  val elementsFromPoint: 'tags this -> x:float -> y:float -> Element.t list [@@js.call "elementsFromPoint"]
  val getAnimations: 'tags this -> Animation.t list [@@js.call "getAnimations"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** A Node containing a doctype. *)
and[@js.scope "DocumentType"] DocumentType : sig
  type t = [`ChildNode | `DocumentType | `EventTarget | `Node] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ChildNode | `DocumentType | `EventTarget | `Node]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ChildNode | `DocumentType | `EventTarget | `Node]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `DocumentType ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_name: 'tags this -> string [@@js.get "name"]
  
  (** Returns the node document. Returns null for documents. *)
  val get_ownerDocument: 'tags this -> Document.t [@@js.get "ownerDocument"]
  val get_publicId: 'tags this -> string [@@js.get "publicId"]
  val get_systemId: 'tags this -> string [@@js.get "systemId"]
  val create: name:string -> ownerDocument:Document.t -> publicId:string -> systemId:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end

(** A DOM event that represents a drag and drop interaction. The user initiates a drag by placing a pointer device (such as a mouse) on the touch surface and then dragging the pointer to a new location (such as another DOM element). Applications are free to interpret a drag and drop interaction in an application-specific way. *)
and[@js.scope "DragEvent"] DragEvent : sig
  type t = [`DragEvent | `Event | `MouseEvent | `UIEvent] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`DragEvent | `Event | `MouseEvent | `UIEvent]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`DragEvent | `Event | `MouseEvent | `UIEvent]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `DragEvent ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Returns the DataTransfer object for the event. *)
  val get_dataTransfer: 'tags this -> DataTransfer.t option [@@js.get "dataTransfer"]
  val create: ?dataTransfer:DataTransfer.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': type_:string -> ?eventInitDict:DragEventInit.t -> unit -> t [@@js.create]
end
and DragEventInit : sig
  type t = [`DragEventInit | `EventInit | `EventModifierInit | `MouseEventInit | `UIEventInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`DragEventInit | `EventInit | `EventModifierInit | `MouseEventInit | `UIEventInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`DragEventInit | `EventInit | `EventModifierInit | `MouseEventInit | `UIEventInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `DragEventInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_dataTransfer: 'tags this -> DataTransfer.t option option [@@js.get "dataTransfer"]
  val set_dataTransfer: 'tags this -> DataTransfer.t option -> unit [@@js.set "dataTransfer"]
  val create: ?dataTransfer:DataTransfer.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** Element is the most general base class from which all objects in a Document inherit. It only has methods and properties common to all kinds of elements. More specific classes inherit from Element. *)
and[@js.scope "Element"] Element : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `Element | `EventTarget | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `Element | `EventTarget | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `Element | `EventTarget | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `Element ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_attributes: 'tags this -> NamedNodeMap.t [@@js.get "attributes"]
  
  (** Allows for manipulation of element's class content attribute as a set of whitespace-separated tokens through a DOMTokenList object. *)
  val get_classList: 'tags this -> DOMTokenList.t [@@js.get "classList"]
  
  (** Returns the value of element's class content attribute. Can be set to change it. *)
  val get_className: 'tags this -> string [@@js.get "className"]
  
  (** Returns the value of element's class content attribute. Can be set to change it. *)
  val set_className: 'tags this -> string -> unit [@@js.set "className"]
  val get_clientHeight: 'tags this -> float [@@js.get "clientHeight"]
  val get_clientLeft: 'tags this -> float [@@js.get "clientLeft"]
  val get_clientTop: 'tags this -> float [@@js.get "clientTop"]
  val get_clientWidth: 'tags this -> float [@@js.get "clientWidth"]
  
  (** Returns the value of element's id content attribute. Can be set to change it. *)
  val get_id: 'tags this -> string [@@js.get "id"]
  
  (** Returns the value of element's id content attribute. Can be set to change it. *)
  val set_id: 'tags this -> string -> unit [@@js.set "id"]
  
  (** Returns the local name. *)
  val get_localName: 'tags this -> string [@@js.get "localName"]
  
  (** Returns the namespace. *)
  val get_namespaceURI: 'tags this -> string option [@@js.get "namespaceURI"]
  val get_onfullscreenchange: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onfullscreenchange"]
  val set_onfullscreenchange: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onfullscreenchange"]
  val get_onfullscreenerror: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onfullscreenerror"]
  val set_onfullscreenerror: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onfullscreenerror"]
  val get_outerHTML: 'tags this -> string [@@js.get "outerHTML"]
  val set_outerHTML: 'tags this -> string -> unit [@@js.set "outerHTML"]
  
  (** Returns the node document. Returns null for documents. *)
  val get_ownerDocument: 'tags this -> Document.t [@@js.get "ownerDocument"]
  val get_part: 'tags this -> DOMTokenList.t [@@js.get "part"]
  
  (** Returns the namespace prefix. *)
  val get_prefix: 'tags this -> string option [@@js.get "prefix"]
  val get_scrollHeight: 'tags this -> float [@@js.get "scrollHeight"]
  val get_scrollLeft: 'tags this -> float [@@js.get "scrollLeft"]
  val set_scrollLeft: 'tags this -> float -> unit [@@js.set "scrollLeft"]
  val get_scrollTop: 'tags this -> float [@@js.get "scrollTop"]
  val set_scrollTop: 'tags this -> float -> unit [@@js.set "scrollTop"]
  val get_scrollWidth: 'tags this -> float [@@js.get "scrollWidth"]
  
  (** Returns element's shadow root, if any, and if shadow root's mode is "open", and null otherwise. *)
  val get_shadowRoot: 'tags this -> ShadowRoot.t option [@@js.get "shadowRoot"]
  
  (** Returns the value of element's slot content attribute. Can be set to change it. *)
  val get_slot: 'tags this -> string [@@js.get "slot"]
  
  (** Returns the value of element's slot content attribute. Can be set to change it. *)
  val set_slot: 'tags this -> string -> unit [@@js.set "slot"]
  
  (** Returns the HTML-uppercased qualified name. *)
  val get_tagName: 'tags this -> string [@@js.get "tagName"]
  
  (** Creates a shadow root for element and returns it. *)
  val attachShadow: 'tags this -> init:ShadowRootInit.t -> ShadowRoot.t [@@js.call "attachShadow"]
  
  (** Returns the first (starting at element) inclusive ancestor that matches selectors, and null otherwise. *)
  val closest: 'tags this -> selector:'K -> (* FIXME: unknown type 'HTMLElementTagNameMap[K]' *)any option [@@js.call "closest"]
  
  (** Returns the first (starting at element) inclusive ancestor that matches selectors, and null otherwise. *)
  val closest': 'tags this -> selector:'K -> (* FIXME: unknown type 'SVGElementTagNameMap[K]' *)any option [@@js.call "closest"]
  
  (** Returns the first (starting at element) inclusive ancestor that matches selectors, and null otherwise. *)
  val closest'': 'tags this -> selectors:string -> 'E option [@@js.call "closest"]
  
  (** Returns element's first attribute whose qualified name is qualifiedName, and null if there is no such attribute otherwise. *)
  val getAttribute: 'tags this -> qualifiedName:string -> string option [@@js.call "getAttribute"]
  
  (** Returns element's attribute whose namespace is namespace and local name is localName, and null if there is no such attribute otherwise. *)
  val getAttributeNS: 'tags this -> namespace:string option -> localName:string -> string option [@@js.call "getAttributeNS"]
  
  (** Returns the qualified names of all element's attributes. Can contain duplicates. *)
  val getAttributeNames: 'tags this -> string list [@@js.call "getAttributeNames"]
  val getAttributeNode: 'tags this -> qualifiedName:string -> Attr.t option [@@js.call "getAttributeNode"]
  val getAttributeNodeNS: 'tags this -> namespace:string option -> localName:string -> Attr.t option [@@js.call "getAttributeNodeNS"]
  val getBoundingClientRect: 'tags this -> DOMRect.t [@@js.call "getBoundingClientRect"]
  val getClientRects: 'tags this -> DOMRectList.t [@@js.call "getClientRects"]
  
  (** Returns a HTMLCollection of the elements in the object on which the method was invoked (a document or an element) that have all the classes given by classNames. The classNames argument is interpreted as a space-separated list of classes. *)
  val getElementsByClassName: 'tags this -> classNames:string -> t HTMLCollectionOf.t [@@js.call "getElementsByClassName"]
  val getElementsByTagName: 'tags this -> qualifiedName:'K -> (* FIXME: unknown type 'HTMLElementTagNameMap[K]' *)any HTMLCollectionOf.t [@@js.call "getElementsByTagName"]
  val getElementsByTagName': 'tags this -> qualifiedName:'K -> (* FIXME: unknown type 'SVGElementTagNameMap[K]' *)any HTMLCollectionOf.t [@@js.call "getElementsByTagName"]
  val getElementsByTagName'': 'tags this -> qualifiedName:string -> t HTMLCollectionOf.t [@@js.call "getElementsByTagName"]
  val getElementsByTagNameNS: 'tags this -> namespaceURI:([`L_s403_http___www_w3_org_1999_xhtml[@js "http://www.w3.org/1999/xhtml"]] [@js.enum]) -> localName:string -> HTMLElement.t HTMLCollectionOf.t [@@js.call "getElementsByTagNameNS"]
  val getElementsByTagNameNS': 'tags this -> namespaceURI:([`L_s404_http___www_w3_org_2000_svg[@js "http://www.w3.org/2000/svg"]] [@js.enum]) -> localName:string -> SVGElement.t HTMLCollectionOf.t [@@js.call "getElementsByTagNameNS"]
  val getElementsByTagNameNS'': 'tags this -> namespace:string option -> localName:string -> t HTMLCollectionOf.t [@@js.call "getElementsByTagNameNS"]
  
  (** Returns true if element has an attribute whose qualified name is qualifiedName, and false otherwise. *)
  val hasAttribute: 'tags this -> qualifiedName:string -> bool [@@js.call "hasAttribute"]
  
  (** Returns true if element has an attribute whose namespace is namespace and local name is localName. *)
  val hasAttributeNS: 'tags this -> namespace:string option -> localName:string -> bool [@@js.call "hasAttributeNS"]
  
  (** Returns true if element has attributes, and false otherwise. *)
  val hasAttributes: 'tags this -> bool [@@js.call "hasAttributes"]
  val hasPointerCapture: 'tags this -> pointerId:float -> bool [@@js.call "hasPointerCapture"]
  val insertAdjacentElement: 'tags this -> where:InsertPosition.t -> element:t -> t option [@@js.call "insertAdjacentElement"]
  val insertAdjacentHTML: 'tags this -> position:InsertPosition.t -> text:string -> unit [@@js.call "insertAdjacentHTML"]
  val insertAdjacentText: 'tags this -> where:InsertPosition.t -> data:string -> unit [@@js.call "insertAdjacentText"]
  
  (** Returns true if matching selectors against element's root yields element, and false otherwise. *)
  val matches: 'tags this -> selectors:string -> bool [@@js.call "matches"]
  val releasePointerCapture: 'tags this -> pointerId:float -> unit [@@js.call "releasePointerCapture"]
  
  (** Removes element's first attribute whose qualified name is qualifiedName. *)
  val removeAttribute: 'tags this -> qualifiedName:string -> unit [@@js.call "removeAttribute"]
  
  (** Removes element's attribute whose namespace is namespace and local name is localName. *)
  val removeAttributeNS: 'tags this -> namespace:string option -> localName:string -> unit [@@js.call "removeAttributeNS"]
  val removeAttributeNode: 'tags this -> attr:Attr.t -> Attr.t [@@js.call "removeAttributeNode"]
  
  (**
    Displays element fullscreen and resolves promise when done.
    
    When supplied, options's navigationUI member indicates whether showing navigation UI while in fullscreen is preferred or not. If set to "show", navigation simplicity is preferred over screen space, and if set to "hide", more screen space is preferred. User agents are always free to honor user preference over the application's. The default value "auto" indicates no application preference.
  *)
  val requestFullscreen: 'tags this -> ?options:FullscreenOptions.t -> unit -> unit Promise.t_1 [@@js.call "requestFullscreen"]
  val requestPointerLock: 'tags this -> unit [@@js.call "requestPointerLock"]
  val scroll: 'tags this -> ?options:ScrollToOptions.t -> unit -> unit [@@js.call "scroll"]
  val scroll': 'tags this -> x:float -> y:float -> unit [@@js.call "scroll"]
  val scrollBy: 'tags this -> ?options:ScrollToOptions.t -> unit -> unit [@@js.call "scrollBy"]
  val scrollBy': 'tags this -> x:float -> y:float -> unit [@@js.call "scrollBy"]
  val scrollIntoView: 'tags this -> ?arg:([`U1 of bool | `U2 of ScrollIntoViewOptions.t] [@js.union]) -> unit -> unit [@@js.call "scrollIntoView"]
  val scrollTo: 'tags this -> ?options:ScrollToOptions.t -> unit -> unit [@@js.call "scrollTo"]
  val scrollTo': 'tags this -> x:float -> y:float -> unit [@@js.call "scrollTo"]
  
  (** Sets the value of element's first attribute whose qualified name is qualifiedName to value. *)
  val setAttribute: 'tags this -> qualifiedName:string -> value:string -> unit [@@js.call "setAttribute"]
  
  (** Sets the value of element's attribute whose namespace is namespace and local name is localName to value. *)
  val setAttributeNS: 'tags this -> namespace:string option -> qualifiedName:string -> value:string -> unit [@@js.call "setAttributeNS"]
  val setAttributeNode: 'tags this -> attr:Attr.t -> Attr.t option [@@js.call "setAttributeNode"]
  val setAttributeNodeNS: 'tags this -> attr:Attr.t -> Attr.t option [@@js.call "setAttributeNodeNS"]
  val setPointerCapture: 'tags this -> pointerId:float -> unit [@@js.call "setPointerCapture"]
  
  (**
    If force is not given, "toggles" qualifiedName, removing it if it is present and adding it if it is not present. If force is true, adds qualifiedName. If force is false, removes qualifiedName.
    
    Returns true if qualifiedName is now present, and false otherwise.
  *)
  val toggleAttribute: 'tags this -> qualifiedName:string -> ?force:bool -> unit -> bool [@@js.call "toggleAttribute"]
  
  (** @deprecated This is a legacy alias of `matches`. *)
  val webkitMatchesSelector: 'tags this -> selectors:string -> bool [@@js.call "webkitMatchesSelector"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'ElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'ElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
and ElementCSSInlineStyle : sig
  type t = [`ElementCSSInlineStyle] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ElementCSSInlineStyle]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ElementCSSInlineStyle]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ElementCSSInlineStyle ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_style: 'tags this -> CSSStyleDeclaration.t [@@js.get "style"]
  val create: style:CSSStyleDeclaration.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
and[@js.scope "ElementInternals"] ElementInternals : sig
  type t = [`ARIAMixin | `ElementInternals] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `ElementInternals]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `ElementInternals]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ElementInternals ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Returns the ShadowRoot for internals's target element, if the target element is a shadow host, or null otherwise. *)
  val get_shadowRoot: 'tags this -> ShadowRoot.t option [@@js.get "shadowRoot"]
  val create: ?shadowRoot:ShadowRoot.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end
and EventModifierInit : sig
  type t = [`EventInit | `EventModifierInit | `UIEventInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventInit | `EventModifierInit | `UIEventInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventInit | `EventModifierInit | `UIEventInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `EventModifierInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_altKey: 'tags this -> bool option [@@js.get "altKey"]
  val set_altKey: 'tags this -> bool -> unit [@@js.set "altKey"]
  val get_ctrlKey: 'tags this -> bool option [@@js.get "ctrlKey"]
  val set_ctrlKey: 'tags this -> bool -> unit [@@js.set "ctrlKey"]
  val get_metaKey: 'tags this -> bool option [@@js.get "metaKey"]
  val set_metaKey: 'tags this -> bool -> unit [@@js.set "metaKey"]
  val get_modifierAltGraph: 'tags this -> bool option [@@js.get "modifierAltGraph"]
  val set_modifierAltGraph: 'tags this -> bool -> unit [@@js.set "modifierAltGraph"]
  val get_modifierCapsLock: 'tags this -> bool option [@@js.get "modifierCapsLock"]
  val set_modifierCapsLock: 'tags this -> bool -> unit [@@js.set "modifierCapsLock"]
  val get_modifierFn: 'tags this -> bool option [@@js.get "modifierFn"]
  val set_modifierFn: 'tags this -> bool -> unit [@@js.set "modifierFn"]
  val get_modifierFnLock: 'tags this -> bool option [@@js.get "modifierFnLock"]
  val set_modifierFnLock: 'tags this -> bool -> unit [@@js.set "modifierFnLock"]
  val get_modifierHyper: 'tags this -> bool option [@@js.get "modifierHyper"]
  val set_modifierHyper: 'tags this -> bool -> unit [@@js.set "modifierHyper"]
  val get_modifierNumLock: 'tags this -> bool option [@@js.get "modifierNumLock"]
  val set_modifierNumLock: 'tags this -> bool -> unit [@@js.set "modifierNumLock"]
  val get_modifierScrollLock: 'tags this -> bool option [@@js.get "modifierScrollLock"]
  val set_modifierScrollLock: 'tags this -> bool -> unit [@@js.set "modifierScrollLock"]
  val get_modifierSuper: 'tags this -> bool option [@@js.get "modifierSuper"]
  val set_modifierSuper: 'tags this -> bool -> unit [@@js.set "modifierSuper"]
  val get_modifierSymbol: 'tags this -> bool option [@@js.get "modifierSymbol"]
  val set_modifierSymbol: 'tags this -> bool -> unit [@@js.set "modifierSymbol"]
  val get_modifierSymbolLock: 'tags this -> bool option [@@js.get "modifierSymbolLock"]
  val set_modifierSymbolLock: 'tags this -> bool -> unit [@@js.set "modifierSymbolLock"]
  val get_shiftKey: 'tags this -> bool option [@@js.get "shiftKey"]
  val set_shiftKey: 'tags this -> bool -> unit [@@js.set "shiftKey"]
  val create: ?altKey:bool -> ?ctrlKey:bool -> ?metaKey:bool -> ?modifierAltGraph:bool -> ?modifierCapsLock:bool -> ?modifierFn:bool -> ?modifierFnLock:bool -> ?modifierHyper:bool -> ?modifierNumLock:bool -> ?modifierScrollLock:bool -> ?modifierSuper:bool -> ?modifierSymbol:bool -> ?modifierSymbolLock:bool -> ?shiftKey:bool -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** Focus-related events like focus, blur, focusin, or focusout. *)
and[@js.scope "FocusEvent"] FocusEvent : sig
  type t = [`Event | `FocusEvent | `UIEvent] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Event | `FocusEvent | `UIEvent]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Event | `FocusEvent | `UIEvent]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `FocusEvent ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_relatedTarget: 'tags this -> EventTarget.t option [@@js.get "relatedTarget"]
  val create: ?relatedTarget:EventTarget.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': type_:string -> ?eventInitDict:FocusEventInit.t -> unit -> t [@@js.create]
end
and FocusEventInit : sig
  type t = [`EventInit | `FocusEventInit | `UIEventInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventInit | `FocusEventInit | `UIEventInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventInit | `FocusEventInit | `UIEventInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `FocusEventInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_relatedTarget: 'tags this -> EventTarget.t option option [@@js.get "relatedTarget"]
  val set_relatedTarget: 'tags this -> EventTarget.t option -> unit [@@js.set "relatedTarget"]
  val create: ?relatedTarget:EventTarget.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** Provides a way to easily construct a set of key/value pairs representing form fields and their values, which can then be easily sent using the XMLHttpRequest.send() method. It uses the same format a form would use if the encoding type were set to "multipart/form-data". *)
and[@js.scope "FormData"] FormData : sig
  type t = [`FormData | (string * FormDataEntryValue.t) IterableIterator.tags_1] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`FormData | (string * FormDataEntryValue.t) IterableIterator.tags_1]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`FormData | (string * FormDataEntryValue.t) IterableIterator.tags_1]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `FormData ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  (* [Symbol.iterator]: unit -> (string * FormDataEntryValue.t) IterableIterator.t_1 *)
  
  (** Returns an array of key, value pairs for every entry in the list. *)
  val entries: 'tags this -> (string * FormDataEntryValue.t) IterableIterator.t_1 [@@js.call "entries"]
  
  (** Returns a list of keys in the list. *)
  val keys: 'tags this -> string IterableIterator.t_1 [@@js.call "keys"]
  
  (** Returns a list of values in the list. *)
  val values: 'tags this -> FormDataEntryValue.t IterableIterator.t_1 [@@js.call "values"]
  val append: 'tags this -> name:string -> value:([`U1 of string | `U2 of Blob.t] [@js.union]) -> ?fileName:string -> unit -> unit [@@js.call "append"]
  val delete: 'tags this -> name:string -> unit [@@js.call "delete"]
  val get_: 'tags this -> name:string -> FormDataEntryValue.t option [@@js.call "get"]
  val getAll: 'tags this -> name:string -> FormDataEntryValue.t list [@@js.call "getAll"]
  val has: 'tags this -> name:string -> bool [@@js.call "has"]
  val set_: 'tags this -> name:string -> value:([`U1 of string | `U2 of Blob.t] [@js.union]) -> ?fileName:string -> unit -> unit [@@js.call "set"]
  val forEach: 'tags this -> callbackfn:(value:FormDataEntryValue.t -> key:string -> parent:t -> unit) -> ?thisArg:any -> unit -> unit [@@js.call "forEach"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: ?form:HTMLFormElement.t -> unit -> t [@@js.create]
end
and[@js.scope "FormDataEvent"] FormDataEvent : sig
  type t = [`Event | `FormDataEvent] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Event | `FormDataEvent]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Event | `FormDataEvent]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `FormDataEvent ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Returns a FormData object representing names and values of elements associated to the target form. Operations on the FormData object will affect form data to be submitted. *)
  val get_formData: 'tags this -> FormData.t [@@js.get "formData"]
  val create: formData:FormData.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': type_:string -> eventInitDict:FormDataEventInit.t -> t [@@js.create]
end
and FormDataEventInit : sig
  type t = [`EventInit | `FormDataEventInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventInit | `FormDataEventInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventInit | `FormDataEventInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `FormDataEventInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_formData: 'tags this -> FormData.t [@@js.get "formData"]
  val set_formData: 'tags this -> FormData.t -> unit [@@js.set "formData"]
  val create: formData:FormData.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
and GlobalEventHandlers : sig
  type t = [`GlobalEventHandlers] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`GlobalEventHandlers]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`GlobalEventHandlers]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `GlobalEventHandlers ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    Fires when the user aborts the download.
    @param ev The event.
  *)
  val get_onabort: 'tags this -> (this:t -> ev:UIEvent.t -> any) option [@@js.get "onabort"]
  
  (**
    Fires when the user aborts the download.
    @param ev The event.
  *)
  val set_onabort: 'tags this -> (this:t -> ev:UIEvent.t -> any) option -> unit [@@js.set "onabort"]
  val get_onanimationcancel: 'tags this -> (this:t -> ev:AnimationEvent.t -> any) option [@@js.get "onanimationcancel"]
  val set_onanimationcancel: 'tags this -> (this:t -> ev:AnimationEvent.t -> any) option -> unit [@@js.set "onanimationcancel"]
  val get_onanimationend: 'tags this -> (this:t -> ev:AnimationEvent.t -> any) option [@@js.get "onanimationend"]
  val set_onanimationend: 'tags this -> (this:t -> ev:AnimationEvent.t -> any) option -> unit [@@js.set "onanimationend"]
  val get_onanimationiteration: 'tags this -> (this:t -> ev:AnimationEvent.t -> any) option [@@js.get "onanimationiteration"]
  val set_onanimationiteration: 'tags this -> (this:t -> ev:AnimationEvent.t -> any) option -> unit [@@js.set "onanimationiteration"]
  val get_onanimationstart: 'tags this -> (this:t -> ev:AnimationEvent.t -> any) option [@@js.get "onanimationstart"]
  val set_onanimationstart: 'tags this -> (this:t -> ev:AnimationEvent.t -> any) option -> unit [@@js.set "onanimationstart"]
  val get_onauxclick: 'tags this -> (this:t -> ev:MouseEvent.t -> any) option [@@js.get "onauxclick"]
  val set_onauxclick: 'tags this -> (this:t -> ev:MouseEvent.t -> any) option -> unit [@@js.set "onauxclick"]
  
  (**
    Fires when the object loses the input focus.
    @param ev The focus event.
  *)
  val get_onblur: 'tags this -> (this:t -> ev:FocusEvent.t -> any) option [@@js.get "onblur"]
  
  (**
    Fires when the object loses the input focus.
    @param ev The focus event.
  *)
  val set_onblur: 'tags this -> (this:t -> ev:FocusEvent.t -> any) option -> unit [@@js.set "onblur"]
  
  (**
    Occurs when playback is possible, but would require further buffering.
    @param ev The event.
  *)
  val get_oncanplay: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "oncanplay"]
  
  (**
    Occurs when playback is possible, but would require further buffering.
    @param ev The event.
  *)
  val set_oncanplay: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "oncanplay"]
  val get_oncanplaythrough: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "oncanplaythrough"]
  val set_oncanplaythrough: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "oncanplaythrough"]
  
  (**
    Fires when the contents of the object or selection have changed.
    @param ev The event.
  *)
  val get_onchange: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onchange"]
  
  (**
    Fires when the contents of the object or selection have changed.
    @param ev The event.
  *)
  val set_onchange: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onchange"]
  
  (**
    Fires when the user clicks the left mouse button on the object
    @param ev The mouse event.
  *)
  val get_onclick: 'tags this -> (this:t -> ev:MouseEvent.t -> any) option [@@js.get "onclick"]
  
  (**
    Fires when the user clicks the left mouse button on the object
    @param ev The mouse event.
  *)
  val set_onclick: 'tags this -> (this:t -> ev:MouseEvent.t -> any) option -> unit [@@js.set "onclick"]
  val get_onclose: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onclose"]
  val set_onclose: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onclose"]
  
  (**
    Fires when the user clicks the right mouse button in the client area, opening the context menu.
    @param ev The mouse event.
  *)
  val get_oncontextmenu: 'tags this -> (this:t -> ev:MouseEvent.t -> any) option [@@js.get "oncontextmenu"]
  
  (**
    Fires when the user clicks the right mouse button in the client area, opening the context menu.
    @param ev The mouse event.
  *)
  val set_oncontextmenu: 'tags this -> (this:t -> ev:MouseEvent.t -> any) option -> unit [@@js.set "oncontextmenu"]
  val get_oncuechange: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "oncuechange"]
  val set_oncuechange: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "oncuechange"]
  
  (**
    Fires when the user double-clicks the object.
    @param ev The mouse event.
  *)
  val get_ondblclick: 'tags this -> (this:t -> ev:MouseEvent.t -> any) option [@@js.get "ondblclick"]
  
  (**
    Fires when the user double-clicks the object.
    @param ev The mouse event.
  *)
  val set_ondblclick: 'tags this -> (this:t -> ev:MouseEvent.t -> any) option -> unit [@@js.set "ondblclick"]
  
  (**
    Fires on the source object continuously during a drag operation.
    @param ev The event.
  *)
  val get_ondrag: 'tags this -> (this:t -> ev:DragEvent.t -> any) option [@@js.get "ondrag"]
  
  (**
    Fires on the source object continuously during a drag operation.
    @param ev The event.
  *)
  val set_ondrag: 'tags this -> (this:t -> ev:DragEvent.t -> any) option -> unit [@@js.set "ondrag"]
  
  (**
    Fires on the source object when the user releases the mouse at the close of a drag operation.
    @param ev The event.
  *)
  val get_ondragend: 'tags this -> (this:t -> ev:DragEvent.t -> any) option [@@js.get "ondragend"]
  
  (**
    Fires on the source object when the user releases the mouse at the close of a drag operation.
    @param ev The event.
  *)
  val set_ondragend: 'tags this -> (this:t -> ev:DragEvent.t -> any) option -> unit [@@js.set "ondragend"]
  
  (**
    Fires on the target element when the user drags the object to a valid drop target.
    @param ev The drag event.
  *)
  val get_ondragenter: 'tags this -> (this:t -> ev:DragEvent.t -> any) option [@@js.get "ondragenter"]
  
  (**
    Fires on the target element when the user drags the object to a valid drop target.
    @param ev The drag event.
  *)
  val set_ondragenter: 'tags this -> (this:t -> ev:DragEvent.t -> any) option -> unit [@@js.set "ondragenter"]
  
  (**
    Fires on the target object when the user moves the mouse out of a valid drop target during a drag operation.
    @param ev The drag event.
  *)
  val get_ondragleave: 'tags this -> (this:t -> ev:DragEvent.t -> any) option [@@js.get "ondragleave"]
  
  (**
    Fires on the target object when the user moves the mouse out of a valid drop target during a drag operation.
    @param ev The drag event.
  *)
  val set_ondragleave: 'tags this -> (this:t -> ev:DragEvent.t -> any) option -> unit [@@js.set "ondragleave"]
  
  (**
    Fires on the target element continuously while the user drags the object over a valid drop target.
    @param ev The event.
  *)
  val get_ondragover: 'tags this -> (this:t -> ev:DragEvent.t -> any) option [@@js.get "ondragover"]
  
  (**
    Fires on the target element continuously while the user drags the object over a valid drop target.
    @param ev The event.
  *)
  val set_ondragover: 'tags this -> (this:t -> ev:DragEvent.t -> any) option -> unit [@@js.set "ondragover"]
  
  (**
    Fires on the source object when the user starts to drag a text selection or selected object.
    @param ev The event.
  *)
  val get_ondragstart: 'tags this -> (this:t -> ev:DragEvent.t -> any) option [@@js.get "ondragstart"]
  
  (**
    Fires on the source object when the user starts to drag a text selection or selected object.
    @param ev The event.
  *)
  val set_ondragstart: 'tags this -> (this:t -> ev:DragEvent.t -> any) option -> unit [@@js.set "ondragstart"]
  val get_ondrop: 'tags this -> (this:t -> ev:DragEvent.t -> any) option [@@js.get "ondrop"]
  val set_ondrop: 'tags this -> (this:t -> ev:DragEvent.t -> any) option -> unit [@@js.set "ondrop"]
  
  (**
    Occurs when the duration attribute is updated.
    @param ev The event.
  *)
  val get_ondurationchange: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "ondurationchange"]
  
  (**
    Occurs when the duration attribute is updated.
    @param ev The event.
  *)
  val set_ondurationchange: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "ondurationchange"]
  
  (**
    Occurs when the media element is reset to its initial state.
    @param ev The event.
  *)
  val get_onemptied: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onemptied"]
  
  (**
    Occurs when the media element is reset to its initial state.
    @param ev The event.
  *)
  val set_onemptied: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onemptied"]
  
  (**
    Occurs when the end of playback is reached.
    @param ev The event
  *)
  val get_onended: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onended"]
  
  (**
    Occurs when the end of playback is reached.
    @param ev The event
  *)
  val set_onended: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onended"]
  
  (**
    Fires when an error occurs during object loading.
    @param ev The event.
  *)
  val get_onerror: 'tags this -> OnErrorEventHandler.t [@@js.get "onerror"]
  
  (**
    Fires when an error occurs during object loading.
    @param ev The event.
  *)
  val set_onerror: 'tags this -> OnErrorEventHandler.t -> unit [@@js.set "onerror"]
  
  (**
    Fires when the object receives focus.
    @param ev The event.
  *)
  val get_onfocus: 'tags this -> (this:t -> ev:FocusEvent.t -> any) option [@@js.get "onfocus"]
  
  (**
    Fires when the object receives focus.
    @param ev The event.
  *)
  val set_onfocus: 'tags this -> (this:t -> ev:FocusEvent.t -> any) option -> unit [@@js.set "onfocus"]
  val get_onformdata: 'tags this -> (this:t -> ev:FormDataEvent.t -> any) option [@@js.get "onformdata"]
  val set_onformdata: 'tags this -> (this:t -> ev:FormDataEvent.t -> any) option -> unit [@@js.set "onformdata"]
  val get_ongotpointercapture: 'tags this -> (this:t -> ev:PointerEvent.t -> any) option [@@js.get "ongotpointercapture"]
  val set_ongotpointercapture: 'tags this -> (this:t -> ev:PointerEvent.t -> any) option -> unit [@@js.set "ongotpointercapture"]
  val get_oninput: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "oninput"]
  val set_oninput: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "oninput"]
  val get_oninvalid: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "oninvalid"]
  val set_oninvalid: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "oninvalid"]
  
  (**
    Fires when the user presses a key.
    @param ev The keyboard event
  *)
  val get_onkeydown: 'tags this -> (this:t -> ev:KeyboardEvent.t -> any) option [@@js.get "onkeydown"]
  
  (**
    Fires when the user presses a key.
    @param ev The keyboard event
  *)
  val set_onkeydown: 'tags this -> (this:t -> ev:KeyboardEvent.t -> any) option -> unit [@@js.set "onkeydown"]
  
  (**
    Fires when the user presses an alphanumeric key.
    @param ev The event.
    @deprecated 
  *)
  val get_onkeypress: 'tags this -> (this:t -> ev:KeyboardEvent.t -> any) option [@@js.get "onkeypress"]
  
  (**
    Fires when the user presses an alphanumeric key.
    @param ev The event.
    @deprecated 
  *)
  val set_onkeypress: 'tags this -> (this:t -> ev:KeyboardEvent.t -> any) option -> unit [@@js.set "onkeypress"]
  
  (**
    Fires when the user releases a key.
    @param ev The keyboard event
  *)
  val get_onkeyup: 'tags this -> (this:t -> ev:KeyboardEvent.t -> any) option [@@js.get "onkeyup"]
  
  (**
    Fires when the user releases a key.
    @param ev The keyboard event
  *)
  val set_onkeyup: 'tags this -> (this:t -> ev:KeyboardEvent.t -> any) option -> unit [@@js.set "onkeyup"]
  
  (**
    Fires immediately after the browser loads the object.
    @param ev The event.
  *)
  val get_onload: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onload"]
  
  (**
    Fires immediately after the browser loads the object.
    @param ev The event.
  *)
  val set_onload: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onload"]
  
  (**
    Occurs when media data is loaded at the current playback position.
    @param ev The event.
  *)
  val get_onloadeddata: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onloadeddata"]
  
  (**
    Occurs when media data is loaded at the current playback position.
    @param ev The event.
  *)
  val set_onloadeddata: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onloadeddata"]
  
  (**
    Occurs when the duration and dimensions of the media have been determined.
    @param ev The event.
  *)
  val get_onloadedmetadata: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onloadedmetadata"]
  
  (**
    Occurs when the duration and dimensions of the media have been determined.
    @param ev The event.
  *)
  val set_onloadedmetadata: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onloadedmetadata"]
  
  (**
    Occurs when Internet Explorer begins looking for media data.
    @param ev The event.
  *)
  val get_onloadstart: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onloadstart"]
  
  (**
    Occurs when Internet Explorer begins looking for media data.
    @param ev The event.
  *)
  val set_onloadstart: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onloadstart"]
  val get_onlostpointercapture: 'tags this -> (this:t -> ev:PointerEvent.t -> any) option [@@js.get "onlostpointercapture"]
  val set_onlostpointercapture: 'tags this -> (this:t -> ev:PointerEvent.t -> any) option -> unit [@@js.set "onlostpointercapture"]
  
  (**
    Fires when the user clicks the object with either mouse button.
    @param ev The mouse event.
  *)
  val get_onmousedown: 'tags this -> (this:t -> ev:MouseEvent.t -> any) option [@@js.get "onmousedown"]
  
  (**
    Fires when the user clicks the object with either mouse button.
    @param ev The mouse event.
  *)
  val set_onmousedown: 'tags this -> (this:t -> ev:MouseEvent.t -> any) option -> unit [@@js.set "onmousedown"]
  val get_onmouseenter: 'tags this -> (this:t -> ev:MouseEvent.t -> any) option [@@js.get "onmouseenter"]
  val set_onmouseenter: 'tags this -> (this:t -> ev:MouseEvent.t -> any) option -> unit [@@js.set "onmouseenter"]
  val get_onmouseleave: 'tags this -> (this:t -> ev:MouseEvent.t -> any) option [@@js.get "onmouseleave"]
  val set_onmouseleave: 'tags this -> (this:t -> ev:MouseEvent.t -> any) option -> unit [@@js.set "onmouseleave"]
  
  (**
    Fires when the user moves the mouse over the object.
    @param ev The mouse event.
  *)
  val get_onmousemove: 'tags this -> (this:t -> ev:MouseEvent.t -> any) option [@@js.get "onmousemove"]
  
  (**
    Fires when the user moves the mouse over the object.
    @param ev The mouse event.
  *)
  val set_onmousemove: 'tags this -> (this:t -> ev:MouseEvent.t -> any) option -> unit [@@js.set "onmousemove"]
  
  (**
    Fires when the user moves the mouse pointer outside the boundaries of the object.
    @param ev The mouse event.
  *)
  val get_onmouseout: 'tags this -> (this:t -> ev:MouseEvent.t -> any) option [@@js.get "onmouseout"]
  
  (**
    Fires when the user moves the mouse pointer outside the boundaries of the object.
    @param ev The mouse event.
  *)
  val set_onmouseout: 'tags this -> (this:t -> ev:MouseEvent.t -> any) option -> unit [@@js.set "onmouseout"]
  
  (**
    Fires when the user moves the mouse pointer into the object.
    @param ev The mouse event.
  *)
  val get_onmouseover: 'tags this -> (this:t -> ev:MouseEvent.t -> any) option [@@js.get "onmouseover"]
  
  (**
    Fires when the user moves the mouse pointer into the object.
    @param ev The mouse event.
  *)
  val set_onmouseover: 'tags this -> (this:t -> ev:MouseEvent.t -> any) option -> unit [@@js.set "onmouseover"]
  
  (**
    Fires when the user releases a mouse button while the mouse is over the object.
    @param ev The mouse event.
  *)
  val get_onmouseup: 'tags this -> (this:t -> ev:MouseEvent.t -> any) option [@@js.get "onmouseup"]
  
  (**
    Fires when the user releases a mouse button while the mouse is over the object.
    @param ev The mouse event.
  *)
  val set_onmouseup: 'tags this -> (this:t -> ev:MouseEvent.t -> any) option -> unit [@@js.set "onmouseup"]
  
  (**
    Occurs when playback is paused.
    @param ev The event.
  *)
  val get_onpause: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onpause"]
  
  (**
    Occurs when playback is paused.
    @param ev The event.
  *)
  val set_onpause: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onpause"]
  
  (**
    Occurs when the play method is requested.
    @param ev The event.
  *)
  val get_onplay: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onplay"]
  
  (**
    Occurs when the play method is requested.
    @param ev The event.
  *)
  val set_onplay: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onplay"]
  
  (**
    Occurs when the audio or video has started playing.
    @param ev The event.
  *)
  val get_onplaying: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onplaying"]
  
  (**
    Occurs when the audio or video has started playing.
    @param ev The event.
  *)
  val set_onplaying: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onplaying"]
  val get_onpointercancel: 'tags this -> (this:t -> ev:PointerEvent.t -> any) option [@@js.get "onpointercancel"]
  val set_onpointercancel: 'tags this -> (this:t -> ev:PointerEvent.t -> any) option -> unit [@@js.set "onpointercancel"]
  val get_onpointerdown: 'tags this -> (this:t -> ev:PointerEvent.t -> any) option [@@js.get "onpointerdown"]
  val set_onpointerdown: 'tags this -> (this:t -> ev:PointerEvent.t -> any) option -> unit [@@js.set "onpointerdown"]
  val get_onpointerenter: 'tags this -> (this:t -> ev:PointerEvent.t -> any) option [@@js.get "onpointerenter"]
  val set_onpointerenter: 'tags this -> (this:t -> ev:PointerEvent.t -> any) option -> unit [@@js.set "onpointerenter"]
  val get_onpointerleave: 'tags this -> (this:t -> ev:PointerEvent.t -> any) option [@@js.get "onpointerleave"]
  val set_onpointerleave: 'tags this -> (this:t -> ev:PointerEvent.t -> any) option -> unit [@@js.set "onpointerleave"]
  val get_onpointermove: 'tags this -> (this:t -> ev:PointerEvent.t -> any) option [@@js.get "onpointermove"]
  val set_onpointermove: 'tags this -> (this:t -> ev:PointerEvent.t -> any) option -> unit [@@js.set "onpointermove"]
  val get_onpointerout: 'tags this -> (this:t -> ev:PointerEvent.t -> any) option [@@js.get "onpointerout"]
  val set_onpointerout: 'tags this -> (this:t -> ev:PointerEvent.t -> any) option -> unit [@@js.set "onpointerout"]
  val get_onpointerover: 'tags this -> (this:t -> ev:PointerEvent.t -> any) option [@@js.get "onpointerover"]
  val set_onpointerover: 'tags this -> (this:t -> ev:PointerEvent.t -> any) option -> unit [@@js.set "onpointerover"]
  val get_onpointerup: 'tags this -> (this:t -> ev:PointerEvent.t -> any) option [@@js.get "onpointerup"]
  val set_onpointerup: 'tags this -> (this:t -> ev:PointerEvent.t -> any) option -> unit [@@js.set "onpointerup"]
  
  (**
    Occurs to indicate progress while downloading media data.
    @param ev The event.
  *)
  val get_onprogress: 'tags this -> (this:t -> ev:ProgressEvent.t_0 -> any) option [@@js.get "onprogress"]
  
  (**
    Occurs to indicate progress while downloading media data.
    @param ev The event.
  *)
  val set_onprogress: 'tags this -> (this:t -> ev:ProgressEvent.t_0 -> any) option -> unit [@@js.set "onprogress"]
  
  (**
    Occurs when the playback rate is increased or decreased.
    @param ev The event.
  *)
  val get_onratechange: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onratechange"]
  
  (**
    Occurs when the playback rate is increased or decreased.
    @param ev The event.
  *)
  val set_onratechange: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onratechange"]
  
  (**
    Fires when the user resets a form.
    @param ev The event.
  *)
  val get_onreset: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onreset"]
  
  (**
    Fires when the user resets a form.
    @param ev The event.
  *)
  val set_onreset: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onreset"]
  val get_onresize: 'tags this -> (this:t -> ev:UIEvent.t -> any) option [@@js.get "onresize"]
  val set_onresize: 'tags this -> (this:t -> ev:UIEvent.t -> any) option -> unit [@@js.set "onresize"]
  
  (**
    Fires when the user repositions the scroll box in the scroll bar on the object.
    @param ev The event.
  *)
  val get_onscroll: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onscroll"]
  
  (**
    Fires when the user repositions the scroll box in the scroll bar on the object.
    @param ev The event.
  *)
  val set_onscroll: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onscroll"]
  val get_onsecuritypolicyviolation: 'tags this -> (this:t -> ev:SecurityPolicyViolationEvent.t -> any) option [@@js.get "onsecuritypolicyviolation"]
  val set_onsecuritypolicyviolation: 'tags this -> (this:t -> ev:SecurityPolicyViolationEvent.t -> any) option -> unit [@@js.set "onsecuritypolicyviolation"]
  
  (**
    Occurs when the seek operation ends.
    @param ev The event.
  *)
  val get_onseeked: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onseeked"]
  
  (**
    Occurs when the seek operation ends.
    @param ev The event.
  *)
  val set_onseeked: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onseeked"]
  
  (**
    Occurs when the current playback position is moved.
    @param ev The event.
  *)
  val get_onseeking: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onseeking"]
  
  (**
    Occurs when the current playback position is moved.
    @param ev The event.
  *)
  val set_onseeking: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onseeking"]
  
  (**
    Fires when the current selection changes.
    @param ev The event.
  *)
  val get_onselect: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onselect"]
  
  (**
    Fires when the current selection changes.
    @param ev The event.
  *)
  val set_onselect: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onselect"]
  val get_onselectionchange: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onselectionchange"]
  val set_onselectionchange: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onselectionchange"]
  val get_onselectstart: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onselectstart"]
  val set_onselectstart: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onselectstart"]
  val get_onslotchange: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onslotchange"]
  val set_onslotchange: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onslotchange"]
  
  (**
    Occurs when the download has stopped.
    @param ev The event.
  *)
  val get_onstalled: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onstalled"]
  
  (**
    Occurs when the download has stopped.
    @param ev The event.
  *)
  val set_onstalled: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onstalled"]
  val get_onsubmit: 'tags this -> (this:t -> ev:SubmitEvent.t -> any) option [@@js.get "onsubmit"]
  val set_onsubmit: 'tags this -> (this:t -> ev:SubmitEvent.t -> any) option -> unit [@@js.set "onsubmit"]
  
  (**
    Occurs if the load operation has been intentionally halted.
    @param ev The event.
  *)
  val get_onsuspend: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onsuspend"]
  
  (**
    Occurs if the load operation has been intentionally halted.
    @param ev The event.
  *)
  val set_onsuspend: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onsuspend"]
  
  (**
    Occurs to indicate the current playback position.
    @param ev The event.
  *)
  val get_ontimeupdate: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "ontimeupdate"]
  
  (**
    Occurs to indicate the current playback position.
    @param ev The event.
  *)
  val set_ontimeupdate: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "ontimeupdate"]
  val get_ontoggle: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "ontoggle"]
  val set_ontoggle: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "ontoggle"]
  val get_ontouchcancel: 'tags this -> (this:t -> ev:TouchEvent.t -> any) option option [@@js.get "ontouchcancel"]
  val set_ontouchcancel: 'tags this -> ([`Null | `Undefined of undefined | `U1 of (this:t -> ev:TouchEvent.t -> any)] [@js.union]) -> unit [@@js.set "ontouchcancel"]
  val get_ontouchend: 'tags this -> (this:t -> ev:TouchEvent.t -> any) option option [@@js.get "ontouchend"]
  val set_ontouchend: 'tags this -> ([`Null | `Undefined of undefined | `U1 of (this:t -> ev:TouchEvent.t -> any)] [@js.union]) -> unit [@@js.set "ontouchend"]
  val get_ontouchmove: 'tags this -> (this:t -> ev:TouchEvent.t -> any) option option [@@js.get "ontouchmove"]
  val set_ontouchmove: 'tags this -> ([`Null | `Undefined of undefined | `U1 of (this:t -> ev:TouchEvent.t -> any)] [@js.union]) -> unit [@@js.set "ontouchmove"]
  val get_ontouchstart: 'tags this -> (this:t -> ev:TouchEvent.t -> any) option option [@@js.get "ontouchstart"]
  val set_ontouchstart: 'tags this -> ([`Null | `Undefined of undefined | `U1 of (this:t -> ev:TouchEvent.t -> any)] [@js.union]) -> unit [@@js.set "ontouchstart"]
  val get_ontransitioncancel: 'tags this -> (this:t -> ev:TransitionEvent.t -> any) option [@@js.get "ontransitioncancel"]
  val set_ontransitioncancel: 'tags this -> (this:t -> ev:TransitionEvent.t -> any) option -> unit [@@js.set "ontransitioncancel"]
  val get_ontransitionend: 'tags this -> (this:t -> ev:TransitionEvent.t -> any) option [@@js.get "ontransitionend"]
  val set_ontransitionend: 'tags this -> (this:t -> ev:TransitionEvent.t -> any) option -> unit [@@js.set "ontransitionend"]
  val get_ontransitionrun: 'tags this -> (this:t -> ev:TransitionEvent.t -> any) option [@@js.get "ontransitionrun"]
  val set_ontransitionrun: 'tags this -> (this:t -> ev:TransitionEvent.t -> any) option -> unit [@@js.set "ontransitionrun"]
  val get_ontransitionstart: 'tags this -> (this:t -> ev:TransitionEvent.t -> any) option [@@js.get "ontransitionstart"]
  val set_ontransitionstart: 'tags this -> (this:t -> ev:TransitionEvent.t -> any) option -> unit [@@js.set "ontransitionstart"]
  
  (**
    Occurs when the volume is changed, or playback is muted or unmuted.
    @param ev The event.
  *)
  val get_onvolumechange: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onvolumechange"]
  
  (**
    Occurs when the volume is changed, or playback is muted or unmuted.
    @param ev The event.
  *)
  val set_onvolumechange: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onvolumechange"]
  
  (**
    Occurs when playback stops because the next frame of a video resource is not available.
    @param ev The event.
  *)
  val get_onwaiting: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onwaiting"]
  
  (**
    Occurs when playback stops because the next frame of a video resource is not available.
    @param ev The event.
  *)
  val set_onwaiting: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onwaiting"]
  
  (** @deprecated This is a legacy alias of `onanimationend`. *)
  val get_onwebkitanimationend: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onwebkitanimationend"]
  
  (** @deprecated This is a legacy alias of `onanimationend`. *)
  val set_onwebkitanimationend: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onwebkitanimationend"]
  
  (** @deprecated This is a legacy alias of `onanimationiteration`. *)
  val get_onwebkitanimationiteration: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onwebkitanimationiteration"]
  
  (** @deprecated This is a legacy alias of `onanimationiteration`. *)
  val set_onwebkitanimationiteration: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onwebkitanimationiteration"]
  
  (** @deprecated This is a legacy alias of `onanimationstart`. *)
  val get_onwebkitanimationstart: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onwebkitanimationstart"]
  
  (** @deprecated This is a legacy alias of `onanimationstart`. *)
  val set_onwebkitanimationstart: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onwebkitanimationstart"]
  
  (** @deprecated This is a legacy alias of `ontransitionend`. *)
  val get_onwebkittransitionend: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onwebkittransitionend"]
  
  (** @deprecated This is a legacy alias of `ontransitionend`. *)
  val set_onwebkittransitionend: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onwebkittransitionend"]
  val get_onwheel: 'tags this -> (this:t -> ev:WheelEvent.t -> any) option [@@js.get "onwheel"]
  val set_onwheel: 'tags this -> (this:t -> ev:WheelEvent.t -> any) option -> unit [@@js.set "onwheel"]
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'GlobalEventHandlersEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'GlobalEventHandlersEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
and[@js.scope "HTMLAllCollection"] HTMLAllCollection : sig
  type t = [`HTMLAllCollection | Element.t ArrayLike.tags_1 | Element.t IterableIterator.tags_1] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`HTMLAllCollection | Element.t ArrayLike.tags_1 | Element.t IterableIterator.tags_1]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`HTMLAllCollection | Element.t ArrayLike.tags_1 | Element.t IterableIterator.tags_1]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLAllCollection ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  (* [Symbol.iterator]: unit -> Element.t IterableIterator.t_1 *)
  
  (** Returns the number of elements in the collection. *)
  val get_length: 'tags this -> float [@@js.get "length"]
  
  (** Returns the item with index index from the collection (determined by tree order). *)
  val item: 'tags this -> ?nameOrIndex:string -> unit -> (Element.t, HTMLCollection.t) union2 option [@@js.call "item"]
  
  (**
    Returns the item with ID or name name from the collection.
    
    If there are multiple matching items, then an HTMLCollection object containing all those elements is returned.
    
    Only button, form, iframe, input, map, meta, object, select, and textarea elements can have a name for the purpose of this method; their name is given by the value of their name attribute.
  *)
  val namedItem: 'tags this -> name:string -> (Element.t, HTMLCollection.t) union2 option [@@js.call "namedItem"]
  val get: 'tags this -> float -> Element.t [@@js.index_get]
  val set: 'tags this -> float -> Element.t -> unit [@@js.index_set]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Hyperlink elements and provides special properties and methods (beyond those of the regular HTMLElement object interface that they inherit from) for manipulating the layout and presentation of such elements. *)
and[@js.scope "HTMLAnchorElement"] HTMLAnchorElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLAnchorElement | `HTMLElement | `HTMLHyperlinkElementUtils | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLAnchorElement | `HTMLElement | `HTMLHyperlinkElementUtils | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLAnchorElement | `HTMLElement | `HTMLHyperlinkElementUtils | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLAnchorElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    Sets or retrieves the character set used to encode the object.
    @deprecated 
  *)
  val get_charset: 'tags this -> string [@@js.get "charset"]
  
  (**
    Sets or retrieves the character set used to encode the object.
    @deprecated 
  *)
  val set_charset: 'tags this -> string -> unit [@@js.set "charset"]
  
  (**
    Sets or retrieves the coordinates of the object.
    @deprecated 
  *)
  val get_coords: 'tags this -> string [@@js.get "coords"]
  
  (**
    Sets or retrieves the coordinates of the object.
    @deprecated 
  *)
  val set_coords: 'tags this -> string -> unit [@@js.set "coords"]
  val get_download: 'tags this -> string [@@js.get "download"]
  val set_download: 'tags this -> string -> unit [@@js.set "download"]
  
  (** Sets or retrieves the language code of the object. *)
  val get_hreflang: 'tags this -> string [@@js.get "hreflang"]
  
  (** Sets or retrieves the language code of the object. *)
  val set_hreflang: 'tags this -> string -> unit [@@js.set "hreflang"]
  
  (**
    Sets or retrieves the shape of the object.
    @deprecated 
  *)
  val get_name: 'tags this -> string [@@js.get "name"]
  
  (**
    Sets or retrieves the shape of the object.
    @deprecated 
  *)
  val set_name: 'tags this -> string -> unit [@@js.set "name"]
  val get_ping: 'tags this -> string [@@js.get "ping"]
  val set_ping: 'tags this -> string -> unit [@@js.set "ping"]
  val get_referrerPolicy: 'tags this -> string [@@js.get "referrerPolicy"]
  val set_referrerPolicy: 'tags this -> string -> unit [@@js.set "referrerPolicy"]
  
  (** Sets or retrieves the relationship between the object and the destination of the link. *)
  val get_rel: 'tags this -> string [@@js.get "rel"]
  
  (** Sets or retrieves the relationship between the object and the destination of the link. *)
  val set_rel: 'tags this -> string -> unit [@@js.set "rel"]
  val get_relList: 'tags this -> DOMTokenList.t [@@js.get "relList"]
  
  (**
    Sets or retrieves the relationship between the object and the destination of the link.
    @deprecated 
  *)
  val get_rev: 'tags this -> string [@@js.get "rev"]
  
  (**
    Sets or retrieves the relationship between the object and the destination of the link.
    @deprecated 
  *)
  val set_rev: 'tags this -> string -> unit [@@js.set "rev"]
  
  (**
    Sets or retrieves the shape of the object.
    @deprecated 
  *)
  val get_shape: 'tags this -> string [@@js.get "shape"]
  
  (**
    Sets or retrieves the shape of the object.
    @deprecated 
  *)
  val set_shape: 'tags this -> string -> unit [@@js.set "shape"]
  
  (** Sets or retrieves the window or frame at which to target content. *)
  val get_target: 'tags this -> string [@@js.get "target"]
  
  (** Sets or retrieves the window or frame at which to target content. *)
  val set_target: 'tags this -> string -> unit [@@js.set "target"]
  
  (** Retrieves or sets the text of the object as a string. *)
  val get_text: 'tags this -> string [@@js.get "text"]
  
  (** Retrieves or sets the text of the object as a string. *)
  val set_text: 'tags this -> string -> unit [@@js.set "text"]
  val get_type: 'tags this -> string [@@js.get "type"]
  val set_type: 'tags this -> string -> unit [@@js.set "type"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Provides special properties and methods (beyond those of the regular object HTMLElement interface it also has available to it by inheritance) for manipulating the layout and presentation of <area> elements. *)
and[@js.scope "HTMLAreaElement"] HTMLAreaElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLAreaElement | `HTMLElement | `HTMLHyperlinkElementUtils | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLAreaElement | `HTMLElement | `HTMLHyperlinkElementUtils | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLAreaElement | `HTMLElement | `HTMLHyperlinkElementUtils | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLAreaElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Sets or retrieves a text alternative to the graphic. *)
  val get_alt: 'tags this -> string [@@js.get "alt"]
  
  (** Sets or retrieves a text alternative to the graphic. *)
  val set_alt: 'tags this -> string -> unit [@@js.set "alt"]
  
  (** Sets or retrieves the coordinates of the object. *)
  val get_coords: 'tags this -> string [@@js.get "coords"]
  
  (** Sets or retrieves the coordinates of the object. *)
  val set_coords: 'tags this -> string -> unit [@@js.set "coords"]
  val get_download: 'tags this -> string [@@js.get "download"]
  val set_download: 'tags this -> string -> unit [@@js.set "download"]
  
  (**
    Sets or gets whether clicks in this region cause action.
    @deprecated 
  *)
  val get_noHref: 'tags this -> bool [@@js.get "noHref"]
  
  (**
    Sets or gets whether clicks in this region cause action.
    @deprecated 
  *)
  val set_noHref: 'tags this -> bool -> unit [@@js.set "noHref"]
  val get_ping: 'tags this -> string [@@js.get "ping"]
  val set_ping: 'tags this -> string -> unit [@@js.set "ping"]
  val get_referrerPolicy: 'tags this -> string [@@js.get "referrerPolicy"]
  val set_referrerPolicy: 'tags this -> string -> unit [@@js.set "referrerPolicy"]
  val get_rel: 'tags this -> string [@@js.get "rel"]
  val set_rel: 'tags this -> string -> unit [@@js.set "rel"]
  val get_relList: 'tags this -> DOMTokenList.t [@@js.get "relList"]
  
  (** Sets or retrieves the shape of the object. *)
  val get_shape: 'tags this -> string [@@js.get "shape"]
  
  (** Sets or retrieves the shape of the object. *)
  val set_shape: 'tags this -> string -> unit [@@js.set "shape"]
  
  (** Sets or retrieves the window or frame at which to target content. *)
  val get_target: 'tags this -> string [@@js.get "target"]
  
  (** Sets or retrieves the window or frame at which to target content. *)
  val set_target: 'tags this -> string -> unit [@@js.set "target"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Provides properties and methods for manipulating the layout and presentation of <canvas> elements. The HTMLCanvasElement interface also inherits the properties and methods of the HTMLElement interface. *)
and[@js.scope "HTMLCanvasElement"] HTMLCanvasElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLCanvasElement | `HTMLElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLCanvasElement | `HTMLElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLCanvasElement | `HTMLElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLCanvasElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Gets or sets the height of a canvas element on a document. *)
  val get_height: 'tags this -> float [@@js.get "height"]
  
  (** Gets or sets the height of a canvas element on a document. *)
  val set_height: 'tags this -> float -> unit [@@js.set "height"]
  
  (** Gets or sets the width of a canvas element on a document. *)
  val get_width: 'tags this -> float [@@js.get "width"]
  
  (** Gets or sets the width of a canvas element on a document. *)
  val set_width: 'tags this -> float -> unit [@@js.set "width"]
  val captureStream: 'tags this -> ?frameRequestRate:float -> unit -> MediaStream.t [@@js.call "captureStream"]
  
  (**
    Returns an object that provides methods and properties for drawing and manipulating images and graphics on a canvas element in a document. A context object includes information about colors, line widths, fonts, and other graphic parameters that can be drawn on a canvas.
    @param contextId The identifier (ID) of the type of canvas to create. Internet Explorer 9 and Internet Explorer 10 support only a 2-D context using canvas.getContext("2d"); IE11 Preview also supports 3-D or WebGL context using canvas.getContext("experimental-webgl");
  *)
  val getContext: 'tags this -> contextId:([`L_s1_2d[@js "2d"]] [@js.enum]) -> ?options:CanvasRenderingContext2DSettings.t -> unit -> CanvasRenderingContext2D.t option [@@js.call "getContext"]
  
  (** Returns an object that provides methods and properties for drawing and manipulating images and graphics on a canvas element in a document. A context object includes information about colors, line widths, fonts, and other graphic parameters that can be drawn on a canvas. *)
  val getContext': 'tags this -> contextId:([`L_s159_bitmaprenderer[@js "bitmaprenderer"]] [@js.enum]) -> ?options:ImageBitmapRenderingContextSettings.t -> unit -> ImageBitmapRenderingContext.t option [@@js.call "getContext"]
  
  (** Returns an object that provides methods and properties for drawing and manipulating images and graphics on a canvas element in a document. A context object includes information about colors, line widths, fonts, and other graphic parameters that can be drawn on a canvas. *)
  val getContext'': 'tags this -> contextId:([`L_s863_webgl[@js "webgl"]] [@js.enum]) -> ?options:WebGLContextAttributes.t -> unit -> WebGLRenderingContext.t option [@@js.call "getContext"]
  
  (** Returns an object that provides methods and properties for drawing and manipulating images and graphics on a canvas element in a document. A context object includes information about colors, line widths, fonts, and other graphic parameters that can be drawn on a canvas. *)
  val getContext''': 'tags this -> contextId:([`L_s864_webgl2[@js "webgl2"]] [@js.enum]) -> ?options:WebGLContextAttributes.t -> unit -> WebGL2RenderingContext.t option [@@js.call "getContext"]
  
  (** Returns an object that provides methods and properties for drawing and manipulating images and graphics on a canvas element in a document. A context object includes information about colors, line widths, fonts, and other graphic parameters that can be drawn on a canvas. *)
  val getContext'''': 'tags this -> contextId:string -> ?options:any -> unit -> RenderingContext.t option [@@js.call "getContext"]
  val toBlob: 'tags this -> callback:BlobCallback.t -> ?type_:string -> ?quality:any -> unit -> unit [@@js.call "toBlob"]
  
  (**
    Returns the content of the current canvas as an image that you can use as a source for another canvas or an HTML element.
    @param type The standard MIME type for the image format to return. If you do not specify this parameter, the default value is a PNG format image.
  *)
  val toDataURL: 'tags this -> ?type_:string -> ?quality:any -> unit -> string [@@js.call "toDataURL"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
and[@js.scope "HTMLCollection"] HTMLCollection : sig
  type t = [`HTMLCollection | `HTMLCollectionBase | Element.t ArrayLike.tags_1 | Element.t IterableIterator.tags_1] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`HTMLCollection | `HTMLCollectionBase | Element.t ArrayLike.tags_1 | Element.t IterableIterator.tags_1]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`HTMLCollection | `HTMLCollectionBase | Element.t ArrayLike.tags_1 | Element.t IterableIterator.tags_1]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLCollection ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Retrieves a select object or an object from an options collection. *)
  val namedItem: 'tags this -> name:string -> Element.t option [@@js.call "namedItem"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** A generic collection (array-like object similar to arguments) of elements (in document order) and offers methods and properties for selecting from the list. *)
and HTMLCollectionBase : sig
  type t = [`HTMLCollectionBase | Element.t ArrayLike.tags_1 | Element.t IterableIterator.tags_1] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`HTMLCollectionBase | Element.t ArrayLike.tags_1 | Element.t IterableIterator.tags_1]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`HTMLCollectionBase | Element.t ArrayLike.tags_1 | Element.t IterableIterator.tags_1]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLCollectionBase ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  (* [Symbol.iterator]: unit -> Element.t IterableIterator.t_1 *)
  
  (** Sets or retrieves the number of objects in a collection. *)
  val get_length: 'tags this -> float [@@js.get "length"]
  
  (** Retrieves an object from various collections. *)
  val item: 'tags this -> index:float -> Element.t option [@@js.call "item"]
  val get: 'tags this -> float -> Element.t [@@js.index_get]
  val set: 'tags this -> float -> Element.t -> unit [@@js.index_set]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
and HTMLCollectionOf : sig
  type 'T t = [`HTMLCollectionBase | `HTMLCollectionOf of 'T | 'T ArrayLike.tags_1 | 'T IterableIterator.tags_1] intf [@@js.custom { of_js=(fun _T -> Obj.magic); to_js=(fun _T -> Obj.magic) }]
  type 'T t_1 = 'T t
  [@@@js.stop]
  type 'T tags = [`HTMLCollectionBase | `HTMLCollectionOf of 'T | 'T ArrayLike.tags_1 | 'T IterableIterator.tags_1]
  type 'T tags_1 = 'T tags
  [@@@js.start]
  [@@@js.implem 
    type 'T tags = [`HTMLCollectionBase | `HTMLCollectionOf of 'T | 'T ArrayLike.tags_1 | 'T IterableIterator.tags_1]
    type 'T tags_1 = 'T tags
  ]
  type ('tags, 'T) this = 'tags intf constraint 'tags = [> `HTMLCollectionOf of 'T ]
  val t_to_js: ('T -> Ojs.t) -> 'T t -> Ojs.t
  val t_of_js: (Ojs.t -> 'T) -> Ojs.t -> 'T t
  val t_1_to_js: ('T -> Ojs.t) -> 'T t_1 -> Ojs.t
  val t_1_of_js: (Ojs.t -> 'T) -> Ojs.t -> 'T t_1
  (* [Symbol.iterator]: unit -> 'T IterableIterator.t_1 *)
  
  (** Retrieves an object from various collections. *)
  val item: ('tags, 'T) this -> index:float -> 'T option [@@js.call "item"]
  val namedItem: ('tags, 'T) this -> name:string -> 'T option [@@js.call "namedItem"]
  val get: ('tags, 'T) this -> float -> 'T [@@js.index_get]
  val set: ('tags, 'T) this -> float -> 'T -> unit [@@js.index_set]
  val cast_from: ('tags, 'T) this -> 'T t [@@js.custom let cast_from = Obj.magic]
end

(** Any HTML element. Some elements directly implement this interface, while others implement it via an interface that inherits it. *)
and[@js.scope "HTMLElement"] HTMLElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_accessKey: 'tags this -> string [@@js.get "accessKey"]
  val set_accessKey: 'tags this -> string -> unit [@@js.set "accessKey"]
  val get_accessKeyLabel: 'tags this -> string [@@js.get "accessKeyLabel"]
  val get_autocapitalize: 'tags this -> string [@@js.get "autocapitalize"]
  val set_autocapitalize: 'tags this -> string -> unit [@@js.set "autocapitalize"]
  val get_dir: 'tags this -> string [@@js.get "dir"]
  val set_dir: 'tags this -> string -> unit [@@js.set "dir"]
  val get_draggable: 'tags this -> bool [@@js.get "draggable"]
  val set_draggable: 'tags this -> bool -> unit [@@js.set "draggable"]
  val get_hidden: 'tags this -> bool [@@js.get "hidden"]
  val set_hidden: 'tags this -> bool -> unit [@@js.set "hidden"]
  val get_innerText: 'tags this -> string [@@js.get "innerText"]
  val set_innerText: 'tags this -> string -> unit [@@js.set "innerText"]
  val get_lang: 'tags this -> string [@@js.get "lang"]
  val set_lang: 'tags this -> string -> unit [@@js.set "lang"]
  val get_offsetHeight: 'tags this -> float [@@js.get "offsetHeight"]
  val get_offsetLeft: 'tags this -> float [@@js.get "offsetLeft"]
  val get_offsetParent: 'tags this -> Element.t option [@@js.get "offsetParent"]
  val get_offsetTop: 'tags this -> float [@@js.get "offsetTop"]
  val get_offsetWidth: 'tags this -> float [@@js.get "offsetWidth"]
  val get_outerText: 'tags this -> string [@@js.get "outerText"]
  val set_outerText: 'tags this -> string -> unit [@@js.set "outerText"]
  val get_spellcheck: 'tags this -> bool [@@js.get "spellcheck"]
  val set_spellcheck: 'tags this -> bool -> unit [@@js.set "spellcheck"]
  val get_title: 'tags this -> string [@@js.get "title"]
  val set_title: 'tags this -> string -> unit [@@js.set "title"]
  val get_translate: 'tags this -> bool [@@js.get "translate"]
  val set_translate: 'tags this -> bool -> unit [@@js.set "translate"]
  val attachInternals: 'tags this -> ElementInternals.t [@@js.call "attachInternals"]
  val click: 'tags this -> unit [@@js.call "click"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Provides special properties (beyond the regular HTMLElement interface it also has available to it by inheritance) for manipulating <embed> elements. *)
and[@js.scope "HTMLEmbedElement"] HTMLEmbedElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLEmbedElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLEmbedElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLEmbedElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLEmbedElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** @deprecated  *)
  val get_align: 'tags this -> string [@@js.get "align"]
  
  (** @deprecated  *)
  val set_align: 'tags this -> string -> unit [@@js.set "align"]
  
  (** Sets or retrieves the height of the object. *)
  val get_height: 'tags this -> string [@@js.get "height"]
  
  (** Sets or retrieves the height of the object. *)
  val set_height: 'tags this -> string -> unit [@@js.set "height"]
  
  (**
    Sets or retrieves the name of the object.
    @deprecated 
  *)
  val get_name: 'tags this -> string [@@js.get "name"]
  
  (**
    Sets or retrieves the name of the object.
    @deprecated 
  *)
  val set_name: 'tags this -> string -> unit [@@js.set "name"]
  
  (** Sets or retrieves a URL to be loaded by the object. *)
  val get_src: 'tags this -> string [@@js.get "src"]
  
  (** Sets or retrieves a URL to be loaded by the object. *)
  val set_src: 'tags this -> string -> unit [@@js.set "src"]
  val get_type: 'tags this -> string [@@js.get "type"]
  val set_type: 'tags this -> string -> unit [@@js.set "type"]
  
  (** Sets or retrieves the width of the object. *)
  val get_width: 'tags this -> string [@@js.get "width"]
  
  (** Sets or retrieves the width of the object. *)
  val set_width: 'tags this -> string -> unit [@@js.set "width"]
  val getSVGDocument: 'tags this -> Document.t option [@@js.call "getSVGDocument"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** A collection of HTML form control elements. *)
and[@js.scope "HTMLFormControlsCollection"] HTMLFormControlsCollection : sig
  type t = [`HTMLCollectionBase | `HTMLFormControlsCollection | Element.t ArrayLike.tags_1 | Element.t IterableIterator.tags_1] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`HTMLCollectionBase | `HTMLFormControlsCollection | Element.t ArrayLike.tags_1 | Element.t IterableIterator.tags_1]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`HTMLCollectionBase | `HTMLFormControlsCollection | Element.t ArrayLike.tags_1 | Element.t IterableIterator.tags_1]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLFormControlsCollection ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    Returns the item with ID or name name from the collection.
    
    If there are multiple matching items, then a RadioNodeList object containing all those elements is returned.
  *)
  val namedItem: 'tags this -> name:string -> (Element.t, RadioNodeList.t) union2 option [@@js.call "namedItem"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** A <form> element in the DOM; it allows access to and in some cases modification of aspects of the form, as well as access to its component elements. *)
and[@js.scope "HTMLFormElement"] HTMLFormElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLFormElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable | Element.t ArrayLike.tags_1 | Element.t IterableIterator.tags_1] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLFormElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable | Element.t ArrayLike.tags_1 | Element.t IterableIterator.tags_1]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLFormElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable | Element.t ArrayLike.tags_1 | Element.t IterableIterator.tags_1]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLFormElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  (* [Symbol.iterator]: unit -> Element.t IterableIterator.t_1 *)
  
  (** Sets or retrieves a list of character encodings for input data that must be accepted by the server processing the form. *)
  val get_acceptCharset: 'tags this -> string [@@js.get "acceptCharset"]
  
  (** Sets or retrieves a list of character encodings for input data that must be accepted by the server processing the form. *)
  val set_acceptCharset: 'tags this -> string -> unit [@@js.set "acceptCharset"]
  
  (** Sets or retrieves the URL to which the form content is sent for processing. *)
  val get_action: 'tags this -> string [@@js.get "action"]
  
  (** Sets or retrieves the URL to which the form content is sent for processing. *)
  val set_action: 'tags this -> string -> unit [@@js.set "action"]
  
  (** Specifies whether autocomplete is applied to an editable text field. *)
  val get_autocomplete: 'tags this -> string [@@js.get "autocomplete"]
  
  (** Specifies whether autocomplete is applied to an editable text field. *)
  val set_autocomplete: 'tags this -> string -> unit [@@js.set "autocomplete"]
  
  (** Retrieves a collection, in source order, of all controls in a given form. *)
  val get_elements: 'tags this -> HTMLFormControlsCollection.t [@@js.get "elements"]
  
  (** Sets or retrieves the MIME encoding for the form. *)
  val get_encoding: 'tags this -> string [@@js.get "encoding"]
  
  (** Sets or retrieves the MIME encoding for the form. *)
  val set_encoding: 'tags this -> string -> unit [@@js.set "encoding"]
  
  (** Sets or retrieves the encoding type for the form. *)
  val get_enctype: 'tags this -> string [@@js.get "enctype"]
  
  (** Sets or retrieves the encoding type for the form. *)
  val set_enctype: 'tags this -> string -> unit [@@js.set "enctype"]
  
  (** Sets or retrieves the number of objects in a collection. *)
  val get_length: 'tags this -> float [@@js.get "length"]
  
  (** Sets or retrieves how to send the form data to the server. *)
  val get_method: 'tags this -> string [@@js.get "method"]
  
  (** Sets or retrieves how to send the form data to the server. *)
  val set_method: 'tags this -> string -> unit [@@js.set "method"]
  
  (** Sets or retrieves the name of the object. *)
  val get_name: 'tags this -> string [@@js.get "name"]
  
  (** Sets or retrieves the name of the object. *)
  val set_name: 'tags this -> string -> unit [@@js.set "name"]
  
  (** Designates a form that is not validated when submitted. *)
  val get_noValidate: 'tags this -> bool [@@js.get "noValidate"]
  
  (** Designates a form that is not validated when submitted. *)
  val set_noValidate: 'tags this -> bool -> unit [@@js.set "noValidate"]
  
  (** Sets or retrieves the window or frame at which to target content. *)
  val get_target: 'tags this -> string [@@js.get "target"]
  
  (** Sets or retrieves the window or frame at which to target content. *)
  val set_target: 'tags this -> string -> unit [@@js.set "target"]
  
  (** Returns whether a form will validate when it is submitted, without having to submit it. *)
  val checkValidity: 'tags this -> bool [@@js.call "checkValidity"]
  val reportValidity: 'tags this -> bool [@@js.call "reportValidity"]
  val requestSubmit: 'tags this -> ?submitter:HTMLElement.t option -> unit -> unit [@@js.call "requestSubmit"]
  
  (** Fires when the user resets a form. *)
  val reset: 'tags this -> unit [@@js.call "reset"]
  
  (** Fires when a FORM is about to be submitted. *)
  val submit: 'tags this -> unit [@@js.call "submit"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val get: 'tags this -> float -> Element.t [@@js.index_get]
  val set: 'tags this -> float -> Element.t -> unit [@@js.index_set]
  val get': 'tags this -> string -> any [@@js.index_get]
  val set': 'tags this -> string -> any -> unit [@@js.index_set]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Contains the descriptive information, or metadata, for a document. This object inherits all of the properties and methods described in the HTMLElement interface. *)
and[@js.scope "HTMLHeadElement"] HTMLHeadElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLHeadElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLHeadElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLHeadElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLHeadElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Provides special properties and methods for manipulating <img> elements. *)
and[@js.scope "HTMLImageElement"] HTMLImageElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLImageElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLImageElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLImageElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLImageElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    Sets or retrieves how the object is aligned with adjacent text.
    @deprecated 
  *)
  val get_align: 'tags this -> string [@@js.get "align"]
  
  (**
    Sets or retrieves how the object is aligned with adjacent text.
    @deprecated 
  *)
  val set_align: 'tags this -> string -> unit [@@js.set "align"]
  
  (** Sets or retrieves a text alternative to the graphic. *)
  val get_alt: 'tags this -> string [@@js.get "alt"]
  
  (** Sets or retrieves a text alternative to the graphic. *)
  val set_alt: 'tags this -> string -> unit [@@js.set "alt"]
  
  (**
    Specifies the properties of a border drawn around an object.
    @deprecated 
  *)
  val get_border: 'tags this -> string [@@js.get "border"]
  
  (**
    Specifies the properties of a border drawn around an object.
    @deprecated 
  *)
  val set_border: 'tags this -> string -> unit [@@js.set "border"]
  
  (** Retrieves whether the object is fully loaded. *)
  val get_complete: 'tags this -> bool [@@js.get "complete"]
  val get_crossOrigin: 'tags this -> string option [@@js.get "crossOrigin"]
  val set_crossOrigin: 'tags this -> string option -> unit [@@js.set "crossOrigin"]
  val get_currentSrc: 'tags this -> string [@@js.get "currentSrc"]
  val get_decoding: 'tags this -> ([`L_s130_async[@js "async"] | `L_s141_auto[@js "auto"] | `L_s778_sync[@js "sync"]] [@js.enum]) [@@js.get "decoding"]
  val set_decoding: 'tags this -> ([`U1 of ([`L_s130_async[@js "async"]] [@js.enum]) | `U2 of ([`L_s778_sync[@js "sync"]] [@js.enum]) | `U3 of ([`L_s141_auto[@js "auto"]] [@js.enum])] [@js.union]) -> unit [@@js.set "decoding"]
  
  (** Sets or retrieves the height of the object. *)
  val get_height: 'tags this -> float [@@js.get "height"]
  
  (** Sets or retrieves the height of the object. *)
  val set_height: 'tags this -> float -> unit [@@js.set "height"]
  
  (**
    Sets or retrieves the width of the border to draw around the object.
    @deprecated 
  *)
  val get_hspace: 'tags this -> float [@@js.get "hspace"]
  
  (**
    Sets or retrieves the width of the border to draw around the object.
    @deprecated 
  *)
  val set_hspace: 'tags this -> float -> unit [@@js.set "hspace"]
  
  (** Sets or retrieves whether the image is a server-side image map. *)
  val get_isMap: 'tags this -> bool [@@js.get "isMap"]
  
  (** Sets or retrieves whether the image is a server-side image map. *)
  val set_isMap: 'tags this -> bool -> unit [@@js.set "isMap"]
  
  (** Sets or retrieves the policy for loading image elements that are outside the viewport. *)
  val get_loading: 'tags this -> ([`L_s283_eager[@js "eager"] | `L_s454_lazy[@js "lazy"]] [@js.enum]) [@@js.get "loading"]
  
  (** Sets or retrieves the policy for loading image elements that are outside the viewport. *)
  val set_loading: 'tags this -> ([`U1 of ([`L_s283_eager[@js "eager"]] [@js.enum]) | `U2 of ([`L_s454_lazy[@js "lazy"]] [@js.enum])] [@js.union]) -> unit [@@js.set "loading"]
  
  (**
    Sets or retrieves a Uniform Resource Identifier (URI) to a long description of the object.
    @deprecated 
  *)
  val get_longDesc: 'tags this -> string [@@js.get "longDesc"]
  
  (**
    Sets or retrieves a Uniform Resource Identifier (URI) to a long description of the object.
    @deprecated 
  *)
  val set_longDesc: 'tags this -> string -> unit [@@js.set "longDesc"]
  
  (** @deprecated  *)
  val get_lowsrc: 'tags this -> string [@@js.get "lowsrc"]
  
  (** @deprecated  *)
  val set_lowsrc: 'tags this -> string -> unit [@@js.set "lowsrc"]
  
  (**
    Sets or retrieves the name of the object.
    @deprecated 
  *)
  val get_name: 'tags this -> string [@@js.get "name"]
  
  (**
    Sets or retrieves the name of the object.
    @deprecated 
  *)
  val set_name: 'tags this -> string -> unit [@@js.set "name"]
  
  (** The original height of the image resource before sizing. *)
  val get_naturalHeight: 'tags this -> float [@@js.get "naturalHeight"]
  
  (** The original width of the image resource before sizing. *)
  val get_naturalWidth: 'tags this -> float [@@js.get "naturalWidth"]
  val get_referrerPolicy: 'tags this -> string [@@js.get "referrerPolicy"]
  val set_referrerPolicy: 'tags this -> string -> unit [@@js.set "referrerPolicy"]
  val get_sizes: 'tags this -> string [@@js.get "sizes"]
  val set_sizes: 'tags this -> string -> unit [@@js.set "sizes"]
  
  (** The address or URL of the a media resource that is to be considered. *)
  val get_src: 'tags this -> string [@@js.get "src"]
  
  (** The address or URL of the a media resource that is to be considered. *)
  val set_src: 'tags this -> string -> unit [@@js.set "src"]
  val get_srcset: 'tags this -> string [@@js.get "srcset"]
  val set_srcset: 'tags this -> string -> unit [@@js.set "srcset"]
  
  (** Sets or retrieves the URL, often with a bookmark extension (#name), to use as a client-side image map. *)
  val get_useMap: 'tags this -> string [@@js.get "useMap"]
  
  (** Sets or retrieves the URL, often with a bookmark extension (#name), to use as a client-side image map. *)
  val set_useMap: 'tags this -> string -> unit [@@js.set "useMap"]
  
  (**
    Sets or retrieves the vertical margin for the object.
    @deprecated 
  *)
  val get_vspace: 'tags this -> float [@@js.get "vspace"]
  
  (**
    Sets or retrieves the vertical margin for the object.
    @deprecated 
  *)
  val set_vspace: 'tags this -> float -> unit [@@js.set "vspace"]
  
  (** Sets or retrieves the width of the object. *)
  val get_width: 'tags this -> float [@@js.get "width"]
  
  (** Sets or retrieves the width of the object. *)
  val set_width: 'tags this -> float -> unit [@@js.set "width"]
  val get_x: 'tags this -> float [@@js.get "x"]
  val get_y: 'tags this -> float [@@js.get "y"]
  val decode: 'tags this -> unit Promise.t_1 [@@js.call "decode"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Adds to HTMLElement the properties and methods needed to support basic media-related capabilities that are common to audio and video. *)
and[@js.scope "HTMLMediaElement"] HTMLMediaElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLMediaElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLMediaElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLMediaElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLMediaElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Gets or sets a value that indicates whether to start playing the media automatically. *)
  val get_autoplay: 'tags this -> bool [@@js.get "autoplay"]
  
  (** Gets or sets a value that indicates whether to start playing the media automatically. *)
  val set_autoplay: 'tags this -> bool -> unit [@@js.set "autoplay"]
  
  (** Gets a collection of buffered time ranges. *)
  val get_buffered: 'tags this -> TimeRanges.t [@@js.get "buffered"]
  
  (** Gets or sets a flag that indicates whether the client provides a set of controls for the media (in case the developer does not include controls for the player). *)
  val get_controls: 'tags this -> bool [@@js.get "controls"]
  
  (** Gets or sets a flag that indicates whether the client provides a set of controls for the media (in case the developer does not include controls for the player). *)
  val set_controls: 'tags this -> bool -> unit [@@js.set "controls"]
  val get_crossOrigin: 'tags this -> string option [@@js.get "crossOrigin"]
  val set_crossOrigin: 'tags this -> string option -> unit [@@js.set "crossOrigin"]
  
  (** Gets the address or URL of the current media resource that is selected by IHTMLMediaElement. *)
  val get_currentSrc: 'tags this -> string [@@js.get "currentSrc"]
  
  (** Gets or sets the current playback position, in seconds. *)
  val get_currentTime: 'tags this -> float [@@js.get "currentTime"]
  
  (** Gets or sets the current playback position, in seconds. *)
  val set_currentTime: 'tags this -> float -> unit [@@js.set "currentTime"]
  val get_defaultMuted: 'tags this -> bool [@@js.get "defaultMuted"]
  val set_defaultMuted: 'tags this -> bool -> unit [@@js.set "defaultMuted"]
  
  (** Gets or sets the default playback rate when the user is not using fast forward or reverse for a video or audio resource. *)
  val get_defaultPlaybackRate: 'tags this -> float [@@js.get "defaultPlaybackRate"]
  
  (** Gets or sets the default playback rate when the user is not using fast forward or reverse for a video or audio resource. *)
  val set_defaultPlaybackRate: 'tags this -> float -> unit [@@js.set "defaultPlaybackRate"]
  val get_disableRemotePlayback: 'tags this -> bool [@@js.get "disableRemotePlayback"]
  val set_disableRemotePlayback: 'tags this -> bool -> unit [@@js.set "disableRemotePlayback"]
  
  (** Returns the duration in seconds of the current media resource. A NaN value is returned if duration is not available, or Infinity if the media resource is streaming. *)
  val get_duration: 'tags this -> float [@@js.get "duration"]
  
  (** Gets information about whether the playback has ended or not. *)
  val get_ended: 'tags this -> bool [@@js.get "ended"]
  
  (** Returns an object representing the current error state of the audio or video element. *)
  val get_error: 'tags this -> MediaError.t option [@@js.get "error"]
  
  (** Gets or sets a flag to specify whether playback should restart after it completes. *)
  val get_loop: 'tags this -> bool [@@js.get "loop"]
  
  (** Gets or sets a flag to specify whether playback should restart after it completes. *)
  val set_loop: 'tags this -> bool -> unit [@@js.set "loop"]
  
  (** Available only in secure contexts. *)
  val get_mediaKeys: 'tags this -> MediaKeys.t option [@@js.get "mediaKeys"]
  
  (** Gets or sets a flag that indicates whether the audio (either audio or the audio track on video media) is muted. *)
  val get_muted: 'tags this -> bool [@@js.get "muted"]
  
  (** Gets or sets a flag that indicates whether the audio (either audio or the audio track on video media) is muted. *)
  val set_muted: 'tags this -> bool -> unit [@@js.set "muted"]
  
  (** Gets the current network activity for the element. *)
  val get_networkState: 'tags this -> float [@@js.get "networkState"]
  val get_onencrypted: 'tags this -> (this:t -> ev:MediaEncryptedEvent.t -> any) option [@@js.get "onencrypted"]
  val set_onencrypted: 'tags this -> (this:t -> ev:MediaEncryptedEvent.t -> any) option -> unit [@@js.set "onencrypted"]
  val get_onwaitingforkey: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onwaitingforkey"]
  val set_onwaitingforkey: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onwaitingforkey"]
  
  (** Gets a flag that specifies whether playback is paused. *)
  val get_paused: 'tags this -> bool [@@js.get "paused"]
  
  (** Gets or sets the current rate of speed for the media resource to play. This speed is expressed as a multiple of the normal speed of the media resource. *)
  val get_playbackRate: 'tags this -> float [@@js.get "playbackRate"]
  
  (** Gets or sets the current rate of speed for the media resource to play. This speed is expressed as a multiple of the normal speed of the media resource. *)
  val set_playbackRate: 'tags this -> float -> unit [@@js.set "playbackRate"]
  
  (** Gets TimeRanges for the current media resource that has been played. *)
  val get_played: 'tags this -> TimeRanges.t [@@js.get "played"]
  
  (** Gets or sets a value indicating what data should be preloaded, if any. *)
  val get_preload: 'tags this -> ([`L_s0[@js ""] | `L_s141_auto[@js "auto"] | `L_s512_metadata[@js "metadata"] | `L_s548_none[@js "none"]] [@js.enum]) [@@js.get "preload"]
  
  (** Gets or sets a value indicating what data should be preloaded, if any. *)
  val set_preload: 'tags this -> ([`U1 of ([`L_s548_none[@js "none"]] [@js.enum]) | `U2 of ([`L_s512_metadata[@js "metadata"]] [@js.enum]) | `U3 of ([`L_s141_auto[@js "auto"]] [@js.enum]) | `U4 of ([`L_s0[@js ""]] [@js.enum])] [@js.union]) -> unit [@@js.set "preload"]
  val get_readyState: 'tags this -> float [@@js.get "readyState"]
  val get_remote: 'tags this -> RemotePlayback.t [@@js.get "remote"]
  
  (** Returns a TimeRanges object that represents the ranges of the current media resource that can be seeked. *)
  val get_seekable: 'tags this -> TimeRanges.t [@@js.get "seekable"]
  
  (** Gets a flag that indicates whether the client is currently moving to a new playback position in the media resource. *)
  val get_seeking: 'tags this -> bool [@@js.get "seeking"]
  
  (** The address or URL of the a media resource that is to be considered. *)
  val get_src: 'tags this -> string [@@js.get "src"]
  
  (** The address or URL of the a media resource that is to be considered. *)
  val set_src: 'tags this -> string -> unit [@@js.set "src"]
  val get_srcObject: 'tags this -> MediaProvider.t option [@@js.get "srcObject"]
  val set_srcObject: 'tags this -> MediaProvider.t option -> unit [@@js.set "srcObject"]
  val get_textTracks: 'tags this -> TextTrackList.t [@@js.get "textTracks"]
  
  (** Gets or sets the volume level for audio portions of the media element. *)
  val get_volume: 'tags this -> float [@@js.get "volume"]
  
  (** Gets or sets the volume level for audio portions of the media element. *)
  val set_volume: 'tags this -> float -> unit [@@js.set "volume"]
  val addTextTrack: 'tags this -> kind:TextTrackKind.t -> ?label:string -> ?language:string -> unit -> TextTrack.t [@@js.call "addTextTrack"]
  
  (** Returns a string that specifies whether the client can play a given media resource type. *)
  val canPlayType: 'tags this -> type_:string -> CanPlayTypeResult.t [@@js.call "canPlayType"]
  val fastSeek: 'tags this -> time:float -> unit [@@js.call "fastSeek"]
  
  (** Resets the audio or video object and loads a new media resource. *)
  val load: 'tags this -> unit [@@js.call "load"]
  
  (** Pauses the current playback and sets paused to TRUE. This can be used to test whether the media is playing or paused. You can also use the pause or play events to tell whether the media is playing or not. *)
  val pause: 'tags this -> unit [@@js.call "pause"]
  
  (** Loads and starts playback of a media resource. *)
  val play: 'tags this -> unit Promise.t_1 [@@js.call "play"]
  
  (** Available only in secure contexts. *)
  val setMediaKeys: 'tags this -> mediaKeys:MediaKeys.t option -> unit Promise.t_1 [@@js.call "setMediaKeys"]
  val get_HAVE_CURRENT_DATA: 'tags this -> float [@@js.get "HAVE_CURRENT_DATA"]
  val get_HAVE_ENOUGH_DATA: 'tags this -> float [@@js.get "HAVE_ENOUGH_DATA"]
  val get_HAVE_FUTURE_DATA: 'tags this -> float [@@js.get "HAVE_FUTURE_DATA"]
  val get_HAVE_METADATA: 'tags this -> float [@@js.get "HAVE_METADATA"]
  val get_HAVE_NOTHING: 'tags this -> float [@@js.get "HAVE_NOTHING"]
  val get_NETWORK_EMPTY: 'tags this -> float [@@js.get "NETWORK_EMPTY"]
  val get_NETWORK_IDLE: 'tags this -> float [@@js.get "NETWORK_IDLE"]
  val get_NETWORK_LOADING: 'tags this -> float [@@js.get "NETWORK_LOADING"]
  val get_NETWORK_NO_SOURCE: 'tags this -> float [@@js.get "NETWORK_NO_SOURCE"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLMediaElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLMediaElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
  val have_current_data: unit -> float [@@js.get "HAVE_CURRENT_DATA"]
  val have_enough_data: unit -> float [@@js.get "HAVE_ENOUGH_DATA"]
  val have_future_data: unit -> float [@@js.get "HAVE_FUTURE_DATA"]
  val have_metadata: unit -> float [@@js.get "HAVE_METADATA"]
  val have_nothing: unit -> float [@@js.get "HAVE_NOTHING"]
  val network_empty: unit -> float [@@js.get "NETWORK_EMPTY"]
  val network_idle: unit -> float [@@js.get "NETWORK_IDLE"]
  val network_loading: unit -> float [@@js.get "NETWORK_LOADING"]
  val network_no_source: unit -> float [@@js.get "NETWORK_NO_SOURCE"]
end
and HTMLOrSVGImageElement : sig
  type t = (HTMLImageElement.t, SVGImageElement.t) union2
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
and HTMLOrSVGScriptElement : sig
  type t = (HTMLScriptElement.t, SVGScriptElement.t) union2
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end

(** HTML <script> elements expose the HTMLScriptElement interface, which provides special properties and methods for manipulating the behavior and execution of <script> elements (beyond the inherited HTMLElement interface). *)
and[@js.scope "HTMLScriptElement"] HTMLScriptElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLScriptElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLScriptElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLScriptElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLScriptElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_async: 'tags this -> bool [@@js.get "async"]
  val set_async: 'tags this -> bool -> unit [@@js.set "async"]
  
  (**
    Sets or retrieves the character set used to encode the object.
    @deprecated 
  *)
  val get_charset: 'tags this -> string [@@js.get "charset"]
  
  (**
    Sets or retrieves the character set used to encode the object.
    @deprecated 
  *)
  val set_charset: 'tags this -> string -> unit [@@js.set "charset"]
  val get_crossOrigin: 'tags this -> string option [@@js.get "crossOrigin"]
  val set_crossOrigin: 'tags this -> string option -> unit [@@js.set "crossOrigin"]
  
  (** Sets or retrieves the status of the script. *)
  val get_defer: 'tags this -> bool [@@js.get "defer"]
  
  (** Sets or retrieves the status of the script. *)
  val set_defer: 'tags this -> bool -> unit [@@js.set "defer"]
  
  (**
    Sets or retrieves the event for which the script is written.
    @deprecated 
  *)
  val get_event: 'tags this -> string [@@js.get "event"]
  
  (**
    Sets or retrieves the event for which the script is written.
    @deprecated 
  *)
  val set_event: 'tags this -> string -> unit [@@js.set "event"]
  
  (**
    Sets or retrieves the object that is bound to the event script.
    @deprecated 
  *)
  val get_htmlFor: 'tags this -> string [@@js.get "htmlFor"]
  
  (**
    Sets or retrieves the object that is bound to the event script.
    @deprecated 
  *)
  val set_htmlFor: 'tags this -> string -> unit [@@js.set "htmlFor"]
  val get_integrity: 'tags this -> string [@@js.get "integrity"]
  val set_integrity: 'tags this -> string -> unit [@@js.set "integrity"]
  val get_noModule: 'tags this -> bool [@@js.get "noModule"]
  val set_noModule: 'tags this -> bool -> unit [@@js.set "noModule"]
  val get_referrerPolicy: 'tags this -> string [@@js.get "referrerPolicy"]
  val set_referrerPolicy: 'tags this -> string -> unit [@@js.set "referrerPolicy"]
  
  (** Retrieves the URL to an external file that contains the source code or data. *)
  val get_src: 'tags this -> string [@@js.get "src"]
  
  (** Retrieves the URL to an external file that contains the source code or data. *)
  val set_src: 'tags this -> string -> unit [@@js.set "src"]
  
  (** Retrieves or sets the text of the object as a string. *)
  val get_text: 'tags this -> string [@@js.get "text"]
  
  (** Retrieves or sets the text of the object as a string. *)
  val set_text: 'tags this -> string -> unit [@@js.set "text"]
  
  (** Sets or retrieves the MIME type for the associated scripting engine. *)
  val get_type: 'tags this -> string [@@js.get "type"]
  
  (** Sets or retrieves the MIME type for the associated scripting engine. *)
  val set_type: 'tags this -> string -> unit [@@js.set "type"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
and[@js.scope "HTMLSlotElement"] HTMLSlotElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLSlotElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLSlotElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLSlotElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLSlotElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_name: 'tags this -> string [@@js.get "name"]
  val set_name: 'tags this -> string -> unit [@@js.set "name"]
  val assign: 'tags this -> nodes:(([`U1 of Element.t | `U2 of Text.t] [@js.union]) list [@js.variadic]) -> unit [@@js.call "assign"]
  val assignedElements: 'tags this -> ?options:AssignedNodesOptions.t -> unit -> Element.t list [@@js.call "assignedElements"]
  val assignedNodes: 'tags this -> ?options:AssignedNodesOptions.t -> unit -> Node.t list [@@js.call "assignedNodes"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Provides special properties and methods for manipulating video objects. It also inherits properties and methods of HTMLMediaElement and HTMLElement. *)
and[@js.scope "HTMLVideoElement"] HTMLVideoElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLMediaElement | `HTMLOrSVGElement | `HTMLVideoElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLMediaElement | `HTMLOrSVGElement | `HTMLVideoElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLMediaElement | `HTMLOrSVGElement | `HTMLVideoElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLVideoElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_disablePictureInPicture: 'tags this -> bool [@@js.get "disablePictureInPicture"]
  val set_disablePictureInPicture: 'tags this -> bool -> unit [@@js.set "disablePictureInPicture"]
  
  (** Gets or sets the height of the video element. *)
  val get_height: 'tags this -> float [@@js.get "height"]
  
  (** Gets or sets the height of the video element. *)
  val set_height: 'tags this -> float -> unit [@@js.set "height"]
  val get_onenterpictureinpicture: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onenterpictureinpicture"]
  val set_onenterpictureinpicture: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onenterpictureinpicture"]
  val get_onleavepictureinpicture: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onleavepictureinpicture"]
  val set_onleavepictureinpicture: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onleavepictureinpicture"]
  
  (** Gets or sets the playsinline of the video element. for example, On iPhone, video elements will now be allowed to play inline, and will not automatically enter fullscreen mode when playback begins. *)
  val get_playsInline: 'tags this -> bool [@@js.get "playsInline"]
  
  (** Gets or sets the playsinline of the video element. for example, On iPhone, video elements will now be allowed to play inline, and will not automatically enter fullscreen mode when playback begins. *)
  val set_playsInline: 'tags this -> bool -> unit [@@js.set "playsInline"]
  
  (** Gets or sets a URL of an image to display, for example, like a movie poster. This can be a still frame from the video, or another image if no video data is available. *)
  val get_poster: 'tags this -> string [@@js.get "poster"]
  
  (** Gets or sets a URL of an image to display, for example, like a movie poster. This can be a still frame from the video, or another image if no video data is available. *)
  val set_poster: 'tags this -> string -> unit [@@js.set "poster"]
  
  (** Gets the intrinsic height of a video in CSS pixels, or zero if the dimensions are not known. *)
  val get_videoHeight: 'tags this -> float [@@js.get "videoHeight"]
  
  (** Gets the intrinsic width of a video in CSS pixels, or zero if the dimensions are not known. *)
  val get_videoWidth: 'tags this -> float [@@js.get "videoWidth"]
  
  (** Gets or sets the width of the video element. *)
  val get_width: 'tags this -> float [@@js.get "width"]
  
  (** Gets or sets the width of the video element. *)
  val set_width: 'tags this -> float -> unit [@@js.set "width"]
  val getVideoPlaybackQuality: 'tags this -> VideoPlaybackQuality.t [@@js.call "getVideoPlaybackQuality"]
  val requestPictureInPicture: 'tags this -> PictureInPictureWindow.t Promise.t_1 [@@js.call "requestPictureInPicture"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLVideoElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLVideoElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
and[@js.scope "ImageBitmapRenderingContext"] ImageBitmapRenderingContext : sig
  type t = [`ImageBitmapRenderingContext] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ImageBitmapRenderingContext]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ImageBitmapRenderingContext]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ImageBitmapRenderingContext ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Returns the canvas element that the context is bound to. *)
  val get_canvas: 'tags this -> HTMLCanvasElement.t [@@js.get "canvas"]
  
  (** Transfers the underlying bitmap data from imageBitmap to context, and the bitmap becomes the contents of the canvas element to which context is bound. *)
  val transferFromImageBitmap: 'tags this -> bitmap:ImageBitmap.t option -> unit [@@js.call "transferFromImageBitmap"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
and ImageBitmapSource : sig
  type t = (Blob.t, CanvasImageSource.t, ImageData.t) union3
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
and[@js.scope "InputEvent"] InputEvent : sig
  type t = [`Event | `InputEvent | `UIEvent] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Event | `InputEvent | `UIEvent]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Event | `InputEvent | `UIEvent]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `InputEvent ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_data: 'tags this -> string option [@@js.get "data"]
  val get_dataTransfer: 'tags this -> DataTransfer.t option [@@js.get "dataTransfer"]
  val get_inputType: 'tags this -> string [@@js.get "inputType"]
  val get_isComposing: 'tags this -> bool [@@js.get "isComposing"]
  val getTargetRanges: 'tags this -> StaticRange.t list [@@js.call "getTargetRanges"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: type_:string -> ?eventInitDict:InputEventInit.t -> unit -> t [@@js.create]
end
and InputEventInit : sig
  type t = [`EventInit | `InputEventInit | `UIEventInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventInit | `InputEventInit | `UIEventInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventInit | `InputEventInit | `UIEventInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `InputEventInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_data: 'tags this -> string option option [@@js.get "data"]
  val set_data: 'tags this -> string option -> unit [@@js.set "data"]
  val get_dataTransfer: 'tags this -> DataTransfer.t option option [@@js.get "dataTransfer"]
  val set_dataTransfer: 'tags this -> DataTransfer.t option -> unit [@@js.set "dataTransfer"]
  val get_inputType: 'tags this -> string option [@@js.get "inputType"]
  val set_inputType: 'tags this -> string -> unit [@@js.set "inputType"]
  val get_isComposing: 'tags this -> bool option [@@js.get "isComposing"]
  val set_isComposing: 'tags this -> bool -> unit [@@js.set "isComposing"]
  val get_targetRanges: 'tags this -> StaticRange.t list option [@@js.get "targetRanges"]
  val set_targetRanges: 'tags this -> StaticRange.t list -> unit [@@js.set "targetRanges"]
  val create: ?data:string -> ?dataTransfer:DataTransfer.t -> ?inputType:string -> ?isComposing:bool -> ?targetRanges:StaticRange.t list -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** KeyboardEvent objects describe a user interaction with the keyboard; each event describes a single interaction between the user and a key (or combination of a key with modifier keys) on the keyboard. *)
and[@js.scope "KeyboardEvent"] KeyboardEvent : sig
  type t = [`Event | `KeyboardEvent | `UIEvent] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Event | `KeyboardEvent | `UIEvent]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Event | `KeyboardEvent | `UIEvent]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `KeyboardEvent ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_altKey: 'tags this -> bool [@@js.get "altKey"]
  
  (** @deprecated  *)
  val get_charCode: 'tags this -> float [@@js.get "charCode"]
  val get_code: 'tags this -> string [@@js.get "code"]
  val get_ctrlKey: 'tags this -> bool [@@js.get "ctrlKey"]
  val get_isComposing: 'tags this -> bool [@@js.get "isComposing"]
  val get_key: 'tags this -> string [@@js.get "key"]
  
  (** @deprecated  *)
  val get_keyCode: 'tags this -> float [@@js.get "keyCode"]
  val get_location: 'tags this -> float [@@js.get "location"]
  val get_metaKey: 'tags this -> bool [@@js.get "metaKey"]
  val get_repeat: 'tags this -> bool [@@js.get "repeat"]
  val get_shiftKey: 'tags this -> bool [@@js.get "shiftKey"]
  val getModifierState: 'tags this -> keyArg:string -> bool [@@js.call "getModifierState"]
  
  (** @deprecated  *)
  val initKeyboardEvent: 'tags this -> typeArg:string -> ?bubblesArg:bool -> ?cancelableArg:bool -> ?viewArg:Window.t option -> ?keyArg:string -> ?locationArg:float -> ?ctrlKey:bool -> ?altKey:bool -> ?shiftKey:bool -> ?metaKey:bool -> unit -> unit [@@js.call "initKeyboardEvent"]
  val get_DOM_KEY_LOCATION_LEFT: 'tags this -> float [@@js.get "DOM_KEY_LOCATION_LEFT"]
  val get_DOM_KEY_LOCATION_NUMPAD: 'tags this -> float [@@js.get "DOM_KEY_LOCATION_NUMPAD"]
  val get_DOM_KEY_LOCATION_RIGHT: 'tags this -> float [@@js.get "DOM_KEY_LOCATION_RIGHT"]
  val get_DOM_KEY_LOCATION_STANDARD: 'tags this -> float [@@js.get "DOM_KEY_LOCATION_STANDARD"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: type_:string -> ?eventInitDict:KeyboardEventInit.t -> unit -> t [@@js.create]
  val dom_key_location_left: unit -> float [@@js.get "DOM_KEY_LOCATION_LEFT"]
  val dom_key_location_numpad: unit -> float [@@js.get "DOM_KEY_LOCATION_NUMPAD"]
  val dom_key_location_right: unit -> float [@@js.get "DOM_KEY_LOCATION_RIGHT"]
  val dom_key_location_standard: unit -> float [@@js.get "DOM_KEY_LOCATION_STANDARD"]
end
and KeyboardEventInit : sig
  type t = [`EventInit | `EventModifierInit | `KeyboardEventInit | `UIEventInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventInit | `EventModifierInit | `KeyboardEventInit | `UIEventInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventInit | `EventModifierInit | `KeyboardEventInit | `UIEventInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `KeyboardEventInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** @deprecated  *)
  val get_charCode: 'tags this -> float option [@@js.get "charCode"]
  
  (** @deprecated  *)
  val set_charCode: 'tags this -> float -> unit [@@js.set "charCode"]
  val get_code: 'tags this -> string option [@@js.get "code"]
  val set_code: 'tags this -> string -> unit [@@js.set "code"]
  val get_isComposing: 'tags this -> bool option [@@js.get "isComposing"]
  val set_isComposing: 'tags this -> bool -> unit [@@js.set "isComposing"]
  val get_key: 'tags this -> string option [@@js.get "key"]
  val set_key: 'tags this -> string -> unit [@@js.set "key"]
  
  (** @deprecated  *)
  val get_keyCode: 'tags this -> float option [@@js.get "keyCode"]
  
  (** @deprecated  *)
  val set_keyCode: 'tags this -> float -> unit [@@js.set "keyCode"]
  val get_location: 'tags this -> float option [@@js.get "location"]
  val set_location: 'tags this -> float -> unit [@@js.set "location"]
  val get_repeat: 'tags this -> bool option [@@js.get "repeat"]
  val set_repeat: 'tags this -> bool -> unit [@@js.set "repeat"]
  val create: ?charCode:float -> ?code:string -> ?isComposing:bool -> ?key:string -> ?keyCode:float -> ?location:float -> ?repeat:bool -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
and LinkStyle : sig
  type t = [`LinkStyle] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`LinkStyle]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`LinkStyle]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `LinkStyle ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_sheet: 'tags this -> CSSStyleSheet.t option [@@js.get "sheet"]
  val create: ?sheet:CSSStyleSheet.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** A message received by a target object. *)
and[@js.scope "MessageEvent"] MessageEvent : sig
  type 'T t = [`Event | `MessageEvent of 'T] intf [@@js.custom { of_js=(fun _T -> Obj.magic); to_js=(fun _T -> Obj.magic) }]
  type 'T t_1 = 'T t
  type t_0 = any t
  [@@@js.stop]
  type 'T tags = [`Event | `MessageEvent of 'T]
  type 'T tags_1 = 'T tags
  type tags_0 = any tags
  [@@@js.start]
  [@@@js.implem 
    type 'T tags = [`Event | `MessageEvent of 'T]
    type 'T tags_1 = 'T tags
    type tags_0 = any tags
  ]
  type ('tags, 'T) this = 'tags intf constraint 'tags = [> `MessageEvent of 'T ]
  val t_to_js: ('T -> Ojs.t) -> 'T t -> Ojs.t
  val t_of_js: (Ojs.t -> 'T) -> Ojs.t -> 'T t
  val t_1_to_js: ('T -> Ojs.t) -> 'T t_1 -> Ojs.t
  val t_1_of_js: (Ojs.t -> 'T) -> Ojs.t -> 'T t_1
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** @deprecated  *)
  val initMessageEvent: ('tags, 'T) this -> type_:string -> ?bubbles:bool -> ?cancelable:bool -> ?data:any -> ?origin:string -> ?lastEventId:string -> ?source:MessageEventSource.t option -> ?ports:MessagePort.t Iterable.t_1 -> unit -> unit [@@js.call "initMessageEvent"]
  
  (** Returns the data of the message. *)
  val get_data: ('tags, 'T) this -> 'T [@@js.get "data"]
  
  (** Returns the last event ID string, for server-sent events. *)
  val get_lastEventId: ('tags, 'T) this -> string [@@js.get "lastEventId"]
  
  (** Returns the origin of the message, for server-sent events and cross-document messaging. *)
  val get_origin: ('tags, 'T) this -> string [@@js.get "origin"]
  
  (** Returns the MessagePort array sent with the message, for cross-document messaging and channel messaging. *)
  val get_ports: ('tags, 'T) this -> MessagePort.t list [@@js.get "ports"]
  
  (** Returns the WindowProxy of the source window, for cross-document messaging, and the MessagePort being attached, in the connect event fired at SharedWorkerGlobalScope objects. *)
  val get_source: ('tags, 'T) this -> MessageEventSource.t option [@@js.get "source"]
  
  (** @deprecated  *)
  val initMessageEvent': ('tags, 'T) this -> type_:string -> ?bubbles:bool -> ?cancelable:bool -> ?data:any -> ?origin:string -> ?lastEventId:string -> ?source:MessageEventSource.t option -> ?ports:MessagePort.t list -> unit -> unit [@@js.call "initMessageEvent"]
  val cast_from: ('tags, 'T) this -> 'T t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t_0 [@@js.get "prototype"]
  val create: type_:string -> ?eventInitDict:'T MessageEventInit.t -> unit -> 'T t [@@js.create]
end
and MessageEventInit : sig
  type 'T t = [`EventInit | `MessageEventInit of 'T] intf [@@js.custom { of_js=(fun _T -> Obj.magic); to_js=(fun _T -> Obj.magic) }]
  type 'T t_1 = 'T t
  type t_0 = any t
  [@@@js.stop]
  type 'T tags = [`EventInit | `MessageEventInit of 'T]
  type 'T tags_1 = 'T tags
  type tags_0 = any tags
  [@@@js.start]
  [@@@js.implem 
    type 'T tags = [`EventInit | `MessageEventInit of 'T]
    type 'T tags_1 = 'T tags
    type tags_0 = any tags
  ]
  type ('tags, 'T) this = 'tags intf constraint 'tags = [> `MessageEventInit of 'T ]
  val t_to_js: ('T -> Ojs.t) -> 'T t -> Ojs.t
  val t_of_js: (Ojs.t -> 'T) -> Ojs.t -> 'T t
  val t_1_to_js: ('T -> Ojs.t) -> 'T t_1 -> Ojs.t
  val t_1_of_js: (Ojs.t -> 'T) -> Ojs.t -> 'T t_1
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_data: ('tags, 'T) this -> 'T option [@@js.get "data"]
  val set_data: ('tags, 'T) this -> 'T -> unit [@@js.set "data"]
  val get_lastEventId: ('tags, 'T) this -> string option [@@js.get "lastEventId"]
  val set_lastEventId: ('tags, 'T) this -> string -> unit [@@js.set "lastEventId"]
  val get_origin: ('tags, 'T) this -> string option [@@js.get "origin"]
  val set_origin: ('tags, 'T) this -> string -> unit [@@js.set "origin"]
  val get_ports: ('tags, 'T) this -> MessagePort.t list option [@@js.get "ports"]
  val set_ports: ('tags, 'T) this -> MessagePort.t list -> unit [@@js.set "ports"]
  val get_source: ('tags, 'T) this -> MessageEventSource.t option option [@@js.get "source"]
  val set_source: ('tags, 'T) this -> MessageEventSource.t option -> unit [@@js.set "source"]
  val create: ?data:'T -> ?lastEventId:string -> ?origin:string -> ?ports:MessagePort.t list -> ?source:MessageEventSource.t -> unit -> 'T t [@@js.builder]
  val cast_from: ('tags, 'T) this -> 'T t [@@js.custom let cast_from = Obj.magic]
end
and MessageEventSource : sig
  type t = (MessagePort.t, ServiceWorker.t, WindowProxy.t) union3
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end

(** This Channel Messaging API interface represents one of the two ports of a MessageChannel, allowing messages to be sent from one port and listening out for them arriving at the other. *)
and[@js.scope "MessagePort"] MessagePort : sig
  type t = [`EventTarget | `MessagePort] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventTarget | `MessagePort]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventTarget | `MessagePort]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MessagePort ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_onmessage: 'tags this -> (this:t -> ev:MessageEvent.t_0 -> any) option [@@js.get "onmessage"]
  val set_onmessage: 'tags this -> (this:t -> ev:MessageEvent.t_0 -> any) option -> unit [@@js.set "onmessage"]
  val get_onmessageerror: 'tags this -> (this:t -> ev:MessageEvent.t_0 -> any) option [@@js.get "onmessageerror"]
  val set_onmessageerror: 'tags this -> (this:t -> ev:MessageEvent.t_0 -> any) option -> unit [@@js.set "onmessageerror"]
  
  (** Disconnects the port, so that it is no longer active. *)
  val close: 'tags this -> unit [@@js.call "close"]
  
  (**
    Posts a message through the channel. Objects listed in transfer are transferred, not just cloned, meaning that they are no longer usable on the sending side.
    
    Throws a "DataCloneError" DOMException if transfer contains duplicate objects or port, or if message could not be cloned.
  *)
  val postMessage: 'tags this -> message:any -> transfer:Transferable.t list -> unit [@@js.call "postMessage"]
  
  (**
    Posts a message through the channel. Objects listed in transfer are transferred, not just cloned, meaning that they are no longer usable on the sending side.
    
    Throws a "DataCloneError" DOMException if transfer contains duplicate objects or port, or if message could not be cloned.
  *)
  val postMessage': 'tags this -> message:any -> ?options:StructuredSerializeOptions.t -> unit -> unit [@@js.call "postMessage"]
  
  (** Begins dispatching messages received on the port. *)
  val start: 'tags this -> unit [@@js.call "start"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'MessagePortEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'MessagePortEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Events that occur due to the user interacting with a pointing device (such as a mouse). Common events using this interface include click, dblclick, mouseup, mousedown. *)
and[@js.scope "MouseEvent"] MouseEvent : sig
  type t = [`Event | `MouseEvent | `UIEvent] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Event | `MouseEvent | `UIEvent]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Event | `MouseEvent | `UIEvent]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MouseEvent ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_altKey: 'tags this -> bool [@@js.get "altKey"]
  val get_button: 'tags this -> float [@@js.get "button"]
  val get_buttons: 'tags this -> float [@@js.get "buttons"]
  val get_clientX: 'tags this -> float [@@js.get "clientX"]
  val get_clientY: 'tags this -> float [@@js.get "clientY"]
  val get_ctrlKey: 'tags this -> bool [@@js.get "ctrlKey"]
  val get_metaKey: 'tags this -> bool [@@js.get "metaKey"]
  val get_movementX: 'tags this -> float [@@js.get "movementX"]
  val get_movementY: 'tags this -> float [@@js.get "movementY"]
  val get_offsetX: 'tags this -> float [@@js.get "offsetX"]
  val get_offsetY: 'tags this -> float [@@js.get "offsetY"]
  val get_pageX: 'tags this -> float [@@js.get "pageX"]
  val get_pageY: 'tags this -> float [@@js.get "pageY"]
  val get_relatedTarget: 'tags this -> EventTarget.t option [@@js.get "relatedTarget"]
  val get_screenX: 'tags this -> float [@@js.get "screenX"]
  val get_screenY: 'tags this -> float [@@js.get "screenY"]
  val get_shiftKey: 'tags this -> bool [@@js.get "shiftKey"]
  val get_x: 'tags this -> float [@@js.get "x"]
  val get_y: 'tags this -> float [@@js.get "y"]
  val getModifierState: 'tags this -> keyArg:string -> bool [@@js.call "getModifierState"]
  
  (** @deprecated  *)
  val initMouseEvent: 'tags this -> typeArg:string -> canBubbleArg:bool -> cancelableArg:bool -> viewArg:Window.t -> detailArg:float -> screenXArg:float -> screenYArg:float -> clientXArg:float -> clientYArg:float -> ctrlKeyArg:bool -> altKeyArg:bool -> shiftKeyArg:bool -> metaKeyArg:bool -> buttonArg:float -> relatedTargetArg:EventTarget.t option -> unit [@@js.call "initMouseEvent"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: type_:string -> ?eventInitDict:MouseEventInit.t -> unit -> t [@@js.create]
end
and MouseEventInit : sig
  type t = [`EventInit | `EventModifierInit | `MouseEventInit | `UIEventInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventInit | `EventModifierInit | `MouseEventInit | `UIEventInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventInit | `EventModifierInit | `MouseEventInit | `UIEventInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MouseEventInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_button: 'tags this -> float option [@@js.get "button"]
  val set_button: 'tags this -> float -> unit [@@js.set "button"]
  val get_buttons: 'tags this -> float option [@@js.get "buttons"]
  val set_buttons: 'tags this -> float -> unit [@@js.set "buttons"]
  val get_clientX: 'tags this -> float option [@@js.get "clientX"]
  val set_clientX: 'tags this -> float -> unit [@@js.set "clientX"]
  val get_clientY: 'tags this -> float option [@@js.get "clientY"]
  val set_clientY: 'tags this -> float -> unit [@@js.set "clientY"]
  val get_movementX: 'tags this -> float option [@@js.get "movementX"]
  val set_movementX: 'tags this -> float -> unit [@@js.set "movementX"]
  val get_movementY: 'tags this -> float option [@@js.get "movementY"]
  val set_movementY: 'tags this -> float -> unit [@@js.set "movementY"]
  val get_relatedTarget: 'tags this -> EventTarget.t option option [@@js.get "relatedTarget"]
  val set_relatedTarget: 'tags this -> EventTarget.t option -> unit [@@js.set "relatedTarget"]
  val get_screenX: 'tags this -> float option [@@js.get "screenX"]
  val set_screenX: 'tags this -> float -> unit [@@js.set "screenX"]
  val get_screenY: 'tags this -> float option [@@js.get "screenY"]
  val set_screenY: 'tags this -> float -> unit [@@js.set "screenY"]
  val create: ?button:float -> ?buttons:float -> ?clientX:float -> ?clientY:float -> ?movementX:float -> ?movementY:float -> ?relatedTarget:EventTarget.t -> ?screenX:float -> ?screenY:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** Provides event properties that are specific to modifications to the Document Object Model (DOM) hierarchy and nodes. *)
and[@js.scope "MutationEvent"] MutationEvent : sig
  type t = [`Event | `MutationEvent] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Event | `MutationEvent]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Event | `MutationEvent]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MutationEvent ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** @deprecated  *)
  val get_attrChange: 'tags this -> float [@@js.get "attrChange"]
  
  (** @deprecated  *)
  val get_attrName: 'tags this -> string [@@js.get "attrName"]
  
  (** @deprecated  *)
  val get_newValue: 'tags this -> string [@@js.get "newValue"]
  
  (** @deprecated  *)
  val get_prevValue: 'tags this -> string [@@js.get "prevValue"]
  
  (** @deprecated  *)
  val get_relatedNode: 'tags this -> Node.t option [@@js.get "relatedNode"]
  
  (** @deprecated  *)
  val initMutationEvent: 'tags this -> typeArg:string -> ?bubblesArg:bool -> ?cancelableArg:bool -> ?relatedNodeArg:Node.t option -> ?prevValueArg:string -> ?newValueArg:string -> ?attrNameArg:string -> ?attrChangeArg:float -> unit -> unit [@@js.call "initMutationEvent"]
  val get_ADDITION: 'tags this -> float [@@js.get "ADDITION"]
  val get_MODIFICATION: 'tags this -> float [@@js.get "MODIFICATION"]
  val get_REMOVAL: 'tags this -> float [@@js.get "REMOVAL"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
  val addition: unit -> float [@@js.get "ADDITION"]
  val modification: unit -> float [@@js.get "MODIFICATION"]
  val removal: unit -> float [@@js.get "REMOVAL"]
end

(** A collection of Attr objects. Objects inside a NamedNodeMap are not in any particular order, unlike NodeList, although they may be accessed by an index as in an array. *)
and[@js.scope "NamedNodeMap"] NamedNodeMap : sig
  type t = [`NamedNodeMap | Attr.t ArrayLike.tags_1 | Attr.t IterableIterator.tags_1] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`NamedNodeMap | Attr.t ArrayLike.tags_1 | Attr.t IterableIterator.tags_1]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`NamedNodeMap | Attr.t ArrayLike.tags_1 | Attr.t IterableIterator.tags_1]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `NamedNodeMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  (* [Symbol.iterator]: unit -> Attr.t IterableIterator.t_1 *)
  val get_length: 'tags this -> float [@@js.get "length"]
  val getNamedItem: 'tags this -> qualifiedName:string -> Attr.t option [@@js.call "getNamedItem"]
  val getNamedItemNS: 'tags this -> namespace:string option -> localName:string -> Attr.t option [@@js.call "getNamedItemNS"]
  val item: 'tags this -> index:float -> Attr.t option [@@js.call "item"]
  val removeNamedItem: 'tags this -> qualifiedName:string -> Attr.t [@@js.call "removeNamedItem"]
  val removeNamedItemNS: 'tags this -> namespace:string option -> localName:string -> Attr.t [@@js.call "removeNamedItemNS"]
  val setNamedItem: 'tags this -> attr:Attr.t -> Attr.t option [@@js.call "setNamedItem"]
  val setNamedItemNS: 'tags this -> attr:Attr.t -> Attr.t option [@@js.call "setNamedItemNS"]
  val get: 'tags this -> float -> Attr.t [@@js.index_get]
  val set: 'tags this -> float -> Attr.t -> unit [@@js.index_set]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** The state and the identity of the user agent. It allows scripts to query it and to register themselves to carry on some activities. *)
and[@js.scope "Navigator"] Navigator : sig
  type t = [`Navigator | `NavigatorAutomationInformation | `NavigatorConcurrentHardware | `NavigatorContentUtils | `NavigatorCookies | `NavigatorID | `NavigatorLanguage | `NavigatorNetworkInformation | `NavigatorOnLine | `NavigatorPlugins | `NavigatorStorage] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Navigator | `NavigatorAutomationInformation | `NavigatorConcurrentHardware | `NavigatorContentUtils | `NavigatorCookies | `NavigatorID | `NavigatorLanguage | `NavigatorNetworkInformation | `NavigatorOnLine | `NavigatorPlugins | `NavigatorStorage]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Navigator | `NavigatorAutomationInformation | `NavigatorConcurrentHardware | `NavigatorContentUtils | `NavigatorCookies | `NavigatorID | `NavigatorLanguage | `NavigatorNetworkInformation | `NavigatorOnLine | `NavigatorPlugins | `NavigatorStorage]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `Navigator ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Available only in secure contexts. *)
  val requestMediaKeySystemAccess: 'tags this -> keySystem:string -> supportedConfigurations:MediaKeySystemConfiguration.t Iterable.t_1 -> MediaKeySystemAccess.t Promise.t_1 [@@js.call "requestMediaKeySystemAccess"]
  val vibrate: 'tags this -> pattern:float Iterable.t_1 -> bool [@@js.call "vibrate"]
  
  (** Available only in secure contexts. *)
  val get_clipboard: 'tags this -> Clipboard.t [@@js.get "clipboard"]
  
  (** Available only in secure contexts. *)
  val get_credentials: 'tags this -> CredentialsContainer.t [@@js.get "credentials"]
  val get_doNotTrack: 'tags this -> string option [@@js.get "doNotTrack"]
  val get_geolocation: 'tags this -> Geolocation.t [@@js.get "geolocation"]
  val get_maxTouchPoints: 'tags this -> float [@@js.get "maxTouchPoints"]
  val get_mediaCapabilities: 'tags this -> MediaCapabilities.t [@@js.get "mediaCapabilities"]
  
  (** Available only in secure contexts. *)
  val get_mediaDevices: 'tags this -> MediaDevices.t [@@js.get "mediaDevices"]
  val get_mediaSession: 'tags this -> MediaSession.t [@@js.get "mediaSession"]
  val get_permissions: 'tags this -> Permissions.t [@@js.get "permissions"]
  
  (** Available only in secure contexts. *)
  val get_serviceWorker: 'tags this -> ServiceWorkerContainer.t [@@js.get "serviceWorker"]
  
  (** Available only in secure contexts. *)
  val canShare: 'tags this -> ?data:ShareData.t -> unit -> bool [@@js.call "canShare"]
  val getGamepads: 'tags this -> Gamepad.t option list [@@js.call "getGamepads"]
  
  (** Available only in secure contexts. *)
  val requestMediaKeySystemAccess': 'tags this -> keySystem:string -> supportedConfigurations:MediaKeySystemConfiguration.t list -> MediaKeySystemAccess.t Promise.t_1 [@@js.call "requestMediaKeySystemAccess"]
  val sendBeacon: 'tags this -> url:([`U1 of string | `U2 of URL.t] [@js.union]) -> ?data:BodyInit.t option -> unit -> bool [@@js.call "sendBeacon"]
  
  (** Available only in secure contexts. *)
  val share: 'tags this -> ?data:ShareData.t -> unit -> unit Promise.t_1 [@@js.call "share"]
  val vibrate': 'tags this -> pattern:VibratePattern.t -> bool [@@js.call "vibrate"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Node is an interface from which a number of DOM API object types inherit. It allows those types to be treated similarly; for example, inheriting the same set of methods, or being tested in the same way. *)
and[@js.scope "Node"] Node : sig
  type t = [`EventTarget | `Node] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventTarget | `Node]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventTarget | `Node]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `Node ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Returns node's node document's document base URL. *)
  val get_baseURI: 'tags this -> string [@@js.get "baseURI"]
  
  (** Returns the children. *)
  val get_childNodes: 'tags this -> ChildNode.t NodeListOf.t [@@js.get "childNodes"]
  
  (** Returns the first child. *)
  val get_firstChild: 'tags this -> ChildNode.t option [@@js.get "firstChild"]
  
  (** Returns true if node is connected and false otherwise. *)
  val get_isConnected: 'tags this -> bool [@@js.get "isConnected"]
  
  (** Returns the last child. *)
  val get_lastChild: 'tags this -> ChildNode.t option [@@js.get "lastChild"]
  
  (** Returns the next sibling. *)
  val get_nextSibling: 'tags this -> ChildNode.t option [@@js.get "nextSibling"]
  
  (** Returns a string appropriate for the type of node. *)
  val get_nodeName: 'tags this -> string [@@js.get "nodeName"]
  
  (** Returns the type of node. *)
  val get_nodeType: 'tags this -> float [@@js.get "nodeType"]
  val get_nodeValue: 'tags this -> string option [@@js.get "nodeValue"]
  val set_nodeValue: 'tags this -> string option -> unit [@@js.set "nodeValue"]
  
  (** Returns the node document. Returns null for documents. *)
  val get_ownerDocument: 'tags this -> Document.t option [@@js.get "ownerDocument"]
  
  (** Returns the parent element. *)
  val get_parentElement: 'tags this -> HTMLElement.t option [@@js.get "parentElement"]
  
  (** Returns the parent. *)
  val get_parentNode: 'tags this -> ParentNode.t option [@@js.get "parentNode"]
  
  (** Returns the previous sibling. *)
  val get_previousSibling: 'tags this -> ChildNode.t option [@@js.get "previousSibling"]
  val get_textContent: 'tags this -> string option [@@js.get "textContent"]
  val set_textContent: 'tags this -> string option -> unit [@@js.set "textContent"]
  val appendChild: 'tags this -> node:'T -> 'T [@@js.call "appendChild"]
  
  (** Returns a copy of node. If deep is true, the copy also includes the node's descendants. *)
  val cloneNode: 'tags this -> ?deep:bool -> unit -> t [@@js.call "cloneNode"]
  
  (** Returns a bitmask indicating the position of other relative to node. *)
  val compareDocumentPosition: 'tags this -> other:t -> float [@@js.call "compareDocumentPosition"]
  
  (** Returns true if other is an inclusive descendant of node, and false otherwise. *)
  val contains: 'tags this -> other:t option -> bool [@@js.call "contains"]
  
  (** Returns node's root. *)
  val getRootNode: 'tags this -> ?options:GetRootNodeOptions.t -> unit -> t [@@js.call "getRootNode"]
  
  (** Returns whether node has children. *)
  val hasChildNodes: 'tags this -> bool [@@js.call "hasChildNodes"]
  val insertBefore: 'tags this -> node:'T -> child:t option -> 'T [@@js.call "insertBefore"]
  val isDefaultNamespace: 'tags this -> namespace:string option -> bool [@@js.call "isDefaultNamespace"]
  
  (** Returns whether node and otherNode have the same properties. *)
  val isEqualNode: 'tags this -> otherNode:t option -> bool [@@js.call "isEqualNode"]
  val isSameNode: 'tags this -> otherNode:t option -> bool [@@js.call "isSameNode"]
  val lookupNamespaceURI: 'tags this -> prefix:string option -> string option [@@js.call "lookupNamespaceURI"]
  val lookupPrefix: 'tags this -> namespace:string option -> string option [@@js.call "lookupPrefix"]
  
  (** Removes empty exclusive Text nodes and concatenates the data of remaining contiguous exclusive Text nodes into the first of their nodes. *)
  val normalize: 'tags this -> unit [@@js.call "normalize"]
  val removeChild: 'tags this -> child:'T -> 'T [@@js.call "removeChild"]
  val replaceChild: 'tags this -> node:t -> child:'T -> 'T [@@js.call "replaceChild"]
  val get_ATTRIBUTE_NODE: 'tags this -> float [@@js.get "ATTRIBUTE_NODE"]
  
  (** node is a CDATASection node. *)
  val get_CDATA_SECTION_NODE: 'tags this -> float [@@js.get "CDATA_SECTION_NODE"]
  
  (** node is a Comment node. *)
  val get_COMMENT_NODE: 'tags this -> float [@@js.get "COMMENT_NODE"]
  
  (** node is a DocumentFragment node. *)
  val get_DOCUMENT_FRAGMENT_NODE: 'tags this -> float [@@js.get "DOCUMENT_FRAGMENT_NODE"]
  
  (** node is a document. *)
  val get_DOCUMENT_NODE: 'tags this -> float [@@js.get "DOCUMENT_NODE"]
  
  (** Set when other is a descendant of node. *)
  val get_DOCUMENT_POSITION_CONTAINED_BY: 'tags this -> float [@@js.get "DOCUMENT_POSITION_CONTAINED_BY"]
  
  (** Set when other is an ancestor of node. *)
  val get_DOCUMENT_POSITION_CONTAINS: 'tags this -> float [@@js.get "DOCUMENT_POSITION_CONTAINS"]
  
  (** Set when node and other are not in the same tree. *)
  val get_DOCUMENT_POSITION_DISCONNECTED: 'tags this -> float [@@js.get "DOCUMENT_POSITION_DISCONNECTED"]
  
  (** Set when other is following node. *)
  val get_DOCUMENT_POSITION_FOLLOWING: 'tags this -> float [@@js.get "DOCUMENT_POSITION_FOLLOWING"]
  val get_DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: 'tags this -> float [@@js.get "DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC"]
  
  (** Set when other is preceding node. *)
  val get_DOCUMENT_POSITION_PRECEDING: 'tags this -> float [@@js.get "DOCUMENT_POSITION_PRECEDING"]
  
  (** node is a doctype. *)
  val get_DOCUMENT_TYPE_NODE: 'tags this -> float [@@js.get "DOCUMENT_TYPE_NODE"]
  
  (** node is an element. *)
  val get_ELEMENT_NODE: 'tags this -> float [@@js.get "ELEMENT_NODE"]
  val get_ENTITY_NODE: 'tags this -> float [@@js.get "ENTITY_NODE"]
  val get_ENTITY_REFERENCE_NODE: 'tags this -> float [@@js.get "ENTITY_REFERENCE_NODE"]
  val get_NOTATION_NODE: 'tags this -> float [@@js.get "NOTATION_NODE"]
  
  (** node is a ProcessingInstruction node. *)
  val get_PROCESSING_INSTRUCTION_NODE: 'tags this -> float [@@js.get "PROCESSING_INSTRUCTION_NODE"]
  
  (** node is a Text node. *)
  val get_TEXT_NODE: 'tags this -> float [@@js.get "TEXT_NODE"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
  val attribute_node: unit -> float [@@js.get "ATTRIBUTE_NODE"]
  
  (** node is a CDATASection node. *)
  val cdata_section_node: unit -> float [@@js.get "CDATA_SECTION_NODE"]
  
  (** node is a Comment node. *)
  val comment_node: unit -> float [@@js.get "COMMENT_NODE"]
  
  (** node is a DocumentFragment node. *)
  val document_fragment_node: unit -> float [@@js.get "DOCUMENT_FRAGMENT_NODE"]
  
  (** node is a document. *)
  val document_node: unit -> float [@@js.get "DOCUMENT_NODE"]
  
  (** Set when other is a descendant of node. *)
  val document_position_contained_by: unit -> float [@@js.get "DOCUMENT_POSITION_CONTAINED_BY"]
  
  (** Set when other is an ancestor of node. *)
  val document_position_contains: unit -> float [@@js.get "DOCUMENT_POSITION_CONTAINS"]
  
  (** Set when node and other are not in the same tree. *)
  val document_position_disconnected: unit -> float [@@js.get "DOCUMENT_POSITION_DISCONNECTED"]
  
  (** Set when other is following node. *)
  val document_position_following: unit -> float [@@js.get "DOCUMENT_POSITION_FOLLOWING"]
  val document_position_implementation_specific: unit -> float [@@js.get "DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC"]
  
  (** Set when other is preceding node. *)
  val document_position_preceding: unit -> float [@@js.get "DOCUMENT_POSITION_PRECEDING"]
  
  (** node is a doctype. *)
  val document_type_node: unit -> float [@@js.get "DOCUMENT_TYPE_NODE"]
  
  (** node is an element. *)
  val element_node: unit -> float [@@js.get "ELEMENT_NODE"]
  val entity_node: unit -> float [@@js.get "ENTITY_NODE"]
  val entity_reference_node: unit -> float [@@js.get "ENTITY_REFERENCE_NODE"]
  val notation_node: unit -> float [@@js.get "NOTATION_NODE"]
  
  (** node is a ProcessingInstruction node. *)
  val processing_instruction_node: unit -> float [@@js.get "PROCESSING_INSTRUCTION_NODE"]
  
  (** node is a Text node. *)
  val text_node: unit -> float [@@js.get "TEXT_NODE"]
end
and[@js.scope "NodeFilter"] NodeFilter : sig
  module AnonymousInterface545 : sig
    type t = private Ojs.t
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    val acceptNode: t -> node:Node.t -> float [@@js.call "acceptNode"]
  end
  type t = (AnonymousInterface545.t, (Node.t -> float)) union2
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val filter_accept: unit -> float [@@js.get "FILTER_ACCEPT"]
  val filter_reject: unit -> float [@@js.get "FILTER_REJECT"]
  val filter_skip: unit -> float [@@js.get "FILTER_SKIP"]
  val show_all: unit -> float [@@js.get "SHOW_ALL"]
  val show_attribute: unit -> float [@@js.get "SHOW_ATTRIBUTE"]
  val show_cdata_section: unit -> float [@@js.get "SHOW_CDATA_SECTION"]
  val show_comment: unit -> float [@@js.get "SHOW_COMMENT"]
  val show_document: unit -> float [@@js.get "SHOW_DOCUMENT"]
  val show_document_fragment: unit -> float [@@js.get "SHOW_DOCUMENT_FRAGMENT"]
  val show_document_type: unit -> float [@@js.get "SHOW_DOCUMENT_TYPE"]
  val show_element: unit -> float [@@js.get "SHOW_ELEMENT"]
  val show_entity: unit -> float [@@js.get "SHOW_ENTITY"]
  val show_entity_reference: unit -> float [@@js.get "SHOW_ENTITY_REFERENCE"]
  val show_notation: unit -> float [@@js.get "SHOW_NOTATION"]
  val show_processing_instruction: unit -> float [@@js.get "SHOW_PROCESSING_INSTRUCTION"]
  val show_text: unit -> float [@@js.get "SHOW_TEXT"]
end

(** An iterator over the members of a list of the nodes in a subtree of the DOM. The nodes will be returned in document order. *)
and[@js.scope "NodeIterator"] NodeIterator : sig
  type t = [`NodeIterator] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`NodeIterator]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`NodeIterator]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `NodeIterator ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_filter: 'tags this -> NodeFilter.t option [@@js.get "filter"]
  val get_pointerBeforeReferenceNode: 'tags this -> bool [@@js.get "pointerBeforeReferenceNode"]
  val get_referenceNode: 'tags this -> Node.t [@@js.get "referenceNode"]
  val get_root: 'tags this -> Node.t [@@js.get "root"]
  val get_whatToShow: 'tags this -> float [@@js.get "whatToShow"]
  
  (** @deprecated  *)
  val detach: 'tags this -> unit [@@js.call "detach"]
  val nextNode: 'tags this -> Node.t option [@@js.call "nextNode"]
  val previousNode: 'tags this -> Node.t option [@@js.call "previousNode"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** NodeList objects are collections of nodes, usually returned by properties such as Node.childNodes and methods such as document.querySelectorAll(). *)
and[@js.scope "NodeList"] NodeList : sig
  type t = [`NodeList | Node.t ArrayLike.tags_1 | Node.t IterableIterator.tags_1] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`NodeList | Node.t ArrayLike.tags_1 | Node.t IterableIterator.tags_1]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`NodeList | Node.t ArrayLike.tags_1 | Node.t IterableIterator.tags_1]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `NodeList ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  (* [Symbol.iterator]: unit -> Node.t IterableIterator.t_1 *)
  
  (** Returns an array of key, value pairs for every entry in the list. *)
  val entries: 'tags this -> (float * Node.t) IterableIterator.t_1 [@@js.call "entries"]
  
  (** Returns an list of keys in the list. *)
  val keys: 'tags this -> float IterableIterator.t_1 [@@js.call "keys"]
  
  (** Returns an list of values in the list. *)
  val values: 'tags this -> Node.t IterableIterator.t_1 [@@js.call "values"]
  
  (** Returns the number of nodes in the collection. *)
  val get_length: 'tags this -> float [@@js.get "length"]
  
  (** Returns the node with index index from the collection. The nodes are sorted in tree order. *)
  val item: 'tags this -> index:float -> Node.t option [@@js.call "item"]
  
  (**
    Performs the specified action for each node in an list.
    @param callbackfn A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the list.
    @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
  *)
  val forEach: 'tags this -> callbackfn:(value:Node.t -> key:float -> parent:t -> unit) -> ?thisArg:any -> unit -> unit [@@js.call "forEach"]
  val get: 'tags this -> float -> Node.t [@@js.index_get]
  val set: 'tags this -> float -> Node.t -> unit [@@js.index_set]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
and NodeListOf : sig
  type 'TNode t = [`NodeList | `NodeListOf of 'TNode | 'TNode ArrayLike.tags_1 | 'TNode IterableIterator.tags_1] intf [@@js.custom { of_js=(fun _TNode -> Obj.magic); to_js=(fun _TNode -> Obj.magic) }]
  type 'TNode t_1 = 'TNode t
  [@@@js.stop]
  type 'TNode tags = [`NodeList | `NodeListOf of 'TNode | 'TNode ArrayLike.tags_1 | 'TNode IterableIterator.tags_1]
  type 'TNode tags_1 = 'TNode tags
  [@@@js.start]
  [@@@js.implem 
    type 'TNode tags = [`NodeList | `NodeListOf of 'TNode | 'TNode ArrayLike.tags_1 | 'TNode IterableIterator.tags_1]
    type 'TNode tags_1 = 'TNode tags
  ]
  type ('tags, 'TNode) this = 'tags intf constraint 'tags = [> `NodeListOf of 'TNode ]
  val t_to_js: ('TNode -> Ojs.t) -> 'TNode t -> Ojs.t
  val t_of_js: (Ojs.t -> 'TNode) -> Ojs.t -> 'TNode t
  val t_1_to_js: ('TNode -> Ojs.t) -> 'TNode t_1 -> Ojs.t
  val t_1_of_js: (Ojs.t -> 'TNode) -> Ojs.t -> 'TNode t_1
  (* [Symbol.iterator]: unit -> 'TNode IterableIterator.t_1 *)
  
  (** Returns an array of key, value pairs for every entry in the list. *)
  val entries: ('tags, 'TNode) this -> (float * 'TNode) IterableIterator.t_1 [@@js.call "entries"]
  
  (** Returns an list of keys in the list. *)
  val keys: ('tags, 'TNode) this -> float IterableIterator.t_1 [@@js.call "keys"]
  
  (** Returns an list of values in the list. *)
  val values: ('tags, 'TNode) this -> 'TNode IterableIterator.t_1 [@@js.call "values"]
  
  (** Returns the node with index index from the collection. The nodes are sorted in tree order. *)
  val item: ('tags, 'TNode) this -> index:float -> 'TNode [@@js.call "item"]
  
  (**
    Performs the specified action for each node in an list.
    @param callbackfn A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the list.
    @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
  *)
  val forEach: ('tags, 'TNode) this -> callbackfn:(value:'TNode -> key:float -> parent:'TNode t -> unit) -> ?thisArg:any -> unit -> unit [@@js.call "forEach"]
  val get: ('tags, 'TNode) this -> float -> 'TNode [@@js.index_get]
  val set: ('tags, 'TNode) this -> float -> 'TNode -> unit [@@js.index_set]
  val cast_from: ('tags, 'TNode) this -> 'TNode t [@@js.custom let cast_from = Obj.magic]
end
and NonDocumentTypeChildNode : sig
  type t = [`NonDocumentTypeChildNode] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`NonDocumentTypeChildNode]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`NonDocumentTypeChildNode]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `NonDocumentTypeChildNode ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Returns the first following sibling that is an element, and null otherwise. *)
  val get_nextElementSibling: 'tags this -> Element.t option [@@js.get "nextElementSibling"]
  
  (** Returns the first preceding sibling that is an element, and null otherwise. *)
  val get_previousElementSibling: 'tags this -> Element.t option [@@js.get "previousElementSibling"]
  val create: ?nextElementSibling:Element.t -> ?previousElementSibling:Element.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
and NonElementParentNode : sig
  type t = [`NonElementParentNode] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`NonElementParentNode]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`NonElementParentNode]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `NonElementParentNode ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Returns the first element within node's descendants whose ID is elementId. *)
  val getElementById: 'tags this -> elementId:string -> Element.t option [@@js.call "getElementById"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
and ParentNode : sig
  type t = [`EventTarget | `Node | `ParentNode] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventTarget | `Node | `ParentNode]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventTarget | `Node | `ParentNode]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ParentNode ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_childElementCount: 'tags this -> float [@@js.get "childElementCount"]
  
  (** Returns the child elements. *)
  val get_children: 'tags this -> HTMLCollection.t [@@js.get "children"]
  
  (** Returns the first child that is an element, and null otherwise. *)
  val get_firstElementChild: 'tags this -> Element.t option [@@js.get "firstElementChild"]
  
  (** Returns the last child that is an element, and null otherwise. *)
  val get_lastElementChild: 'tags this -> Element.t option [@@js.get "lastElementChild"]
  
  (**
    Inserts nodes after the last child of node, while replacing strings in nodes with equivalent Text nodes.
    
    Throws a "HierarchyRequestError" DOMException if the constraints of the node tree are violated.
  *)
  val append: 'tags this -> nodes:(([`U1 of Node.t | `U2 of string] [@js.union]) list [@js.variadic]) -> unit [@@js.call "append"]
  
  (**
    Inserts nodes before the first child of node, while replacing strings in nodes with equivalent Text nodes.
    
    Throws a "HierarchyRequestError" DOMException if the constraints of the node tree are violated.
  *)
  val prepend: 'tags this -> nodes:(([`U1 of Node.t | `U2 of string] [@js.union]) list [@js.variadic]) -> unit [@@js.call "prepend"]
  
  (** Returns the first element that is a descendant of node that matches selectors. *)
  val querySelector: 'tags this -> selectors:'K -> (* FIXME: unknown type 'HTMLElementTagNameMap[K]' *)any option [@@js.call "querySelector"]
  
  (** Returns the first element that is a descendant of node that matches selectors. *)
  val querySelector': 'tags this -> selectors:'K -> (* FIXME: unknown type 'SVGElementTagNameMap[K]' *)any option [@@js.call "querySelector"]
  
  (** Returns the first element that is a descendant of node that matches selectors. *)
  val querySelector'': 'tags this -> selectors:string -> 'E option [@@js.call "querySelector"]
  
  (** Returns all element descendants of node that match selectors. *)
  val querySelectorAll: 'tags this -> selectors:'K -> (* FIXME: unknown type 'HTMLElementTagNameMap[K]' *)any NodeListOf.t [@@js.call "querySelectorAll"]
  
  (** Returns all element descendants of node that match selectors. *)
  val querySelectorAll': 'tags this -> selectors:'K -> (* FIXME: unknown type 'SVGElementTagNameMap[K]' *)any NodeListOf.t [@@js.call "querySelectorAll"]
  
  (** Returns all element descendants of node that match selectors. *)
  val querySelectorAll'': 'tags this -> selectors:string -> 'E NodeListOf.t [@@js.call "querySelectorAll"]
  
  (**
    Replace all children of node with nodes, while replacing strings in nodes with equivalent Text nodes.
    
    Throws a "HierarchyRequestError" DOMException if the constraints of the node tree are violated.
  *)
  val replaceChildren: 'tags this -> nodes:(([`U1 of Node.t | `U2 of string] [@js.union]) list [@js.variadic]) -> unit [@@js.call "replaceChildren"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** The state of a DOM event produced by a pointer such as the geometry of the contact point, the device type that generated the event, the amount of pressure that was applied on the contact surface, etc. *)
and[@js.scope "PointerEvent"] PointerEvent : sig
  type t = [`Event | `MouseEvent | `PointerEvent | `UIEvent] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Event | `MouseEvent | `PointerEvent | `UIEvent]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Event | `MouseEvent | `PointerEvent | `UIEvent]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PointerEvent ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_height: 'tags this -> float [@@js.get "height"]
  val get_isPrimary: 'tags this -> bool [@@js.get "isPrimary"]
  val get_pointerId: 'tags this -> float [@@js.get "pointerId"]
  val get_pointerType: 'tags this -> string [@@js.get "pointerType"]
  val get_pressure: 'tags this -> float [@@js.get "pressure"]
  val get_tangentialPressure: 'tags this -> float [@@js.get "tangentialPressure"]
  val get_tiltX: 'tags this -> float [@@js.get "tiltX"]
  val get_tiltY: 'tags this -> float [@@js.get "tiltY"]
  val get_twist: 'tags this -> float [@@js.get "twist"]
  val get_width: 'tags this -> float [@@js.get "width"]
  
  (** Available only in secure contexts. *)
  val getCoalescedEvents: 'tags this -> t list [@@js.call "getCoalescedEvents"]
  val getPredictedEvents: 'tags this -> t list [@@js.call "getPredictedEvents"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: type_:string -> ?eventInitDict:PointerEventInit.t -> unit -> t [@@js.create]
end
and PointerEventInit : sig
  type t = [`EventInit | `EventModifierInit | `MouseEventInit | `PointerEventInit | `UIEventInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventInit | `EventModifierInit | `MouseEventInit | `PointerEventInit | `UIEventInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventInit | `EventModifierInit | `MouseEventInit | `PointerEventInit | `UIEventInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PointerEventInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_coalescedEvents: 'tags this -> PointerEvent.t list option [@@js.get "coalescedEvents"]
  val set_coalescedEvents: 'tags this -> PointerEvent.t list -> unit [@@js.set "coalescedEvents"]
  val get_height: 'tags this -> float option [@@js.get "height"]
  val set_height: 'tags this -> float -> unit [@@js.set "height"]
  val get_isPrimary: 'tags this -> bool option [@@js.get "isPrimary"]
  val set_isPrimary: 'tags this -> bool -> unit [@@js.set "isPrimary"]
  val get_pointerId: 'tags this -> float option [@@js.get "pointerId"]
  val set_pointerId: 'tags this -> float -> unit [@@js.set "pointerId"]
  val get_pointerType: 'tags this -> string option [@@js.get "pointerType"]
  val set_pointerType: 'tags this -> string -> unit [@@js.set "pointerType"]
  val get_predictedEvents: 'tags this -> PointerEvent.t list option [@@js.get "predictedEvents"]
  val set_predictedEvents: 'tags this -> PointerEvent.t list -> unit [@@js.set "predictedEvents"]
  val get_pressure: 'tags this -> float option [@@js.get "pressure"]
  val set_pressure: 'tags this -> float -> unit [@@js.set "pressure"]
  val get_tangentialPressure: 'tags this -> float option [@@js.get "tangentialPressure"]
  val set_tangentialPressure: 'tags this -> float -> unit [@@js.set "tangentialPressure"]
  val get_tiltX: 'tags this -> float option [@@js.get "tiltX"]
  val set_tiltX: 'tags this -> float -> unit [@@js.set "tiltX"]
  val get_tiltY: 'tags this -> float option [@@js.get "tiltY"]
  val set_tiltY: 'tags this -> float -> unit [@@js.set "tiltY"]
  val get_twist: 'tags this -> float option [@@js.get "twist"]
  val set_twist: 'tags this -> float -> unit [@@js.set "twist"]
  val get_width: 'tags this -> float option [@@js.get "width"]
  val set_width: 'tags this -> float -> unit [@@js.set "width"]
  val create: ?coalescedEvents:PointerEvent.t list -> ?height:float -> ?isPrimary:bool -> ?pointerId:float -> ?pointerType:string -> ?predictedEvents:PointerEvent.t list -> ?pressure:float -> ?tangentialPressure:float -> ?tiltX:float -> ?tiltY:float -> ?twist:float -> ?width:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** A processing instruction embeds application-specific instructions in XML which can be ignored by other applications that don't recognize them. *)
and[@js.scope "ProcessingInstruction"] ProcessingInstruction : sig
  type t = [`CharacterData | `ChildNode | `EventTarget | `LinkStyle | `Node | `NonDocumentTypeChildNode | `ProcessingInstruction] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`CharacterData | `ChildNode | `EventTarget | `LinkStyle | `Node | `NonDocumentTypeChildNode | `ProcessingInstruction]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`CharacterData | `ChildNode | `EventTarget | `LinkStyle | `Node | `NonDocumentTypeChildNode | `ProcessingInstruction]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ProcessingInstruction ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Returns the node document. Returns null for documents. *)
  val get_ownerDocument: 'tags this -> Document.t [@@js.get "ownerDocument"]
  val get_target: 'tags this -> string [@@js.get "target"]
  val create: ownerDocument:Document.t -> target:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end
and[@js.scope "RTCDataChannel"] RTCDataChannel : sig
  type t = [`EventTarget | `RTCDataChannel] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventTarget | `RTCDataChannel]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventTarget | `RTCDataChannel]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RTCDataChannel ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_binaryType: 'tags this -> BinaryType.t [@@js.get "binaryType"]
  val set_binaryType: 'tags this -> BinaryType.t -> unit [@@js.set "binaryType"]
  val get_bufferedAmount: 'tags this -> float [@@js.get "bufferedAmount"]
  val get_bufferedAmountLowThreshold: 'tags this -> float [@@js.get "bufferedAmountLowThreshold"]
  val set_bufferedAmountLowThreshold: 'tags this -> float -> unit [@@js.set "bufferedAmountLowThreshold"]
  val get_id: 'tags this -> float option [@@js.get "id"]
  val get_label: 'tags this -> string [@@js.get "label"]
  val get_maxPacketLifeTime: 'tags this -> float option [@@js.get "maxPacketLifeTime"]
  val get_maxRetransmits: 'tags this -> float option [@@js.get "maxRetransmits"]
  val get_negotiated: 'tags this -> bool [@@js.get "negotiated"]
  val get_onbufferedamountlow: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onbufferedamountlow"]
  val set_onbufferedamountlow: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onbufferedamountlow"]
  val get_onclose: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onclose"]
  val set_onclose: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onclose"]
  val get_onerror: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onerror"]
  val set_onerror: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onerror"]
  val get_onmessage: 'tags this -> (this:t -> ev:MessageEvent.t_0 -> any) option [@@js.get "onmessage"]
  val set_onmessage: 'tags this -> (this:t -> ev:MessageEvent.t_0 -> any) option -> unit [@@js.set "onmessage"]
  val get_onopen: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onopen"]
  val set_onopen: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onopen"]
  val get_ordered: 'tags this -> bool [@@js.get "ordered"]
  val get_protocol: 'tags this -> string [@@js.get "protocol"]
  val get_readyState: 'tags this -> RTCDataChannelState.t [@@js.get "readyState"]
  val close: 'tags this -> unit [@@js.call "close"]
  val send: 'tags this -> data:string -> unit [@@js.call "send"]
  val send': 'tags this -> data:Blob.t -> unit [@@js.call "send"]
  val send'': 'tags this -> data:ArrayBuffer.t_0 -> unit [@@js.call "send"]
  val send''': 'tags this -> data:ArrayBufferView.t_0 -> unit [@@js.call "send"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'RTCDataChannelEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'RTCDataChannelEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
and[@js.scope "RTCDataChannelEvent"] RTCDataChannelEvent : sig
  type t = [`Event | `RTCDataChannelEvent] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Event | `RTCDataChannelEvent]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Event | `RTCDataChannelEvent]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RTCDataChannelEvent ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_channel: 'tags this -> RTCDataChannel.t [@@js.get "channel"]
  val create: channel:RTCDataChannel.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': type_:string -> eventInitDict:RTCDataChannelEventInit.t -> t [@@js.create]
end
and RTCDataChannelEventInit : sig
  type t = [`EventInit | `RTCDataChannelEventInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventInit | `RTCDataChannelEventInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventInit | `RTCDataChannelEventInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RTCDataChannelEventInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_channel: 'tags this -> RTCDataChannel.t [@@js.get "channel"]
  val set_channel: 'tags this -> RTCDataChannel.t -> unit [@@js.set "channel"]
  val create: channel:RTCDataChannel.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
and[@js.scope "RadioNodeList"] RadioNodeList : sig
  type t = [`NodeList | `RadioNodeList | Node.t ArrayLike.tags_1 | Node.t IterableIterator.tags_1] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`NodeList | `RadioNodeList | Node.t ArrayLike.tags_1 | Node.t IterableIterator.tags_1]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`NodeList | `RadioNodeList | Node.t ArrayLike.tags_1 | Node.t IterableIterator.tags_1]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RadioNodeList ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_value: 'tags this -> string [@@js.get "value"]
  val set_value: 'tags this -> string -> unit [@@js.set "value"]
  val create: value:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end

(** A fragment of a document that can contain nodes and parts of text nodes. *)
and[@js.scope "Range"] Range : sig
  type t = [`AbstractRange | `Range] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AbstractRange | `Range]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AbstractRange | `Range]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `Range ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Returns the node, furthest away from the document, that is an ancestor of both range's start node and end node. *)
  val get_commonAncestorContainer: 'tags this -> Node.t [@@js.get "commonAncestorContainer"]
  val cloneContents: 'tags this -> DocumentFragment.t [@@js.call "cloneContents"]
  val cloneRange: 'tags this -> t [@@js.call "cloneRange"]
  val collapse: 'tags this -> ?toStart:bool -> unit -> unit [@@js.call "collapse"]
  val compareBoundaryPoints: 'tags this -> how:float -> sourceRange:t -> float [@@js.call "compareBoundaryPoints"]
  
  (** Returns −1 if the point is before the range, 0 if the point is in the range, and 1 if the point is after the range. *)
  val comparePoint: 'tags this -> node:Node.t -> offset:float -> float [@@js.call "comparePoint"]
  val createContextualFragment: 'tags this -> fragment:string -> DocumentFragment.t [@@js.call "createContextualFragment"]
  val deleteContents: 'tags this -> unit [@@js.call "deleteContents"]
  val detach: 'tags this -> unit [@@js.call "detach"]
  val extractContents: 'tags this -> DocumentFragment.t [@@js.call "extractContents"]
  val getBoundingClientRect: 'tags this -> DOMRect.t [@@js.call "getBoundingClientRect"]
  val getClientRects: 'tags this -> DOMRectList.t [@@js.call "getClientRects"]
  val insertNode: 'tags this -> node:Node.t -> unit [@@js.call "insertNode"]
  
  (** Returns whether range intersects node. *)
  val intersectsNode: 'tags this -> node:Node.t -> bool [@@js.call "intersectsNode"]
  val isPointInRange: 'tags this -> node:Node.t -> offset:float -> bool [@@js.call "isPointInRange"]
  val selectNode: 'tags this -> node:Node.t -> unit [@@js.call "selectNode"]
  val selectNodeContents: 'tags this -> node:Node.t -> unit [@@js.call "selectNodeContents"]
  val setEnd: 'tags this -> node:Node.t -> offset:float -> unit [@@js.call "setEnd"]
  val setEndAfter: 'tags this -> node:Node.t -> unit [@@js.call "setEndAfter"]
  val setEndBefore: 'tags this -> node:Node.t -> unit [@@js.call "setEndBefore"]
  val setStart: 'tags this -> node:Node.t -> offset:float -> unit [@@js.call "setStart"]
  val setStartAfter: 'tags this -> node:Node.t -> unit [@@js.call "setStartAfter"]
  val setStartBefore: 'tags this -> node:Node.t -> unit [@@js.call "setStartBefore"]
  val surroundContents: 'tags this -> newParent:Node.t -> unit [@@js.call "surroundContents"]
  
  (** Returns a string representation of an object. *)
  val toString: 'tags this -> string [@@js.call "toString"]
  val get_END_TO_END: 'tags this -> float [@@js.get "END_TO_END"]
  val get_END_TO_START: 'tags this -> float [@@js.get "END_TO_START"]
  val get_START_TO_END: 'tags this -> float [@@js.get "START_TO_END"]
  val get_START_TO_START: 'tags this -> float [@@js.get "START_TO_START"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
  val end_to_end: unit -> float [@@js.get "END_TO_END"]
  val end_to_start: unit -> float [@@js.get "END_TO_START"]
  val start_to_end: unit -> float [@@js.get "START_TO_END"]
  val start_to_start: unit -> float [@@js.get "START_TO_START"]
  val toString': unit -> string [@@js.global "toString"]
end
and RenderingContext : sig
  type t = (CanvasRenderingContext2D.t, ImageBitmapRenderingContext.t, WebGL2RenderingContext.t, WebGLRenderingContext.t) union4
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end

(** This Fetch API interface represents a resource request. *)
and[@js.scope "Request"] Request : sig
  type t = [`Body | `Request] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Body | `Request]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Body | `Request]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `Request ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Returns the cache mode associated with request, which is a string indicating how the request will interact with the browser's cache when fetching. *)
  val get_cache: 'tags this -> RequestCache.t [@@js.get "cache"]
  
  (** Returns the credentials mode associated with request, which is a string indicating whether credentials will be sent with the request always, never, or only when sent to a same-origin URL. *)
  val get_credentials: 'tags this -> RequestCredentials.t [@@js.get "credentials"]
  
  (** Returns the kind of resource requested by request, e.g., "document" or "script". *)
  val get_destination: 'tags this -> RequestDestination.t [@@js.get "destination"]
  
  (** Returns a Headers object consisting of the headers associated with request. Note that headers added in the network layer by the user agent will not be accounted for in this object, e.g., the "Host" header. *)
  val get_headers: 'tags this -> Headers.t [@@js.get "headers"]
  
  (** Returns request's subresource integrity metadata, which is a cryptographic hash of the resource being fetched. Its value consists of multiple hashes separated by whitespace. \[SRI\] *)
  val get_integrity: 'tags this -> string [@@js.get "integrity"]
  
  (** Returns a boolean indicating whether or not request can outlive the global in which it was created. *)
  val get_keepalive: 'tags this -> bool [@@js.get "keepalive"]
  
  (** Returns request's HTTP method, which is "GET" by default. *)
  val get_method: 'tags this -> string [@@js.get "method"]
  
  (** Returns the mode associated with request, which is a string indicating whether the request will use CORS, or will be restricted to same-origin URLs. *)
  val get_mode: 'tags this -> RequestMode.t [@@js.get "mode"]
  
  (** Returns the redirect mode associated with request, which is a string indicating how redirects for the request will be handled during fetching. A request will follow redirects by default. *)
  val get_redirect: 'tags this -> RequestRedirect.t [@@js.get "redirect"]
  
  (** Returns the referrer of request. Its value can be a same-origin URL if explicitly set in init, the empty string to indicate no referrer, and "about:client" when defaulting to the global's default. This is used during fetching to determine the value of the `Referer` header of the request being made. *)
  val get_referrer: 'tags this -> string [@@js.get "referrer"]
  
  (** Returns the referrer policy associated with request. This is used during fetching to compute the value of the request's referrer. *)
  val get_referrerPolicy: 'tags this -> ReferrerPolicy.t [@@js.get "referrerPolicy"]
  
  (** Returns the signal associated with request, which is an AbortSignal object indicating whether or not request has been aborted, and its abort event handler. *)
  val get_signal: 'tags this -> AbortSignal.t [@@js.get "signal"]
  
  (** Returns the URL of request as a string. *)
  val get_url: 'tags this -> string [@@js.get "url"]
  val clone: 'tags this -> t [@@js.call "clone"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: input:RequestInfo.t -> ?init:RequestInit.t -> unit -> t [@@js.create]
end
and RequestInfo : sig
  type t = ([`String of string | `Other of Request.t] [@js.union on_field "dummy"]) Primitive.t
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
and RequestInit : sig
  type t = [`RequestInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`RequestInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`RequestInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RequestInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** A BodyInit object or null to set request's body. *)
  val get_body: 'tags this -> BodyInit.t option option [@@js.get "body"]
  
  (** A BodyInit object or null to set request's body. *)
  val set_body: 'tags this -> BodyInit.t option -> unit [@@js.set "body"]
  
  (** A string indicating how the request will interact with the browser's cache to set request's cache. *)
  val get_cache: 'tags this -> RequestCache.t option [@@js.get "cache"]
  
  (** A string indicating how the request will interact with the browser's cache to set request's cache. *)
  val set_cache: 'tags this -> RequestCache.t -> unit [@@js.set "cache"]
  
  (** A string indicating whether credentials will be sent with the request always, never, or only when sent to a same-origin URL. Sets request's credentials. *)
  val get_credentials: 'tags this -> RequestCredentials.t option [@@js.get "credentials"]
  
  (** A string indicating whether credentials will be sent with the request always, never, or only when sent to a same-origin URL. Sets request's credentials. *)
  val set_credentials: 'tags this -> RequestCredentials.t -> unit [@@js.set "credentials"]
  
  (** A Headers object, an object literal, or an array of two-item arrays to set request's headers. *)
  val get_headers: 'tags this -> HeadersInit.t option [@@js.get "headers"]
  
  (** A Headers object, an object literal, or an array of two-item arrays to set request's headers. *)
  val set_headers: 'tags this -> HeadersInit.t -> unit [@@js.set "headers"]
  
  (** A cryptographic hash of the resource to be fetched by request. Sets request's integrity. *)
  val get_integrity: 'tags this -> string option [@@js.get "integrity"]
  
  (** A cryptographic hash of the resource to be fetched by request. Sets request's integrity. *)
  val set_integrity: 'tags this -> string -> unit [@@js.set "integrity"]
  
  (** A boolean to set request's keepalive. *)
  val get_keepalive: 'tags this -> bool option [@@js.get "keepalive"]
  
  (** A boolean to set request's keepalive. *)
  val set_keepalive: 'tags this -> bool -> unit [@@js.set "keepalive"]
  
  (** A string to set request's method. *)
  val get_method: 'tags this -> string option [@@js.get "method"]
  
  (** A string to set request's method. *)
  val set_method: 'tags this -> string -> unit [@@js.set "method"]
  
  (** A string to indicate whether the request will use CORS, or will be restricted to same-origin URLs. Sets request's mode. *)
  val get_mode: 'tags this -> RequestMode.t option [@@js.get "mode"]
  
  (** A string to indicate whether the request will use CORS, or will be restricted to same-origin URLs. Sets request's mode. *)
  val set_mode: 'tags this -> RequestMode.t -> unit [@@js.set "mode"]
  
  (** A string indicating whether request follows redirects, results in an error upon encountering a redirect, or returns the redirect (in an opaque fashion). Sets request's redirect. *)
  val get_redirect: 'tags this -> RequestRedirect.t option [@@js.get "redirect"]
  
  (** A string indicating whether request follows redirects, results in an error upon encountering a redirect, or returns the redirect (in an opaque fashion). Sets request's redirect. *)
  val set_redirect: 'tags this -> RequestRedirect.t -> unit [@@js.set "redirect"]
  
  (** A string whose value is a same-origin URL, "about:client", or the empty string, to set request's referrer. *)
  val get_referrer: 'tags this -> string option [@@js.get "referrer"]
  
  (** A string whose value is a same-origin URL, "about:client", or the empty string, to set request's referrer. *)
  val set_referrer: 'tags this -> string -> unit [@@js.set "referrer"]
  
  (** A referrer policy to set request's referrerPolicy. *)
  val get_referrerPolicy: 'tags this -> ReferrerPolicy.t option [@@js.get "referrerPolicy"]
  
  (** A referrer policy to set request's referrerPolicy. *)
  val set_referrerPolicy: 'tags this -> ReferrerPolicy.t -> unit [@@js.set "referrerPolicy"]
  
  (** An AbortSignal to set request's signal. *)
  val get_signal: 'tags this -> AbortSignal.t option option [@@js.get "signal"]
  
  (** An AbortSignal to set request's signal. *)
  val set_signal: 'tags this -> AbortSignal.t option -> unit [@@js.set "signal"]
  
  (** Can only be null. Used to disassociate request from any Window. *)
  val get_window: 'tags this -> undefined option [@@js.get "window"]
  
  (** Can only be null. Used to disassociate request from any Window. *)
  val set_window: 'tags this -> null -> unit [@@js.set "window"]
  val create: ?body:BodyInit.t -> ?cache:RequestCache.t -> ?credentials:RequestCredentials.t -> ?headers:HeadersInit.t -> ?integrity:string -> ?keepalive:bool -> ?method_:(string[@js "method"]) -> ?mode:RequestMode.t -> ?redirect:RequestRedirect.t -> ?referrer:string -> ?referrerPolicy:ReferrerPolicy.t -> ?signal:AbortSignal.t -> ?window:never -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** This Fetch API interface represents the response to a request. *)
and[@js.scope "Response"] Response : sig
  type t = [`Body | `Response] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Body | `Response]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Body | `Response]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `Response ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_headers: 'tags this -> Headers.t [@@js.get "headers"]
  val get_ok: 'tags this -> bool [@@js.get "ok"]
  val get_redirected: 'tags this -> bool [@@js.get "redirected"]
  val get_status: 'tags this -> float [@@js.get "status"]
  val get_statusText: 'tags this -> string [@@js.get "statusText"]
  val get_type: 'tags this -> ResponseType.t [@@js.get "type"]
  val get_url: 'tags this -> string [@@js.get "url"]
  val clone: 'tags this -> t [@@js.call "clone"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: ?body:BodyInit.t option -> ?init:ResponseInit.t -> unit -> t [@@js.create]
  val error: unit -> t [@@js.global "error"]
  val redirect: url:([`U1 of string | `U2 of URL.t] [@js.union]) -> ?status:float -> unit -> t [@@js.global "redirect"]
end

(** An interface for the <circle> element. The circle element is defined by the cx and cy attributes that denote the coordinates of the centre of the circle. *)
and[@js.scope "SVGCircleElement"] SVGCircleElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGCircleElement | `SVGElement | `SVGGeometryElement | `SVGGraphicsElement | `SVGTests | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGCircleElement | `SVGElement | `SVGGeometryElement | `SVGGraphicsElement | `SVGTests | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGCircleElement | `SVGElement | `SVGGeometryElement | `SVGGraphicsElement | `SVGTests | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGCircleElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_cx: 'tags this -> SVGAnimatedLength.t [@@js.get "cx"]
  val get_cy: 'tags this -> SVGAnimatedLength.t [@@js.get "cy"]
  val get_r: 'tags this -> SVGAnimatedLength.t [@@js.get "r"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** All of the SVG DOM interfaces that correspond directly to elements in the SVG language derive from the SVGElement interface. *)
and[@js.scope "SVGElement"] SVGElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    Returns the value of element's class content attribute. Can be set to change it.
    @deprecated 
  *)
  val get_className: 'tags this -> any [@@js.get "className"]
  val get_ownerSVGElement: 'tags this -> SVGSVGElement.t option [@@js.get "ownerSVGElement"]
  val get_viewportElement: 'tags this -> t option [@@js.get "viewportElement"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Provides access to the properties of <ellipse> elements. *)
and[@js.scope "SVGEllipseElement"] SVGEllipseElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGEllipseElement | `SVGGeometryElement | `SVGGraphicsElement | `SVGTests | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGEllipseElement | `SVGGeometryElement | `SVGGraphicsElement | `SVGTests | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGEllipseElement | `SVGGeometryElement | `SVGGraphicsElement | `SVGTests | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGEllipseElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_cx: 'tags this -> SVGAnimatedLength.t [@@js.get "cx"]
  val get_cy: 'tags this -> SVGAnimatedLength.t [@@js.get "cy"]
  val get_rx: 'tags this -> SVGAnimatedLength.t [@@js.get "rx"]
  val get_ry: 'tags this -> SVGAnimatedLength.t [@@js.get "ry"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
and[@js.scope "SVGGeometryElement"] SVGGeometryElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGGeometryElement | `SVGGraphicsElement | `SVGTests | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGGeometryElement | `SVGGraphicsElement | `SVGTests | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGGeometryElement | `SVGGraphicsElement | `SVGTests | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGGeometryElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_pathLength: 'tags this -> SVGAnimatedNumber.t [@@js.get "pathLength"]
  val getPointAtLength: 'tags this -> distance:float -> DOMPoint.t [@@js.call "getPointAtLength"]
  val getTotalLength: 'tags this -> float [@@js.call "getTotalLength"]
  val isPointInFill: 'tags this -> ?point:DOMPointInit.t -> unit -> bool [@@js.call "isPointInFill"]
  val isPointInStroke: 'tags this -> ?point:DOMPointInit.t -> unit -> bool [@@js.call "isPointInStroke"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** SVG elements whose primary purpose is to directly render graphics into a group. *)
and[@js.scope "SVGGraphicsElement"] SVGGraphicsElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGGraphicsElement | `SVGTests | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGGraphicsElement | `SVGTests | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGGraphicsElement | `SVGTests | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGGraphicsElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_transform: 'tags this -> SVGAnimatedTransformList.t [@@js.get "transform"]
  val getBBox: 'tags this -> ?options:SVGBoundingBoxOptions.t -> unit -> DOMRect.t [@@js.call "getBBox"]
  val getCTM: 'tags this -> DOMMatrix.t option [@@js.call "getCTM"]
  val getScreenCTM: 'tags this -> DOMMatrix.t option [@@js.call "getScreenCTM"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Corresponds to the <image> element. *)
and[@js.scope "SVGImageElement"] SVGImageElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGGraphicsElement | `SVGImageElement | `SVGTests | `SVGURIReference | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGGraphicsElement | `SVGImageElement | `SVGTests | `SVGURIReference | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGGraphicsElement | `SVGImageElement | `SVGTests | `SVGURIReference | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGImageElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_height: 'tags this -> SVGAnimatedLength.t [@@js.get "height"]
  val get_preserveAspectRatio: 'tags this -> SVGAnimatedPreserveAspectRatio.t [@@js.get "preserveAspectRatio"]
  val get_width: 'tags this -> SVGAnimatedLength.t [@@js.get "width"]
  val get_x: 'tags this -> SVGAnimatedLength.t [@@js.get "x"]
  val get_y: 'tags this -> SVGAnimatedLength.t [@@js.get "y"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Provides access to the properties of <line> elements, as well as methods to manipulate them. *)
and[@js.scope "SVGLineElement"] SVGLineElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGGeometryElement | `SVGGraphicsElement | `SVGLineElement | `SVGTests | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGGeometryElement | `SVGGraphicsElement | `SVGLineElement | `SVGTests | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGGeometryElement | `SVGGraphicsElement | `SVGLineElement | `SVGTests | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGLineElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_x1: 'tags this -> SVGAnimatedLength.t [@@js.get "x1"]
  val get_x2: 'tags this -> SVGAnimatedLength.t [@@js.get "x2"]
  val get_y1: 'tags this -> SVGAnimatedLength.t [@@js.get "y1"]
  val get_y2: 'tags this -> SVGAnimatedLength.t [@@js.get "y2"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Corresponds to the <path> element. *)
and[@js.scope "SVGPathElement"] SVGPathElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGGeometryElement | `SVGGraphicsElement | `SVGPathElement | `SVGTests | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGGeometryElement | `SVGGraphicsElement | `SVGPathElement | `SVGTests | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGGeometryElement | `SVGGraphicsElement | `SVGPathElement | `SVGTests | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGPathElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Provides access to the properties of <polygon> elements, as well as methods to manipulate them. *)
and[@js.scope "SVGPolygonElement"] SVGPolygonElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGAnimatedPoints | `SVGElement | `SVGGeometryElement | `SVGGraphicsElement | `SVGPolygonElement | `SVGTests | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGAnimatedPoints | `SVGElement | `SVGGeometryElement | `SVGGraphicsElement | `SVGPolygonElement | `SVGTests | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGAnimatedPoints | `SVGElement | `SVGGeometryElement | `SVGGraphicsElement | `SVGPolygonElement | `SVGTests | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGPolygonElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Provides access to the properties of <polyline> elements, as well as methods to manipulate them. *)
and[@js.scope "SVGPolylineElement"] SVGPolylineElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGAnimatedPoints | `SVGElement | `SVGGeometryElement | `SVGGraphicsElement | `SVGPolylineElement | `SVGTests | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGAnimatedPoints | `SVGElement | `SVGGeometryElement | `SVGGraphicsElement | `SVGPolylineElement | `SVGTests | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGAnimatedPoints | `SVGElement | `SVGGeometryElement | `SVGGraphicsElement | `SVGPolylineElement | `SVGTests | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGPolylineElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Provides access to the properties of <rect> elements, as well as methods to manipulate them. *)
and[@js.scope "SVGRectElement"] SVGRectElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGGeometryElement | `SVGGraphicsElement | `SVGRectElement | `SVGTests | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGGeometryElement | `SVGGraphicsElement | `SVGRectElement | `SVGTests | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGGeometryElement | `SVGGraphicsElement | `SVGRectElement | `SVGTests | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGRectElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_height: 'tags this -> SVGAnimatedLength.t [@@js.get "height"]
  val get_rx: 'tags this -> SVGAnimatedLength.t [@@js.get "rx"]
  val get_ry: 'tags this -> SVGAnimatedLength.t [@@js.get "ry"]
  val get_width: 'tags this -> SVGAnimatedLength.t [@@js.get "width"]
  val get_x: 'tags this -> SVGAnimatedLength.t [@@js.get "x"]
  val get_y: 'tags this -> SVGAnimatedLength.t [@@js.get "y"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Provides access to the properties of <svg> elements, as well as methods to manipulate them. This interface contains also various miscellaneous commonly-used utility methods, such as matrix operations and the ability to control the time of redraw on visual rendering devices. *)
and[@js.scope "SVGSVGElement"] SVGSVGElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFitToViewBox | `SVGGraphicsElement | `SVGSVGElement | `SVGTests | `Slottable | `WindowEventHandlers] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFitToViewBox | `SVGGraphicsElement | `SVGSVGElement | `SVGTests | `Slottable | `WindowEventHandlers]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFitToViewBox | `SVGGraphicsElement | `SVGSVGElement | `SVGTests | `Slottable | `WindowEventHandlers]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGSVGElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_currentScale: 'tags this -> float [@@js.get "currentScale"]
  val set_currentScale: 'tags this -> float -> unit [@@js.set "currentScale"]
  val get_currentTranslate: 'tags this -> DOMPointReadOnly.t [@@js.get "currentTranslate"]
  val get_height: 'tags this -> SVGAnimatedLength.t [@@js.get "height"]
  val get_width: 'tags this -> SVGAnimatedLength.t [@@js.get "width"]
  val get_x: 'tags this -> SVGAnimatedLength.t [@@js.get "x"]
  val get_y: 'tags this -> SVGAnimatedLength.t [@@js.get "y"]
  val animationsPaused: 'tags this -> bool [@@js.call "animationsPaused"]
  val checkEnclosure: 'tags this -> element:SVGElement.t -> rect:DOMRectReadOnly.t -> bool [@@js.call "checkEnclosure"]
  val checkIntersection: 'tags this -> element:SVGElement.t -> rect:DOMRectReadOnly.t -> bool [@@js.call "checkIntersection"]
  val createSVGAngle: 'tags this -> SVGAngle.t [@@js.call "createSVGAngle"]
  val createSVGLength: 'tags this -> SVGLength.t [@@js.call "createSVGLength"]
  val createSVGMatrix: 'tags this -> DOMMatrix.t [@@js.call "createSVGMatrix"]
  val createSVGNumber: 'tags this -> SVGNumber.t [@@js.call "createSVGNumber"]
  val createSVGPoint: 'tags this -> DOMPoint.t [@@js.call "createSVGPoint"]
  val createSVGRect: 'tags this -> DOMRect.t [@@js.call "createSVGRect"]
  val createSVGTransform: 'tags this -> SVGTransform.t [@@js.call "createSVGTransform"]
  val createSVGTransformFromMatrix: 'tags this -> ?matrix:DOMMatrix2DInit.t -> unit -> SVGTransform.t [@@js.call "createSVGTransformFromMatrix"]
  val deselectAll: 'tags this -> unit [@@js.call "deselectAll"]
  
  (** @deprecated  *)
  val forceRedraw: 'tags this -> unit [@@js.call "forceRedraw"]
  val getCurrentTime: 'tags this -> float [@@js.call "getCurrentTime"]
  val getElementById: 'tags this -> elementId:string -> Element.t [@@js.call "getElementById"]
  val getEnclosureList: 'tags this -> rect:DOMRectReadOnly.t -> referenceElement:SVGElement.t option -> (SVGCircleElement.t, SVGEllipseElement.t, SVGImageElement.t, SVGLineElement.t, SVGPathElement.t, SVGPolygonElement.t, SVGPolylineElement.t, (SVGRectElement.t, SVGTextElement.t, SVGUseElement.t) union3) union8 NodeListOf.t [@@js.call "getEnclosureList"]
  val getIntersectionList: 'tags this -> rect:DOMRectReadOnly.t -> referenceElement:SVGElement.t option -> (SVGCircleElement.t, SVGEllipseElement.t, SVGImageElement.t, SVGLineElement.t, SVGPathElement.t, SVGPolygonElement.t, SVGPolylineElement.t, (SVGRectElement.t, SVGTextElement.t, SVGUseElement.t) union3) union8 NodeListOf.t [@@js.call "getIntersectionList"]
  val pauseAnimations: 'tags this -> unit [@@js.call "pauseAnimations"]
  val setCurrentTime: 'tags this -> seconds:float -> unit [@@js.call "setCurrentTime"]
  
  (** @deprecated  *)
  val suspendRedraw: 'tags this -> maxWaitMilliseconds:float -> float [@@js.call "suspendRedraw"]
  val unpauseAnimations: 'tags this -> unit [@@js.call "unpauseAnimations"]
  
  (** @deprecated  *)
  val unsuspendRedraw: 'tags this -> suspendHandleID:float -> unit [@@js.call "unsuspendRedraw"]
  
  (** @deprecated  *)
  val unsuspendRedrawAll: 'tags this -> unit [@@js.call "unsuspendRedrawAll"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGSVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGSVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Corresponds to the SVG <script> element. *)
and[@js.scope "SVGScriptElement"] SVGScriptElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGScriptElement | `SVGURIReference | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGScriptElement | `SVGURIReference | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGScriptElement | `SVGURIReference | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGScriptElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_type: 'tags this -> string [@@js.get "type"]
  val set_type: 'tags this -> string -> unit [@@js.set "type"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Implemented by elements that support rendering child text content. It is inherited by various text-related interfaces, such as SVGTextElement, SVGTSpanElement, SVGTRefElement, SVGAltGlyphElement and SVGTextPathElement. *)
and[@js.scope "SVGTextContentElement"] SVGTextContentElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGGraphicsElement | `SVGTests | `SVGTextContentElement | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGGraphicsElement | `SVGTests | `SVGTextContentElement | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGGraphicsElement | `SVGTests | `SVGTextContentElement | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGTextContentElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_lengthAdjust: 'tags this -> SVGAnimatedEnumeration.t [@@js.get "lengthAdjust"]
  val get_textLength: 'tags this -> SVGAnimatedLength.t [@@js.get "textLength"]
  val getCharNumAtPosition: 'tags this -> ?point:DOMPointInit.t -> unit -> float [@@js.call "getCharNumAtPosition"]
  val getComputedTextLength: 'tags this -> float [@@js.call "getComputedTextLength"]
  val getEndPositionOfChar: 'tags this -> charnum:float -> DOMPoint.t [@@js.call "getEndPositionOfChar"]
  val getExtentOfChar: 'tags this -> charnum:float -> DOMRect.t [@@js.call "getExtentOfChar"]
  val getNumberOfChars: 'tags this -> float [@@js.call "getNumberOfChars"]
  val getRotationOfChar: 'tags this -> charnum:float -> float [@@js.call "getRotationOfChar"]
  val getStartPositionOfChar: 'tags this -> charnum:float -> DOMPoint.t [@@js.call "getStartPositionOfChar"]
  val getSubStringLength: 'tags this -> charnum:float -> nchars:float -> float [@@js.call "getSubStringLength"]
  
  (** @deprecated  *)
  val selectSubString: 'tags this -> charnum:float -> nchars:float -> unit [@@js.call "selectSubString"]
  val get_LENGTHADJUST_SPACING: 'tags this -> float [@@js.get "LENGTHADJUST_SPACING"]
  val get_LENGTHADJUST_SPACINGANDGLYPHS: 'tags this -> float [@@js.get "LENGTHADJUST_SPACINGANDGLYPHS"]
  val get_LENGTHADJUST_UNKNOWN: 'tags this -> float [@@js.get "LENGTHADJUST_UNKNOWN"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
  val lengthadjust_spacing: unit -> float [@@js.get "LENGTHADJUST_SPACING"]
  val lengthadjust_spacingandglyphs: unit -> float [@@js.get "LENGTHADJUST_SPACINGANDGLYPHS"]
  val lengthadjust_unknown: unit -> float [@@js.get "LENGTHADJUST_UNKNOWN"]
end

(** Corresponds to the <text> elements. *)
and[@js.scope "SVGTextElement"] SVGTextElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGGraphicsElement | `SVGTests | `SVGTextContentElement | `SVGTextElement | `SVGTextPositioningElement | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGGraphicsElement | `SVGTests | `SVGTextContentElement | `SVGTextElement | `SVGTextPositioningElement | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGGraphicsElement | `SVGTests | `SVGTextContentElement | `SVGTextElement | `SVGTextPositioningElement | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGTextElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Implemented by elements that support attributes that position individual text glyphs. It is inherited by SVGTextElement, SVGTSpanElement, SVGTRefElement and SVGAltGlyphElement. *)
and[@js.scope "SVGTextPositioningElement"] SVGTextPositioningElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGGraphicsElement | `SVGTests | `SVGTextContentElement | `SVGTextPositioningElement | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGGraphicsElement | `SVGTests | `SVGTextContentElement | `SVGTextPositioningElement | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGGraphicsElement | `SVGTests | `SVGTextContentElement | `SVGTextPositioningElement | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGTextPositioningElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_dx: 'tags this -> SVGAnimatedLengthList.t [@@js.get "dx"]
  val get_dy: 'tags this -> SVGAnimatedLengthList.t [@@js.get "dy"]
  val get_rotate: 'tags this -> SVGAnimatedNumberList.t [@@js.get "rotate"]
  val get_x: 'tags this -> SVGAnimatedLengthList.t [@@js.get "x"]
  val get_y: 'tags this -> SVGAnimatedLengthList.t [@@js.get "y"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Corresponds to the <use> element. *)
and[@js.scope "SVGUseElement"] SVGUseElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGGraphicsElement | `SVGTests | `SVGURIReference | `SVGUseElement | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGGraphicsElement | `SVGTests | `SVGURIReference | `SVGUseElement | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGGraphicsElement | `SVGTests | `SVGURIReference | `SVGUseElement | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGUseElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_height: 'tags this -> SVGAnimatedLength.t [@@js.get "height"]
  val get_width: 'tags this -> SVGAnimatedLength.t [@@js.get "width"]
  val get_x: 'tags this -> SVGAnimatedLength.t [@@js.get "x"]
  val get_y: 'tags this -> SVGAnimatedLength.t [@@js.get "y"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** A Selection object represents the range of text selected by the user or the current position of the caret. To obtain a Selection object for examination or modification, call Window.getSelection(). *)
and[@js.scope "Selection"] Selection : sig
  type t = [`Selection] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Selection]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Selection]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `Selection ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_anchorNode: 'tags this -> Node.t option [@@js.get "anchorNode"]
  val get_anchorOffset: 'tags this -> float [@@js.get "anchorOffset"]
  val get_focusNode: 'tags this -> Node.t option [@@js.get "focusNode"]
  val get_focusOffset: 'tags this -> float [@@js.get "focusOffset"]
  val get_isCollapsed: 'tags this -> bool [@@js.get "isCollapsed"]
  val get_rangeCount: 'tags this -> float [@@js.get "rangeCount"]
  val get_type: 'tags this -> string [@@js.get "type"]
  val addRange: 'tags this -> range:Range.t -> unit [@@js.call "addRange"]
  val collapse: 'tags this -> node:Node.t option -> ?offset:float -> unit -> unit [@@js.call "collapse"]
  val collapseToEnd: 'tags this -> unit [@@js.call "collapseToEnd"]
  val collapseToStart: 'tags this -> unit [@@js.call "collapseToStart"]
  val containsNode: 'tags this -> node:Node.t -> ?allowPartialContainment:bool -> unit -> bool [@@js.call "containsNode"]
  val deleteFromDocument: 'tags this -> unit [@@js.call "deleteFromDocument"]
  val empty: 'tags this -> unit [@@js.call "empty"]
  val extend: 'tags this -> node:Node.t -> ?offset:float -> unit -> unit [@@js.call "extend"]
  val getRangeAt: 'tags this -> index:float -> Range.t [@@js.call "getRangeAt"]
  val removeAllRanges: 'tags this -> unit [@@js.call "removeAllRanges"]
  val removeRange: 'tags this -> range:Range.t -> unit [@@js.call "removeRange"]
  val selectAllChildren: 'tags this -> node:Node.t -> unit [@@js.call "selectAllChildren"]
  val setBaseAndExtent: 'tags this -> anchorNode:Node.t -> anchorOffset:float -> focusNode:Node.t -> focusOffset:float -> unit [@@js.call "setBaseAndExtent"]
  val setPosition: 'tags this -> node:Node.t option -> ?offset:float -> unit -> unit [@@js.call "setPosition"]
  val toString: 'tags this -> string [@@js.call "toString"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
  val toString': unit -> string [@@js.global "toString"]
end

(**
  This ServiceWorker API interface provides a reference to a service worker. Multiple browsing contexts (e.g. pages, workers, etc.) can be associated with the same service worker, each through a unique ServiceWorker object.
  Available only in secure contexts.
*)
and[@js.scope "ServiceWorker"] ServiceWorker : sig
  type t = [`AbstractWorker | `EventTarget | `ServiceWorker] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AbstractWorker | `EventTarget | `ServiceWorker]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AbstractWorker | `EventTarget | `ServiceWorker]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ServiceWorker ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_onstatechange: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onstatechange"]
  val set_onstatechange: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onstatechange"]
  val get_scriptURL: 'tags this -> string [@@js.get "scriptURL"]
  val get_state: 'tags this -> ServiceWorkerState.t [@@js.get "state"]
  val postMessage: 'tags this -> message:any -> transfer:Transferable.t list -> unit [@@js.call "postMessage"]
  val postMessage': 'tags this -> message:any -> ?options:StructuredSerializeOptions.t -> unit -> unit [@@js.call "postMessage"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'ServiceWorkerEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'ServiceWorkerEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(**
  The ServiceWorkerContainer interface of the ServiceWorker API provides an object representing the service worker as an overall unit in the network ecosystem, including facilities to register, unregister and update service workers, and access the state of service workers and their registrations.
  Available only in secure contexts.
*)
and[@js.scope "ServiceWorkerContainer"] ServiceWorkerContainer : sig
  type t = [`EventTarget | `ServiceWorkerContainer] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventTarget | `ServiceWorkerContainer]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventTarget | `ServiceWorkerContainer]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ServiceWorkerContainer ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_controller: 'tags this -> ServiceWorker.t option [@@js.get "controller"]
  val get_oncontrollerchange: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "oncontrollerchange"]
  val set_oncontrollerchange: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "oncontrollerchange"]
  val get_onmessage: 'tags this -> (this:t -> ev:MessageEvent.t_0 -> any) option [@@js.get "onmessage"]
  val set_onmessage: 'tags this -> (this:t -> ev:MessageEvent.t_0 -> any) option -> unit [@@js.set "onmessage"]
  val get_onmessageerror: 'tags this -> (this:t -> ev:MessageEvent.t_0 -> any) option [@@js.get "onmessageerror"]
  val set_onmessageerror: 'tags this -> (this:t -> ev:MessageEvent.t_0 -> any) option -> unit [@@js.set "onmessageerror"]
  val get_ready: 'tags this -> ServiceWorkerRegistration.t Promise.t_1 [@@js.get "ready"]
  val getRegistration: 'tags this -> ?clientURL:([`U1 of string | `U2 of URL.t] [@js.union]) -> unit -> ServiceWorkerRegistration.t option Promise.t_1 [@@js.call "getRegistration"]
  val getRegistrations: 'tags this -> ServiceWorkerRegistration.t list Promise.t_1 [@@js.call "getRegistrations"]
  val register: 'tags this -> scriptURL:([`U1 of string | `U2 of URL.t] [@js.union]) -> ?options:RegistrationOptions.t -> unit -> ServiceWorkerRegistration.t Promise.t_1 [@@js.call "register"]
  val startMessages: 'tags this -> unit [@@js.call "startMessages"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'ServiceWorkerContainerEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'ServiceWorkerContainerEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(**
  This ServiceWorker API interface represents the service worker registration. You register a service worker to control one or more pages that share the same origin.
  Available only in secure contexts.
*)
and[@js.scope "ServiceWorkerRegistration"] ServiceWorkerRegistration : sig
  type t = [`EventTarget | `ServiceWorkerRegistration] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventTarget | `ServiceWorkerRegistration]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventTarget | `ServiceWorkerRegistration]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ServiceWorkerRegistration ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_active: 'tags this -> ServiceWorker.t option [@@js.get "active"]
  val get_installing: 'tags this -> ServiceWorker.t option [@@js.get "installing"]
  val get_onupdatefound: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onupdatefound"]
  val set_onupdatefound: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onupdatefound"]
  val get_pushManager: 'tags this -> PushManager.t [@@js.get "pushManager"]
  val get_scope: 'tags this -> string [@@js.get "scope"]
  val get_updateViaCache: 'tags this -> ServiceWorkerUpdateViaCache.t [@@js.get "updateViaCache"]
  val get_waiting: 'tags this -> ServiceWorker.t option [@@js.get "waiting"]
  val getNotifications: 'tags this -> ?filter:GetNotificationOptions.t -> unit -> Notification.t list Promise.t_1 [@@js.call "getNotifications"]
  val showNotification: 'tags this -> title:string -> ?options:NotificationOptions.t -> unit -> unit Promise.t_1 [@@js.call "showNotification"]
  val unregister: 'tags this -> bool Promise.t_1 [@@js.call "unregister"]
  val update: 'tags this -> unit Promise.t_1 [@@js.call "update"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'ServiceWorkerRegistrationEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'ServiceWorkerRegistrationEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
and[@js.scope "ShadowRoot"] ShadowRoot : sig
  type t = [`DocumentFragment | `DocumentOrShadowRoot | `EventTarget | `InnerHTML | `Node | `NonElementParentNode | `ParentNode | `ShadowRoot] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`DocumentFragment | `DocumentOrShadowRoot | `EventTarget | `InnerHTML | `Node | `NonElementParentNode | `ParentNode | `ShadowRoot]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`DocumentFragment | `DocumentOrShadowRoot | `EventTarget | `InnerHTML | `Node | `NonElementParentNode | `ParentNode | `ShadowRoot]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ShadowRoot ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_delegatesFocus: 'tags this -> bool [@@js.get "delegatesFocus"]
  val get_host: 'tags this -> Element.t [@@js.get "host"]
  val get_mode: 'tags this -> ShadowRootMode.t [@@js.get "mode"]
  val get_onslotchange: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onslotchange"]
  val set_onslotchange: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onslotchange"]
  val get_slotAssignment: 'tags this -> SlotAssignmentMode.t [@@js.get "slotAssignment"]
  
  (** Throws a "NotSupportedError" DOMException if context object is a shadow root. *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'ShadowRootEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'ShadowRootEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
and Slottable : sig
  type t = [`Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `Slottable ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_assignedSlot: 'tags this -> HTMLSlotElement.t option [@@js.get "assignedSlot"]
  val create: ?assignedSlot:HTMLSlotElement.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
and[@js.scope "StaticRange"] StaticRange : sig
  type t = [`AbstractRange | `StaticRange] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AbstractRange | `StaticRange]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AbstractRange | `StaticRange]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `StaticRange ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: StaticRangeInit.t -> t [@@js.create]
end
and StaticRangeInit : sig
  type t = [`StaticRangeInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`StaticRangeInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`StaticRangeInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `StaticRangeInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_endContainer: 'tags this -> Node.t [@@js.get "endContainer"]
  val set_endContainer: 'tags this -> Node.t -> unit [@@js.set "endContainer"]
  val get_endOffset: 'tags this -> float [@@js.get "endOffset"]
  val set_endOffset: 'tags this -> float -> unit [@@js.set "endOffset"]
  val get_startContainer: 'tags this -> Node.t [@@js.get "startContainer"]
  val set_startContainer: 'tags this -> Node.t -> unit [@@js.set "startContainer"]
  val get_startOffset: 'tags this -> float [@@js.get "startOffset"]
  val set_startOffset: 'tags this -> float -> unit [@@js.set "startOffset"]
  val create: endContainer:Node.t -> endOffset:float -> startContainer:Node.t -> startOffset:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
and StructuredSerializeOptions : sig
  type t = [`StructuredSerializeOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`StructuredSerializeOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`StructuredSerializeOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `StructuredSerializeOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_transfer: 'tags this -> Transferable.t list option [@@js.get "transfer"]
  val set_transfer: 'tags this -> Transferable.t list -> unit [@@js.set "transfer"]
  val create: ?transfer:Transferable.t list -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** A single style sheet. CSS style sheets will further implement the more specialized CSSStyleSheet interface. *)
and[@js.scope "StyleSheet"] StyleSheet : sig
  type t = [`StyleSheet] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`StyleSheet]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`StyleSheet]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `StyleSheet ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_disabled: 'tags this -> bool [@@js.get "disabled"]
  val set_disabled: 'tags this -> bool -> unit [@@js.set "disabled"]
  val get_href: 'tags this -> string option [@@js.get "href"]
  val get_media: 'tags this -> MediaList.t [@@js.get "media"]
  val get_ownerNode: 'tags this -> (Element.t, ProcessingInstruction.t) union2 option [@@js.get "ownerNode"]
  val get_parentStyleSheet: 'tags this -> CSSStyleSheet.t option [@@js.get "parentStyleSheet"]
  val get_title: 'tags this -> string option [@@js.get "title"]
  val get_type: 'tags this -> string [@@js.get "type"]
  val create: disabled:bool -> ?href:string -> media:MediaList.t -> ?ownerNode:(Element.t, ProcessingInstruction.t) union2 -> ?parentStyleSheet:CSSStyleSheet.t -> ?title:string -> type_:(string[@js "type"]) -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end

(** A list of StyleSheet. *)
and[@js.scope "StyleSheetList"] StyleSheetList : sig
  type t = [`StyleSheetList | CSSStyleSheet.t ArrayLike.tags_1 | CSSStyleSheet.t IterableIterator.tags_1] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`StyleSheetList | CSSStyleSheet.t ArrayLike.tags_1 | CSSStyleSheet.t IterableIterator.tags_1]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`StyleSheetList | CSSStyleSheet.t ArrayLike.tags_1 | CSSStyleSheet.t IterableIterator.tags_1]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `StyleSheetList ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  (* [Symbol.iterator]: unit -> CSSStyleSheet.t IterableIterator.t_1 *)
  val get_length: 'tags this -> float [@@js.get "length"]
  val item: 'tags this -> index:float -> CSSStyleSheet.t option [@@js.call "item"]
  val get: 'tags this -> float -> CSSStyleSheet.t [@@js.index_get]
  val set: 'tags this -> float -> CSSStyleSheet.t -> unit [@@js.index_set]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
and[@js.scope "SubmitEvent"] SubmitEvent : sig
  type t = [`Event | `SubmitEvent] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Event | `SubmitEvent]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Event | `SubmitEvent]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SubmitEvent ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Returns the element representing the submit button that triggered the form submission, or null if the submission was not triggered by a button. *)
  val get_submitter: 'tags this -> HTMLElement.t option [@@js.get "submitter"]
  val create: ?submitter:HTMLElement.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': type_:string -> ?eventInitDict:SubmitEventInit.t -> unit -> t [@@js.create]
end
and SubmitEventInit : sig
  type t = [`EventInit | `SubmitEventInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventInit | `SubmitEventInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventInit | `SubmitEventInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SubmitEventInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_submitter: 'tags this -> HTMLElement.t option option [@@js.get "submitter"]
  val set_submitter: 'tags this -> HTMLElement.t option -> unit [@@js.set "submitter"]
  val create: ?submitter:HTMLElement.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
and TexImageSource : sig
  type t = (HTMLCanvasElement.t, HTMLImageElement.t, HTMLVideoElement.t, ImageBitmap.t, ImageData.t) union5
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end

(** The textual content of Element or Attr. If an element has no markup within its content, it has a single child implementing Text that contains the element's text. However, if the element contains markup, it is parsed into information items and Text nodes that form its children. *)
and[@js.scope "Text"] Text : sig
  type t = [`CharacterData | `ChildNode | `EventTarget | `Node | `NonDocumentTypeChildNode | `Slottable | `Text] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`CharacterData | `ChildNode | `EventTarget | `Node | `NonDocumentTypeChildNode | `Slottable | `Text]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`CharacterData | `ChildNode | `EventTarget | `Node | `NonDocumentTypeChildNode | `Slottable | `Text]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `Text ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Returns the combined data of all direct Text node siblings. *)
  val get_wholeText: 'tags this -> string [@@js.get "wholeText"]
  
  (** Splits data at the given offset and returns the remainder as Text node. *)
  val splitText: 'tags this -> offset:float -> t [@@js.call "splitText"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: ?data:string -> unit -> t [@@js.create]
end

(** An event sent when the state of contacts with a touch-sensitive surface changes. This surface can be a touch screen or trackpad, for example. The event can describe one or more points of contact with the screen and includes support for detecting movement, addition and removal of contact points, and so forth. *)
and[@js.scope "TouchEvent"] TouchEvent : sig
  type t = [`Event | `TouchEvent | `UIEvent] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Event | `TouchEvent | `UIEvent]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Event | `TouchEvent | `UIEvent]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `TouchEvent ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_altKey: 'tags this -> bool [@@js.get "altKey"]
  val get_changedTouches: 'tags this -> TouchList.t [@@js.get "changedTouches"]
  val get_ctrlKey: 'tags this -> bool [@@js.get "ctrlKey"]
  val get_metaKey: 'tags this -> bool [@@js.get "metaKey"]
  val get_shiftKey: 'tags this -> bool [@@js.get "shiftKey"]
  val get_targetTouches: 'tags this -> TouchList.t [@@js.get "targetTouches"]
  val get_touches: 'tags this -> TouchList.t [@@js.get "touches"]
  val create: altKey:bool -> changedTouches:TouchList.t -> ctrlKey:bool -> metaKey:bool -> shiftKey:bool -> targetTouches:TouchList.t -> touches:TouchList.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': type_:string -> ?eventInitDict:TouchEventInit.t -> unit -> t [@@js.create]
end
and TouchEventInit : sig
  type t = [`EventInit | `EventModifierInit | `TouchEventInit | `UIEventInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventInit | `EventModifierInit | `TouchEventInit | `UIEventInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventInit | `EventModifierInit | `TouchEventInit | `UIEventInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `TouchEventInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_changedTouches: 'tags this -> Touch.t list option [@@js.get "changedTouches"]
  val set_changedTouches: 'tags this -> Touch.t list -> unit [@@js.set "changedTouches"]
  val get_targetTouches: 'tags this -> Touch.t list option [@@js.get "targetTouches"]
  val set_targetTouches: 'tags this -> Touch.t list -> unit [@@js.set "targetTouches"]
  val get_touches: 'tags this -> Touch.t list option [@@js.get "touches"]
  val set_touches: 'tags this -> Touch.t list -> unit [@@js.set "touches"]
  val create: ?changedTouches:Touch.t list -> ?targetTouches:Touch.t list -> ?touches:Touch.t list -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
and Transferable : sig
  type t = (ArrayBuffer.t_0, ImageBitmap.t, MessagePort.t) union3
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end

(** The nodes of a document subtree and a position within them. *)
and[@js.scope "TreeWalker"] TreeWalker : sig
  type t = [`TreeWalker] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`TreeWalker]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`TreeWalker]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `TreeWalker ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_currentNode: 'tags this -> Node.t [@@js.get "currentNode"]
  val set_currentNode: 'tags this -> Node.t -> unit [@@js.set "currentNode"]
  val get_filter: 'tags this -> NodeFilter.t option [@@js.get "filter"]
  val get_root: 'tags this -> Node.t [@@js.get "root"]
  val get_whatToShow: 'tags this -> float [@@js.get "whatToShow"]
  val firstChild: 'tags this -> Node.t option [@@js.call "firstChild"]
  val lastChild: 'tags this -> Node.t option [@@js.call "lastChild"]
  val nextNode: 'tags this -> Node.t option [@@js.call "nextNode"]
  val nextSibling: 'tags this -> Node.t option [@@js.call "nextSibling"]
  val parentNode: 'tags this -> Node.t option [@@js.call "parentNode"]
  val previousNode: 'tags this -> Node.t option [@@js.call "previousNode"]
  val previousSibling: 'tags this -> Node.t option [@@js.call "previousSibling"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Simple user interface events. *)
and[@js.scope "UIEvent"] UIEvent : sig
  type t = [`Event | `UIEvent] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Event | `UIEvent]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Event | `UIEvent]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `UIEvent ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_detail: 'tags this -> float [@@js.get "detail"]
  val get_view: 'tags this -> Window.t option [@@js.get "view"]
  
  (** @deprecated  *)
  val get_which: 'tags this -> float [@@js.get "which"]
  
  (** @deprecated  *)
  val initUIEvent: 'tags this -> typeArg:string -> ?bubblesArg:bool -> ?cancelableArg:bool -> ?viewArg:Window.t option -> ?detailArg:float -> unit -> unit [@@js.call "initUIEvent"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: type_:string -> ?eventInitDict:UIEventInit.t -> unit -> t [@@js.create]
end
and UIEventInit : sig
  type t = [`EventInit | `UIEventInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventInit | `UIEventInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventInit | `UIEventInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `UIEventInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_detail: 'tags this -> float option [@@js.get "detail"]
  val set_detail: 'tags this -> float -> unit [@@js.set "detail"]
  val get_view: 'tags this -> Window.t option option [@@js.get "view"]
  val set_view: 'tags this -> Window.t option -> unit [@@js.set "view"]
  
  (** @deprecated  *)
  val get_which: 'tags this -> float option [@@js.get "which"]
  
  (** @deprecated  *)
  val set_which: 'tags this -> float -> unit [@@js.set "which"]
  val create: ?detail:float -> ?view:Window.t -> ?which:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
and[@js.scope "WebGL2RenderingContext"] WebGL2RenderingContext : sig
  type t = [`WebGL2RenderingContext | `WebGL2RenderingContextBase | `WebGL2RenderingContextOverloads | `WebGLRenderingContextBase] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`WebGL2RenderingContext | `WebGL2RenderingContextBase | `WebGL2RenderingContextOverloads | `WebGLRenderingContextBase]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`WebGL2RenderingContext | `WebGL2RenderingContextBase | `WebGL2RenderingContextOverloads | `WebGLRenderingContextBase]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `WebGL2RenderingContext ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
  val active_uniform_blocks: unit -> GLenum.t [@@js.get "ACTIVE_UNIFORM_BLOCKS"]
  val already_signaled: unit -> GLenum.t [@@js.get "ALREADY_SIGNALED"]
  val any_samples_passed: unit -> GLenum.t [@@js.get "ANY_SAMPLES_PASSED"]
  val any_samples_passed_conservative: unit -> GLenum.t [@@js.get "ANY_SAMPLES_PASSED_CONSERVATIVE"]
  val color: unit -> GLenum.t [@@js.get "COLOR"]
  val color_attachment1: unit -> GLenum.t [@@js.get "COLOR_ATTACHMENT1"]
  val color_attachment10: unit -> GLenum.t [@@js.get "COLOR_ATTACHMENT10"]
  val color_attachment11: unit -> GLenum.t [@@js.get "COLOR_ATTACHMENT11"]
  val color_attachment12: unit -> GLenum.t [@@js.get "COLOR_ATTACHMENT12"]
  val color_attachment13: unit -> GLenum.t [@@js.get "COLOR_ATTACHMENT13"]
  val color_attachment14: unit -> GLenum.t [@@js.get "COLOR_ATTACHMENT14"]
  val color_attachment15: unit -> GLenum.t [@@js.get "COLOR_ATTACHMENT15"]
  val color_attachment2: unit -> GLenum.t [@@js.get "COLOR_ATTACHMENT2"]
  val color_attachment3: unit -> GLenum.t [@@js.get "COLOR_ATTACHMENT3"]
  val color_attachment4: unit -> GLenum.t [@@js.get "COLOR_ATTACHMENT4"]
  val color_attachment5: unit -> GLenum.t [@@js.get "COLOR_ATTACHMENT5"]
  val color_attachment6: unit -> GLenum.t [@@js.get "COLOR_ATTACHMENT6"]
  val color_attachment7: unit -> GLenum.t [@@js.get "COLOR_ATTACHMENT7"]
  val color_attachment8: unit -> GLenum.t [@@js.get "COLOR_ATTACHMENT8"]
  val color_attachment9: unit -> GLenum.t [@@js.get "COLOR_ATTACHMENT9"]
  val compare_ref_to_texture: unit -> GLenum.t [@@js.get "COMPARE_REF_TO_TEXTURE"]
  val condition_satisfied: unit -> GLenum.t [@@js.get "CONDITION_SATISFIED"]
  val copy_read_buffer: unit -> GLenum.t [@@js.get "COPY_READ_BUFFER"]
  val copy_read_buffer_binding: unit -> GLenum.t [@@js.get "COPY_READ_BUFFER_BINDING"]
  val copy_write_buffer: unit -> GLenum.t [@@js.get "COPY_WRITE_BUFFER"]
  val copy_write_buffer_binding: unit -> GLenum.t [@@js.get "COPY_WRITE_BUFFER_BINDING"]
  val current_query: unit -> GLenum.t [@@js.get "CURRENT_QUERY"]
  val depth: unit -> GLenum.t [@@js.get "DEPTH"]
  val depth24_stencil8: unit -> GLenum.t [@@js.get "DEPTH24_STENCIL8"]
  val depth32f_stencil8: unit -> GLenum.t [@@js.get "DEPTH32F_STENCIL8"]
  val depth_component24: unit -> GLenum.t [@@js.get "DEPTH_COMPONENT24"]
  val depth_component32f: unit -> GLenum.t [@@js.get "DEPTH_COMPONENT32F"]
  val draw_buffer0: unit -> GLenum.t [@@js.get "DRAW_BUFFER0"]
  val draw_buffer1: unit -> GLenum.t [@@js.get "DRAW_BUFFER1"]
  val draw_buffer10: unit -> GLenum.t [@@js.get "DRAW_BUFFER10"]
  val draw_buffer11: unit -> GLenum.t [@@js.get "DRAW_BUFFER11"]
  val draw_buffer12: unit -> GLenum.t [@@js.get "DRAW_BUFFER12"]
  val draw_buffer13: unit -> GLenum.t [@@js.get "DRAW_BUFFER13"]
  val draw_buffer14: unit -> GLenum.t [@@js.get "DRAW_BUFFER14"]
  val draw_buffer15: unit -> GLenum.t [@@js.get "DRAW_BUFFER15"]
  val draw_buffer2: unit -> GLenum.t [@@js.get "DRAW_BUFFER2"]
  val draw_buffer3: unit -> GLenum.t [@@js.get "DRAW_BUFFER3"]
  val draw_buffer4: unit -> GLenum.t [@@js.get "DRAW_BUFFER4"]
  val draw_buffer5: unit -> GLenum.t [@@js.get "DRAW_BUFFER5"]
  val draw_buffer6: unit -> GLenum.t [@@js.get "DRAW_BUFFER6"]
  val draw_buffer7: unit -> GLenum.t [@@js.get "DRAW_BUFFER7"]
  val draw_buffer8: unit -> GLenum.t [@@js.get "DRAW_BUFFER8"]
  val draw_buffer9: unit -> GLenum.t [@@js.get "DRAW_BUFFER9"]
  val draw_framebuffer: unit -> GLenum.t [@@js.get "DRAW_FRAMEBUFFER"]
  val draw_framebuffer_binding: unit -> GLenum.t [@@js.get "DRAW_FRAMEBUFFER_BINDING"]
  val dynamic_copy: unit -> GLenum.t [@@js.get "DYNAMIC_COPY"]
  val dynamic_read: unit -> GLenum.t [@@js.get "DYNAMIC_READ"]
  val float_32_unsigned_int_24_8_rev: unit -> GLenum.t [@@js.get "FLOAT_32_UNSIGNED_INT_24_8_REV"]
  val fLOAT_MAT2x3: unit -> GLenum.t [@@js.get "FLOAT_MAT2x3"]
  val fLOAT_MAT2x4: unit -> GLenum.t [@@js.get "FLOAT_MAT2x4"]
  val fLOAT_MAT3x2: unit -> GLenum.t [@@js.get "FLOAT_MAT3x2"]
  val fLOAT_MAT3x4: unit -> GLenum.t [@@js.get "FLOAT_MAT3x4"]
  val fLOAT_MAT4x2: unit -> GLenum.t [@@js.get "FLOAT_MAT4x2"]
  val fLOAT_MAT4x3: unit -> GLenum.t [@@js.get "FLOAT_MAT4x3"]
  val fragment_shader_derivative_hint: unit -> GLenum.t [@@js.get "FRAGMENT_SHADER_DERIVATIVE_HINT"]
  val framebuffer_attachment_alpha_size: unit -> GLenum.t [@@js.get "FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE"]
  val framebuffer_attachment_blue_size: unit -> GLenum.t [@@js.get "FRAMEBUFFER_ATTACHMENT_BLUE_SIZE"]
  val framebuffer_attachment_color_encoding: unit -> GLenum.t [@@js.get "FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING"]
  val framebuffer_attachment_component_type: unit -> GLenum.t [@@js.get "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE"]
  val framebuffer_attachment_depth_size: unit -> GLenum.t [@@js.get "FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE"]
  val framebuffer_attachment_green_size: unit -> GLenum.t [@@js.get "FRAMEBUFFER_ATTACHMENT_GREEN_SIZE"]
  val framebuffer_attachment_red_size: unit -> GLenum.t [@@js.get "FRAMEBUFFER_ATTACHMENT_RED_SIZE"]
  val framebuffer_attachment_stencil_size: unit -> GLenum.t [@@js.get "FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE"]
  val framebuffer_attachment_texture_layer: unit -> GLenum.t [@@js.get "FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER"]
  val framebuffer_default: unit -> GLenum.t [@@js.get "FRAMEBUFFER_DEFAULT"]
  val framebuffer_incomplete_multisample: unit -> GLenum.t [@@js.get "FRAMEBUFFER_INCOMPLETE_MULTISAMPLE"]
  val half_float: unit -> GLenum.t [@@js.get "HALF_FLOAT"]
  val interleaved_attribs: unit -> GLenum.t [@@js.get "INTERLEAVED_ATTRIBS"]
  val int_2_10_10_10_rev: unit -> GLenum.t [@@js.get "INT_2_10_10_10_REV"]
  val int_sampler_2d: unit -> GLenum.t [@@js.get "INT_SAMPLER_2D"]
  val int_sampler_2d_array: unit -> GLenum.t [@@js.get "INT_SAMPLER_2D_ARRAY"]
  val int_sampler_3d: unit -> GLenum.t [@@js.get "INT_SAMPLER_3D"]
  val int_sampler_cube: unit -> GLenum.t [@@js.get "INT_SAMPLER_CUBE"]
  val invalid_index: unit -> GLenum.t [@@js.get "INVALID_INDEX"]
  val max: unit -> GLenum.t [@@js.get "MAX"]
  val max_3d_texture_size: unit -> GLenum.t [@@js.get "MAX_3D_TEXTURE_SIZE"]
  val max_array_texture_layers: unit -> GLenum.t [@@js.get "MAX_ARRAY_TEXTURE_LAYERS"]
  val max_client_wait_timeout_webgl: unit -> GLenum.t [@@js.get "MAX_CLIENT_WAIT_TIMEOUT_WEBGL"]
  val max_color_attachments: unit -> GLenum.t [@@js.get "MAX_COLOR_ATTACHMENTS"]
  val max_combined_fragment_uniform_components: unit -> GLenum.t [@@js.get "MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS"]
  val max_combined_uniform_blocks: unit -> GLenum.t [@@js.get "MAX_COMBINED_UNIFORM_BLOCKS"]
  val max_combined_vertex_uniform_components: unit -> GLenum.t [@@js.get "MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS"]
  val max_draw_buffers: unit -> GLenum.t [@@js.get "MAX_DRAW_BUFFERS"]
  val max_elements_indices: unit -> GLenum.t [@@js.get "MAX_ELEMENTS_INDICES"]
  val max_elements_vertices: unit -> GLenum.t [@@js.get "MAX_ELEMENTS_VERTICES"]
  val max_element_index: unit -> GLenum.t [@@js.get "MAX_ELEMENT_INDEX"]
  val max_fragment_input_components: unit -> GLenum.t [@@js.get "MAX_FRAGMENT_INPUT_COMPONENTS"]
  val max_fragment_uniform_blocks: unit -> GLenum.t [@@js.get "MAX_FRAGMENT_UNIFORM_BLOCKS"]
  val max_fragment_uniform_components: unit -> GLenum.t [@@js.get "MAX_FRAGMENT_UNIFORM_COMPONENTS"]
  val max_program_texel_offset: unit -> GLenum.t [@@js.get "MAX_PROGRAM_TEXEL_OFFSET"]
  val max_samples: unit -> GLenum.t [@@js.get "MAX_SAMPLES"]
  val max_server_wait_timeout: unit -> GLenum.t [@@js.get "MAX_SERVER_WAIT_TIMEOUT"]
  val max_texture_lod_bias: unit -> GLenum.t [@@js.get "MAX_TEXTURE_LOD_BIAS"]
  val max_transform_feedback_interleaved_components: unit -> GLenum.t [@@js.get "MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS"]
  val max_transform_feedback_separate_attribs: unit -> GLenum.t [@@js.get "MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS"]
  val max_transform_feedback_separate_components: unit -> GLenum.t [@@js.get "MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS"]
  val max_uniform_block_size: unit -> GLenum.t [@@js.get "MAX_UNIFORM_BLOCK_SIZE"]
  val max_uniform_buffer_bindings: unit -> GLenum.t [@@js.get "MAX_UNIFORM_BUFFER_BINDINGS"]
  val max_varying_components: unit -> GLenum.t [@@js.get "MAX_VARYING_COMPONENTS"]
  val max_vertex_output_components: unit -> GLenum.t [@@js.get "MAX_VERTEX_OUTPUT_COMPONENTS"]
  val max_vertex_uniform_blocks: unit -> GLenum.t [@@js.get "MAX_VERTEX_UNIFORM_BLOCKS"]
  val max_vertex_uniform_components: unit -> GLenum.t [@@js.get "MAX_VERTEX_UNIFORM_COMPONENTS"]
  val min: unit -> GLenum.t [@@js.get "MIN"]
  val min_program_texel_offset: unit -> GLenum.t [@@js.get "MIN_PROGRAM_TEXEL_OFFSET"]
  val object_type: unit -> GLenum.t [@@js.get "OBJECT_TYPE"]
  val pack_row_length: unit -> GLenum.t [@@js.get "PACK_ROW_LENGTH"]
  val pack_skip_pixels: unit -> GLenum.t [@@js.get "PACK_SKIP_PIXELS"]
  val pack_skip_rows: unit -> GLenum.t [@@js.get "PACK_SKIP_ROWS"]
  val pixel_pack_buffer: unit -> GLenum.t [@@js.get "PIXEL_PACK_BUFFER"]
  val pixel_pack_buffer_binding: unit -> GLenum.t [@@js.get "PIXEL_PACK_BUFFER_BINDING"]
  val pixel_unpack_buffer: unit -> GLenum.t [@@js.get "PIXEL_UNPACK_BUFFER"]
  val pixel_unpack_buffer_binding: unit -> GLenum.t [@@js.get "PIXEL_UNPACK_BUFFER_BINDING"]
  val query_result: unit -> GLenum.t [@@js.get "QUERY_RESULT"]
  val query_result_available: unit -> GLenum.t [@@js.get "QUERY_RESULT_AVAILABLE"]
  val r11f_g11f_b10f: unit -> GLenum.t [@@js.get "R11F_G11F_B10F"]
  val r16f: unit -> GLenum.t [@@js.get "R16F"]
  val r16i: unit -> GLenum.t [@@js.get "R16I"]
  val r16ui: unit -> GLenum.t [@@js.get "R16UI"]
  val r32f: unit -> GLenum.t [@@js.get "R32F"]
  val r32i: unit -> GLenum.t [@@js.get "R32I"]
  val r32ui: unit -> GLenum.t [@@js.get "R32UI"]
  val r8: unit -> GLenum.t [@@js.get "R8"]
  val r8i: unit -> GLenum.t [@@js.get "R8I"]
  val r8ui: unit -> GLenum.t [@@js.get "R8UI"]
  val r8_snorm: unit -> GLenum.t [@@js.get "R8_SNORM"]
  val rasterizer_discard: unit -> GLenum.t [@@js.get "RASTERIZER_DISCARD"]
  val read_buffer: unit -> GLenum.t [@@js.get "READ_BUFFER"]
  val read_framebuffer: unit -> GLenum.t [@@js.get "READ_FRAMEBUFFER"]
  val read_framebuffer_binding: unit -> GLenum.t [@@js.get "READ_FRAMEBUFFER_BINDING"]
  val red: unit -> GLenum.t [@@js.get "RED"]
  val red_integer: unit -> GLenum.t [@@js.get "RED_INTEGER"]
  val renderbuffer_samples: unit -> GLenum.t [@@js.get "RENDERBUFFER_SAMPLES"]
  val rg: unit -> GLenum.t [@@js.get "RG"]
  val rg16f: unit -> GLenum.t [@@js.get "RG16F"]
  val rg16i: unit -> GLenum.t [@@js.get "RG16I"]
  val rg16ui: unit -> GLenum.t [@@js.get "RG16UI"]
  val rg32f: unit -> GLenum.t [@@js.get "RG32F"]
  val rg32i: unit -> GLenum.t [@@js.get "RG32I"]
  val rg32ui: unit -> GLenum.t [@@js.get "RG32UI"]
  val rg8: unit -> GLenum.t [@@js.get "RG8"]
  val rg8i: unit -> GLenum.t [@@js.get "RG8I"]
  val rg8ui: unit -> GLenum.t [@@js.get "RG8UI"]
  val rg8_snorm: unit -> GLenum.t [@@js.get "RG8_SNORM"]
  val rgb10_a2: unit -> GLenum.t [@@js.get "RGB10_A2"]
  val rgb10_a2ui: unit -> GLenum.t [@@js.get "RGB10_A2UI"]
  val rgb16f: unit -> GLenum.t [@@js.get "RGB16F"]
  val rgb16i: unit -> GLenum.t [@@js.get "RGB16I"]
  val rgb16ui: unit -> GLenum.t [@@js.get "RGB16UI"]
  val rgb32f: unit -> GLenum.t [@@js.get "RGB32F"]
  val rgb32i: unit -> GLenum.t [@@js.get "RGB32I"]
  val rgb32ui: unit -> GLenum.t [@@js.get "RGB32UI"]
  val rgb8: unit -> GLenum.t [@@js.get "RGB8"]
  val rgb8i: unit -> GLenum.t [@@js.get "RGB8I"]
  val rgb8ui: unit -> GLenum.t [@@js.get "RGB8UI"]
  val rgb8_snorm: unit -> GLenum.t [@@js.get "RGB8_SNORM"]
  val rgb9_e5: unit -> GLenum.t [@@js.get "RGB9_E5"]
  val rgba16f: unit -> GLenum.t [@@js.get "RGBA16F"]
  val rgba16i: unit -> GLenum.t [@@js.get "RGBA16I"]
  val rgba16ui: unit -> GLenum.t [@@js.get "RGBA16UI"]
  val rgba32f: unit -> GLenum.t [@@js.get "RGBA32F"]
  val rgba32i: unit -> GLenum.t [@@js.get "RGBA32I"]
  val rgba32ui: unit -> GLenum.t [@@js.get "RGBA32UI"]
  val rgba8: unit -> GLenum.t [@@js.get "RGBA8"]
  val rgba8i: unit -> GLenum.t [@@js.get "RGBA8I"]
  val rgba8ui: unit -> GLenum.t [@@js.get "RGBA8UI"]
  val rgba8_snorm: unit -> GLenum.t [@@js.get "RGBA8_SNORM"]
  val rgba_integer: unit -> GLenum.t [@@js.get "RGBA_INTEGER"]
  val rgb_integer: unit -> GLenum.t [@@js.get "RGB_INTEGER"]
  val rg_integer: unit -> GLenum.t [@@js.get "RG_INTEGER"]
  val sampler_2d_array: unit -> GLenum.t [@@js.get "SAMPLER_2D_ARRAY"]
  val sampler_2d_array_shadow: unit -> GLenum.t [@@js.get "SAMPLER_2D_ARRAY_SHADOW"]
  val sampler_2d_shadow: unit -> GLenum.t [@@js.get "SAMPLER_2D_SHADOW"]
  val sampler_3d: unit -> GLenum.t [@@js.get "SAMPLER_3D"]
  val sampler_binding: unit -> GLenum.t [@@js.get "SAMPLER_BINDING"]
  val sampler_cube_shadow: unit -> GLenum.t [@@js.get "SAMPLER_CUBE_SHADOW"]
  val separate_attribs: unit -> GLenum.t [@@js.get "SEPARATE_ATTRIBS"]
  val signaled: unit -> GLenum.t [@@js.get "SIGNALED"]
  val signed_normalized: unit -> GLenum.t [@@js.get "SIGNED_NORMALIZED"]
  val srgb: unit -> GLenum.t [@@js.get "SRGB"]
  val srgb8: unit -> GLenum.t [@@js.get "SRGB8"]
  val srgb8_alpha8: unit -> GLenum.t [@@js.get "SRGB8_ALPHA8"]
  val static_copy: unit -> GLenum.t [@@js.get "STATIC_COPY"]
  val static_read: unit -> GLenum.t [@@js.get "STATIC_READ"]
  val stencil: unit -> GLenum.t [@@js.get "STENCIL"]
  val stream_copy: unit -> GLenum.t [@@js.get "STREAM_COPY"]
  val stream_read: unit -> GLenum.t [@@js.get "STREAM_READ"]
  val sync_condition: unit -> GLenum.t [@@js.get "SYNC_CONDITION"]
  val sync_fence: unit -> GLenum.t [@@js.get "SYNC_FENCE"]
  val sync_flags: unit -> GLenum.t [@@js.get "SYNC_FLAGS"]
  val sync_flush_commands_bit: unit -> GLenum.t [@@js.get "SYNC_FLUSH_COMMANDS_BIT"]
  val sync_gpu_commands_complete: unit -> GLenum.t [@@js.get "SYNC_GPU_COMMANDS_COMPLETE"]
  val sync_status: unit -> GLenum.t [@@js.get "SYNC_STATUS"]
  val texture_2d_array: unit -> GLenum.t [@@js.get "TEXTURE_2D_ARRAY"]
  val texture_3d: unit -> GLenum.t [@@js.get "TEXTURE_3D"]
  val texture_base_level: unit -> GLenum.t [@@js.get "TEXTURE_BASE_LEVEL"]
  val texture_binding_2d_array: unit -> GLenum.t [@@js.get "TEXTURE_BINDING_2D_ARRAY"]
  val texture_binding_3d: unit -> GLenum.t [@@js.get "TEXTURE_BINDING_3D"]
  val texture_compare_func: unit -> GLenum.t [@@js.get "TEXTURE_COMPARE_FUNC"]
  val texture_compare_mode: unit -> GLenum.t [@@js.get "TEXTURE_COMPARE_MODE"]
  val texture_immutable_format: unit -> GLenum.t [@@js.get "TEXTURE_IMMUTABLE_FORMAT"]
  val texture_immutable_levels: unit -> GLenum.t [@@js.get "TEXTURE_IMMUTABLE_LEVELS"]
  val texture_max_level: unit -> GLenum.t [@@js.get "TEXTURE_MAX_LEVEL"]
  val texture_max_lod: unit -> GLenum.t [@@js.get "TEXTURE_MAX_LOD"]
  val texture_min_lod: unit -> GLenum.t [@@js.get "TEXTURE_MIN_LOD"]
  val texture_wrap_r: unit -> GLenum.t [@@js.get "TEXTURE_WRAP_R"]
  val timeout_expired: unit -> GLenum.t [@@js.get "TIMEOUT_EXPIRED"]
  val timeout_ignored: unit -> GLint64.t [@@js.get "TIMEOUT_IGNORED"]
  val transform_feedback: unit -> GLenum.t [@@js.get "TRANSFORM_FEEDBACK"]
  val transform_feedback_active: unit -> GLenum.t [@@js.get "TRANSFORM_FEEDBACK_ACTIVE"]
  val transform_feedback_binding: unit -> GLenum.t [@@js.get "TRANSFORM_FEEDBACK_BINDING"]
  val transform_feedback_buffer: unit -> GLenum.t [@@js.get "TRANSFORM_FEEDBACK_BUFFER"]
  val transform_feedback_buffer_binding: unit -> GLenum.t [@@js.get "TRANSFORM_FEEDBACK_BUFFER_BINDING"]
  val transform_feedback_buffer_mode: unit -> GLenum.t [@@js.get "TRANSFORM_FEEDBACK_BUFFER_MODE"]
  val transform_feedback_buffer_size: unit -> GLenum.t [@@js.get "TRANSFORM_FEEDBACK_BUFFER_SIZE"]
  val transform_feedback_buffer_start: unit -> GLenum.t [@@js.get "TRANSFORM_FEEDBACK_BUFFER_START"]
  val transform_feedback_paused: unit -> GLenum.t [@@js.get "TRANSFORM_FEEDBACK_PAUSED"]
  val transform_feedback_primitives_written: unit -> GLenum.t [@@js.get "TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN"]
  val transform_feedback_varyings: unit -> GLenum.t [@@js.get "TRANSFORM_FEEDBACK_VARYINGS"]
  val uniform_array_stride: unit -> GLenum.t [@@js.get "UNIFORM_ARRAY_STRIDE"]
  val uniform_block_active_uniforms: unit -> GLenum.t [@@js.get "UNIFORM_BLOCK_ACTIVE_UNIFORMS"]
  val uniform_block_active_uniform_indices: unit -> GLenum.t [@@js.get "UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES"]
  val uniform_block_binding: unit -> GLenum.t [@@js.get "UNIFORM_BLOCK_BINDING"]
  val uniform_block_data_size: unit -> GLenum.t [@@js.get "UNIFORM_BLOCK_DATA_SIZE"]
  val uniform_block_index: unit -> GLenum.t [@@js.get "UNIFORM_BLOCK_INDEX"]
  val uniform_block_referenced_by_fragment_shader: unit -> GLenum.t [@@js.get "UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER"]
  val uniform_block_referenced_by_vertex_shader: unit -> GLenum.t [@@js.get "UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER"]
  val uniform_buffer: unit -> GLenum.t [@@js.get "UNIFORM_BUFFER"]
  val uniform_buffer_binding: unit -> GLenum.t [@@js.get "UNIFORM_BUFFER_BINDING"]
  val uniform_buffer_offset_alignment: unit -> GLenum.t [@@js.get "UNIFORM_BUFFER_OFFSET_ALIGNMENT"]
  val uniform_buffer_size: unit -> GLenum.t [@@js.get "UNIFORM_BUFFER_SIZE"]
  val uniform_buffer_start: unit -> GLenum.t [@@js.get "UNIFORM_BUFFER_START"]
  val uniform_is_row_major: unit -> GLenum.t [@@js.get "UNIFORM_IS_ROW_MAJOR"]
  val uniform_matrix_stride: unit -> GLenum.t [@@js.get "UNIFORM_MATRIX_STRIDE"]
  val uniform_offset: unit -> GLenum.t [@@js.get "UNIFORM_OFFSET"]
  val uniform_size: unit -> GLenum.t [@@js.get "UNIFORM_SIZE"]
  val uniform_type: unit -> GLenum.t [@@js.get "UNIFORM_TYPE"]
  val unpack_image_height: unit -> GLenum.t [@@js.get "UNPACK_IMAGE_HEIGHT"]
  val unpack_row_length: unit -> GLenum.t [@@js.get "UNPACK_ROW_LENGTH"]
  val unpack_skip_images: unit -> GLenum.t [@@js.get "UNPACK_SKIP_IMAGES"]
  val unpack_skip_pixels: unit -> GLenum.t [@@js.get "UNPACK_SKIP_PIXELS"]
  val unpack_skip_rows: unit -> GLenum.t [@@js.get "UNPACK_SKIP_ROWS"]
  val unsignaled: unit -> GLenum.t [@@js.get "UNSIGNALED"]
  val unsigned_int_10f_11f_11f_rev: unit -> GLenum.t [@@js.get "UNSIGNED_INT_10F_11F_11F_REV"]
  val unsigned_int_24_8: unit -> GLenum.t [@@js.get "UNSIGNED_INT_24_8"]
  val unsigned_int_2_10_10_10_rev: unit -> GLenum.t [@@js.get "UNSIGNED_INT_2_10_10_10_REV"]
  val unsigned_int_5_9_9_9_rev: unit -> GLenum.t [@@js.get "UNSIGNED_INT_5_9_9_9_REV"]
  val unsigned_int_sampler_2d: unit -> GLenum.t [@@js.get "UNSIGNED_INT_SAMPLER_2D"]
  val unsigned_int_sampler_2d_array: unit -> GLenum.t [@@js.get "UNSIGNED_INT_SAMPLER_2D_ARRAY"]
  val unsigned_int_sampler_3d: unit -> GLenum.t [@@js.get "UNSIGNED_INT_SAMPLER_3D"]
  val unsigned_int_sampler_cube: unit -> GLenum.t [@@js.get "UNSIGNED_INT_SAMPLER_CUBE"]
  val unsigned_int_vec2: unit -> GLenum.t [@@js.get "UNSIGNED_INT_VEC2"]
  val unsigned_int_vec3: unit -> GLenum.t [@@js.get "UNSIGNED_INT_VEC3"]
  val unsigned_int_vec4: unit -> GLenum.t [@@js.get "UNSIGNED_INT_VEC4"]
  val unsigned_normalized: unit -> GLenum.t [@@js.get "UNSIGNED_NORMALIZED"]
  val vertex_array_binding: unit -> GLenum.t [@@js.get "VERTEX_ARRAY_BINDING"]
  val vertex_attrib_array_divisor: unit -> GLenum.t [@@js.get "VERTEX_ATTRIB_ARRAY_DIVISOR"]
  val vertex_attrib_array_integer: unit -> GLenum.t [@@js.get "VERTEX_ATTRIB_ARRAY_INTEGER"]
  val wait_failed: unit -> GLenum.t [@@js.get "WAIT_FAILED"]
  val active_attributes: unit -> GLenum.t [@@js.get "ACTIVE_ATTRIBUTES"]
  val active_texture: unit -> GLenum.t [@@js.get "ACTIVE_TEXTURE"]
  val active_uniforms: unit -> GLenum.t [@@js.get "ACTIVE_UNIFORMS"]
  val aliased_line_width_range: unit -> GLenum.t [@@js.get "ALIASED_LINE_WIDTH_RANGE"]
  val aliased_point_size_range: unit -> GLenum.t [@@js.get "ALIASED_POINT_SIZE_RANGE"]
  val alpha: unit -> GLenum.t [@@js.get "ALPHA"]
  val alpha_bits: unit -> GLenum.t [@@js.get "ALPHA_BITS"]
  val always: unit -> GLenum.t [@@js.get "ALWAYS"]
  val array_buffer: unit -> GLenum.t [@@js.get "ARRAY_BUFFER"]
  val array_buffer_binding: unit -> GLenum.t [@@js.get "ARRAY_BUFFER_BINDING"]
  val attached_shaders: unit -> GLenum.t [@@js.get "ATTACHED_SHADERS"]
  val back: unit -> GLenum.t [@@js.get "BACK"]
  val blend: unit -> GLenum.t [@@js.get "BLEND"]
  val blend_color: unit -> GLenum.t [@@js.get "BLEND_COLOR"]
  val blend_dst_alpha: unit -> GLenum.t [@@js.get "BLEND_DST_ALPHA"]
  val blend_dst_rgb: unit -> GLenum.t [@@js.get "BLEND_DST_RGB"]
  val blend_equation: unit -> GLenum.t [@@js.get "BLEND_EQUATION"]
  val blend_equation_alpha: unit -> GLenum.t [@@js.get "BLEND_EQUATION_ALPHA"]
  val blend_equation_rgb: unit -> GLenum.t [@@js.get "BLEND_EQUATION_RGB"]
  val blend_src_alpha: unit -> GLenum.t [@@js.get "BLEND_SRC_ALPHA"]
  val blend_src_rgb: unit -> GLenum.t [@@js.get "BLEND_SRC_RGB"]
  val blue_bits: unit -> GLenum.t [@@js.get "BLUE_BITS"]
  val bool: unit -> GLenum.t [@@js.get "BOOL"]
  val bool_vec2: unit -> GLenum.t [@@js.get "BOOL_VEC2"]
  val bool_vec3: unit -> GLenum.t [@@js.get "BOOL_VEC3"]
  val bool_vec4: unit -> GLenum.t [@@js.get "BOOL_VEC4"]
  val browser_default_webgl: unit -> GLenum.t [@@js.get "BROWSER_DEFAULT_WEBGL"]
  val buffer_size: unit -> GLenum.t [@@js.get "BUFFER_SIZE"]
  val buffer_usage: unit -> GLenum.t [@@js.get "BUFFER_USAGE"]
  val byte: unit -> GLenum.t [@@js.get "BYTE"]
  val ccw: unit -> GLenum.t [@@js.get "CCW"]
  val clamp_to_edge: unit -> GLenum.t [@@js.get "CLAMP_TO_EDGE"]
  val color_attachment0: unit -> GLenum.t [@@js.get "COLOR_ATTACHMENT0"]
  val color_buffer_bit: unit -> GLenum.t [@@js.get "COLOR_BUFFER_BIT"]
  val color_clear_value: unit -> GLenum.t [@@js.get "COLOR_CLEAR_VALUE"]
  val color_writemask: unit -> GLenum.t [@@js.get "COLOR_WRITEMASK"]
  val compile_status: unit -> GLenum.t [@@js.get "COMPILE_STATUS"]
  val compressed_texture_formats: unit -> GLenum.t [@@js.get "COMPRESSED_TEXTURE_FORMATS"]
  val constant_alpha: unit -> GLenum.t [@@js.get "CONSTANT_ALPHA"]
  val constant_color: unit -> GLenum.t [@@js.get "CONSTANT_COLOR"]
  val context_lost_webgl: unit -> GLenum.t [@@js.get "CONTEXT_LOST_WEBGL"]
  val cull_face: unit -> GLenum.t [@@js.get "CULL_FACE"]
  val cull_face_mode: unit -> GLenum.t [@@js.get "CULL_FACE_MODE"]
  val current_program: unit -> GLenum.t [@@js.get "CURRENT_PROGRAM"]
  val current_vertex_attrib: unit -> GLenum.t [@@js.get "CURRENT_VERTEX_ATTRIB"]
  val cw: unit -> GLenum.t [@@js.get "CW"]
  val decr: unit -> GLenum.t [@@js.get "DECR"]
  val decr_wrap: unit -> GLenum.t [@@js.get "DECR_WRAP"]
  val delete_status: unit -> GLenum.t [@@js.get "DELETE_STATUS"]
  val depth_attachment: unit -> GLenum.t [@@js.get "DEPTH_ATTACHMENT"]
  val depth_bits: unit -> GLenum.t [@@js.get "DEPTH_BITS"]
  val depth_buffer_bit: unit -> GLenum.t [@@js.get "DEPTH_BUFFER_BIT"]
  val depth_clear_value: unit -> GLenum.t [@@js.get "DEPTH_CLEAR_VALUE"]
  val depth_component: unit -> GLenum.t [@@js.get "DEPTH_COMPONENT"]
  val depth_component16: unit -> GLenum.t [@@js.get "DEPTH_COMPONENT16"]
  val depth_func: unit -> GLenum.t [@@js.get "DEPTH_FUNC"]
  val depth_range: unit -> GLenum.t [@@js.get "DEPTH_RANGE"]
  val depth_stencil: unit -> GLenum.t [@@js.get "DEPTH_STENCIL"]
  val depth_stencil_attachment: unit -> GLenum.t [@@js.get "DEPTH_STENCIL_ATTACHMENT"]
  val depth_test: unit -> GLenum.t [@@js.get "DEPTH_TEST"]
  val depth_writemask: unit -> GLenum.t [@@js.get "DEPTH_WRITEMASK"]
  val dither: unit -> GLenum.t [@@js.get "DITHER"]
  val dont_care: unit -> GLenum.t [@@js.get "DONT_CARE"]
  val dst_alpha: unit -> GLenum.t [@@js.get "DST_ALPHA"]
  val dst_color: unit -> GLenum.t [@@js.get "DST_COLOR"]
  val dynamic_draw: unit -> GLenum.t [@@js.get "DYNAMIC_DRAW"]
  val element_array_buffer: unit -> GLenum.t [@@js.get "ELEMENT_ARRAY_BUFFER"]
  val element_array_buffer_binding: unit -> GLenum.t [@@js.get "ELEMENT_ARRAY_BUFFER_BINDING"]
  val equal: unit -> GLenum.t [@@js.get "EQUAL"]
  val fastest: unit -> GLenum.t [@@js.get "FASTEST"]
  val float: unit -> GLenum.t [@@js.get "FLOAT"]
  val float_mat2: unit -> GLenum.t [@@js.get "FLOAT_MAT2"]
  val float_mat3: unit -> GLenum.t [@@js.get "FLOAT_MAT3"]
  val float_mat4: unit -> GLenum.t [@@js.get "FLOAT_MAT4"]
  val float_vec2: unit -> GLenum.t [@@js.get "FLOAT_VEC2"]
  val float_vec3: unit -> GLenum.t [@@js.get "FLOAT_VEC3"]
  val float_vec4: unit -> GLenum.t [@@js.get "FLOAT_VEC4"]
  val fragment_shader: unit -> GLenum.t [@@js.get "FRAGMENT_SHADER"]
  val framebuffer: unit -> GLenum.t [@@js.get "FRAMEBUFFER"]
  val framebuffer_attachment_object_name: unit -> GLenum.t [@@js.get "FRAMEBUFFER_ATTACHMENT_OBJECT_NAME"]
  val framebuffer_attachment_object_type: unit -> GLenum.t [@@js.get "FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE"]
  val framebuffer_attachment_texture_cube_map_face: unit -> GLenum.t [@@js.get "FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE"]
  val framebuffer_attachment_texture_level: unit -> GLenum.t [@@js.get "FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL"]
  val framebuffer_binding: unit -> GLenum.t [@@js.get "FRAMEBUFFER_BINDING"]
  val framebuffer_complete: unit -> GLenum.t [@@js.get "FRAMEBUFFER_COMPLETE"]
  val framebuffer_incomplete_attachment: unit -> GLenum.t [@@js.get "FRAMEBUFFER_INCOMPLETE_ATTACHMENT"]
  val framebuffer_incomplete_dimensions: unit -> GLenum.t [@@js.get "FRAMEBUFFER_INCOMPLETE_DIMENSIONS"]
  val framebuffer_incomplete_missing_attachment: unit -> GLenum.t [@@js.get "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT"]
  val framebuffer_unsupported: unit -> GLenum.t [@@js.get "FRAMEBUFFER_UNSUPPORTED"]
  val front: unit -> GLenum.t [@@js.get "FRONT"]
  val front_and_back: unit -> GLenum.t [@@js.get "FRONT_AND_BACK"]
  val front_face: unit -> GLenum.t [@@js.get "FRONT_FACE"]
  val func_add: unit -> GLenum.t [@@js.get "FUNC_ADD"]
  val func_reverse_subtract: unit -> GLenum.t [@@js.get "FUNC_REVERSE_SUBTRACT"]
  val func_subtract: unit -> GLenum.t [@@js.get "FUNC_SUBTRACT"]
  val generate_mipmap_hint: unit -> GLenum.t [@@js.get "GENERATE_MIPMAP_HINT"]
  val gequal: unit -> GLenum.t [@@js.get "GEQUAL"]
  val greater: unit -> GLenum.t [@@js.get "GREATER"]
  val green_bits: unit -> GLenum.t [@@js.get "GREEN_BITS"]
  val high_float: unit -> GLenum.t [@@js.get "HIGH_FLOAT"]
  val high_int: unit -> GLenum.t [@@js.get "HIGH_INT"]
  val implementation_color_read_format: unit -> GLenum.t [@@js.get "IMPLEMENTATION_COLOR_READ_FORMAT"]
  val implementation_color_read_type: unit -> GLenum.t [@@js.get "IMPLEMENTATION_COLOR_READ_TYPE"]
  val incr: unit -> GLenum.t [@@js.get "INCR"]
  val incr_wrap: unit -> GLenum.t [@@js.get "INCR_WRAP"]
  val int: unit -> GLenum.t [@@js.get "INT"]
  val int_vec2: unit -> GLenum.t [@@js.get "INT_VEC2"]
  val int_vec3: unit -> GLenum.t [@@js.get "INT_VEC3"]
  val int_vec4: unit -> GLenum.t [@@js.get "INT_VEC4"]
  val invalid_enum: unit -> GLenum.t [@@js.get "INVALID_ENUM"]
  val invalid_framebuffer_operation: unit -> GLenum.t [@@js.get "INVALID_FRAMEBUFFER_OPERATION"]
  val invalid_operation: unit -> GLenum.t [@@js.get "INVALID_OPERATION"]
  val invalid_value: unit -> GLenum.t [@@js.get "INVALID_VALUE"]
  val invert: unit -> GLenum.t [@@js.get "INVERT"]
  val keep: unit -> GLenum.t [@@js.get "KEEP"]
  val lequal: unit -> GLenum.t [@@js.get "LEQUAL"]
  val less: unit -> GLenum.t [@@js.get "LESS"]
  val linear: unit -> GLenum.t [@@js.get "LINEAR"]
  val linear_mipmap_linear: unit -> GLenum.t [@@js.get "LINEAR_MIPMAP_LINEAR"]
  val linear_mipmap_nearest: unit -> GLenum.t [@@js.get "LINEAR_MIPMAP_NEAREST"]
  val lines: unit -> GLenum.t [@@js.get "LINES"]
  val line_loop: unit -> GLenum.t [@@js.get "LINE_LOOP"]
  val line_strip: unit -> GLenum.t [@@js.get "LINE_STRIP"]
  val line_width: unit -> GLenum.t [@@js.get "LINE_WIDTH"]
  val link_status: unit -> GLenum.t [@@js.get "LINK_STATUS"]
  val low_float: unit -> GLenum.t [@@js.get "LOW_FLOAT"]
  val low_int: unit -> GLenum.t [@@js.get "LOW_INT"]
  val luminance: unit -> GLenum.t [@@js.get "LUMINANCE"]
  val luminance_alpha: unit -> GLenum.t [@@js.get "LUMINANCE_ALPHA"]
  val max_combined_texture_image_units: unit -> GLenum.t [@@js.get "MAX_COMBINED_TEXTURE_IMAGE_UNITS"]
  val max_cube_map_texture_size: unit -> GLenum.t [@@js.get "MAX_CUBE_MAP_TEXTURE_SIZE"]
  val max_fragment_uniform_vectors: unit -> GLenum.t [@@js.get "MAX_FRAGMENT_UNIFORM_VECTORS"]
  val max_renderbuffer_size: unit -> GLenum.t [@@js.get "MAX_RENDERBUFFER_SIZE"]
  val max_texture_image_units: unit -> GLenum.t [@@js.get "MAX_TEXTURE_IMAGE_UNITS"]
  val max_texture_size: unit -> GLenum.t [@@js.get "MAX_TEXTURE_SIZE"]
  val max_varying_vectors: unit -> GLenum.t [@@js.get "MAX_VARYING_VECTORS"]
  val max_vertex_attribs: unit -> GLenum.t [@@js.get "MAX_VERTEX_ATTRIBS"]
  val max_vertex_texture_image_units: unit -> GLenum.t [@@js.get "MAX_VERTEX_TEXTURE_IMAGE_UNITS"]
  val max_vertex_uniform_vectors: unit -> GLenum.t [@@js.get "MAX_VERTEX_UNIFORM_VECTORS"]
  val max_viewport_dims: unit -> GLenum.t [@@js.get "MAX_VIEWPORT_DIMS"]
  val medium_float: unit -> GLenum.t [@@js.get "MEDIUM_FLOAT"]
  val medium_int: unit -> GLenum.t [@@js.get "MEDIUM_INT"]
  val mirrored_repeat: unit -> GLenum.t [@@js.get "MIRRORED_REPEAT"]
  val nearest: unit -> GLenum.t [@@js.get "NEAREST"]
  val nearest_mipmap_linear: unit -> GLenum.t [@@js.get "NEAREST_MIPMAP_LINEAR"]
  val nearest_mipmap_nearest: unit -> GLenum.t [@@js.get "NEAREST_MIPMAP_NEAREST"]
  val never: unit -> GLenum.t [@@js.get "NEVER"]
  val nicest: unit -> GLenum.t [@@js.get "NICEST"]
  val none: unit -> GLenum.t [@@js.get "NONE"]
  val notequal: unit -> GLenum.t [@@js.get "NOTEQUAL"]
  val no_error: unit -> GLenum.t [@@js.get "NO_ERROR"]
  val one: unit -> GLenum.t [@@js.get "ONE"]
  val one_minus_constant_alpha: unit -> GLenum.t [@@js.get "ONE_MINUS_CONSTANT_ALPHA"]
  val one_minus_constant_color: unit -> GLenum.t [@@js.get "ONE_MINUS_CONSTANT_COLOR"]
  val one_minus_dst_alpha: unit -> GLenum.t [@@js.get "ONE_MINUS_DST_ALPHA"]
  val one_minus_dst_color: unit -> GLenum.t [@@js.get "ONE_MINUS_DST_COLOR"]
  val one_minus_src_alpha: unit -> GLenum.t [@@js.get "ONE_MINUS_SRC_ALPHA"]
  val one_minus_src_color: unit -> GLenum.t [@@js.get "ONE_MINUS_SRC_COLOR"]
  val out_of_memory: unit -> GLenum.t [@@js.get "OUT_OF_MEMORY"]
  val pack_alignment: unit -> GLenum.t [@@js.get "PACK_ALIGNMENT"]
  val points: unit -> GLenum.t [@@js.get "POINTS"]
  val polygon_offset_factor: unit -> GLenum.t [@@js.get "POLYGON_OFFSET_FACTOR"]
  val polygon_offset_fill: unit -> GLenum.t [@@js.get "POLYGON_OFFSET_FILL"]
  val polygon_offset_units: unit -> GLenum.t [@@js.get "POLYGON_OFFSET_UNITS"]
  val red_bits: unit -> GLenum.t [@@js.get "RED_BITS"]
  val renderbuffer: unit -> GLenum.t [@@js.get "RENDERBUFFER"]
  val renderbuffer_alpha_size: unit -> GLenum.t [@@js.get "RENDERBUFFER_ALPHA_SIZE"]
  val renderbuffer_binding: unit -> GLenum.t [@@js.get "RENDERBUFFER_BINDING"]
  val renderbuffer_blue_size: unit -> GLenum.t [@@js.get "RENDERBUFFER_BLUE_SIZE"]
  val renderbuffer_depth_size: unit -> GLenum.t [@@js.get "RENDERBUFFER_DEPTH_SIZE"]
  val renderbuffer_green_size: unit -> GLenum.t [@@js.get "RENDERBUFFER_GREEN_SIZE"]
  val renderbuffer_height: unit -> GLenum.t [@@js.get "RENDERBUFFER_HEIGHT"]
  val renderbuffer_internal_format: unit -> GLenum.t [@@js.get "RENDERBUFFER_INTERNAL_FORMAT"]
  val renderbuffer_red_size: unit -> GLenum.t [@@js.get "RENDERBUFFER_RED_SIZE"]
  val renderbuffer_stencil_size: unit -> GLenum.t [@@js.get "RENDERBUFFER_STENCIL_SIZE"]
  val renderbuffer_width: unit -> GLenum.t [@@js.get "RENDERBUFFER_WIDTH"]
  val renderer: unit -> GLenum.t [@@js.get "RENDERER"]
  val repeat: unit -> GLenum.t [@@js.get "REPEAT"]
  val replace: unit -> GLenum.t [@@js.get "REPLACE"]
  val rgb: unit -> GLenum.t [@@js.get "RGB"]
  val rgb565: unit -> GLenum.t [@@js.get "RGB565"]
  val rgb5_a1: unit -> GLenum.t [@@js.get "RGB5_A1"]
  val rgba: unit -> GLenum.t [@@js.get "RGBA"]
  val rgba4: unit -> GLenum.t [@@js.get "RGBA4"]
  val sampler_2d: unit -> GLenum.t [@@js.get "SAMPLER_2D"]
  val sampler_cube: unit -> GLenum.t [@@js.get "SAMPLER_CUBE"]
  val samples: unit -> GLenum.t [@@js.get "SAMPLES"]
  val sample_alpha_to_coverage: unit -> GLenum.t [@@js.get "SAMPLE_ALPHA_TO_COVERAGE"]
  val sample_buffers: unit -> GLenum.t [@@js.get "SAMPLE_BUFFERS"]
  val sample_coverage: unit -> GLenum.t [@@js.get "SAMPLE_COVERAGE"]
  val sample_coverage_invert: unit -> GLenum.t [@@js.get "SAMPLE_COVERAGE_INVERT"]
  val sample_coverage_value: unit -> GLenum.t [@@js.get "SAMPLE_COVERAGE_VALUE"]
  val scissor_box: unit -> GLenum.t [@@js.get "SCISSOR_BOX"]
  val scissor_test: unit -> GLenum.t [@@js.get "SCISSOR_TEST"]
  val shader_type: unit -> GLenum.t [@@js.get "SHADER_TYPE"]
  val shading_language_version: unit -> GLenum.t [@@js.get "SHADING_LANGUAGE_VERSION"]
  val short: unit -> GLenum.t [@@js.get "SHORT"]
  val src_alpha: unit -> GLenum.t [@@js.get "SRC_ALPHA"]
  val src_alpha_saturate: unit -> GLenum.t [@@js.get "SRC_ALPHA_SATURATE"]
  val src_color: unit -> GLenum.t [@@js.get "SRC_COLOR"]
  val static_draw: unit -> GLenum.t [@@js.get "STATIC_DRAW"]
  val stencil_attachment: unit -> GLenum.t [@@js.get "STENCIL_ATTACHMENT"]
  val stencil_back_fail: unit -> GLenum.t [@@js.get "STENCIL_BACK_FAIL"]
  val stencil_back_func: unit -> GLenum.t [@@js.get "STENCIL_BACK_FUNC"]
  val stencil_back_pass_depth_fail: unit -> GLenum.t [@@js.get "STENCIL_BACK_PASS_DEPTH_FAIL"]
  val stencil_back_pass_depth_pass: unit -> GLenum.t [@@js.get "STENCIL_BACK_PASS_DEPTH_PASS"]
  val stencil_back_ref: unit -> GLenum.t [@@js.get "STENCIL_BACK_REF"]
  val stencil_back_value_mask: unit -> GLenum.t [@@js.get "STENCIL_BACK_VALUE_MASK"]
  val stencil_back_writemask: unit -> GLenum.t [@@js.get "STENCIL_BACK_WRITEMASK"]
  val stencil_bits: unit -> GLenum.t [@@js.get "STENCIL_BITS"]
  val stencil_buffer_bit: unit -> GLenum.t [@@js.get "STENCIL_BUFFER_BIT"]
  val stencil_clear_value: unit -> GLenum.t [@@js.get "STENCIL_CLEAR_VALUE"]
  val stencil_fail: unit -> GLenum.t [@@js.get "STENCIL_FAIL"]
  val stencil_func: unit -> GLenum.t [@@js.get "STENCIL_FUNC"]
  val stencil_index8: unit -> GLenum.t [@@js.get "STENCIL_INDEX8"]
  val stencil_pass_depth_fail: unit -> GLenum.t [@@js.get "STENCIL_PASS_DEPTH_FAIL"]
  val stencil_pass_depth_pass: unit -> GLenum.t [@@js.get "STENCIL_PASS_DEPTH_PASS"]
  val stencil_ref: unit -> GLenum.t [@@js.get "STENCIL_REF"]
  val stencil_test: unit -> GLenum.t [@@js.get "STENCIL_TEST"]
  val stencil_value_mask: unit -> GLenum.t [@@js.get "STENCIL_VALUE_MASK"]
  val stencil_writemask: unit -> GLenum.t [@@js.get "STENCIL_WRITEMASK"]
  val stream_draw: unit -> GLenum.t [@@js.get "STREAM_DRAW"]
  val subpixel_bits: unit -> GLenum.t [@@js.get "SUBPIXEL_BITS"]
  val texture: unit -> GLenum.t [@@js.get "TEXTURE"]
  val texture0: unit -> GLenum.t [@@js.get "TEXTURE0"]
  val texture1: unit -> GLenum.t [@@js.get "TEXTURE1"]
  val texture10: unit -> GLenum.t [@@js.get "TEXTURE10"]
  val texture11: unit -> GLenum.t [@@js.get "TEXTURE11"]
  val texture12: unit -> GLenum.t [@@js.get "TEXTURE12"]
  val texture13: unit -> GLenum.t [@@js.get "TEXTURE13"]
  val texture14: unit -> GLenum.t [@@js.get "TEXTURE14"]
  val texture15: unit -> GLenum.t [@@js.get "TEXTURE15"]
  val texture16: unit -> GLenum.t [@@js.get "TEXTURE16"]
  val texture17: unit -> GLenum.t [@@js.get "TEXTURE17"]
  val texture18: unit -> GLenum.t [@@js.get "TEXTURE18"]
  val texture19: unit -> GLenum.t [@@js.get "TEXTURE19"]
  val texture2: unit -> GLenum.t [@@js.get "TEXTURE2"]
  val texture20: unit -> GLenum.t [@@js.get "TEXTURE20"]
  val texture21: unit -> GLenum.t [@@js.get "TEXTURE21"]
  val texture22: unit -> GLenum.t [@@js.get "TEXTURE22"]
  val texture23: unit -> GLenum.t [@@js.get "TEXTURE23"]
  val texture24: unit -> GLenum.t [@@js.get "TEXTURE24"]
  val texture25: unit -> GLenum.t [@@js.get "TEXTURE25"]
  val texture26: unit -> GLenum.t [@@js.get "TEXTURE26"]
  val texture27: unit -> GLenum.t [@@js.get "TEXTURE27"]
  val texture28: unit -> GLenum.t [@@js.get "TEXTURE28"]
  val texture29: unit -> GLenum.t [@@js.get "TEXTURE29"]
  val texture3: unit -> GLenum.t [@@js.get "TEXTURE3"]
  val texture30: unit -> GLenum.t [@@js.get "TEXTURE30"]
  val texture31: unit -> GLenum.t [@@js.get "TEXTURE31"]
  val texture4: unit -> GLenum.t [@@js.get "TEXTURE4"]
  val texture5: unit -> GLenum.t [@@js.get "TEXTURE5"]
  val texture6: unit -> GLenum.t [@@js.get "TEXTURE6"]
  val texture7: unit -> GLenum.t [@@js.get "TEXTURE7"]
  val texture8: unit -> GLenum.t [@@js.get "TEXTURE8"]
  val texture9: unit -> GLenum.t [@@js.get "TEXTURE9"]
  val texture_2d: unit -> GLenum.t [@@js.get "TEXTURE_2D"]
  val texture_binding_2d: unit -> GLenum.t [@@js.get "TEXTURE_BINDING_2D"]
  val texture_binding_cube_map: unit -> GLenum.t [@@js.get "TEXTURE_BINDING_CUBE_MAP"]
  val texture_cube_map: unit -> GLenum.t [@@js.get "TEXTURE_CUBE_MAP"]
  val texture_cube_map_negative_x: unit -> GLenum.t [@@js.get "TEXTURE_CUBE_MAP_NEGATIVE_X"]
  val texture_cube_map_negative_y: unit -> GLenum.t [@@js.get "TEXTURE_CUBE_MAP_NEGATIVE_Y"]
  val texture_cube_map_negative_z: unit -> GLenum.t [@@js.get "TEXTURE_CUBE_MAP_NEGATIVE_Z"]
  val texture_cube_map_positive_x: unit -> GLenum.t [@@js.get "TEXTURE_CUBE_MAP_POSITIVE_X"]
  val texture_cube_map_positive_y: unit -> GLenum.t [@@js.get "TEXTURE_CUBE_MAP_POSITIVE_Y"]
  val texture_cube_map_positive_z: unit -> GLenum.t [@@js.get "TEXTURE_CUBE_MAP_POSITIVE_Z"]
  val texture_mag_filter: unit -> GLenum.t [@@js.get "TEXTURE_MAG_FILTER"]
  val texture_min_filter: unit -> GLenum.t [@@js.get "TEXTURE_MIN_FILTER"]
  val texture_wrap_s: unit -> GLenum.t [@@js.get "TEXTURE_WRAP_S"]
  val texture_wrap_t: unit -> GLenum.t [@@js.get "TEXTURE_WRAP_T"]
  val triangles: unit -> GLenum.t [@@js.get "TRIANGLES"]
  val triangle_fan: unit -> GLenum.t [@@js.get "TRIANGLE_FAN"]
  val triangle_strip: unit -> GLenum.t [@@js.get "TRIANGLE_STRIP"]
  val unpack_alignment: unit -> GLenum.t [@@js.get "UNPACK_ALIGNMENT"]
  val unpack_colorspace_conversion_webgl: unit -> GLenum.t [@@js.get "UNPACK_COLORSPACE_CONVERSION_WEBGL"]
  val unpack_flip_y_webgl: unit -> GLenum.t [@@js.get "UNPACK_FLIP_Y_WEBGL"]
  val unpack_premultiply_alpha_webgl: unit -> GLenum.t [@@js.get "UNPACK_PREMULTIPLY_ALPHA_WEBGL"]
  val unsigned_byte: unit -> GLenum.t [@@js.get "UNSIGNED_BYTE"]
  val unsigned_int: unit -> GLenum.t [@@js.get "UNSIGNED_INT"]
  val unsigned_short: unit -> GLenum.t [@@js.get "UNSIGNED_SHORT"]
  val unsigned_short_4_4_4_4: unit -> GLenum.t [@@js.get "UNSIGNED_SHORT_4_4_4_4"]
  val unsigned_short_5_5_5_1: unit -> GLenum.t [@@js.get "UNSIGNED_SHORT_5_5_5_1"]
  val unsigned_short_5_6_5: unit -> GLenum.t [@@js.get "UNSIGNED_SHORT_5_6_5"]
  val validate_status: unit -> GLenum.t [@@js.get "VALIDATE_STATUS"]
  val vendor: unit -> GLenum.t [@@js.get "VENDOR"]
  val version: unit -> GLenum.t [@@js.get "VERSION"]
  val vertex_attrib_array_buffer_binding: unit -> GLenum.t [@@js.get "VERTEX_ATTRIB_ARRAY_BUFFER_BINDING"]
  val vertex_attrib_array_enabled: unit -> GLenum.t [@@js.get "VERTEX_ATTRIB_ARRAY_ENABLED"]
  val vertex_attrib_array_normalized: unit -> GLenum.t [@@js.get "VERTEX_ATTRIB_ARRAY_NORMALIZED"]
  val vertex_attrib_array_pointer: unit -> GLenum.t [@@js.get "VERTEX_ATTRIB_ARRAY_POINTER"]
  val vertex_attrib_array_size: unit -> GLenum.t [@@js.get "VERTEX_ATTRIB_ARRAY_SIZE"]
  val vertex_attrib_array_stride: unit -> GLenum.t [@@js.get "VERTEX_ATTRIB_ARRAY_STRIDE"]
  val vertex_attrib_array_type: unit -> GLenum.t [@@js.get "VERTEX_ATTRIB_ARRAY_TYPE"]
  val vertex_shader: unit -> GLenum.t [@@js.get "VERTEX_SHADER"]
  val viewport: unit -> GLenum.t [@@js.get "VIEWPORT"]
  val zero: unit -> GLenum.t [@@js.get "ZERO"]
end
and WebGL2RenderingContextBase : sig
  type t = [`WebGL2RenderingContextBase] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`WebGL2RenderingContextBase]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`WebGL2RenderingContextBase]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `WebGL2RenderingContextBase ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val clearBufferfv: 'tags this -> buffer:GLenum.t -> drawbuffer:GLint.t -> values:GLfloat.t Iterable.t_1 -> ?srcOffset:GLuint.t -> unit -> unit [@@js.call "clearBufferfv"]
  val clearBufferiv: 'tags this -> buffer:GLenum.t -> drawbuffer:GLint.t -> values:GLint.t Iterable.t_1 -> ?srcOffset:GLuint.t -> unit -> unit [@@js.call "clearBufferiv"]
  val clearBufferuiv: 'tags this -> buffer:GLenum.t -> drawbuffer:GLint.t -> values:GLuint.t Iterable.t_1 -> ?srcOffset:GLuint.t -> unit -> unit [@@js.call "clearBufferuiv"]
  val drawBuffers: 'tags this -> buffers:GLenum.t Iterable.t_1 -> unit [@@js.call "drawBuffers"]
  val getActiveUniforms: 'tags this -> program:WebGLProgram.t -> uniformIndices:GLuint.t Iterable.t_1 -> pname:GLenum.t -> any [@@js.call "getActiveUniforms"]
  val getUniformIndices: 'tags this -> program:WebGLProgram.t -> uniformNames:string Iterable.t_1 -> GLuint.t Iterable.t_1 option [@@js.call "getUniformIndices"]
  val invalidateFramebuffer: 'tags this -> target:GLenum.t -> attachments:GLenum.t Iterable.t_1 -> unit [@@js.call "invalidateFramebuffer"]
  val invalidateSubFramebuffer: 'tags this -> target:GLenum.t -> attachments:GLenum.t Iterable.t_1 -> x:GLint.t -> y:GLint.t -> width:GLsizei.t -> height:GLsizei.t -> unit [@@js.call "invalidateSubFramebuffer"]
  val transformFeedbackVaryings: 'tags this -> program:WebGLProgram.t -> varyings:string Iterable.t_1 -> bufferMode:GLenum.t -> unit [@@js.call "transformFeedbackVaryings"]
  val uniform1uiv: 'tags this -> location:WebGLUniformLocation.t option -> data:GLuint.t Iterable.t_1 -> ?srcOffset:GLuint.t -> ?srcLength:GLuint.t -> unit -> unit [@@js.call "uniform1uiv"]
  val uniform2uiv: 'tags this -> location:WebGLUniformLocation.t option -> data:GLuint.t Iterable.t_1 -> ?srcOffset:GLuint.t -> ?srcLength:GLuint.t -> unit -> unit [@@js.call "uniform2uiv"]
  val uniform3uiv: 'tags this -> location:WebGLUniformLocation.t option -> data:GLuint.t Iterable.t_1 -> ?srcOffset:GLuint.t -> ?srcLength:GLuint.t -> unit -> unit [@@js.call "uniform3uiv"]
  val uniform4uiv: 'tags this -> location:WebGLUniformLocation.t option -> data:GLuint.t Iterable.t_1 -> ?srcOffset:GLuint.t -> ?srcLength:GLuint.t -> unit -> unit [@@js.call "uniform4uiv"]
  val uniformMatrix2x3fv: 'tags this -> location:WebGLUniformLocation.t option -> transpose:GLboolean.t -> data:GLfloat.t Iterable.t_1 -> ?srcOffset:GLuint.t -> ?srcLength:GLuint.t -> unit -> unit [@@js.call "uniformMatrix2x3fv"]
  val uniformMatrix2x4fv: 'tags this -> location:WebGLUniformLocation.t option -> transpose:GLboolean.t -> data:GLfloat.t Iterable.t_1 -> ?srcOffset:GLuint.t -> ?srcLength:GLuint.t -> unit -> unit [@@js.call "uniformMatrix2x4fv"]
  val uniformMatrix3x2fv: 'tags this -> location:WebGLUniformLocation.t option -> transpose:GLboolean.t -> data:GLfloat.t Iterable.t_1 -> ?srcOffset:GLuint.t -> ?srcLength:GLuint.t -> unit -> unit [@@js.call "uniformMatrix3x2fv"]
  val uniformMatrix3x4fv: 'tags this -> location:WebGLUniformLocation.t option -> transpose:GLboolean.t -> data:GLfloat.t Iterable.t_1 -> ?srcOffset:GLuint.t -> ?srcLength:GLuint.t -> unit -> unit [@@js.call "uniformMatrix3x4fv"]
  val uniformMatrix4x2fv: 'tags this -> location:WebGLUniformLocation.t option -> transpose:GLboolean.t -> data:GLfloat.t Iterable.t_1 -> ?srcOffset:GLuint.t -> ?srcLength:GLuint.t -> unit -> unit [@@js.call "uniformMatrix4x2fv"]
  val uniformMatrix4x3fv: 'tags this -> location:WebGLUniformLocation.t option -> transpose:GLboolean.t -> data:GLfloat.t Iterable.t_1 -> ?srcOffset:GLuint.t -> ?srcLength:GLuint.t -> unit -> unit [@@js.call "uniformMatrix4x3fv"]
  val vertexAttribI4iv: 'tags this -> index:GLuint.t -> values:GLint.t Iterable.t_1 -> unit [@@js.call "vertexAttribI4iv"]
  val vertexAttribI4uiv: 'tags this -> index:GLuint.t -> values:GLuint.t Iterable.t_1 -> unit [@@js.call "vertexAttribI4uiv"]
  val beginQuery: 'tags this -> target:GLenum.t -> query:WebGLQuery.t -> unit [@@js.call "beginQuery"]
  val beginTransformFeedback: 'tags this -> primitiveMode:GLenum.t -> unit [@@js.call "beginTransformFeedback"]
  val bindBufferBase: 'tags this -> target:GLenum.t -> index:GLuint.t -> buffer:WebGLBuffer.t option -> unit [@@js.call "bindBufferBase"]
  val bindBufferRange: 'tags this -> target:GLenum.t -> index:GLuint.t -> buffer:WebGLBuffer.t option -> offset:GLintptr.t -> size:GLsizeiptr.t -> unit [@@js.call "bindBufferRange"]
  val bindSampler: 'tags this -> unit:GLuint.t -> sampler:WebGLSampler.t option -> unit [@@js.call "bindSampler"]
  val bindTransformFeedback: 'tags this -> target:GLenum.t -> tf:WebGLTransformFeedback.t option -> unit [@@js.call "bindTransformFeedback"]
  val bindVertexArray: 'tags this -> array:WebGLVertexArrayObject.t option -> unit [@@js.call "bindVertexArray"]
  val blitFramebuffer: 'tags this -> srcX0:GLint.t -> srcY0:GLint.t -> srcX1:GLint.t -> srcY1:GLint.t -> dstX0:GLint.t -> dstY0:GLint.t -> dstX1:GLint.t -> dstY1:GLint.t -> mask:GLbitfield.t -> filter:GLenum.t -> unit [@@js.call "blitFramebuffer"]
  val clearBufferfi: 'tags this -> buffer:GLenum.t -> drawbuffer:GLint.t -> depth:GLfloat.t -> stencil:GLint.t -> unit [@@js.call "clearBufferfi"]
  val clearBufferfv': 'tags this -> buffer:GLenum.t -> drawbuffer:GLint.t -> values:Float32List.t -> ?srcOffset:GLuint.t -> unit -> unit [@@js.call "clearBufferfv"]
  val clearBufferiv': 'tags this -> buffer:GLenum.t -> drawbuffer:GLint.t -> values:Int32List.t -> ?srcOffset:GLuint.t -> unit -> unit [@@js.call "clearBufferiv"]
  val clearBufferuiv': 'tags this -> buffer:GLenum.t -> drawbuffer:GLint.t -> values:Uint32List.t -> ?srcOffset:GLuint.t -> unit -> unit [@@js.call "clearBufferuiv"]
  val clientWaitSync: 'tags this -> sync:WebGLSync.t -> flags:GLbitfield.t -> timeout:GLuint64.t -> GLenum.t [@@js.call "clientWaitSync"]
  val compressedTexImage3D: 'tags this -> target:GLenum.t -> level:GLint.t -> internalformat:GLenum.t -> width:GLsizei.t -> height:GLsizei.t -> depth:GLsizei.t -> border:GLint.t -> imageSize:GLsizei.t -> offset:GLintptr.t -> unit [@@js.call "compressedTexImage3D"]
  val compressedTexImage3D': 'tags this -> target:GLenum.t -> level:GLint.t -> internalformat:GLenum.t -> width:GLsizei.t -> height:GLsizei.t -> depth:GLsizei.t -> border:GLint.t -> srcData:ArrayBufferView.t_0 -> ?srcOffset:GLuint.t -> ?srcLengthOverride:GLuint.t -> unit -> unit [@@js.call "compressedTexImage3D"]
  val compressedTexSubImage3D: 'tags this -> target:GLenum.t -> level:GLint.t -> xoffset:GLint.t -> yoffset:GLint.t -> zoffset:GLint.t -> width:GLsizei.t -> height:GLsizei.t -> depth:GLsizei.t -> format:GLenum.t -> imageSize:GLsizei.t -> offset:GLintptr.t -> unit [@@js.call "compressedTexSubImage3D"]
  val compressedTexSubImage3D': 'tags this -> target:GLenum.t -> level:GLint.t -> xoffset:GLint.t -> yoffset:GLint.t -> zoffset:GLint.t -> width:GLsizei.t -> height:GLsizei.t -> depth:GLsizei.t -> format:GLenum.t -> srcData:ArrayBufferView.t_0 -> ?srcOffset:GLuint.t -> ?srcLengthOverride:GLuint.t -> unit -> unit [@@js.call "compressedTexSubImage3D"]
  val copyBufferSubData: 'tags this -> readTarget:GLenum.t -> writeTarget:GLenum.t -> readOffset:GLintptr.t -> writeOffset:GLintptr.t -> size:GLsizeiptr.t -> unit [@@js.call "copyBufferSubData"]
  val copyTexSubImage3D: 'tags this -> target:GLenum.t -> level:GLint.t -> xoffset:GLint.t -> yoffset:GLint.t -> zoffset:GLint.t -> x:GLint.t -> y:GLint.t -> width:GLsizei.t -> height:GLsizei.t -> unit [@@js.call "copyTexSubImage3D"]
  val createQuery: 'tags this -> WebGLQuery.t option [@@js.call "createQuery"]
  val createSampler: 'tags this -> WebGLSampler.t option [@@js.call "createSampler"]
  val createTransformFeedback: 'tags this -> WebGLTransformFeedback.t option [@@js.call "createTransformFeedback"]
  val createVertexArray: 'tags this -> WebGLVertexArrayObject.t option [@@js.call "createVertexArray"]
  val deleteQuery: 'tags this -> query:WebGLQuery.t option -> unit [@@js.call "deleteQuery"]
  val deleteSampler: 'tags this -> sampler:WebGLSampler.t option -> unit [@@js.call "deleteSampler"]
  val deleteSync: 'tags this -> sync:WebGLSync.t option -> unit [@@js.call "deleteSync"]
  val deleteTransformFeedback: 'tags this -> tf:WebGLTransformFeedback.t option -> unit [@@js.call "deleteTransformFeedback"]
  val deleteVertexArray: 'tags this -> vertexArray:WebGLVertexArrayObject.t option -> unit [@@js.call "deleteVertexArray"]
  val drawArraysInstanced: 'tags this -> mode:GLenum.t -> first:GLint.t -> count:GLsizei.t -> instanceCount:GLsizei.t -> unit [@@js.call "drawArraysInstanced"]
  val drawBuffers': 'tags this -> buffers:GLenum.t list -> unit [@@js.call "drawBuffers"]
  val drawElementsInstanced: 'tags this -> mode:GLenum.t -> count:GLsizei.t -> type_:GLenum.t -> offset:GLintptr.t -> instanceCount:GLsizei.t -> unit [@@js.call "drawElementsInstanced"]
  val drawRangeElements: 'tags this -> mode:GLenum.t -> start:GLuint.t -> end_:GLuint.t -> count:GLsizei.t -> type_:GLenum.t -> offset:GLintptr.t -> unit [@@js.call "drawRangeElements"]
  val endQuery: 'tags this -> target:GLenum.t -> unit [@@js.call "endQuery"]
  val endTransformFeedback: 'tags this -> unit [@@js.call "endTransformFeedback"]
  val fenceSync: 'tags this -> condition:GLenum.t -> flags:GLbitfield.t -> WebGLSync.t option [@@js.call "fenceSync"]
  val framebufferTextureLayer: 'tags this -> target:GLenum.t -> attachment:GLenum.t -> texture:WebGLTexture.t option -> level:GLint.t -> layer:GLint.t -> unit [@@js.call "framebufferTextureLayer"]
  val getActiveUniformBlockName: 'tags this -> program:WebGLProgram.t -> uniformBlockIndex:GLuint.t -> string option [@@js.call "getActiveUniformBlockName"]
  val getActiveUniformBlockParameter: 'tags this -> program:WebGLProgram.t -> uniformBlockIndex:GLuint.t -> pname:GLenum.t -> any [@@js.call "getActiveUniformBlockParameter"]
  val getActiveUniforms': 'tags this -> program:WebGLProgram.t -> uniformIndices:GLuint.t list -> pname:GLenum.t -> any [@@js.call "getActiveUniforms"]
  val getBufferSubData: 'tags this -> target:GLenum.t -> srcByteOffset:GLintptr.t -> dstBuffer:ArrayBufferView.t_0 -> ?dstOffset:GLuint.t -> ?length:GLuint.t -> unit -> unit [@@js.call "getBufferSubData"]
  val getFragDataLocation: 'tags this -> program:WebGLProgram.t -> name:string -> GLint.t [@@js.call "getFragDataLocation"]
  val getIndexedParameter: 'tags this -> target:GLenum.t -> index:GLuint.t -> any [@@js.call "getIndexedParameter"]
  val getInternalformatParameter: 'tags this -> target:GLenum.t -> internalformat:GLenum.t -> pname:GLenum.t -> any [@@js.call "getInternalformatParameter"]
  val getQuery: 'tags this -> target:GLenum.t -> pname:GLenum.t -> WebGLQuery.t option [@@js.call "getQuery"]
  val getQueryParameter: 'tags this -> query:WebGLQuery.t -> pname:GLenum.t -> any [@@js.call "getQueryParameter"]
  val getSamplerParameter: 'tags this -> sampler:WebGLSampler.t -> pname:GLenum.t -> any [@@js.call "getSamplerParameter"]
  val getSyncParameter: 'tags this -> sync:WebGLSync.t -> pname:GLenum.t -> any [@@js.call "getSyncParameter"]
  val getTransformFeedbackVarying: 'tags this -> program:WebGLProgram.t -> index:GLuint.t -> WebGLActiveInfo.t option [@@js.call "getTransformFeedbackVarying"]
  val getUniformBlockIndex: 'tags this -> program:WebGLProgram.t -> uniformBlockName:string -> GLuint.t [@@js.call "getUniformBlockIndex"]
  val getUniformIndices': 'tags this -> program:WebGLProgram.t -> uniformNames:string list -> GLuint.t list option [@@js.call "getUniformIndices"]
  val invalidateFramebuffer': 'tags this -> target:GLenum.t -> attachments:GLenum.t list -> unit [@@js.call "invalidateFramebuffer"]
  val invalidateSubFramebuffer': 'tags this -> target:GLenum.t -> attachments:GLenum.t list -> x:GLint.t -> y:GLint.t -> width:GLsizei.t -> height:GLsizei.t -> unit [@@js.call "invalidateSubFramebuffer"]
  val isQuery: 'tags this -> query:WebGLQuery.t option -> GLboolean.t [@@js.call "isQuery"]
  val isSampler: 'tags this -> sampler:WebGLSampler.t option -> GLboolean.t [@@js.call "isSampler"]
  val isSync: 'tags this -> sync:WebGLSync.t option -> GLboolean.t [@@js.call "isSync"]
  val isTransformFeedback: 'tags this -> tf:WebGLTransformFeedback.t option -> GLboolean.t [@@js.call "isTransformFeedback"]
  val isVertexArray: 'tags this -> vertexArray:WebGLVertexArrayObject.t option -> GLboolean.t [@@js.call "isVertexArray"]
  val pauseTransformFeedback: 'tags this -> unit [@@js.call "pauseTransformFeedback"]
  val readBuffer: 'tags this -> src:GLenum.t -> unit [@@js.call "readBuffer"]
  val renderbufferStorageMultisample: 'tags this -> target:GLenum.t -> samples:GLsizei.t -> internalformat:GLenum.t -> width:GLsizei.t -> height:GLsizei.t -> unit [@@js.call "renderbufferStorageMultisample"]
  val resumeTransformFeedback: 'tags this -> unit [@@js.call "resumeTransformFeedback"]
  val samplerParameterf: 'tags this -> sampler:WebGLSampler.t -> pname:GLenum.t -> param:GLfloat.t -> unit [@@js.call "samplerParameterf"]
  val samplerParameteri: 'tags this -> sampler:WebGLSampler.t -> pname:GLenum.t -> param:GLint.t -> unit [@@js.call "samplerParameteri"]
  val texImage3D: 'tags this -> target:GLenum.t -> level:GLint.t -> internalformat:GLint.t -> width:GLsizei.t -> height:GLsizei.t -> depth:GLsizei.t -> border:GLint.t -> format:GLenum.t -> type_:GLenum.t -> pboOffset:GLintptr.t -> unit [@@js.call "texImage3D"]
  val texImage3D': 'tags this -> target:GLenum.t -> level:GLint.t -> internalformat:GLint.t -> width:GLsizei.t -> height:GLsizei.t -> depth:GLsizei.t -> border:GLint.t -> format:GLenum.t -> type_:GLenum.t -> source:TexImageSource.t -> unit [@@js.call "texImage3D"]
  val texImage3D'': 'tags this -> target:GLenum.t -> level:GLint.t -> internalformat:GLint.t -> width:GLsizei.t -> height:GLsizei.t -> depth:GLsizei.t -> border:GLint.t -> format:GLenum.t -> type_:GLenum.t -> srcData:ArrayBufferView.t_0 option -> unit [@@js.call "texImage3D"]
  val texImage3D''': 'tags this -> target:GLenum.t -> level:GLint.t -> internalformat:GLint.t -> width:GLsizei.t -> height:GLsizei.t -> depth:GLsizei.t -> border:GLint.t -> format:GLenum.t -> type_:GLenum.t -> srcData:ArrayBufferView.t_0 -> srcOffset:GLuint.t -> unit [@@js.call "texImage3D"]
  val texStorage2D: 'tags this -> target:GLenum.t -> levels:GLsizei.t -> internalformat:GLenum.t -> width:GLsizei.t -> height:GLsizei.t -> unit [@@js.call "texStorage2D"]
  val texStorage3D: 'tags this -> target:GLenum.t -> levels:GLsizei.t -> internalformat:GLenum.t -> width:GLsizei.t -> height:GLsizei.t -> depth:GLsizei.t -> unit [@@js.call "texStorage3D"]
  val texSubImage3D: 'tags this -> target:GLenum.t -> level:GLint.t -> xoffset:GLint.t -> yoffset:GLint.t -> zoffset:GLint.t -> width:GLsizei.t -> height:GLsizei.t -> depth:GLsizei.t -> format:GLenum.t -> type_:GLenum.t -> pboOffset:GLintptr.t -> unit [@@js.call "texSubImage3D"]
  val texSubImage3D': 'tags this -> target:GLenum.t -> level:GLint.t -> xoffset:GLint.t -> yoffset:GLint.t -> zoffset:GLint.t -> width:GLsizei.t -> height:GLsizei.t -> depth:GLsizei.t -> format:GLenum.t -> type_:GLenum.t -> source:TexImageSource.t -> unit [@@js.call "texSubImage3D"]
  val texSubImage3D'': 'tags this -> target:GLenum.t -> level:GLint.t -> xoffset:GLint.t -> yoffset:GLint.t -> zoffset:GLint.t -> width:GLsizei.t -> height:GLsizei.t -> depth:GLsizei.t -> format:GLenum.t -> type_:GLenum.t -> srcData:ArrayBufferView.t_0 option -> ?srcOffset:GLuint.t -> unit -> unit [@@js.call "texSubImage3D"]
  val transformFeedbackVaryings': 'tags this -> program:WebGLProgram.t -> varyings:string list -> bufferMode:GLenum.t -> unit [@@js.call "transformFeedbackVaryings"]
  val uniform1ui: 'tags this -> location:WebGLUniformLocation.t option -> v0:GLuint.t -> unit [@@js.call "uniform1ui"]
  val uniform1uiv': 'tags this -> location:WebGLUniformLocation.t option -> data:Uint32List.t -> ?srcOffset:GLuint.t -> ?srcLength:GLuint.t -> unit -> unit [@@js.call "uniform1uiv"]
  val uniform2ui: 'tags this -> location:WebGLUniformLocation.t option -> v0:GLuint.t -> v1:GLuint.t -> unit [@@js.call "uniform2ui"]
  val uniform2uiv': 'tags this -> location:WebGLUniformLocation.t option -> data:Uint32List.t -> ?srcOffset:GLuint.t -> ?srcLength:GLuint.t -> unit -> unit [@@js.call "uniform2uiv"]
  val uniform3ui: 'tags this -> location:WebGLUniformLocation.t option -> v0:GLuint.t -> v1:GLuint.t -> v2:GLuint.t -> unit [@@js.call "uniform3ui"]
  val uniform3uiv': 'tags this -> location:WebGLUniformLocation.t option -> data:Uint32List.t -> ?srcOffset:GLuint.t -> ?srcLength:GLuint.t -> unit -> unit [@@js.call "uniform3uiv"]
  val uniform4ui: 'tags this -> location:WebGLUniformLocation.t option -> v0:GLuint.t -> v1:GLuint.t -> v2:GLuint.t -> v3:GLuint.t -> unit [@@js.call "uniform4ui"]
  val uniform4uiv': 'tags this -> location:WebGLUniformLocation.t option -> data:Uint32List.t -> ?srcOffset:GLuint.t -> ?srcLength:GLuint.t -> unit -> unit [@@js.call "uniform4uiv"]
  val uniformBlockBinding: 'tags this -> program:WebGLProgram.t -> uniformBlockIndex:GLuint.t -> uniformBlockBinding:GLuint.t -> unit [@@js.call "uniformBlockBinding"]
  val uniformMatrix2x3fv': 'tags this -> location:WebGLUniformLocation.t option -> transpose:GLboolean.t -> data:Float32List.t -> ?srcOffset:GLuint.t -> ?srcLength:GLuint.t -> unit -> unit [@@js.call "uniformMatrix2x3fv"]
  val uniformMatrix2x4fv': 'tags this -> location:WebGLUniformLocation.t option -> transpose:GLboolean.t -> data:Float32List.t -> ?srcOffset:GLuint.t -> ?srcLength:GLuint.t -> unit -> unit [@@js.call "uniformMatrix2x4fv"]
  val uniformMatrix3x2fv': 'tags this -> location:WebGLUniformLocation.t option -> transpose:GLboolean.t -> data:Float32List.t -> ?srcOffset:GLuint.t -> ?srcLength:GLuint.t -> unit -> unit [@@js.call "uniformMatrix3x2fv"]
  val uniformMatrix3x4fv': 'tags this -> location:WebGLUniformLocation.t option -> transpose:GLboolean.t -> data:Float32List.t -> ?srcOffset:GLuint.t -> ?srcLength:GLuint.t -> unit -> unit [@@js.call "uniformMatrix3x4fv"]
  val uniformMatrix4x2fv': 'tags this -> location:WebGLUniformLocation.t option -> transpose:GLboolean.t -> data:Float32List.t -> ?srcOffset:GLuint.t -> ?srcLength:GLuint.t -> unit -> unit [@@js.call "uniformMatrix4x2fv"]
  val uniformMatrix4x3fv': 'tags this -> location:WebGLUniformLocation.t option -> transpose:GLboolean.t -> data:Float32List.t -> ?srcOffset:GLuint.t -> ?srcLength:GLuint.t -> unit -> unit [@@js.call "uniformMatrix4x3fv"]
  val vertexAttribDivisor: 'tags this -> index:GLuint.t -> divisor:GLuint.t -> unit [@@js.call "vertexAttribDivisor"]
  val vertexAttribI4i: 'tags this -> index:GLuint.t -> x:GLint.t -> y:GLint.t -> z:GLint.t -> w:GLint.t -> unit [@@js.call "vertexAttribI4i"]
  val vertexAttribI4iv': 'tags this -> index:GLuint.t -> values:Int32List.t -> unit [@@js.call "vertexAttribI4iv"]
  val vertexAttribI4ui: 'tags this -> index:GLuint.t -> x:GLuint.t -> y:GLuint.t -> z:GLuint.t -> w:GLuint.t -> unit [@@js.call "vertexAttribI4ui"]
  val vertexAttribI4uiv': 'tags this -> index:GLuint.t -> values:Uint32List.t -> unit [@@js.call "vertexAttribI4uiv"]
  val vertexAttribIPointer: 'tags this -> index:GLuint.t -> size:GLint.t -> type_:GLenum.t -> stride:GLsizei.t -> offset:GLintptr.t -> unit [@@js.call "vertexAttribIPointer"]
  val waitSync: 'tags this -> sync:WebGLSync.t -> flags:GLbitfield.t -> timeout:GLint64.t -> unit [@@js.call "waitSync"]
  val get_ACTIVE_UNIFORM_BLOCKS: 'tags this -> GLenum.t [@@js.get "ACTIVE_UNIFORM_BLOCKS"]
  val get_ALREADY_SIGNALED: 'tags this -> GLenum.t [@@js.get "ALREADY_SIGNALED"]
  val get_ANY_SAMPLES_PASSED: 'tags this -> GLenum.t [@@js.get "ANY_SAMPLES_PASSED"]
  val get_ANY_SAMPLES_PASSED_CONSERVATIVE: 'tags this -> GLenum.t [@@js.get "ANY_SAMPLES_PASSED_CONSERVATIVE"]
  val get_COLOR: 'tags this -> GLenum.t [@@js.get "COLOR"]
  val get_COLOR_ATTACHMENT1: 'tags this -> GLenum.t [@@js.get "COLOR_ATTACHMENT1"]
  val get_COLOR_ATTACHMENT10: 'tags this -> GLenum.t [@@js.get "COLOR_ATTACHMENT10"]
  val get_COLOR_ATTACHMENT11: 'tags this -> GLenum.t [@@js.get "COLOR_ATTACHMENT11"]
  val get_COLOR_ATTACHMENT12: 'tags this -> GLenum.t [@@js.get "COLOR_ATTACHMENT12"]
  val get_COLOR_ATTACHMENT13: 'tags this -> GLenum.t [@@js.get "COLOR_ATTACHMENT13"]
  val get_COLOR_ATTACHMENT14: 'tags this -> GLenum.t [@@js.get "COLOR_ATTACHMENT14"]
  val get_COLOR_ATTACHMENT15: 'tags this -> GLenum.t [@@js.get "COLOR_ATTACHMENT15"]
  val get_COLOR_ATTACHMENT2: 'tags this -> GLenum.t [@@js.get "COLOR_ATTACHMENT2"]
  val get_COLOR_ATTACHMENT3: 'tags this -> GLenum.t [@@js.get "COLOR_ATTACHMENT3"]
  val get_COLOR_ATTACHMENT4: 'tags this -> GLenum.t [@@js.get "COLOR_ATTACHMENT4"]
  val get_COLOR_ATTACHMENT5: 'tags this -> GLenum.t [@@js.get "COLOR_ATTACHMENT5"]
  val get_COLOR_ATTACHMENT6: 'tags this -> GLenum.t [@@js.get "COLOR_ATTACHMENT6"]
  val get_COLOR_ATTACHMENT7: 'tags this -> GLenum.t [@@js.get "COLOR_ATTACHMENT7"]
  val get_COLOR_ATTACHMENT8: 'tags this -> GLenum.t [@@js.get "COLOR_ATTACHMENT8"]
  val get_COLOR_ATTACHMENT9: 'tags this -> GLenum.t [@@js.get "COLOR_ATTACHMENT9"]
  val get_COMPARE_REF_TO_TEXTURE: 'tags this -> GLenum.t [@@js.get "COMPARE_REF_TO_TEXTURE"]
  val get_CONDITION_SATISFIED: 'tags this -> GLenum.t [@@js.get "CONDITION_SATISFIED"]
  val get_COPY_READ_BUFFER: 'tags this -> GLenum.t [@@js.get "COPY_READ_BUFFER"]
  val get_COPY_READ_BUFFER_BINDING: 'tags this -> GLenum.t [@@js.get "COPY_READ_BUFFER_BINDING"]
  val get_COPY_WRITE_BUFFER: 'tags this -> GLenum.t [@@js.get "COPY_WRITE_BUFFER"]
  val get_COPY_WRITE_BUFFER_BINDING: 'tags this -> GLenum.t [@@js.get "COPY_WRITE_BUFFER_BINDING"]
  val get_CURRENT_QUERY: 'tags this -> GLenum.t [@@js.get "CURRENT_QUERY"]
  val get_DEPTH: 'tags this -> GLenum.t [@@js.get "DEPTH"]
  val get_DEPTH24_STENCIL8: 'tags this -> GLenum.t [@@js.get "DEPTH24_STENCIL8"]
  val get_DEPTH32F_STENCIL8: 'tags this -> GLenum.t [@@js.get "DEPTH32F_STENCIL8"]
  val get_DEPTH_COMPONENT24: 'tags this -> GLenum.t [@@js.get "DEPTH_COMPONENT24"]
  val get_DEPTH_COMPONENT32F: 'tags this -> GLenum.t [@@js.get "DEPTH_COMPONENT32F"]
  val get_DRAW_BUFFER0: 'tags this -> GLenum.t [@@js.get "DRAW_BUFFER0"]
  val get_DRAW_BUFFER1: 'tags this -> GLenum.t [@@js.get "DRAW_BUFFER1"]
  val get_DRAW_BUFFER10: 'tags this -> GLenum.t [@@js.get "DRAW_BUFFER10"]
  val get_DRAW_BUFFER11: 'tags this -> GLenum.t [@@js.get "DRAW_BUFFER11"]
  val get_DRAW_BUFFER12: 'tags this -> GLenum.t [@@js.get "DRAW_BUFFER12"]
  val get_DRAW_BUFFER13: 'tags this -> GLenum.t [@@js.get "DRAW_BUFFER13"]
  val get_DRAW_BUFFER14: 'tags this -> GLenum.t [@@js.get "DRAW_BUFFER14"]
  val get_DRAW_BUFFER15: 'tags this -> GLenum.t [@@js.get "DRAW_BUFFER15"]
  val get_DRAW_BUFFER2: 'tags this -> GLenum.t [@@js.get "DRAW_BUFFER2"]
  val get_DRAW_BUFFER3: 'tags this -> GLenum.t [@@js.get "DRAW_BUFFER3"]
  val get_DRAW_BUFFER4: 'tags this -> GLenum.t [@@js.get "DRAW_BUFFER4"]
  val get_DRAW_BUFFER5: 'tags this -> GLenum.t [@@js.get "DRAW_BUFFER5"]
  val get_DRAW_BUFFER6: 'tags this -> GLenum.t [@@js.get "DRAW_BUFFER6"]
  val get_DRAW_BUFFER7: 'tags this -> GLenum.t [@@js.get "DRAW_BUFFER7"]
  val get_DRAW_BUFFER8: 'tags this -> GLenum.t [@@js.get "DRAW_BUFFER8"]
  val get_DRAW_BUFFER9: 'tags this -> GLenum.t [@@js.get "DRAW_BUFFER9"]
  val get_DRAW_FRAMEBUFFER: 'tags this -> GLenum.t [@@js.get "DRAW_FRAMEBUFFER"]
  val get_DRAW_FRAMEBUFFER_BINDING: 'tags this -> GLenum.t [@@js.get "DRAW_FRAMEBUFFER_BINDING"]
  val get_DYNAMIC_COPY: 'tags this -> GLenum.t [@@js.get "DYNAMIC_COPY"]
  val get_DYNAMIC_READ: 'tags this -> GLenum.t [@@js.get "DYNAMIC_READ"]
  val get_FLOAT_32_UNSIGNED_INT_24_8_REV: 'tags this -> GLenum.t [@@js.get "FLOAT_32_UNSIGNED_INT_24_8_REV"]
  val get_FLOAT_MAT2x3: 'tags this -> GLenum.t [@@js.get "FLOAT_MAT2x3"]
  val get_FLOAT_MAT2x4: 'tags this -> GLenum.t [@@js.get "FLOAT_MAT2x4"]
  val get_FLOAT_MAT3x2: 'tags this -> GLenum.t [@@js.get "FLOAT_MAT3x2"]
  val get_FLOAT_MAT3x4: 'tags this -> GLenum.t [@@js.get "FLOAT_MAT3x4"]
  val get_FLOAT_MAT4x2: 'tags this -> GLenum.t [@@js.get "FLOAT_MAT4x2"]
  val get_FLOAT_MAT4x3: 'tags this -> GLenum.t [@@js.get "FLOAT_MAT4x3"]
  val get_FRAGMENT_SHADER_DERIVATIVE_HINT: 'tags this -> GLenum.t [@@js.get "FRAGMENT_SHADER_DERIVATIVE_HINT"]
  val get_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE: 'tags this -> GLenum.t [@@js.get "FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE"]
  val get_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE: 'tags this -> GLenum.t [@@js.get "FRAMEBUFFER_ATTACHMENT_BLUE_SIZE"]
  val get_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING: 'tags this -> GLenum.t [@@js.get "FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING"]
  val get_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE: 'tags this -> GLenum.t [@@js.get "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE"]
  val get_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE: 'tags this -> GLenum.t [@@js.get "FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE"]
  val get_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE: 'tags this -> GLenum.t [@@js.get "FRAMEBUFFER_ATTACHMENT_GREEN_SIZE"]
  val get_FRAMEBUFFER_ATTACHMENT_RED_SIZE: 'tags this -> GLenum.t [@@js.get "FRAMEBUFFER_ATTACHMENT_RED_SIZE"]
  val get_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE: 'tags this -> GLenum.t [@@js.get "FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE"]
  val get_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER: 'tags this -> GLenum.t [@@js.get "FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER"]
  val get_FRAMEBUFFER_DEFAULT: 'tags this -> GLenum.t [@@js.get "FRAMEBUFFER_DEFAULT"]
  val get_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE: 'tags this -> GLenum.t [@@js.get "FRAMEBUFFER_INCOMPLETE_MULTISAMPLE"]
  val get_HALF_FLOAT: 'tags this -> GLenum.t [@@js.get "HALF_FLOAT"]
  val get_INTERLEAVED_ATTRIBS: 'tags this -> GLenum.t [@@js.get "INTERLEAVED_ATTRIBS"]
  val get_INT_2_10_10_10_REV: 'tags this -> GLenum.t [@@js.get "INT_2_10_10_10_REV"]
  val get_INT_SAMPLER_2D: 'tags this -> GLenum.t [@@js.get "INT_SAMPLER_2D"]
  val get_INT_SAMPLER_2D_ARRAY: 'tags this -> GLenum.t [@@js.get "INT_SAMPLER_2D_ARRAY"]
  val get_INT_SAMPLER_3D: 'tags this -> GLenum.t [@@js.get "INT_SAMPLER_3D"]
  val get_INT_SAMPLER_CUBE: 'tags this -> GLenum.t [@@js.get "INT_SAMPLER_CUBE"]
  val get_INVALID_INDEX: 'tags this -> GLenum.t [@@js.get "INVALID_INDEX"]
  val get_MAX: 'tags this -> GLenum.t [@@js.get "MAX"]
  val get_MAX_3D_TEXTURE_SIZE: 'tags this -> GLenum.t [@@js.get "MAX_3D_TEXTURE_SIZE"]
  val get_MAX_ARRAY_TEXTURE_LAYERS: 'tags this -> GLenum.t [@@js.get "MAX_ARRAY_TEXTURE_LAYERS"]
  val get_MAX_CLIENT_WAIT_TIMEOUT_WEBGL: 'tags this -> GLenum.t [@@js.get "MAX_CLIENT_WAIT_TIMEOUT_WEBGL"]
  val get_MAX_COLOR_ATTACHMENTS: 'tags this -> GLenum.t [@@js.get "MAX_COLOR_ATTACHMENTS"]
  val get_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS: 'tags this -> GLenum.t [@@js.get "MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS"]
  val get_MAX_COMBINED_UNIFORM_BLOCKS: 'tags this -> GLenum.t [@@js.get "MAX_COMBINED_UNIFORM_BLOCKS"]
  val get_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS: 'tags this -> GLenum.t [@@js.get "MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS"]
  val get_MAX_DRAW_BUFFERS: 'tags this -> GLenum.t [@@js.get "MAX_DRAW_BUFFERS"]
  val get_MAX_ELEMENTS_INDICES: 'tags this -> GLenum.t [@@js.get "MAX_ELEMENTS_INDICES"]
  val get_MAX_ELEMENTS_VERTICES: 'tags this -> GLenum.t [@@js.get "MAX_ELEMENTS_VERTICES"]
  val get_MAX_ELEMENT_INDEX: 'tags this -> GLenum.t [@@js.get "MAX_ELEMENT_INDEX"]
  val get_MAX_FRAGMENT_INPUT_COMPONENTS: 'tags this -> GLenum.t [@@js.get "MAX_FRAGMENT_INPUT_COMPONENTS"]
  val get_MAX_FRAGMENT_UNIFORM_BLOCKS: 'tags this -> GLenum.t [@@js.get "MAX_FRAGMENT_UNIFORM_BLOCKS"]
  val get_MAX_FRAGMENT_UNIFORM_COMPONENTS: 'tags this -> GLenum.t [@@js.get "MAX_FRAGMENT_UNIFORM_COMPONENTS"]
  val get_MAX_PROGRAM_TEXEL_OFFSET: 'tags this -> GLenum.t [@@js.get "MAX_PROGRAM_TEXEL_OFFSET"]
  val get_MAX_SAMPLES: 'tags this -> GLenum.t [@@js.get "MAX_SAMPLES"]
  val get_MAX_SERVER_WAIT_TIMEOUT: 'tags this -> GLenum.t [@@js.get "MAX_SERVER_WAIT_TIMEOUT"]
  val get_MAX_TEXTURE_LOD_BIAS: 'tags this -> GLenum.t [@@js.get "MAX_TEXTURE_LOD_BIAS"]
  val get_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS: 'tags this -> GLenum.t [@@js.get "MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS"]
  val get_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS: 'tags this -> GLenum.t [@@js.get "MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS"]
  val get_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS: 'tags this -> GLenum.t [@@js.get "MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS"]
  val get_MAX_UNIFORM_BLOCK_SIZE: 'tags this -> GLenum.t [@@js.get "MAX_UNIFORM_BLOCK_SIZE"]
  val get_MAX_UNIFORM_BUFFER_BINDINGS: 'tags this -> GLenum.t [@@js.get "MAX_UNIFORM_BUFFER_BINDINGS"]
  val get_MAX_VARYING_COMPONENTS: 'tags this -> GLenum.t [@@js.get "MAX_VARYING_COMPONENTS"]
  val get_MAX_VERTEX_OUTPUT_COMPONENTS: 'tags this -> GLenum.t [@@js.get "MAX_VERTEX_OUTPUT_COMPONENTS"]
  val get_MAX_VERTEX_UNIFORM_BLOCKS: 'tags this -> GLenum.t [@@js.get "MAX_VERTEX_UNIFORM_BLOCKS"]
  val get_MAX_VERTEX_UNIFORM_COMPONENTS: 'tags this -> GLenum.t [@@js.get "MAX_VERTEX_UNIFORM_COMPONENTS"]
  val get_MIN: 'tags this -> GLenum.t [@@js.get "MIN"]
  val get_MIN_PROGRAM_TEXEL_OFFSET: 'tags this -> GLenum.t [@@js.get "MIN_PROGRAM_TEXEL_OFFSET"]
  val get_OBJECT_TYPE: 'tags this -> GLenum.t [@@js.get "OBJECT_TYPE"]
  val get_PACK_ROW_LENGTH: 'tags this -> GLenum.t [@@js.get "PACK_ROW_LENGTH"]
  val get_PACK_SKIP_PIXELS: 'tags this -> GLenum.t [@@js.get "PACK_SKIP_PIXELS"]
  val get_PACK_SKIP_ROWS: 'tags this -> GLenum.t [@@js.get "PACK_SKIP_ROWS"]
  val get_PIXEL_PACK_BUFFER: 'tags this -> GLenum.t [@@js.get "PIXEL_PACK_BUFFER"]
  val get_PIXEL_PACK_BUFFER_BINDING: 'tags this -> GLenum.t [@@js.get "PIXEL_PACK_BUFFER_BINDING"]
  val get_PIXEL_UNPACK_BUFFER: 'tags this -> GLenum.t [@@js.get "PIXEL_UNPACK_BUFFER"]
  val get_PIXEL_UNPACK_BUFFER_BINDING: 'tags this -> GLenum.t [@@js.get "PIXEL_UNPACK_BUFFER_BINDING"]
  val get_QUERY_RESULT: 'tags this -> GLenum.t [@@js.get "QUERY_RESULT"]
  val get_QUERY_RESULT_AVAILABLE: 'tags this -> GLenum.t [@@js.get "QUERY_RESULT_AVAILABLE"]
  val get_R11F_G11F_B10F: 'tags this -> GLenum.t [@@js.get "R11F_G11F_B10F"]
  val get_R16F: 'tags this -> GLenum.t [@@js.get "R16F"]
  val get_R16I: 'tags this -> GLenum.t [@@js.get "R16I"]
  val get_R16UI: 'tags this -> GLenum.t [@@js.get "R16UI"]
  val get_R32F: 'tags this -> GLenum.t [@@js.get "R32F"]
  val get_R32I: 'tags this -> GLenum.t [@@js.get "R32I"]
  val get_R32UI: 'tags this -> GLenum.t [@@js.get "R32UI"]
  val get_R8: 'tags this -> GLenum.t [@@js.get "R8"]
  val get_R8I: 'tags this -> GLenum.t [@@js.get "R8I"]
  val get_R8UI: 'tags this -> GLenum.t [@@js.get "R8UI"]
  val get_R8_SNORM: 'tags this -> GLenum.t [@@js.get "R8_SNORM"]
  val get_RASTERIZER_DISCARD: 'tags this -> GLenum.t [@@js.get "RASTERIZER_DISCARD"]
  val get_READ_BUFFER: 'tags this -> GLenum.t [@@js.get "READ_BUFFER"]
  val get_READ_FRAMEBUFFER: 'tags this -> GLenum.t [@@js.get "READ_FRAMEBUFFER"]
  val get_READ_FRAMEBUFFER_BINDING: 'tags this -> GLenum.t [@@js.get "READ_FRAMEBUFFER_BINDING"]
  val get_RED: 'tags this -> GLenum.t [@@js.get "RED"]
  val get_RED_INTEGER: 'tags this -> GLenum.t [@@js.get "RED_INTEGER"]
  val get_RENDERBUFFER_SAMPLES: 'tags this -> GLenum.t [@@js.get "RENDERBUFFER_SAMPLES"]
  val get_RG: 'tags this -> GLenum.t [@@js.get "RG"]
  val get_RG16F: 'tags this -> GLenum.t [@@js.get "RG16F"]
  val get_RG16I: 'tags this -> GLenum.t [@@js.get "RG16I"]
  val get_RG16UI: 'tags this -> GLenum.t [@@js.get "RG16UI"]
  val get_RG32F: 'tags this -> GLenum.t [@@js.get "RG32F"]
  val get_RG32I: 'tags this -> GLenum.t [@@js.get "RG32I"]
  val get_RG32UI: 'tags this -> GLenum.t [@@js.get "RG32UI"]
  val get_RG8: 'tags this -> GLenum.t [@@js.get "RG8"]
  val get_RG8I: 'tags this -> GLenum.t [@@js.get "RG8I"]
  val get_RG8UI: 'tags this -> GLenum.t [@@js.get "RG8UI"]
  val get_RG8_SNORM: 'tags this -> GLenum.t [@@js.get "RG8_SNORM"]
  val get_RGB10_A2: 'tags this -> GLenum.t [@@js.get "RGB10_A2"]
  val get_RGB10_A2UI: 'tags this -> GLenum.t [@@js.get "RGB10_A2UI"]
  val get_RGB16F: 'tags this -> GLenum.t [@@js.get "RGB16F"]
  val get_RGB16I: 'tags this -> GLenum.t [@@js.get "RGB16I"]
  val get_RGB16UI: 'tags this -> GLenum.t [@@js.get "RGB16UI"]
  val get_RGB32F: 'tags this -> GLenum.t [@@js.get "RGB32F"]
  val get_RGB32I: 'tags this -> GLenum.t [@@js.get "RGB32I"]
  val get_RGB32UI: 'tags this -> GLenum.t [@@js.get "RGB32UI"]
  val get_RGB8: 'tags this -> GLenum.t [@@js.get "RGB8"]
  val get_RGB8I: 'tags this -> GLenum.t [@@js.get "RGB8I"]
  val get_RGB8UI: 'tags this -> GLenum.t [@@js.get "RGB8UI"]
  val get_RGB8_SNORM: 'tags this -> GLenum.t [@@js.get "RGB8_SNORM"]
  val get_RGB9_E5: 'tags this -> GLenum.t [@@js.get "RGB9_E5"]
  val get_RGBA16F: 'tags this -> GLenum.t [@@js.get "RGBA16F"]
  val get_RGBA16I: 'tags this -> GLenum.t [@@js.get "RGBA16I"]
  val get_RGBA16UI: 'tags this -> GLenum.t [@@js.get "RGBA16UI"]
  val get_RGBA32F: 'tags this -> GLenum.t [@@js.get "RGBA32F"]
  val get_RGBA32I: 'tags this -> GLenum.t [@@js.get "RGBA32I"]
  val get_RGBA32UI: 'tags this -> GLenum.t [@@js.get "RGBA32UI"]
  val get_RGBA8: 'tags this -> GLenum.t [@@js.get "RGBA8"]
  val get_RGBA8I: 'tags this -> GLenum.t [@@js.get "RGBA8I"]
  val get_RGBA8UI: 'tags this -> GLenum.t [@@js.get "RGBA8UI"]
  val get_RGBA8_SNORM: 'tags this -> GLenum.t [@@js.get "RGBA8_SNORM"]
  val get_RGBA_INTEGER: 'tags this -> GLenum.t [@@js.get "RGBA_INTEGER"]
  val get_RGB_INTEGER: 'tags this -> GLenum.t [@@js.get "RGB_INTEGER"]
  val get_RG_INTEGER: 'tags this -> GLenum.t [@@js.get "RG_INTEGER"]
  val get_SAMPLER_2D_ARRAY: 'tags this -> GLenum.t [@@js.get "SAMPLER_2D_ARRAY"]
  val get_SAMPLER_2D_ARRAY_SHADOW: 'tags this -> GLenum.t [@@js.get "SAMPLER_2D_ARRAY_SHADOW"]
  val get_SAMPLER_2D_SHADOW: 'tags this -> GLenum.t [@@js.get "SAMPLER_2D_SHADOW"]
  val get_SAMPLER_3D: 'tags this -> GLenum.t [@@js.get "SAMPLER_3D"]
  val get_SAMPLER_BINDING: 'tags this -> GLenum.t [@@js.get "SAMPLER_BINDING"]
  val get_SAMPLER_CUBE_SHADOW: 'tags this -> GLenum.t [@@js.get "SAMPLER_CUBE_SHADOW"]
  val get_SEPARATE_ATTRIBS: 'tags this -> GLenum.t [@@js.get "SEPARATE_ATTRIBS"]
  val get_SIGNALED: 'tags this -> GLenum.t [@@js.get "SIGNALED"]
  val get_SIGNED_NORMALIZED: 'tags this -> GLenum.t [@@js.get "SIGNED_NORMALIZED"]
  val get_SRGB: 'tags this -> GLenum.t [@@js.get "SRGB"]
  val get_SRGB8: 'tags this -> GLenum.t [@@js.get "SRGB8"]
  val get_SRGB8_ALPHA8: 'tags this -> GLenum.t [@@js.get "SRGB8_ALPHA8"]
  val get_STATIC_COPY: 'tags this -> GLenum.t [@@js.get "STATIC_COPY"]
  val get_STATIC_READ: 'tags this -> GLenum.t [@@js.get "STATIC_READ"]
  val get_STENCIL: 'tags this -> GLenum.t [@@js.get "STENCIL"]
  val get_STREAM_COPY: 'tags this -> GLenum.t [@@js.get "STREAM_COPY"]
  val get_STREAM_READ: 'tags this -> GLenum.t [@@js.get "STREAM_READ"]
  val get_SYNC_CONDITION: 'tags this -> GLenum.t [@@js.get "SYNC_CONDITION"]
  val get_SYNC_FENCE: 'tags this -> GLenum.t [@@js.get "SYNC_FENCE"]
  val get_SYNC_FLAGS: 'tags this -> GLenum.t [@@js.get "SYNC_FLAGS"]
  val get_SYNC_FLUSH_COMMANDS_BIT: 'tags this -> GLenum.t [@@js.get "SYNC_FLUSH_COMMANDS_BIT"]
  val get_SYNC_GPU_COMMANDS_COMPLETE: 'tags this -> GLenum.t [@@js.get "SYNC_GPU_COMMANDS_COMPLETE"]
  val get_SYNC_STATUS: 'tags this -> GLenum.t [@@js.get "SYNC_STATUS"]
  val get_TEXTURE_2D_ARRAY: 'tags this -> GLenum.t [@@js.get "TEXTURE_2D_ARRAY"]
  val get_TEXTURE_3D: 'tags this -> GLenum.t [@@js.get "TEXTURE_3D"]
  val get_TEXTURE_BASE_LEVEL: 'tags this -> GLenum.t [@@js.get "TEXTURE_BASE_LEVEL"]
  val get_TEXTURE_BINDING_2D_ARRAY: 'tags this -> GLenum.t [@@js.get "TEXTURE_BINDING_2D_ARRAY"]
  val get_TEXTURE_BINDING_3D: 'tags this -> GLenum.t [@@js.get "TEXTURE_BINDING_3D"]
  val get_TEXTURE_COMPARE_FUNC: 'tags this -> GLenum.t [@@js.get "TEXTURE_COMPARE_FUNC"]
  val get_TEXTURE_COMPARE_MODE: 'tags this -> GLenum.t [@@js.get "TEXTURE_COMPARE_MODE"]
  val get_TEXTURE_IMMUTABLE_FORMAT: 'tags this -> GLenum.t [@@js.get "TEXTURE_IMMUTABLE_FORMAT"]
  val get_TEXTURE_IMMUTABLE_LEVELS: 'tags this -> GLenum.t [@@js.get "TEXTURE_IMMUTABLE_LEVELS"]
  val get_TEXTURE_MAX_LEVEL: 'tags this -> GLenum.t [@@js.get "TEXTURE_MAX_LEVEL"]
  val get_TEXTURE_MAX_LOD: 'tags this -> GLenum.t [@@js.get "TEXTURE_MAX_LOD"]
  val get_TEXTURE_MIN_LOD: 'tags this -> GLenum.t [@@js.get "TEXTURE_MIN_LOD"]
  val get_TEXTURE_WRAP_R: 'tags this -> GLenum.t [@@js.get "TEXTURE_WRAP_R"]
  val get_TIMEOUT_EXPIRED: 'tags this -> GLenum.t [@@js.get "TIMEOUT_EXPIRED"]
  val get_TIMEOUT_IGNORED: 'tags this -> GLint64.t [@@js.get "TIMEOUT_IGNORED"]
  val get_TRANSFORM_FEEDBACK: 'tags this -> GLenum.t [@@js.get "TRANSFORM_FEEDBACK"]
  val get_TRANSFORM_FEEDBACK_ACTIVE: 'tags this -> GLenum.t [@@js.get "TRANSFORM_FEEDBACK_ACTIVE"]
  val get_TRANSFORM_FEEDBACK_BINDING: 'tags this -> GLenum.t [@@js.get "TRANSFORM_FEEDBACK_BINDING"]
  val get_TRANSFORM_FEEDBACK_BUFFER: 'tags this -> GLenum.t [@@js.get "TRANSFORM_FEEDBACK_BUFFER"]
  val get_TRANSFORM_FEEDBACK_BUFFER_BINDING: 'tags this -> GLenum.t [@@js.get "TRANSFORM_FEEDBACK_BUFFER_BINDING"]
  val get_TRANSFORM_FEEDBACK_BUFFER_MODE: 'tags this -> GLenum.t [@@js.get "TRANSFORM_FEEDBACK_BUFFER_MODE"]
  val get_TRANSFORM_FEEDBACK_BUFFER_SIZE: 'tags this -> GLenum.t [@@js.get "TRANSFORM_FEEDBACK_BUFFER_SIZE"]
  val get_TRANSFORM_FEEDBACK_BUFFER_START: 'tags this -> GLenum.t [@@js.get "TRANSFORM_FEEDBACK_BUFFER_START"]
  val get_TRANSFORM_FEEDBACK_PAUSED: 'tags this -> GLenum.t [@@js.get "TRANSFORM_FEEDBACK_PAUSED"]
  val get_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN: 'tags this -> GLenum.t [@@js.get "TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN"]
  val get_TRANSFORM_FEEDBACK_VARYINGS: 'tags this -> GLenum.t [@@js.get "TRANSFORM_FEEDBACK_VARYINGS"]
  val get_UNIFORM_ARRAY_STRIDE: 'tags this -> GLenum.t [@@js.get "UNIFORM_ARRAY_STRIDE"]
  val get_UNIFORM_BLOCK_ACTIVE_UNIFORMS: 'tags this -> GLenum.t [@@js.get "UNIFORM_BLOCK_ACTIVE_UNIFORMS"]
  val get_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES: 'tags this -> GLenum.t [@@js.get "UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES"]
  val get_UNIFORM_BLOCK_BINDING: 'tags this -> GLenum.t [@@js.get "UNIFORM_BLOCK_BINDING"]
  val get_UNIFORM_BLOCK_DATA_SIZE: 'tags this -> GLenum.t [@@js.get "UNIFORM_BLOCK_DATA_SIZE"]
  val get_UNIFORM_BLOCK_INDEX: 'tags this -> GLenum.t [@@js.get "UNIFORM_BLOCK_INDEX"]
  val get_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER: 'tags this -> GLenum.t [@@js.get "UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER"]
  val get_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER: 'tags this -> GLenum.t [@@js.get "UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER"]
  val get_UNIFORM_BUFFER: 'tags this -> GLenum.t [@@js.get "UNIFORM_BUFFER"]
  val get_UNIFORM_BUFFER_BINDING: 'tags this -> GLenum.t [@@js.get "UNIFORM_BUFFER_BINDING"]
  val get_UNIFORM_BUFFER_OFFSET_ALIGNMENT: 'tags this -> GLenum.t [@@js.get "UNIFORM_BUFFER_OFFSET_ALIGNMENT"]
  val get_UNIFORM_BUFFER_SIZE: 'tags this -> GLenum.t [@@js.get "UNIFORM_BUFFER_SIZE"]
  val get_UNIFORM_BUFFER_START: 'tags this -> GLenum.t [@@js.get "UNIFORM_BUFFER_START"]
  val get_UNIFORM_IS_ROW_MAJOR: 'tags this -> GLenum.t [@@js.get "UNIFORM_IS_ROW_MAJOR"]
  val get_UNIFORM_MATRIX_STRIDE: 'tags this -> GLenum.t [@@js.get "UNIFORM_MATRIX_STRIDE"]
  val get_UNIFORM_OFFSET: 'tags this -> GLenum.t [@@js.get "UNIFORM_OFFSET"]
  val get_UNIFORM_SIZE: 'tags this -> GLenum.t [@@js.get "UNIFORM_SIZE"]
  val get_UNIFORM_TYPE: 'tags this -> GLenum.t [@@js.get "UNIFORM_TYPE"]
  val get_UNPACK_IMAGE_HEIGHT: 'tags this -> GLenum.t [@@js.get "UNPACK_IMAGE_HEIGHT"]
  val get_UNPACK_ROW_LENGTH: 'tags this -> GLenum.t [@@js.get "UNPACK_ROW_LENGTH"]
  val get_UNPACK_SKIP_IMAGES: 'tags this -> GLenum.t [@@js.get "UNPACK_SKIP_IMAGES"]
  val get_UNPACK_SKIP_PIXELS: 'tags this -> GLenum.t [@@js.get "UNPACK_SKIP_PIXELS"]
  val get_UNPACK_SKIP_ROWS: 'tags this -> GLenum.t [@@js.get "UNPACK_SKIP_ROWS"]
  val get_UNSIGNALED: 'tags this -> GLenum.t [@@js.get "UNSIGNALED"]
  val get_UNSIGNED_INT_10F_11F_11F_REV: 'tags this -> GLenum.t [@@js.get "UNSIGNED_INT_10F_11F_11F_REV"]
  val get_UNSIGNED_INT_24_8: 'tags this -> GLenum.t [@@js.get "UNSIGNED_INT_24_8"]
  val get_UNSIGNED_INT_2_10_10_10_REV: 'tags this -> GLenum.t [@@js.get "UNSIGNED_INT_2_10_10_10_REV"]
  val get_UNSIGNED_INT_5_9_9_9_REV: 'tags this -> GLenum.t [@@js.get "UNSIGNED_INT_5_9_9_9_REV"]
  val get_UNSIGNED_INT_SAMPLER_2D: 'tags this -> GLenum.t [@@js.get "UNSIGNED_INT_SAMPLER_2D"]
  val get_UNSIGNED_INT_SAMPLER_2D_ARRAY: 'tags this -> GLenum.t [@@js.get "UNSIGNED_INT_SAMPLER_2D_ARRAY"]
  val get_UNSIGNED_INT_SAMPLER_3D: 'tags this -> GLenum.t [@@js.get "UNSIGNED_INT_SAMPLER_3D"]
  val get_UNSIGNED_INT_SAMPLER_CUBE: 'tags this -> GLenum.t [@@js.get "UNSIGNED_INT_SAMPLER_CUBE"]
  val get_UNSIGNED_INT_VEC2: 'tags this -> GLenum.t [@@js.get "UNSIGNED_INT_VEC2"]
  val get_UNSIGNED_INT_VEC3: 'tags this -> GLenum.t [@@js.get "UNSIGNED_INT_VEC3"]
  val get_UNSIGNED_INT_VEC4: 'tags this -> GLenum.t [@@js.get "UNSIGNED_INT_VEC4"]
  val get_UNSIGNED_NORMALIZED: 'tags this -> GLenum.t [@@js.get "UNSIGNED_NORMALIZED"]
  val get_VERTEX_ARRAY_BINDING: 'tags this -> GLenum.t [@@js.get "VERTEX_ARRAY_BINDING"]
  val get_VERTEX_ATTRIB_ARRAY_DIVISOR: 'tags this -> GLenum.t [@@js.get "VERTEX_ATTRIB_ARRAY_DIVISOR"]
  val get_VERTEX_ATTRIB_ARRAY_INTEGER: 'tags this -> GLenum.t [@@js.get "VERTEX_ATTRIB_ARRAY_INTEGER"]
  val get_WAIT_FAILED: 'tags this -> GLenum.t [@@js.get "WAIT_FAILED"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
and WebGL2RenderingContextOverloads : sig
  type t = [`WebGL2RenderingContextOverloads] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`WebGL2RenderingContextOverloads]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`WebGL2RenderingContextOverloads]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `WebGL2RenderingContextOverloads ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val uniform1fv: 'tags this -> location:WebGLUniformLocation.t option -> data:GLfloat.t Iterable.t_1 -> ?srcOffset:GLuint.t -> ?srcLength:GLuint.t -> unit -> unit [@@js.call "uniform1fv"]
  val uniform1iv: 'tags this -> location:WebGLUniformLocation.t option -> data:GLint.t Iterable.t_1 -> ?srcOffset:GLuint.t -> ?srcLength:GLuint.t -> unit -> unit [@@js.call "uniform1iv"]
  val uniform2fv: 'tags this -> location:WebGLUniformLocation.t option -> data:GLfloat.t Iterable.t_1 -> ?srcOffset:GLuint.t -> ?srcLength:GLuint.t -> unit -> unit [@@js.call "uniform2fv"]
  val uniform2iv: 'tags this -> location:WebGLUniformLocation.t option -> data:GLint.t Iterable.t_1 -> ?srcOffset:GLuint.t -> ?srcLength:GLuint.t -> unit -> unit [@@js.call "uniform2iv"]
  val uniform3fv: 'tags this -> location:WebGLUniformLocation.t option -> data:GLfloat.t Iterable.t_1 -> ?srcOffset:GLuint.t -> ?srcLength:GLuint.t -> unit -> unit [@@js.call "uniform3fv"]
  val uniform3iv: 'tags this -> location:WebGLUniformLocation.t option -> data:GLint.t Iterable.t_1 -> ?srcOffset:GLuint.t -> ?srcLength:GLuint.t -> unit -> unit [@@js.call "uniform3iv"]
  val uniform4fv: 'tags this -> location:WebGLUniformLocation.t option -> data:GLfloat.t Iterable.t_1 -> ?srcOffset:GLuint.t -> ?srcLength:GLuint.t -> unit -> unit [@@js.call "uniform4fv"]
  val uniform4iv: 'tags this -> location:WebGLUniformLocation.t option -> data:GLint.t Iterable.t_1 -> ?srcOffset:GLuint.t -> ?srcLength:GLuint.t -> unit -> unit [@@js.call "uniform4iv"]
  val uniformMatrix2fv: 'tags this -> location:WebGLUniformLocation.t option -> transpose:GLboolean.t -> data:GLfloat.t Iterable.t_1 -> ?srcOffset:GLuint.t -> ?srcLength:GLuint.t -> unit -> unit [@@js.call "uniformMatrix2fv"]
  val uniformMatrix3fv: 'tags this -> location:WebGLUniformLocation.t option -> transpose:GLboolean.t -> data:GLfloat.t Iterable.t_1 -> ?srcOffset:GLuint.t -> ?srcLength:GLuint.t -> unit -> unit [@@js.call "uniformMatrix3fv"]
  val uniformMatrix4fv: 'tags this -> location:WebGLUniformLocation.t option -> transpose:GLboolean.t -> data:GLfloat.t Iterable.t_1 -> ?srcOffset:GLuint.t -> ?srcLength:GLuint.t -> unit -> unit [@@js.call "uniformMatrix4fv"]
  val bufferData: 'tags this -> target:GLenum.t -> size:GLsizeiptr.t -> usage:GLenum.t -> unit [@@js.call "bufferData"]
  val bufferData': 'tags this -> target:GLenum.t -> srcData:BufferSource.t option -> usage:GLenum.t -> unit [@@js.call "bufferData"]
  val bufferData'': 'tags this -> target:GLenum.t -> srcData:ArrayBufferView.t_0 -> usage:GLenum.t -> srcOffset:GLuint.t -> ?length:GLuint.t -> unit -> unit [@@js.call "bufferData"]
  val bufferSubData: 'tags this -> target:GLenum.t -> dstByteOffset:GLintptr.t -> srcData:BufferSource.t -> unit [@@js.call "bufferSubData"]
  val bufferSubData': 'tags this -> target:GLenum.t -> dstByteOffset:GLintptr.t -> srcData:ArrayBufferView.t_0 -> srcOffset:GLuint.t -> ?length:GLuint.t -> unit -> unit [@@js.call "bufferSubData"]
  val compressedTexImage2D: 'tags this -> target:GLenum.t -> level:GLint.t -> internalformat:GLenum.t -> width:GLsizei.t -> height:GLsizei.t -> border:GLint.t -> imageSize:GLsizei.t -> offset:GLintptr.t -> unit [@@js.call "compressedTexImage2D"]
  val compressedTexImage2D': 'tags this -> target:GLenum.t -> level:GLint.t -> internalformat:GLenum.t -> width:GLsizei.t -> height:GLsizei.t -> border:GLint.t -> srcData:ArrayBufferView.t_0 -> ?srcOffset:GLuint.t -> ?srcLengthOverride:GLuint.t -> unit -> unit [@@js.call "compressedTexImage2D"]
  val compressedTexSubImage2D: 'tags this -> target:GLenum.t -> level:GLint.t -> xoffset:GLint.t -> yoffset:GLint.t -> width:GLsizei.t -> height:GLsizei.t -> format:GLenum.t -> imageSize:GLsizei.t -> offset:GLintptr.t -> unit [@@js.call "compressedTexSubImage2D"]
  val compressedTexSubImage2D': 'tags this -> target:GLenum.t -> level:GLint.t -> xoffset:GLint.t -> yoffset:GLint.t -> width:GLsizei.t -> height:GLsizei.t -> format:GLenum.t -> srcData:ArrayBufferView.t_0 -> ?srcOffset:GLuint.t -> ?srcLengthOverride:GLuint.t -> unit -> unit [@@js.call "compressedTexSubImage2D"]
  val readPixels: 'tags this -> x:GLint.t -> y:GLint.t -> width:GLsizei.t -> height:GLsizei.t -> format:GLenum.t -> type_:GLenum.t -> dstData:ArrayBufferView.t_0 option -> unit [@@js.call "readPixels"]
  val readPixels': 'tags this -> x:GLint.t -> y:GLint.t -> width:GLsizei.t -> height:GLsizei.t -> format:GLenum.t -> type_:GLenum.t -> offset:GLintptr.t -> unit [@@js.call "readPixels"]
  val readPixels'': 'tags this -> x:GLint.t -> y:GLint.t -> width:GLsizei.t -> height:GLsizei.t -> format:GLenum.t -> type_:GLenum.t -> dstData:ArrayBufferView.t_0 -> dstOffset:GLuint.t -> unit [@@js.call "readPixels"]
  val texImage2D: 'tags this -> target:GLenum.t -> level:GLint.t -> internalformat:GLint.t -> width:GLsizei.t -> height:GLsizei.t -> border:GLint.t -> format:GLenum.t -> type_:GLenum.t -> pixels:ArrayBufferView.t_0 option -> unit [@@js.call "texImage2D"]
  val texImage2D': 'tags this -> target:GLenum.t -> level:GLint.t -> internalformat:GLint.t -> format:GLenum.t -> type_:GLenum.t -> source:TexImageSource.t -> unit [@@js.call "texImage2D"]
  val texImage2D'': 'tags this -> target:GLenum.t -> level:GLint.t -> internalformat:GLint.t -> width:GLsizei.t -> height:GLsizei.t -> border:GLint.t -> format:GLenum.t -> type_:GLenum.t -> pboOffset:GLintptr.t -> unit [@@js.call "texImage2D"]
  val texImage2D''': 'tags this -> target:GLenum.t -> level:GLint.t -> internalformat:GLint.t -> width:GLsizei.t -> height:GLsizei.t -> border:GLint.t -> format:GLenum.t -> type_:GLenum.t -> source:TexImageSource.t -> unit [@@js.call "texImage2D"]
  val texImage2D'''': 'tags this -> target:GLenum.t -> level:GLint.t -> internalformat:GLint.t -> width:GLsizei.t -> height:GLsizei.t -> border:GLint.t -> format:GLenum.t -> type_:GLenum.t -> srcData:ArrayBufferView.t_0 -> srcOffset:GLuint.t -> unit [@@js.call "texImage2D"]
  val texSubImage2D: 'tags this -> target:GLenum.t -> level:GLint.t -> xoffset:GLint.t -> yoffset:GLint.t -> width:GLsizei.t -> height:GLsizei.t -> format:GLenum.t -> type_:GLenum.t -> pixels:ArrayBufferView.t_0 option -> unit [@@js.call "texSubImage2D"]
  val texSubImage2D': 'tags this -> target:GLenum.t -> level:GLint.t -> xoffset:GLint.t -> yoffset:GLint.t -> format:GLenum.t -> type_:GLenum.t -> source:TexImageSource.t -> unit [@@js.call "texSubImage2D"]
  val texSubImage2D'': 'tags this -> target:GLenum.t -> level:GLint.t -> xoffset:GLint.t -> yoffset:GLint.t -> width:GLsizei.t -> height:GLsizei.t -> format:GLenum.t -> type_:GLenum.t -> pboOffset:GLintptr.t -> unit [@@js.call "texSubImage2D"]
  val texSubImage2D''': 'tags this -> target:GLenum.t -> level:GLint.t -> xoffset:GLint.t -> yoffset:GLint.t -> width:GLsizei.t -> height:GLsizei.t -> format:GLenum.t -> type_:GLenum.t -> source:TexImageSource.t -> unit [@@js.call "texSubImage2D"]
  val texSubImage2D'''': 'tags this -> target:GLenum.t -> level:GLint.t -> xoffset:GLint.t -> yoffset:GLint.t -> width:GLsizei.t -> height:GLsizei.t -> format:GLenum.t -> type_:GLenum.t -> srcData:ArrayBufferView.t_0 -> srcOffset:GLuint.t -> unit [@@js.call "texSubImage2D"]
  val uniform1fv': 'tags this -> location:WebGLUniformLocation.t option -> data:Float32List.t -> ?srcOffset:GLuint.t -> ?srcLength:GLuint.t -> unit -> unit [@@js.call "uniform1fv"]
  val uniform1iv': 'tags this -> location:WebGLUniformLocation.t option -> data:Int32List.t -> ?srcOffset:GLuint.t -> ?srcLength:GLuint.t -> unit -> unit [@@js.call "uniform1iv"]
  val uniform2fv': 'tags this -> location:WebGLUniformLocation.t option -> data:Float32List.t -> ?srcOffset:GLuint.t -> ?srcLength:GLuint.t -> unit -> unit [@@js.call "uniform2fv"]
  val uniform2iv': 'tags this -> location:WebGLUniformLocation.t option -> data:Int32List.t -> ?srcOffset:GLuint.t -> ?srcLength:GLuint.t -> unit -> unit [@@js.call "uniform2iv"]
  val uniform3fv': 'tags this -> location:WebGLUniformLocation.t option -> data:Float32List.t -> ?srcOffset:GLuint.t -> ?srcLength:GLuint.t -> unit -> unit [@@js.call "uniform3fv"]
  val uniform3iv': 'tags this -> location:WebGLUniformLocation.t option -> data:Int32List.t -> ?srcOffset:GLuint.t -> ?srcLength:GLuint.t -> unit -> unit [@@js.call "uniform3iv"]
  val uniform4fv': 'tags this -> location:WebGLUniformLocation.t option -> data:Float32List.t -> ?srcOffset:GLuint.t -> ?srcLength:GLuint.t -> unit -> unit [@@js.call "uniform4fv"]
  val uniform4iv': 'tags this -> location:WebGLUniformLocation.t option -> data:Int32List.t -> ?srcOffset:GLuint.t -> ?srcLength:GLuint.t -> unit -> unit [@@js.call "uniform4iv"]
  val uniformMatrix2fv': 'tags this -> location:WebGLUniformLocation.t option -> transpose:GLboolean.t -> data:Float32List.t -> ?srcOffset:GLuint.t -> ?srcLength:GLuint.t -> unit -> unit [@@js.call "uniformMatrix2fv"]
  val uniformMatrix3fv': 'tags this -> location:WebGLUniformLocation.t option -> transpose:GLboolean.t -> data:Float32List.t -> ?srcOffset:GLuint.t -> ?srcLength:GLuint.t -> unit -> unit [@@js.call "uniformMatrix3fv"]
  val uniformMatrix4fv': 'tags this -> location:WebGLUniformLocation.t option -> transpose:GLboolean.t -> data:Float32List.t -> ?srcOffset:GLuint.t -> ?srcLength:GLuint.t -> unit -> unit [@@js.call "uniformMatrix4fv"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** Provides an interface to the OpenGL ES 2.0 graphics rendering context for the drawing surface of an HTML <canvas> element. *)
and[@js.scope "WebGLRenderingContext"] WebGLRenderingContext : sig
  type t = [`WebGLRenderingContext | `WebGLRenderingContextBase | `WebGLRenderingContextOverloads] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`WebGLRenderingContext | `WebGLRenderingContextBase | `WebGLRenderingContextOverloads]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`WebGLRenderingContext | `WebGLRenderingContextBase | `WebGLRenderingContextOverloads]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `WebGLRenderingContext ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
  val active_attributes: unit -> GLenum.t [@@js.get "ACTIVE_ATTRIBUTES"]
  val active_texture: unit -> GLenum.t [@@js.get "ACTIVE_TEXTURE"]
  val active_uniforms: unit -> GLenum.t [@@js.get "ACTIVE_UNIFORMS"]
  val aliased_line_width_range: unit -> GLenum.t [@@js.get "ALIASED_LINE_WIDTH_RANGE"]
  val aliased_point_size_range: unit -> GLenum.t [@@js.get "ALIASED_POINT_SIZE_RANGE"]
  val alpha: unit -> GLenum.t [@@js.get "ALPHA"]
  val alpha_bits: unit -> GLenum.t [@@js.get "ALPHA_BITS"]
  val always: unit -> GLenum.t [@@js.get "ALWAYS"]
  val array_buffer: unit -> GLenum.t [@@js.get "ARRAY_BUFFER"]
  val array_buffer_binding: unit -> GLenum.t [@@js.get "ARRAY_BUFFER_BINDING"]
  val attached_shaders: unit -> GLenum.t [@@js.get "ATTACHED_SHADERS"]
  val back: unit -> GLenum.t [@@js.get "BACK"]
  val blend: unit -> GLenum.t [@@js.get "BLEND"]
  val blend_color: unit -> GLenum.t [@@js.get "BLEND_COLOR"]
  val blend_dst_alpha: unit -> GLenum.t [@@js.get "BLEND_DST_ALPHA"]
  val blend_dst_rgb: unit -> GLenum.t [@@js.get "BLEND_DST_RGB"]
  val blend_equation: unit -> GLenum.t [@@js.get "BLEND_EQUATION"]
  val blend_equation_alpha: unit -> GLenum.t [@@js.get "BLEND_EQUATION_ALPHA"]
  val blend_equation_rgb: unit -> GLenum.t [@@js.get "BLEND_EQUATION_RGB"]
  val blend_src_alpha: unit -> GLenum.t [@@js.get "BLEND_SRC_ALPHA"]
  val blend_src_rgb: unit -> GLenum.t [@@js.get "BLEND_SRC_RGB"]
  val blue_bits: unit -> GLenum.t [@@js.get "BLUE_BITS"]
  val bool: unit -> GLenum.t [@@js.get "BOOL"]
  val bool_vec2: unit -> GLenum.t [@@js.get "BOOL_VEC2"]
  val bool_vec3: unit -> GLenum.t [@@js.get "BOOL_VEC3"]
  val bool_vec4: unit -> GLenum.t [@@js.get "BOOL_VEC4"]
  val browser_default_webgl: unit -> GLenum.t [@@js.get "BROWSER_DEFAULT_WEBGL"]
  val buffer_size: unit -> GLenum.t [@@js.get "BUFFER_SIZE"]
  val buffer_usage: unit -> GLenum.t [@@js.get "BUFFER_USAGE"]
  val byte: unit -> GLenum.t [@@js.get "BYTE"]
  val ccw: unit -> GLenum.t [@@js.get "CCW"]
  val clamp_to_edge: unit -> GLenum.t [@@js.get "CLAMP_TO_EDGE"]
  val color_attachment0: unit -> GLenum.t [@@js.get "COLOR_ATTACHMENT0"]
  val color_buffer_bit: unit -> GLenum.t [@@js.get "COLOR_BUFFER_BIT"]
  val color_clear_value: unit -> GLenum.t [@@js.get "COLOR_CLEAR_VALUE"]
  val color_writemask: unit -> GLenum.t [@@js.get "COLOR_WRITEMASK"]
  val compile_status: unit -> GLenum.t [@@js.get "COMPILE_STATUS"]
  val compressed_texture_formats: unit -> GLenum.t [@@js.get "COMPRESSED_TEXTURE_FORMATS"]
  val constant_alpha: unit -> GLenum.t [@@js.get "CONSTANT_ALPHA"]
  val constant_color: unit -> GLenum.t [@@js.get "CONSTANT_COLOR"]
  val context_lost_webgl: unit -> GLenum.t [@@js.get "CONTEXT_LOST_WEBGL"]
  val cull_face: unit -> GLenum.t [@@js.get "CULL_FACE"]
  val cull_face_mode: unit -> GLenum.t [@@js.get "CULL_FACE_MODE"]
  val current_program: unit -> GLenum.t [@@js.get "CURRENT_PROGRAM"]
  val current_vertex_attrib: unit -> GLenum.t [@@js.get "CURRENT_VERTEX_ATTRIB"]
  val cw: unit -> GLenum.t [@@js.get "CW"]
  val decr: unit -> GLenum.t [@@js.get "DECR"]
  val decr_wrap: unit -> GLenum.t [@@js.get "DECR_WRAP"]
  val delete_status: unit -> GLenum.t [@@js.get "DELETE_STATUS"]
  val depth_attachment: unit -> GLenum.t [@@js.get "DEPTH_ATTACHMENT"]
  val depth_bits: unit -> GLenum.t [@@js.get "DEPTH_BITS"]
  val depth_buffer_bit: unit -> GLenum.t [@@js.get "DEPTH_BUFFER_BIT"]
  val depth_clear_value: unit -> GLenum.t [@@js.get "DEPTH_CLEAR_VALUE"]
  val depth_component: unit -> GLenum.t [@@js.get "DEPTH_COMPONENT"]
  val depth_component16: unit -> GLenum.t [@@js.get "DEPTH_COMPONENT16"]
  val depth_func: unit -> GLenum.t [@@js.get "DEPTH_FUNC"]
  val depth_range: unit -> GLenum.t [@@js.get "DEPTH_RANGE"]
  val depth_stencil: unit -> GLenum.t [@@js.get "DEPTH_STENCIL"]
  val depth_stencil_attachment: unit -> GLenum.t [@@js.get "DEPTH_STENCIL_ATTACHMENT"]
  val depth_test: unit -> GLenum.t [@@js.get "DEPTH_TEST"]
  val depth_writemask: unit -> GLenum.t [@@js.get "DEPTH_WRITEMASK"]
  val dither: unit -> GLenum.t [@@js.get "DITHER"]
  val dont_care: unit -> GLenum.t [@@js.get "DONT_CARE"]
  val dst_alpha: unit -> GLenum.t [@@js.get "DST_ALPHA"]
  val dst_color: unit -> GLenum.t [@@js.get "DST_COLOR"]
  val dynamic_draw: unit -> GLenum.t [@@js.get "DYNAMIC_DRAW"]
  val element_array_buffer: unit -> GLenum.t [@@js.get "ELEMENT_ARRAY_BUFFER"]
  val element_array_buffer_binding: unit -> GLenum.t [@@js.get "ELEMENT_ARRAY_BUFFER_BINDING"]
  val equal: unit -> GLenum.t [@@js.get "EQUAL"]
  val fastest: unit -> GLenum.t [@@js.get "FASTEST"]
  val float: unit -> GLenum.t [@@js.get "FLOAT"]
  val float_mat2: unit -> GLenum.t [@@js.get "FLOAT_MAT2"]
  val float_mat3: unit -> GLenum.t [@@js.get "FLOAT_MAT3"]
  val float_mat4: unit -> GLenum.t [@@js.get "FLOAT_MAT4"]
  val float_vec2: unit -> GLenum.t [@@js.get "FLOAT_VEC2"]
  val float_vec3: unit -> GLenum.t [@@js.get "FLOAT_VEC3"]
  val float_vec4: unit -> GLenum.t [@@js.get "FLOAT_VEC4"]
  val fragment_shader: unit -> GLenum.t [@@js.get "FRAGMENT_SHADER"]
  val framebuffer: unit -> GLenum.t [@@js.get "FRAMEBUFFER"]
  val framebuffer_attachment_object_name: unit -> GLenum.t [@@js.get "FRAMEBUFFER_ATTACHMENT_OBJECT_NAME"]
  val framebuffer_attachment_object_type: unit -> GLenum.t [@@js.get "FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE"]
  val framebuffer_attachment_texture_cube_map_face: unit -> GLenum.t [@@js.get "FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE"]
  val framebuffer_attachment_texture_level: unit -> GLenum.t [@@js.get "FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL"]
  val framebuffer_binding: unit -> GLenum.t [@@js.get "FRAMEBUFFER_BINDING"]
  val framebuffer_complete: unit -> GLenum.t [@@js.get "FRAMEBUFFER_COMPLETE"]
  val framebuffer_incomplete_attachment: unit -> GLenum.t [@@js.get "FRAMEBUFFER_INCOMPLETE_ATTACHMENT"]
  val framebuffer_incomplete_dimensions: unit -> GLenum.t [@@js.get "FRAMEBUFFER_INCOMPLETE_DIMENSIONS"]
  val framebuffer_incomplete_missing_attachment: unit -> GLenum.t [@@js.get "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT"]
  val framebuffer_unsupported: unit -> GLenum.t [@@js.get "FRAMEBUFFER_UNSUPPORTED"]
  val front: unit -> GLenum.t [@@js.get "FRONT"]
  val front_and_back: unit -> GLenum.t [@@js.get "FRONT_AND_BACK"]
  val front_face: unit -> GLenum.t [@@js.get "FRONT_FACE"]
  val func_add: unit -> GLenum.t [@@js.get "FUNC_ADD"]
  val func_reverse_subtract: unit -> GLenum.t [@@js.get "FUNC_REVERSE_SUBTRACT"]
  val func_subtract: unit -> GLenum.t [@@js.get "FUNC_SUBTRACT"]
  val generate_mipmap_hint: unit -> GLenum.t [@@js.get "GENERATE_MIPMAP_HINT"]
  val gequal: unit -> GLenum.t [@@js.get "GEQUAL"]
  val greater: unit -> GLenum.t [@@js.get "GREATER"]
  val green_bits: unit -> GLenum.t [@@js.get "GREEN_BITS"]
  val high_float: unit -> GLenum.t [@@js.get "HIGH_FLOAT"]
  val high_int: unit -> GLenum.t [@@js.get "HIGH_INT"]
  val implementation_color_read_format: unit -> GLenum.t [@@js.get "IMPLEMENTATION_COLOR_READ_FORMAT"]
  val implementation_color_read_type: unit -> GLenum.t [@@js.get "IMPLEMENTATION_COLOR_READ_TYPE"]
  val incr: unit -> GLenum.t [@@js.get "INCR"]
  val incr_wrap: unit -> GLenum.t [@@js.get "INCR_WRAP"]
  val int: unit -> GLenum.t [@@js.get "INT"]
  val int_vec2: unit -> GLenum.t [@@js.get "INT_VEC2"]
  val int_vec3: unit -> GLenum.t [@@js.get "INT_VEC3"]
  val int_vec4: unit -> GLenum.t [@@js.get "INT_VEC4"]
  val invalid_enum: unit -> GLenum.t [@@js.get "INVALID_ENUM"]
  val invalid_framebuffer_operation: unit -> GLenum.t [@@js.get "INVALID_FRAMEBUFFER_OPERATION"]
  val invalid_operation: unit -> GLenum.t [@@js.get "INVALID_OPERATION"]
  val invalid_value: unit -> GLenum.t [@@js.get "INVALID_VALUE"]
  val invert: unit -> GLenum.t [@@js.get "INVERT"]
  val keep: unit -> GLenum.t [@@js.get "KEEP"]
  val lequal: unit -> GLenum.t [@@js.get "LEQUAL"]
  val less: unit -> GLenum.t [@@js.get "LESS"]
  val linear: unit -> GLenum.t [@@js.get "LINEAR"]
  val linear_mipmap_linear: unit -> GLenum.t [@@js.get "LINEAR_MIPMAP_LINEAR"]
  val linear_mipmap_nearest: unit -> GLenum.t [@@js.get "LINEAR_MIPMAP_NEAREST"]
  val lines: unit -> GLenum.t [@@js.get "LINES"]
  val line_loop: unit -> GLenum.t [@@js.get "LINE_LOOP"]
  val line_strip: unit -> GLenum.t [@@js.get "LINE_STRIP"]
  val line_width: unit -> GLenum.t [@@js.get "LINE_WIDTH"]
  val link_status: unit -> GLenum.t [@@js.get "LINK_STATUS"]
  val low_float: unit -> GLenum.t [@@js.get "LOW_FLOAT"]
  val low_int: unit -> GLenum.t [@@js.get "LOW_INT"]
  val luminance: unit -> GLenum.t [@@js.get "LUMINANCE"]
  val luminance_alpha: unit -> GLenum.t [@@js.get "LUMINANCE_ALPHA"]
  val max_combined_texture_image_units: unit -> GLenum.t [@@js.get "MAX_COMBINED_TEXTURE_IMAGE_UNITS"]
  val max_cube_map_texture_size: unit -> GLenum.t [@@js.get "MAX_CUBE_MAP_TEXTURE_SIZE"]
  val max_fragment_uniform_vectors: unit -> GLenum.t [@@js.get "MAX_FRAGMENT_UNIFORM_VECTORS"]
  val max_renderbuffer_size: unit -> GLenum.t [@@js.get "MAX_RENDERBUFFER_SIZE"]
  val max_texture_image_units: unit -> GLenum.t [@@js.get "MAX_TEXTURE_IMAGE_UNITS"]
  val max_texture_size: unit -> GLenum.t [@@js.get "MAX_TEXTURE_SIZE"]
  val max_varying_vectors: unit -> GLenum.t [@@js.get "MAX_VARYING_VECTORS"]
  val max_vertex_attribs: unit -> GLenum.t [@@js.get "MAX_VERTEX_ATTRIBS"]
  val max_vertex_texture_image_units: unit -> GLenum.t [@@js.get "MAX_VERTEX_TEXTURE_IMAGE_UNITS"]
  val max_vertex_uniform_vectors: unit -> GLenum.t [@@js.get "MAX_VERTEX_UNIFORM_VECTORS"]
  val max_viewport_dims: unit -> GLenum.t [@@js.get "MAX_VIEWPORT_DIMS"]
  val medium_float: unit -> GLenum.t [@@js.get "MEDIUM_FLOAT"]
  val medium_int: unit -> GLenum.t [@@js.get "MEDIUM_INT"]
  val mirrored_repeat: unit -> GLenum.t [@@js.get "MIRRORED_REPEAT"]
  val nearest: unit -> GLenum.t [@@js.get "NEAREST"]
  val nearest_mipmap_linear: unit -> GLenum.t [@@js.get "NEAREST_MIPMAP_LINEAR"]
  val nearest_mipmap_nearest: unit -> GLenum.t [@@js.get "NEAREST_MIPMAP_NEAREST"]
  val never: unit -> GLenum.t [@@js.get "NEVER"]
  val nicest: unit -> GLenum.t [@@js.get "NICEST"]
  val none: unit -> GLenum.t [@@js.get "NONE"]
  val notequal: unit -> GLenum.t [@@js.get "NOTEQUAL"]
  val no_error: unit -> GLenum.t [@@js.get "NO_ERROR"]
  val one: unit -> GLenum.t [@@js.get "ONE"]
  val one_minus_constant_alpha: unit -> GLenum.t [@@js.get "ONE_MINUS_CONSTANT_ALPHA"]
  val one_minus_constant_color: unit -> GLenum.t [@@js.get "ONE_MINUS_CONSTANT_COLOR"]
  val one_minus_dst_alpha: unit -> GLenum.t [@@js.get "ONE_MINUS_DST_ALPHA"]
  val one_minus_dst_color: unit -> GLenum.t [@@js.get "ONE_MINUS_DST_COLOR"]
  val one_minus_src_alpha: unit -> GLenum.t [@@js.get "ONE_MINUS_SRC_ALPHA"]
  val one_minus_src_color: unit -> GLenum.t [@@js.get "ONE_MINUS_SRC_COLOR"]
  val out_of_memory: unit -> GLenum.t [@@js.get "OUT_OF_MEMORY"]
  val pack_alignment: unit -> GLenum.t [@@js.get "PACK_ALIGNMENT"]
  val points: unit -> GLenum.t [@@js.get "POINTS"]
  val polygon_offset_factor: unit -> GLenum.t [@@js.get "POLYGON_OFFSET_FACTOR"]
  val polygon_offset_fill: unit -> GLenum.t [@@js.get "POLYGON_OFFSET_FILL"]
  val polygon_offset_units: unit -> GLenum.t [@@js.get "POLYGON_OFFSET_UNITS"]
  val red_bits: unit -> GLenum.t [@@js.get "RED_BITS"]
  val renderbuffer: unit -> GLenum.t [@@js.get "RENDERBUFFER"]
  val renderbuffer_alpha_size: unit -> GLenum.t [@@js.get "RENDERBUFFER_ALPHA_SIZE"]
  val renderbuffer_binding: unit -> GLenum.t [@@js.get "RENDERBUFFER_BINDING"]
  val renderbuffer_blue_size: unit -> GLenum.t [@@js.get "RENDERBUFFER_BLUE_SIZE"]
  val renderbuffer_depth_size: unit -> GLenum.t [@@js.get "RENDERBUFFER_DEPTH_SIZE"]
  val renderbuffer_green_size: unit -> GLenum.t [@@js.get "RENDERBUFFER_GREEN_SIZE"]
  val renderbuffer_height: unit -> GLenum.t [@@js.get "RENDERBUFFER_HEIGHT"]
  val renderbuffer_internal_format: unit -> GLenum.t [@@js.get "RENDERBUFFER_INTERNAL_FORMAT"]
  val renderbuffer_red_size: unit -> GLenum.t [@@js.get "RENDERBUFFER_RED_SIZE"]
  val renderbuffer_stencil_size: unit -> GLenum.t [@@js.get "RENDERBUFFER_STENCIL_SIZE"]
  val renderbuffer_width: unit -> GLenum.t [@@js.get "RENDERBUFFER_WIDTH"]
  val renderer: unit -> GLenum.t [@@js.get "RENDERER"]
  val repeat: unit -> GLenum.t [@@js.get "REPEAT"]
  val replace: unit -> GLenum.t [@@js.get "REPLACE"]
  val rgb: unit -> GLenum.t [@@js.get "RGB"]
  val rgb565: unit -> GLenum.t [@@js.get "RGB565"]
  val rgb5_a1: unit -> GLenum.t [@@js.get "RGB5_A1"]
  val rgba: unit -> GLenum.t [@@js.get "RGBA"]
  val rgba4: unit -> GLenum.t [@@js.get "RGBA4"]
  val sampler_2d: unit -> GLenum.t [@@js.get "SAMPLER_2D"]
  val sampler_cube: unit -> GLenum.t [@@js.get "SAMPLER_CUBE"]
  val samples: unit -> GLenum.t [@@js.get "SAMPLES"]
  val sample_alpha_to_coverage: unit -> GLenum.t [@@js.get "SAMPLE_ALPHA_TO_COVERAGE"]
  val sample_buffers: unit -> GLenum.t [@@js.get "SAMPLE_BUFFERS"]
  val sample_coverage: unit -> GLenum.t [@@js.get "SAMPLE_COVERAGE"]
  val sample_coverage_invert: unit -> GLenum.t [@@js.get "SAMPLE_COVERAGE_INVERT"]
  val sample_coverage_value: unit -> GLenum.t [@@js.get "SAMPLE_COVERAGE_VALUE"]
  val scissor_box: unit -> GLenum.t [@@js.get "SCISSOR_BOX"]
  val scissor_test: unit -> GLenum.t [@@js.get "SCISSOR_TEST"]
  val shader_type: unit -> GLenum.t [@@js.get "SHADER_TYPE"]
  val shading_language_version: unit -> GLenum.t [@@js.get "SHADING_LANGUAGE_VERSION"]
  val short: unit -> GLenum.t [@@js.get "SHORT"]
  val src_alpha: unit -> GLenum.t [@@js.get "SRC_ALPHA"]
  val src_alpha_saturate: unit -> GLenum.t [@@js.get "SRC_ALPHA_SATURATE"]
  val src_color: unit -> GLenum.t [@@js.get "SRC_COLOR"]
  val static_draw: unit -> GLenum.t [@@js.get "STATIC_DRAW"]
  val stencil_attachment: unit -> GLenum.t [@@js.get "STENCIL_ATTACHMENT"]
  val stencil_back_fail: unit -> GLenum.t [@@js.get "STENCIL_BACK_FAIL"]
  val stencil_back_func: unit -> GLenum.t [@@js.get "STENCIL_BACK_FUNC"]
  val stencil_back_pass_depth_fail: unit -> GLenum.t [@@js.get "STENCIL_BACK_PASS_DEPTH_FAIL"]
  val stencil_back_pass_depth_pass: unit -> GLenum.t [@@js.get "STENCIL_BACK_PASS_DEPTH_PASS"]
  val stencil_back_ref: unit -> GLenum.t [@@js.get "STENCIL_BACK_REF"]
  val stencil_back_value_mask: unit -> GLenum.t [@@js.get "STENCIL_BACK_VALUE_MASK"]
  val stencil_back_writemask: unit -> GLenum.t [@@js.get "STENCIL_BACK_WRITEMASK"]
  val stencil_bits: unit -> GLenum.t [@@js.get "STENCIL_BITS"]
  val stencil_buffer_bit: unit -> GLenum.t [@@js.get "STENCIL_BUFFER_BIT"]
  val stencil_clear_value: unit -> GLenum.t [@@js.get "STENCIL_CLEAR_VALUE"]
  val stencil_fail: unit -> GLenum.t [@@js.get "STENCIL_FAIL"]
  val stencil_func: unit -> GLenum.t [@@js.get "STENCIL_FUNC"]
  val stencil_index8: unit -> GLenum.t [@@js.get "STENCIL_INDEX8"]
  val stencil_pass_depth_fail: unit -> GLenum.t [@@js.get "STENCIL_PASS_DEPTH_FAIL"]
  val stencil_pass_depth_pass: unit -> GLenum.t [@@js.get "STENCIL_PASS_DEPTH_PASS"]
  val stencil_ref: unit -> GLenum.t [@@js.get "STENCIL_REF"]
  val stencil_test: unit -> GLenum.t [@@js.get "STENCIL_TEST"]
  val stencil_value_mask: unit -> GLenum.t [@@js.get "STENCIL_VALUE_MASK"]
  val stencil_writemask: unit -> GLenum.t [@@js.get "STENCIL_WRITEMASK"]
  val stream_draw: unit -> GLenum.t [@@js.get "STREAM_DRAW"]
  val subpixel_bits: unit -> GLenum.t [@@js.get "SUBPIXEL_BITS"]
  val texture: unit -> GLenum.t [@@js.get "TEXTURE"]
  val texture0: unit -> GLenum.t [@@js.get "TEXTURE0"]
  val texture1: unit -> GLenum.t [@@js.get "TEXTURE1"]
  val texture10: unit -> GLenum.t [@@js.get "TEXTURE10"]
  val texture11: unit -> GLenum.t [@@js.get "TEXTURE11"]
  val texture12: unit -> GLenum.t [@@js.get "TEXTURE12"]
  val texture13: unit -> GLenum.t [@@js.get "TEXTURE13"]
  val texture14: unit -> GLenum.t [@@js.get "TEXTURE14"]
  val texture15: unit -> GLenum.t [@@js.get "TEXTURE15"]
  val texture16: unit -> GLenum.t [@@js.get "TEXTURE16"]
  val texture17: unit -> GLenum.t [@@js.get "TEXTURE17"]
  val texture18: unit -> GLenum.t [@@js.get "TEXTURE18"]
  val texture19: unit -> GLenum.t [@@js.get "TEXTURE19"]
  val texture2: unit -> GLenum.t [@@js.get "TEXTURE2"]
  val texture20: unit -> GLenum.t [@@js.get "TEXTURE20"]
  val texture21: unit -> GLenum.t [@@js.get "TEXTURE21"]
  val texture22: unit -> GLenum.t [@@js.get "TEXTURE22"]
  val texture23: unit -> GLenum.t [@@js.get "TEXTURE23"]
  val texture24: unit -> GLenum.t [@@js.get "TEXTURE24"]
  val texture25: unit -> GLenum.t [@@js.get "TEXTURE25"]
  val texture26: unit -> GLenum.t [@@js.get "TEXTURE26"]
  val texture27: unit -> GLenum.t [@@js.get "TEXTURE27"]
  val texture28: unit -> GLenum.t [@@js.get "TEXTURE28"]
  val texture29: unit -> GLenum.t [@@js.get "TEXTURE29"]
  val texture3: unit -> GLenum.t [@@js.get "TEXTURE3"]
  val texture30: unit -> GLenum.t [@@js.get "TEXTURE30"]
  val texture31: unit -> GLenum.t [@@js.get "TEXTURE31"]
  val texture4: unit -> GLenum.t [@@js.get "TEXTURE4"]
  val texture5: unit -> GLenum.t [@@js.get "TEXTURE5"]
  val texture6: unit -> GLenum.t [@@js.get "TEXTURE6"]
  val texture7: unit -> GLenum.t [@@js.get "TEXTURE7"]
  val texture8: unit -> GLenum.t [@@js.get "TEXTURE8"]
  val texture9: unit -> GLenum.t [@@js.get "TEXTURE9"]
  val texture_2d: unit -> GLenum.t [@@js.get "TEXTURE_2D"]
  val texture_binding_2d: unit -> GLenum.t [@@js.get "TEXTURE_BINDING_2D"]
  val texture_binding_cube_map: unit -> GLenum.t [@@js.get "TEXTURE_BINDING_CUBE_MAP"]
  val texture_cube_map: unit -> GLenum.t [@@js.get "TEXTURE_CUBE_MAP"]
  val texture_cube_map_negative_x: unit -> GLenum.t [@@js.get "TEXTURE_CUBE_MAP_NEGATIVE_X"]
  val texture_cube_map_negative_y: unit -> GLenum.t [@@js.get "TEXTURE_CUBE_MAP_NEGATIVE_Y"]
  val texture_cube_map_negative_z: unit -> GLenum.t [@@js.get "TEXTURE_CUBE_MAP_NEGATIVE_Z"]
  val texture_cube_map_positive_x: unit -> GLenum.t [@@js.get "TEXTURE_CUBE_MAP_POSITIVE_X"]
  val texture_cube_map_positive_y: unit -> GLenum.t [@@js.get "TEXTURE_CUBE_MAP_POSITIVE_Y"]
  val texture_cube_map_positive_z: unit -> GLenum.t [@@js.get "TEXTURE_CUBE_MAP_POSITIVE_Z"]
  val texture_mag_filter: unit -> GLenum.t [@@js.get "TEXTURE_MAG_FILTER"]
  val texture_min_filter: unit -> GLenum.t [@@js.get "TEXTURE_MIN_FILTER"]
  val texture_wrap_s: unit -> GLenum.t [@@js.get "TEXTURE_WRAP_S"]
  val texture_wrap_t: unit -> GLenum.t [@@js.get "TEXTURE_WRAP_T"]
  val triangles: unit -> GLenum.t [@@js.get "TRIANGLES"]
  val triangle_fan: unit -> GLenum.t [@@js.get "TRIANGLE_FAN"]
  val triangle_strip: unit -> GLenum.t [@@js.get "TRIANGLE_STRIP"]
  val unpack_alignment: unit -> GLenum.t [@@js.get "UNPACK_ALIGNMENT"]
  val unpack_colorspace_conversion_webgl: unit -> GLenum.t [@@js.get "UNPACK_COLORSPACE_CONVERSION_WEBGL"]
  val unpack_flip_y_webgl: unit -> GLenum.t [@@js.get "UNPACK_FLIP_Y_WEBGL"]
  val unpack_premultiply_alpha_webgl: unit -> GLenum.t [@@js.get "UNPACK_PREMULTIPLY_ALPHA_WEBGL"]
  val unsigned_byte: unit -> GLenum.t [@@js.get "UNSIGNED_BYTE"]
  val unsigned_int: unit -> GLenum.t [@@js.get "UNSIGNED_INT"]
  val unsigned_short: unit -> GLenum.t [@@js.get "UNSIGNED_SHORT"]
  val unsigned_short_4_4_4_4: unit -> GLenum.t [@@js.get "UNSIGNED_SHORT_4_4_4_4"]
  val unsigned_short_5_5_5_1: unit -> GLenum.t [@@js.get "UNSIGNED_SHORT_5_5_5_1"]
  val unsigned_short_5_6_5: unit -> GLenum.t [@@js.get "UNSIGNED_SHORT_5_6_5"]
  val validate_status: unit -> GLenum.t [@@js.get "VALIDATE_STATUS"]
  val vendor: unit -> GLenum.t [@@js.get "VENDOR"]
  val version: unit -> GLenum.t [@@js.get "VERSION"]
  val vertex_attrib_array_buffer_binding: unit -> GLenum.t [@@js.get "VERTEX_ATTRIB_ARRAY_BUFFER_BINDING"]
  val vertex_attrib_array_enabled: unit -> GLenum.t [@@js.get "VERTEX_ATTRIB_ARRAY_ENABLED"]
  val vertex_attrib_array_normalized: unit -> GLenum.t [@@js.get "VERTEX_ATTRIB_ARRAY_NORMALIZED"]
  val vertex_attrib_array_pointer: unit -> GLenum.t [@@js.get "VERTEX_ATTRIB_ARRAY_POINTER"]
  val vertex_attrib_array_size: unit -> GLenum.t [@@js.get "VERTEX_ATTRIB_ARRAY_SIZE"]
  val vertex_attrib_array_stride: unit -> GLenum.t [@@js.get "VERTEX_ATTRIB_ARRAY_STRIDE"]
  val vertex_attrib_array_type: unit -> GLenum.t [@@js.get "VERTEX_ATTRIB_ARRAY_TYPE"]
  val vertex_shader: unit -> GLenum.t [@@js.get "VERTEX_SHADER"]
  val viewport: unit -> GLenum.t [@@js.get "VIEWPORT"]
  val zero: unit -> GLenum.t [@@js.get "ZERO"]
end
and WebGLRenderingContextBase : sig
  type t = [`WebGLRenderingContextBase] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`WebGLRenderingContextBase]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`WebGLRenderingContextBase]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `WebGLRenderingContextBase ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val vertexAttrib1fv: 'tags this -> index:GLuint.t -> values:GLfloat.t Iterable.t_1 -> unit [@@js.call "vertexAttrib1fv"]
  val vertexAttrib2fv: 'tags this -> index:GLuint.t -> values:GLfloat.t Iterable.t_1 -> unit [@@js.call "vertexAttrib2fv"]
  val vertexAttrib3fv: 'tags this -> index:GLuint.t -> values:GLfloat.t Iterable.t_1 -> unit [@@js.call "vertexAttrib3fv"]
  val vertexAttrib4fv: 'tags this -> index:GLuint.t -> values:GLfloat.t Iterable.t_1 -> unit [@@js.call "vertexAttrib4fv"]
  val get_canvas: 'tags this -> HTMLCanvasElement.t [@@js.get "canvas"]
  val get_drawingBufferHeight: 'tags this -> GLsizei.t [@@js.get "drawingBufferHeight"]
  val get_drawingBufferWidth: 'tags this -> GLsizei.t [@@js.get "drawingBufferWidth"]
  val activeTexture: 'tags this -> texture:GLenum.t -> unit [@@js.call "activeTexture"]
  val attachShader: 'tags this -> program:WebGLProgram.t -> shader:WebGLShader.t -> unit [@@js.call "attachShader"]
  val bindAttribLocation: 'tags this -> program:WebGLProgram.t -> index:GLuint.t -> name:string -> unit [@@js.call "bindAttribLocation"]
  val bindBuffer: 'tags this -> target:GLenum.t -> buffer:WebGLBuffer.t option -> unit [@@js.call "bindBuffer"]
  val bindFramebuffer: 'tags this -> target:GLenum.t -> framebuffer:WebGLFramebuffer.t option -> unit [@@js.call "bindFramebuffer"]
  val bindRenderbuffer: 'tags this -> target:GLenum.t -> renderbuffer:WebGLRenderbuffer.t option -> unit [@@js.call "bindRenderbuffer"]
  val bindTexture: 'tags this -> target:GLenum.t -> texture:WebGLTexture.t option -> unit [@@js.call "bindTexture"]
  val blendColor: 'tags this -> red:GLclampf.t -> green:GLclampf.t -> blue:GLclampf.t -> alpha:GLclampf.t -> unit [@@js.call "blendColor"]
  val blendEquation: 'tags this -> mode:GLenum.t -> unit [@@js.call "blendEquation"]
  val blendEquationSeparate: 'tags this -> modeRGB:GLenum.t -> modeAlpha:GLenum.t -> unit [@@js.call "blendEquationSeparate"]
  val blendFunc: 'tags this -> sfactor:GLenum.t -> dfactor:GLenum.t -> unit [@@js.call "blendFunc"]
  val blendFuncSeparate: 'tags this -> srcRGB:GLenum.t -> dstRGB:GLenum.t -> srcAlpha:GLenum.t -> dstAlpha:GLenum.t -> unit [@@js.call "blendFuncSeparate"]
  val checkFramebufferStatus: 'tags this -> target:GLenum.t -> GLenum.t [@@js.call "checkFramebufferStatus"]
  val clear: 'tags this -> mask:GLbitfield.t -> unit [@@js.call "clear"]
  val clearColor: 'tags this -> red:GLclampf.t -> green:GLclampf.t -> blue:GLclampf.t -> alpha:GLclampf.t -> unit [@@js.call "clearColor"]
  val clearDepth: 'tags this -> depth:GLclampf.t -> unit [@@js.call "clearDepth"]
  val clearStencil: 'tags this -> s:GLint.t -> unit [@@js.call "clearStencil"]
  val colorMask: 'tags this -> red:GLboolean.t -> green:GLboolean.t -> blue:GLboolean.t -> alpha:GLboolean.t -> unit [@@js.call "colorMask"]
  val compileShader: 'tags this -> shader:WebGLShader.t -> unit [@@js.call "compileShader"]
  val copyTexImage2D: 'tags this -> target:GLenum.t -> level:GLint.t -> internalformat:GLenum.t -> x:GLint.t -> y:GLint.t -> width:GLsizei.t -> height:GLsizei.t -> border:GLint.t -> unit [@@js.call "copyTexImage2D"]
  val copyTexSubImage2D: 'tags this -> target:GLenum.t -> level:GLint.t -> xoffset:GLint.t -> yoffset:GLint.t -> x:GLint.t -> y:GLint.t -> width:GLsizei.t -> height:GLsizei.t -> unit [@@js.call "copyTexSubImage2D"]
  val createBuffer: 'tags this -> WebGLBuffer.t option [@@js.call "createBuffer"]
  val createFramebuffer: 'tags this -> WebGLFramebuffer.t option [@@js.call "createFramebuffer"]
  val createProgram: 'tags this -> WebGLProgram.t option [@@js.call "createProgram"]
  val createRenderbuffer: 'tags this -> WebGLRenderbuffer.t option [@@js.call "createRenderbuffer"]
  val createShader: 'tags this -> type_:GLenum.t -> WebGLShader.t option [@@js.call "createShader"]
  val createTexture: 'tags this -> WebGLTexture.t option [@@js.call "createTexture"]
  val cullFace: 'tags this -> mode:GLenum.t -> unit [@@js.call "cullFace"]
  val deleteBuffer: 'tags this -> buffer:WebGLBuffer.t option -> unit [@@js.call "deleteBuffer"]
  val deleteFramebuffer: 'tags this -> framebuffer:WebGLFramebuffer.t option -> unit [@@js.call "deleteFramebuffer"]
  val deleteProgram: 'tags this -> program:WebGLProgram.t option -> unit [@@js.call "deleteProgram"]
  val deleteRenderbuffer: 'tags this -> renderbuffer:WebGLRenderbuffer.t option -> unit [@@js.call "deleteRenderbuffer"]
  val deleteShader: 'tags this -> shader:WebGLShader.t option -> unit [@@js.call "deleteShader"]
  val deleteTexture: 'tags this -> texture:WebGLTexture.t option -> unit [@@js.call "deleteTexture"]
  val depthFunc: 'tags this -> func:GLenum.t -> unit [@@js.call "depthFunc"]
  val depthMask: 'tags this -> flag:GLboolean.t -> unit [@@js.call "depthMask"]
  val depthRange: 'tags this -> zNear:GLclampf.t -> zFar:GLclampf.t -> unit [@@js.call "depthRange"]
  val detachShader: 'tags this -> program:WebGLProgram.t -> shader:WebGLShader.t -> unit [@@js.call "detachShader"]
  val disable: 'tags this -> cap:GLenum.t -> unit [@@js.call "disable"]
  val disableVertexAttribArray: 'tags this -> index:GLuint.t -> unit [@@js.call "disableVertexAttribArray"]
  val drawArrays: 'tags this -> mode:GLenum.t -> first:GLint.t -> count:GLsizei.t -> unit [@@js.call "drawArrays"]
  val drawElements: 'tags this -> mode:GLenum.t -> count:GLsizei.t -> type_:GLenum.t -> offset:GLintptr.t -> unit [@@js.call "drawElements"]
  val enable: 'tags this -> cap:GLenum.t -> unit [@@js.call "enable"]
  val enableVertexAttribArray: 'tags this -> index:GLuint.t -> unit [@@js.call "enableVertexAttribArray"]
  val finish: 'tags this -> unit [@@js.call "finish"]
  val flush: 'tags this -> unit [@@js.call "flush"]
  val framebufferRenderbuffer: 'tags this -> target:GLenum.t -> attachment:GLenum.t -> renderbuffertarget:GLenum.t -> renderbuffer:WebGLRenderbuffer.t option -> unit [@@js.call "framebufferRenderbuffer"]
  val framebufferTexture2D: 'tags this -> target:GLenum.t -> attachment:GLenum.t -> textarget:GLenum.t -> texture:WebGLTexture.t option -> level:GLint.t -> unit [@@js.call "framebufferTexture2D"]
  val frontFace: 'tags this -> mode:GLenum.t -> unit [@@js.call "frontFace"]
  val generateMipmap: 'tags this -> target:GLenum.t -> unit [@@js.call "generateMipmap"]
  val getActiveAttrib: 'tags this -> program:WebGLProgram.t -> index:GLuint.t -> WebGLActiveInfo.t option [@@js.call "getActiveAttrib"]
  val getActiveUniform: 'tags this -> program:WebGLProgram.t -> index:GLuint.t -> WebGLActiveInfo.t option [@@js.call "getActiveUniform"]
  val getAttachedShaders: 'tags this -> program:WebGLProgram.t -> WebGLShader.t list option [@@js.call "getAttachedShaders"]
  val getAttribLocation: 'tags this -> program:WebGLProgram.t -> name:string -> GLint.t [@@js.call "getAttribLocation"]
  val getBufferParameter: 'tags this -> target:GLenum.t -> pname:GLenum.t -> any [@@js.call "getBufferParameter"]
  val getContextAttributes: 'tags this -> WebGLContextAttributes.t option [@@js.call "getContextAttributes"]
  val getError: 'tags this -> GLenum.t [@@js.call "getError"]
  val getExtension: 'tags this -> extensionName:([`L_s17_EXT_blend_minmax[@js "EXT_blend_minmax"]] [@js.enum]) -> EXT_blend_minmax.t option [@@js.call "getExtension"]
  val getExtension': 'tags this -> extensionName:([`L_s18_EXT_color_buffer_float[@js "EXT_color_buffer_float"]] [@js.enum]) -> EXT_color_buffer_float.t option [@@js.call "getExtension"]
  val getExtension'': 'tags this -> extensionName:([`L_s19_EXT_color_buffer_half_float[@js "EXT_color_buffer_half_float"]] [@js.enum]) -> EXT_color_buffer_half_float.t option [@@js.call "getExtension"]
  val getExtension''': 'tags this -> extensionName:([`L_s20_EXT_float_blend[@js "EXT_float_blend"]] [@js.enum]) -> EXT_float_blend.t option [@@js.call "getExtension"]
  val getExtension'''': 'tags this -> extensionName:([`L_s24_EXT_texture_filter_anisotropic[@js "EXT_texture_filter_anisotropic"]] [@js.enum]) -> EXT_texture_filter_anisotropic.t option [@@js.call "getExtension"]
  val getExtension''''': 'tags this -> extensionName:([`L_s21_EXT_frag_depth[@js "EXT_frag_depth"]] [@js.enum]) -> EXT_frag_depth.t option [@@js.call "getExtension"]
  val getExtension'''''': 'tags this -> extensionName:([`L_s23_EXT_shader_texture_lod[@js "EXT_shader_texture_lod"]] [@js.enum]) -> EXT_shader_texture_lod.t option [@@js.call "getExtension"]
  val getExtension''''''': 'tags this -> extensionName:([`L_s22_EXT_sRGB[@js "EXT_sRGB"]] [@js.enum]) -> EXT_sRGB.t option [@@js.call "getExtension"]
  val getExtension'''''''': 'tags this -> extensionName:([`L_s34_KHR_parallel_shader_compile[@js "KHR_parallel_shader_compile"]] [@js.enum]) -> KHR_parallel_shader_compile.t option [@@js.call "getExtension"]
  val getExtension''''''''': 'tags this -> extensionName:([`L_s52_OES_vertex_array_object[@js "OES_vertex_array_object"]] [@js.enum]) -> OES_vertex_array_object.t option [@@js.call "getExtension"]
  val getExtension'''''''''': 'tags this -> extensionName:([`L_s53_OVR_multiview2[@js "OVR_multiview2"]] [@js.enum]) -> OVR_multiview2.t option [@@js.call "getExtension"]
  val getExtension''''''''''': 'tags this -> extensionName:([`L_s77_WEBGL_color_buffer_float[@js "WEBGL_color_buffer_float"]] [@js.enum]) -> WEBGL_color_buffer_float.t option [@@js.call "getExtension"]
  val getExtension'''''''''''': 'tags this -> extensionName:([`L_s78_WEBGL_compressed_texture_astc[@js "WEBGL_compressed_texture_astc"]] [@js.enum]) -> WEBGL_compressed_texture_astc.t option [@@js.call "getExtension"]
  val getExtension''''''''''''': 'tags this -> extensionName:([`L_s79_WEBGL_compressed_texture_etc[@js "WEBGL_compressed_texture_etc"]] [@js.enum]) -> WEBGL_compressed_texture_etc.t option [@@js.call "getExtension"]
  val getExtension'''''''''''''': 'tags this -> extensionName:([`L_s80_WEBGL_compressed_texture_etc1[@js "WEBGL_compressed_texture_etc1"]] [@js.enum]) -> WEBGL_compressed_texture_etc1.t option [@@js.call "getExtension"]
  val getExtension''''''''''''''': 'tags this -> extensionName:([`L_s81_WEBGL_compressed_texture_pvrtc[@js "WEBGL_compressed_texture_pvrtc"]] [@js.enum]) -> WEBGL_compressed_texture_pvrtc.t option [@@js.call "getExtension"]
  val getExtension'''''''''''''''': 'tags this -> extensionName:([`L_s83_WEBGL_compressed_texture_s3tc_srgb[@js "WEBGL_compressed_texture_s3tc_srgb"]] [@js.enum]) -> WEBGL_compressed_texture_s3tc_srgb.t option [@@js.call "getExtension"]
  val getExtension''''''''''''''''': 'tags this -> extensionName:([`L_s85_WEBGL_debug_shaders[@js "WEBGL_debug_shaders"]] [@js.enum]) -> WEBGL_debug_shaders.t option [@@js.call "getExtension"]
  val getExtension'''''''''''''''''': 'tags this -> extensionName:([`L_s87_WEBGL_draw_buffers[@js "WEBGL_draw_buffers"]] [@js.enum]) -> WEBGL_draw_buffers.t option [@@js.call "getExtension"]
  val getExtension''''''''''''''''''': 'tags this -> extensionName:([`L_s88_WEBGL_lose_context[@js "WEBGL_lose_context"]] [@js.enum]) -> WEBGL_lose_context.t option [@@js.call "getExtension"]
  val getExtension'''''''''''''''''''': 'tags this -> extensionName:([`L_s86_WEBGL_depth_texture[@js "WEBGL_depth_texture"]] [@js.enum]) -> WEBGL_depth_texture.t option [@@js.call "getExtension"]
  val getExtension''''''''''''''''''''': 'tags this -> extensionName:([`L_s84_WEBGL_debug_renderer_info[@js "WEBGL_debug_renderer_info"]] [@js.enum]) -> WEBGL_debug_renderer_info.t option [@@js.call "getExtension"]
  val getExtension'''''''''''''''''''''': 'tags this -> extensionName:([`L_s82_WEBGL_compressed_texture_s3tc[@js "WEBGL_compressed_texture_s3tc"]] [@js.enum]) -> WEBGL_compressed_texture_s3tc.t option [@@js.call "getExtension"]
  val getExtension''''''''''''''''''''''': 'tags this -> extensionName:([`L_s51_OES_texture_half_float_linear[@js "OES_texture_half_float_linear"]] [@js.enum]) -> OES_texture_half_float_linear.t option [@@js.call "getExtension"]
  val getExtension'''''''''''''''''''''''': 'tags this -> extensionName:([`L_s50_OES_texture_half_float[@js "OES_texture_half_float"]] [@js.enum]) -> OES_texture_half_float.t option [@@js.call "getExtension"]
  val getExtension''''''''''''''''''''''''': 'tags this -> extensionName:([`L_s49_OES_texture_float_linear[@js "OES_texture_float_linear"]] [@js.enum]) -> OES_texture_float_linear.t option [@@js.call "getExtension"]
  val getExtension'''''''''''''''''''''''''': 'tags this -> extensionName:([`L_s48_OES_texture_float[@js "OES_texture_float"]] [@js.enum]) -> OES_texture_float.t option [@@js.call "getExtension"]
  val getExtension''''''''''''''''''''''''''': 'tags this -> extensionName:([`L_s47_OES_standard_derivatives[@js "OES_standard_derivatives"]] [@js.enum]) -> OES_standard_derivatives.t option [@@js.call "getExtension"]
  val getExtension'''''''''''''''''''''''''''': 'tags this -> extensionName:([`L_s46_OES_element_index_uint[@js "OES_element_index_uint"]] [@js.enum]) -> OES_element_index_uint.t option [@@js.call "getExtension"]
  val getExtension''''''''''''''''''''''''''''': 'tags this -> extensionName:([`L_s4_ANGLE_instanced_arrays[@js "ANGLE_instanced_arrays"]] [@js.enum]) -> ANGLE_instanced_arrays.t option [@@js.call "getExtension"]
  val getExtension'''''''''''''''''''''''''''''': 'tags this -> name:string -> any [@@js.call "getExtension"]
  val getFramebufferAttachmentParameter: 'tags this -> target:GLenum.t -> attachment:GLenum.t -> pname:GLenum.t -> any [@@js.call "getFramebufferAttachmentParameter"]
  val getParameter: 'tags this -> pname:GLenum.t -> any [@@js.call "getParameter"]
  val getProgramInfoLog: 'tags this -> program:WebGLProgram.t -> string option [@@js.call "getProgramInfoLog"]
  val getProgramParameter: 'tags this -> program:WebGLProgram.t -> pname:GLenum.t -> any [@@js.call "getProgramParameter"]
  val getRenderbufferParameter: 'tags this -> target:GLenum.t -> pname:GLenum.t -> any [@@js.call "getRenderbufferParameter"]
  val getShaderInfoLog: 'tags this -> shader:WebGLShader.t -> string option [@@js.call "getShaderInfoLog"]
  val getShaderParameter: 'tags this -> shader:WebGLShader.t -> pname:GLenum.t -> any [@@js.call "getShaderParameter"]
  val getShaderPrecisionFormat: 'tags this -> shadertype:GLenum.t -> precisiontype:GLenum.t -> WebGLShaderPrecisionFormat.t option [@@js.call "getShaderPrecisionFormat"]
  val getShaderSource: 'tags this -> shader:WebGLShader.t -> string option [@@js.call "getShaderSource"]
  val getSupportedExtensions: 'tags this -> string list option [@@js.call "getSupportedExtensions"]
  val getTexParameter: 'tags this -> target:GLenum.t -> pname:GLenum.t -> any [@@js.call "getTexParameter"]
  val getUniform: 'tags this -> program:WebGLProgram.t -> location:WebGLUniformLocation.t -> any [@@js.call "getUniform"]
  val getUniformLocation: 'tags this -> program:WebGLProgram.t -> name:string -> WebGLUniformLocation.t option [@@js.call "getUniformLocation"]
  val getVertexAttrib: 'tags this -> index:GLuint.t -> pname:GLenum.t -> any [@@js.call "getVertexAttrib"]
  val getVertexAttribOffset: 'tags this -> index:GLuint.t -> pname:GLenum.t -> GLintptr.t [@@js.call "getVertexAttribOffset"]
  val hint: 'tags this -> target:GLenum.t -> mode:GLenum.t -> unit [@@js.call "hint"]
  val isBuffer: 'tags this -> buffer:WebGLBuffer.t option -> GLboolean.t [@@js.call "isBuffer"]
  val isContextLost: 'tags this -> bool [@@js.call "isContextLost"]
  val isEnabled: 'tags this -> cap:GLenum.t -> GLboolean.t [@@js.call "isEnabled"]
  val isFramebuffer: 'tags this -> framebuffer:WebGLFramebuffer.t option -> GLboolean.t [@@js.call "isFramebuffer"]
  val isProgram: 'tags this -> program:WebGLProgram.t option -> GLboolean.t [@@js.call "isProgram"]
  val isRenderbuffer: 'tags this -> renderbuffer:WebGLRenderbuffer.t option -> GLboolean.t [@@js.call "isRenderbuffer"]
  val isShader: 'tags this -> shader:WebGLShader.t option -> GLboolean.t [@@js.call "isShader"]
  val isTexture: 'tags this -> texture:WebGLTexture.t option -> GLboolean.t [@@js.call "isTexture"]
  val lineWidth: 'tags this -> width:GLfloat.t -> unit [@@js.call "lineWidth"]
  val linkProgram: 'tags this -> program:WebGLProgram.t -> unit [@@js.call "linkProgram"]
  val pixelStorei: 'tags this -> pname:GLenum.t -> param:([`U1 of GLint.t | `U2 of GLboolean.t] [@js.union]) -> unit [@@js.call "pixelStorei"]
  val polygonOffset: 'tags this -> factor:GLfloat.t -> units:GLfloat.t -> unit [@@js.call "polygonOffset"]
  val renderbufferStorage: 'tags this -> target:GLenum.t -> internalformat:GLenum.t -> width:GLsizei.t -> height:GLsizei.t -> unit [@@js.call "renderbufferStorage"]
  val sampleCoverage: 'tags this -> value:GLclampf.t -> invert:GLboolean.t -> unit [@@js.call "sampleCoverage"]
  val scissor: 'tags this -> x:GLint.t -> y:GLint.t -> width:GLsizei.t -> height:GLsizei.t -> unit [@@js.call "scissor"]
  val shaderSource: 'tags this -> shader:WebGLShader.t -> source:string -> unit [@@js.call "shaderSource"]
  val stencilFunc: 'tags this -> func:GLenum.t -> ref:GLint.t -> mask:GLuint.t -> unit [@@js.call "stencilFunc"]
  val stencilFuncSeparate: 'tags this -> face:GLenum.t -> func:GLenum.t -> ref:GLint.t -> mask:GLuint.t -> unit [@@js.call "stencilFuncSeparate"]
  val stencilMask: 'tags this -> mask:GLuint.t -> unit [@@js.call "stencilMask"]
  val stencilMaskSeparate: 'tags this -> face:GLenum.t -> mask:GLuint.t -> unit [@@js.call "stencilMaskSeparate"]
  val stencilOp: 'tags this -> fail:GLenum.t -> zfail:GLenum.t -> zpass:GLenum.t -> unit [@@js.call "stencilOp"]
  val stencilOpSeparate: 'tags this -> face:GLenum.t -> fail:GLenum.t -> zfail:GLenum.t -> zpass:GLenum.t -> unit [@@js.call "stencilOpSeparate"]
  val texParameterf: 'tags this -> target:GLenum.t -> pname:GLenum.t -> param:GLfloat.t -> unit [@@js.call "texParameterf"]
  val texParameteri: 'tags this -> target:GLenum.t -> pname:GLenum.t -> param:GLint.t -> unit [@@js.call "texParameteri"]
  val uniform1f: 'tags this -> location:WebGLUniformLocation.t option -> x:GLfloat.t -> unit [@@js.call "uniform1f"]
  val uniform1i: 'tags this -> location:WebGLUniformLocation.t option -> x:GLint.t -> unit [@@js.call "uniform1i"]
  val uniform2f: 'tags this -> location:WebGLUniformLocation.t option -> x:GLfloat.t -> y:GLfloat.t -> unit [@@js.call "uniform2f"]
  val uniform2i: 'tags this -> location:WebGLUniformLocation.t option -> x:GLint.t -> y:GLint.t -> unit [@@js.call "uniform2i"]
  val uniform3f: 'tags this -> location:WebGLUniformLocation.t option -> x:GLfloat.t -> y:GLfloat.t -> z:GLfloat.t -> unit [@@js.call "uniform3f"]
  val uniform3i: 'tags this -> location:WebGLUniformLocation.t option -> x:GLint.t -> y:GLint.t -> z:GLint.t -> unit [@@js.call "uniform3i"]
  val uniform4f: 'tags this -> location:WebGLUniformLocation.t option -> x:GLfloat.t -> y:GLfloat.t -> z:GLfloat.t -> w:GLfloat.t -> unit [@@js.call "uniform4f"]
  val uniform4i: 'tags this -> location:WebGLUniformLocation.t option -> x:GLint.t -> y:GLint.t -> z:GLint.t -> w:GLint.t -> unit [@@js.call "uniform4i"]
  val useProgram: 'tags this -> program:WebGLProgram.t option -> unit [@@js.call "useProgram"]
  val validateProgram: 'tags this -> program:WebGLProgram.t -> unit [@@js.call "validateProgram"]
  val vertexAttrib1f: 'tags this -> index:GLuint.t -> x:GLfloat.t -> unit [@@js.call "vertexAttrib1f"]
  val vertexAttrib1fv': 'tags this -> index:GLuint.t -> values:Float32List.t -> unit [@@js.call "vertexAttrib1fv"]
  val vertexAttrib2f: 'tags this -> index:GLuint.t -> x:GLfloat.t -> y:GLfloat.t -> unit [@@js.call "vertexAttrib2f"]
  val vertexAttrib2fv': 'tags this -> index:GLuint.t -> values:Float32List.t -> unit [@@js.call "vertexAttrib2fv"]
  val vertexAttrib3f: 'tags this -> index:GLuint.t -> x:GLfloat.t -> y:GLfloat.t -> z:GLfloat.t -> unit [@@js.call "vertexAttrib3f"]
  val vertexAttrib3fv': 'tags this -> index:GLuint.t -> values:Float32List.t -> unit [@@js.call "vertexAttrib3fv"]
  val vertexAttrib4f: 'tags this -> index:GLuint.t -> x:GLfloat.t -> y:GLfloat.t -> z:GLfloat.t -> w:GLfloat.t -> unit [@@js.call "vertexAttrib4f"]
  val vertexAttrib4fv': 'tags this -> index:GLuint.t -> values:Float32List.t -> unit [@@js.call "vertexAttrib4fv"]
  val vertexAttribPointer: 'tags this -> index:GLuint.t -> size:GLint.t -> type_:GLenum.t -> normalized:GLboolean.t -> stride:GLsizei.t -> offset:GLintptr.t -> unit [@@js.call "vertexAttribPointer"]
  val viewport: 'tags this -> x:GLint.t -> y:GLint.t -> width:GLsizei.t -> height:GLsizei.t -> unit [@@js.call "viewport"]
  val get_ACTIVE_ATTRIBUTES: 'tags this -> GLenum.t [@@js.get "ACTIVE_ATTRIBUTES"]
  val get_ACTIVE_TEXTURE: 'tags this -> GLenum.t [@@js.get "ACTIVE_TEXTURE"]
  val get_ACTIVE_UNIFORMS: 'tags this -> GLenum.t [@@js.get "ACTIVE_UNIFORMS"]
  val get_ALIASED_LINE_WIDTH_RANGE: 'tags this -> GLenum.t [@@js.get "ALIASED_LINE_WIDTH_RANGE"]
  val get_ALIASED_POINT_SIZE_RANGE: 'tags this -> GLenum.t [@@js.get "ALIASED_POINT_SIZE_RANGE"]
  val get_ALPHA: 'tags this -> GLenum.t [@@js.get "ALPHA"]
  val get_ALPHA_BITS: 'tags this -> GLenum.t [@@js.get "ALPHA_BITS"]
  val get_ALWAYS: 'tags this -> GLenum.t [@@js.get "ALWAYS"]
  val get_ARRAY_BUFFER: 'tags this -> GLenum.t [@@js.get "ARRAY_BUFFER"]
  val get_ARRAY_BUFFER_BINDING: 'tags this -> GLenum.t [@@js.get "ARRAY_BUFFER_BINDING"]
  val get_ATTACHED_SHADERS: 'tags this -> GLenum.t [@@js.get "ATTACHED_SHADERS"]
  val get_BACK: 'tags this -> GLenum.t [@@js.get "BACK"]
  val get_BLEND: 'tags this -> GLenum.t [@@js.get "BLEND"]
  val get_BLEND_COLOR: 'tags this -> GLenum.t [@@js.get "BLEND_COLOR"]
  val get_BLEND_DST_ALPHA: 'tags this -> GLenum.t [@@js.get "BLEND_DST_ALPHA"]
  val get_BLEND_DST_RGB: 'tags this -> GLenum.t [@@js.get "BLEND_DST_RGB"]
  val get_BLEND_EQUATION: 'tags this -> GLenum.t [@@js.get "BLEND_EQUATION"]
  val get_BLEND_EQUATION_ALPHA: 'tags this -> GLenum.t [@@js.get "BLEND_EQUATION_ALPHA"]
  val get_BLEND_EQUATION_RGB: 'tags this -> GLenum.t [@@js.get "BLEND_EQUATION_RGB"]
  val get_BLEND_SRC_ALPHA: 'tags this -> GLenum.t [@@js.get "BLEND_SRC_ALPHA"]
  val get_BLEND_SRC_RGB: 'tags this -> GLenum.t [@@js.get "BLEND_SRC_RGB"]
  val get_BLUE_BITS: 'tags this -> GLenum.t [@@js.get "BLUE_BITS"]
  val get_BOOL: 'tags this -> GLenum.t [@@js.get "BOOL"]
  val get_BOOL_VEC2: 'tags this -> GLenum.t [@@js.get "BOOL_VEC2"]
  val get_BOOL_VEC3: 'tags this -> GLenum.t [@@js.get "BOOL_VEC3"]
  val get_BOOL_VEC4: 'tags this -> GLenum.t [@@js.get "BOOL_VEC4"]
  val get_BROWSER_DEFAULT_WEBGL: 'tags this -> GLenum.t [@@js.get "BROWSER_DEFAULT_WEBGL"]
  val get_BUFFER_SIZE: 'tags this -> GLenum.t [@@js.get "BUFFER_SIZE"]
  val get_BUFFER_USAGE: 'tags this -> GLenum.t [@@js.get "BUFFER_USAGE"]
  val get_BYTE: 'tags this -> GLenum.t [@@js.get "BYTE"]
  val get_CCW: 'tags this -> GLenum.t [@@js.get "CCW"]
  val get_CLAMP_TO_EDGE: 'tags this -> GLenum.t [@@js.get "CLAMP_TO_EDGE"]
  val get_COLOR_ATTACHMENT0: 'tags this -> GLenum.t [@@js.get "COLOR_ATTACHMENT0"]
  val get_COLOR_BUFFER_BIT: 'tags this -> GLenum.t [@@js.get "COLOR_BUFFER_BIT"]
  val get_COLOR_CLEAR_VALUE: 'tags this -> GLenum.t [@@js.get "COLOR_CLEAR_VALUE"]
  val get_COLOR_WRITEMASK: 'tags this -> GLenum.t [@@js.get "COLOR_WRITEMASK"]
  val get_COMPILE_STATUS: 'tags this -> GLenum.t [@@js.get "COMPILE_STATUS"]
  val get_COMPRESSED_TEXTURE_FORMATS: 'tags this -> GLenum.t [@@js.get "COMPRESSED_TEXTURE_FORMATS"]
  val get_CONSTANT_ALPHA: 'tags this -> GLenum.t [@@js.get "CONSTANT_ALPHA"]
  val get_CONSTANT_COLOR: 'tags this -> GLenum.t [@@js.get "CONSTANT_COLOR"]
  val get_CONTEXT_LOST_WEBGL: 'tags this -> GLenum.t [@@js.get "CONTEXT_LOST_WEBGL"]
  val get_CULL_FACE: 'tags this -> GLenum.t [@@js.get "CULL_FACE"]
  val get_CULL_FACE_MODE: 'tags this -> GLenum.t [@@js.get "CULL_FACE_MODE"]
  val get_CURRENT_PROGRAM: 'tags this -> GLenum.t [@@js.get "CURRENT_PROGRAM"]
  val get_CURRENT_VERTEX_ATTRIB: 'tags this -> GLenum.t [@@js.get "CURRENT_VERTEX_ATTRIB"]
  val get_CW: 'tags this -> GLenum.t [@@js.get "CW"]
  val get_DECR: 'tags this -> GLenum.t [@@js.get "DECR"]
  val get_DECR_WRAP: 'tags this -> GLenum.t [@@js.get "DECR_WRAP"]
  val get_DELETE_STATUS: 'tags this -> GLenum.t [@@js.get "DELETE_STATUS"]
  val get_DEPTH_ATTACHMENT: 'tags this -> GLenum.t [@@js.get "DEPTH_ATTACHMENT"]
  val get_DEPTH_BITS: 'tags this -> GLenum.t [@@js.get "DEPTH_BITS"]
  val get_DEPTH_BUFFER_BIT: 'tags this -> GLenum.t [@@js.get "DEPTH_BUFFER_BIT"]
  val get_DEPTH_CLEAR_VALUE: 'tags this -> GLenum.t [@@js.get "DEPTH_CLEAR_VALUE"]
  val get_DEPTH_COMPONENT: 'tags this -> GLenum.t [@@js.get "DEPTH_COMPONENT"]
  val get_DEPTH_COMPONENT16: 'tags this -> GLenum.t [@@js.get "DEPTH_COMPONENT16"]
  val get_DEPTH_FUNC: 'tags this -> GLenum.t [@@js.get "DEPTH_FUNC"]
  val get_DEPTH_RANGE: 'tags this -> GLenum.t [@@js.get "DEPTH_RANGE"]
  val get_DEPTH_STENCIL: 'tags this -> GLenum.t [@@js.get "DEPTH_STENCIL"]
  val get_DEPTH_STENCIL_ATTACHMENT: 'tags this -> GLenum.t [@@js.get "DEPTH_STENCIL_ATTACHMENT"]
  val get_DEPTH_TEST: 'tags this -> GLenum.t [@@js.get "DEPTH_TEST"]
  val get_DEPTH_WRITEMASK: 'tags this -> GLenum.t [@@js.get "DEPTH_WRITEMASK"]
  val get_DITHER: 'tags this -> GLenum.t [@@js.get "DITHER"]
  val get_DONT_CARE: 'tags this -> GLenum.t [@@js.get "DONT_CARE"]
  val get_DST_ALPHA: 'tags this -> GLenum.t [@@js.get "DST_ALPHA"]
  val get_DST_COLOR: 'tags this -> GLenum.t [@@js.get "DST_COLOR"]
  val get_DYNAMIC_DRAW: 'tags this -> GLenum.t [@@js.get "DYNAMIC_DRAW"]
  val get_ELEMENT_ARRAY_BUFFER: 'tags this -> GLenum.t [@@js.get "ELEMENT_ARRAY_BUFFER"]
  val get_ELEMENT_ARRAY_BUFFER_BINDING: 'tags this -> GLenum.t [@@js.get "ELEMENT_ARRAY_BUFFER_BINDING"]
  val get_EQUAL: 'tags this -> GLenum.t [@@js.get "EQUAL"]
  val get_FASTEST: 'tags this -> GLenum.t [@@js.get "FASTEST"]
  val get_FLOAT: 'tags this -> GLenum.t [@@js.get "FLOAT"]
  val get_FLOAT_MAT2: 'tags this -> GLenum.t [@@js.get "FLOAT_MAT2"]
  val get_FLOAT_MAT3: 'tags this -> GLenum.t [@@js.get "FLOAT_MAT3"]
  val get_FLOAT_MAT4: 'tags this -> GLenum.t [@@js.get "FLOAT_MAT4"]
  val get_FLOAT_VEC2: 'tags this -> GLenum.t [@@js.get "FLOAT_VEC2"]
  val get_FLOAT_VEC3: 'tags this -> GLenum.t [@@js.get "FLOAT_VEC3"]
  val get_FLOAT_VEC4: 'tags this -> GLenum.t [@@js.get "FLOAT_VEC4"]
  val get_FRAGMENT_SHADER: 'tags this -> GLenum.t [@@js.get "FRAGMENT_SHADER"]
  val get_FRAMEBUFFER: 'tags this -> GLenum.t [@@js.get "FRAMEBUFFER"]
  val get_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: 'tags this -> GLenum.t [@@js.get "FRAMEBUFFER_ATTACHMENT_OBJECT_NAME"]
  val get_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: 'tags this -> GLenum.t [@@js.get "FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE"]
  val get_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: 'tags this -> GLenum.t [@@js.get "FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE"]
  val get_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: 'tags this -> GLenum.t [@@js.get "FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL"]
  val get_FRAMEBUFFER_BINDING: 'tags this -> GLenum.t [@@js.get "FRAMEBUFFER_BINDING"]
  val get_FRAMEBUFFER_COMPLETE: 'tags this -> GLenum.t [@@js.get "FRAMEBUFFER_COMPLETE"]
  val get_FRAMEBUFFER_INCOMPLETE_ATTACHMENT: 'tags this -> GLenum.t [@@js.get "FRAMEBUFFER_INCOMPLETE_ATTACHMENT"]
  val get_FRAMEBUFFER_INCOMPLETE_DIMENSIONS: 'tags this -> GLenum.t [@@js.get "FRAMEBUFFER_INCOMPLETE_DIMENSIONS"]
  val get_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: 'tags this -> GLenum.t [@@js.get "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT"]
  val get_FRAMEBUFFER_UNSUPPORTED: 'tags this -> GLenum.t [@@js.get "FRAMEBUFFER_UNSUPPORTED"]
  val get_FRONT: 'tags this -> GLenum.t [@@js.get "FRONT"]
  val get_FRONT_AND_BACK: 'tags this -> GLenum.t [@@js.get "FRONT_AND_BACK"]
  val get_FRONT_FACE: 'tags this -> GLenum.t [@@js.get "FRONT_FACE"]
  val get_FUNC_ADD: 'tags this -> GLenum.t [@@js.get "FUNC_ADD"]
  val get_FUNC_REVERSE_SUBTRACT: 'tags this -> GLenum.t [@@js.get "FUNC_REVERSE_SUBTRACT"]
  val get_FUNC_SUBTRACT: 'tags this -> GLenum.t [@@js.get "FUNC_SUBTRACT"]
  val get_GENERATE_MIPMAP_HINT: 'tags this -> GLenum.t [@@js.get "GENERATE_MIPMAP_HINT"]
  val get_GEQUAL: 'tags this -> GLenum.t [@@js.get "GEQUAL"]
  val get_GREATER: 'tags this -> GLenum.t [@@js.get "GREATER"]
  val get_GREEN_BITS: 'tags this -> GLenum.t [@@js.get "GREEN_BITS"]
  val get_HIGH_FLOAT: 'tags this -> GLenum.t [@@js.get "HIGH_FLOAT"]
  val get_HIGH_INT: 'tags this -> GLenum.t [@@js.get "HIGH_INT"]
  val get_IMPLEMENTATION_COLOR_READ_FORMAT: 'tags this -> GLenum.t [@@js.get "IMPLEMENTATION_COLOR_READ_FORMAT"]
  val get_IMPLEMENTATION_COLOR_READ_TYPE: 'tags this -> GLenum.t [@@js.get "IMPLEMENTATION_COLOR_READ_TYPE"]
  val get_INCR: 'tags this -> GLenum.t [@@js.get "INCR"]
  val get_INCR_WRAP: 'tags this -> GLenum.t [@@js.get "INCR_WRAP"]
  val get_INT: 'tags this -> GLenum.t [@@js.get "INT"]
  val get_INT_VEC2: 'tags this -> GLenum.t [@@js.get "INT_VEC2"]
  val get_INT_VEC3: 'tags this -> GLenum.t [@@js.get "INT_VEC3"]
  val get_INT_VEC4: 'tags this -> GLenum.t [@@js.get "INT_VEC4"]
  val get_INVALID_ENUM: 'tags this -> GLenum.t [@@js.get "INVALID_ENUM"]
  val get_INVALID_FRAMEBUFFER_OPERATION: 'tags this -> GLenum.t [@@js.get "INVALID_FRAMEBUFFER_OPERATION"]
  val get_INVALID_OPERATION: 'tags this -> GLenum.t [@@js.get "INVALID_OPERATION"]
  val get_INVALID_VALUE: 'tags this -> GLenum.t [@@js.get "INVALID_VALUE"]
  val get_INVERT: 'tags this -> GLenum.t [@@js.get "INVERT"]
  val get_KEEP: 'tags this -> GLenum.t [@@js.get "KEEP"]
  val get_LEQUAL: 'tags this -> GLenum.t [@@js.get "LEQUAL"]
  val get_LESS: 'tags this -> GLenum.t [@@js.get "LESS"]
  val get_LINEAR: 'tags this -> GLenum.t [@@js.get "LINEAR"]
  val get_LINEAR_MIPMAP_LINEAR: 'tags this -> GLenum.t [@@js.get "LINEAR_MIPMAP_LINEAR"]
  val get_LINEAR_MIPMAP_NEAREST: 'tags this -> GLenum.t [@@js.get "LINEAR_MIPMAP_NEAREST"]
  val get_LINES: 'tags this -> GLenum.t [@@js.get "LINES"]
  val get_LINE_LOOP: 'tags this -> GLenum.t [@@js.get "LINE_LOOP"]
  val get_LINE_STRIP: 'tags this -> GLenum.t [@@js.get "LINE_STRIP"]
  val get_LINE_WIDTH: 'tags this -> GLenum.t [@@js.get "LINE_WIDTH"]
  val get_LINK_STATUS: 'tags this -> GLenum.t [@@js.get "LINK_STATUS"]
  val get_LOW_FLOAT: 'tags this -> GLenum.t [@@js.get "LOW_FLOAT"]
  val get_LOW_INT: 'tags this -> GLenum.t [@@js.get "LOW_INT"]
  val get_LUMINANCE: 'tags this -> GLenum.t [@@js.get "LUMINANCE"]
  val get_LUMINANCE_ALPHA: 'tags this -> GLenum.t [@@js.get "LUMINANCE_ALPHA"]
  val get_MAX_COMBINED_TEXTURE_IMAGE_UNITS: 'tags this -> GLenum.t [@@js.get "MAX_COMBINED_TEXTURE_IMAGE_UNITS"]
  val get_MAX_CUBE_MAP_TEXTURE_SIZE: 'tags this -> GLenum.t [@@js.get "MAX_CUBE_MAP_TEXTURE_SIZE"]
  val get_MAX_FRAGMENT_UNIFORM_VECTORS: 'tags this -> GLenum.t [@@js.get "MAX_FRAGMENT_UNIFORM_VECTORS"]
  val get_MAX_RENDERBUFFER_SIZE: 'tags this -> GLenum.t [@@js.get "MAX_RENDERBUFFER_SIZE"]
  val get_MAX_TEXTURE_IMAGE_UNITS: 'tags this -> GLenum.t [@@js.get "MAX_TEXTURE_IMAGE_UNITS"]
  val get_MAX_TEXTURE_SIZE: 'tags this -> GLenum.t [@@js.get "MAX_TEXTURE_SIZE"]
  val get_MAX_VARYING_VECTORS: 'tags this -> GLenum.t [@@js.get "MAX_VARYING_VECTORS"]
  val get_MAX_VERTEX_ATTRIBS: 'tags this -> GLenum.t [@@js.get "MAX_VERTEX_ATTRIBS"]
  val get_MAX_VERTEX_TEXTURE_IMAGE_UNITS: 'tags this -> GLenum.t [@@js.get "MAX_VERTEX_TEXTURE_IMAGE_UNITS"]
  val get_MAX_VERTEX_UNIFORM_VECTORS: 'tags this -> GLenum.t [@@js.get "MAX_VERTEX_UNIFORM_VECTORS"]
  val get_MAX_VIEWPORT_DIMS: 'tags this -> GLenum.t [@@js.get "MAX_VIEWPORT_DIMS"]
  val get_MEDIUM_FLOAT: 'tags this -> GLenum.t [@@js.get "MEDIUM_FLOAT"]
  val get_MEDIUM_INT: 'tags this -> GLenum.t [@@js.get "MEDIUM_INT"]
  val get_MIRRORED_REPEAT: 'tags this -> GLenum.t [@@js.get "MIRRORED_REPEAT"]
  val get_NEAREST: 'tags this -> GLenum.t [@@js.get "NEAREST"]
  val get_NEAREST_MIPMAP_LINEAR: 'tags this -> GLenum.t [@@js.get "NEAREST_MIPMAP_LINEAR"]
  val get_NEAREST_MIPMAP_NEAREST: 'tags this -> GLenum.t [@@js.get "NEAREST_MIPMAP_NEAREST"]
  val get_NEVER: 'tags this -> GLenum.t [@@js.get "NEVER"]
  val get_NICEST: 'tags this -> GLenum.t [@@js.get "NICEST"]
  val get_NONE: 'tags this -> GLenum.t [@@js.get "NONE"]
  val get_NOTEQUAL: 'tags this -> GLenum.t [@@js.get "NOTEQUAL"]
  val get_NO_ERROR: 'tags this -> GLenum.t [@@js.get "NO_ERROR"]
  val get_ONE: 'tags this -> GLenum.t [@@js.get "ONE"]
  val get_ONE_MINUS_CONSTANT_ALPHA: 'tags this -> GLenum.t [@@js.get "ONE_MINUS_CONSTANT_ALPHA"]
  val get_ONE_MINUS_CONSTANT_COLOR: 'tags this -> GLenum.t [@@js.get "ONE_MINUS_CONSTANT_COLOR"]
  val get_ONE_MINUS_DST_ALPHA: 'tags this -> GLenum.t [@@js.get "ONE_MINUS_DST_ALPHA"]
  val get_ONE_MINUS_DST_COLOR: 'tags this -> GLenum.t [@@js.get "ONE_MINUS_DST_COLOR"]
  val get_ONE_MINUS_SRC_ALPHA: 'tags this -> GLenum.t [@@js.get "ONE_MINUS_SRC_ALPHA"]
  val get_ONE_MINUS_SRC_COLOR: 'tags this -> GLenum.t [@@js.get "ONE_MINUS_SRC_COLOR"]
  val get_OUT_OF_MEMORY: 'tags this -> GLenum.t [@@js.get "OUT_OF_MEMORY"]
  val get_PACK_ALIGNMENT: 'tags this -> GLenum.t [@@js.get "PACK_ALIGNMENT"]
  val get_POINTS: 'tags this -> GLenum.t [@@js.get "POINTS"]
  val get_POLYGON_OFFSET_FACTOR: 'tags this -> GLenum.t [@@js.get "POLYGON_OFFSET_FACTOR"]
  val get_POLYGON_OFFSET_FILL: 'tags this -> GLenum.t [@@js.get "POLYGON_OFFSET_FILL"]
  val get_POLYGON_OFFSET_UNITS: 'tags this -> GLenum.t [@@js.get "POLYGON_OFFSET_UNITS"]
  val get_RED_BITS: 'tags this -> GLenum.t [@@js.get "RED_BITS"]
  val get_RENDERBUFFER: 'tags this -> GLenum.t [@@js.get "RENDERBUFFER"]
  val get_RENDERBUFFER_ALPHA_SIZE: 'tags this -> GLenum.t [@@js.get "RENDERBUFFER_ALPHA_SIZE"]
  val get_RENDERBUFFER_BINDING: 'tags this -> GLenum.t [@@js.get "RENDERBUFFER_BINDING"]
  val get_RENDERBUFFER_BLUE_SIZE: 'tags this -> GLenum.t [@@js.get "RENDERBUFFER_BLUE_SIZE"]
  val get_RENDERBUFFER_DEPTH_SIZE: 'tags this -> GLenum.t [@@js.get "RENDERBUFFER_DEPTH_SIZE"]
  val get_RENDERBUFFER_GREEN_SIZE: 'tags this -> GLenum.t [@@js.get "RENDERBUFFER_GREEN_SIZE"]
  val get_RENDERBUFFER_HEIGHT: 'tags this -> GLenum.t [@@js.get "RENDERBUFFER_HEIGHT"]
  val get_RENDERBUFFER_INTERNAL_FORMAT: 'tags this -> GLenum.t [@@js.get "RENDERBUFFER_INTERNAL_FORMAT"]
  val get_RENDERBUFFER_RED_SIZE: 'tags this -> GLenum.t [@@js.get "RENDERBUFFER_RED_SIZE"]
  val get_RENDERBUFFER_STENCIL_SIZE: 'tags this -> GLenum.t [@@js.get "RENDERBUFFER_STENCIL_SIZE"]
  val get_RENDERBUFFER_WIDTH: 'tags this -> GLenum.t [@@js.get "RENDERBUFFER_WIDTH"]
  val get_RENDERER: 'tags this -> GLenum.t [@@js.get "RENDERER"]
  val get_REPEAT: 'tags this -> GLenum.t [@@js.get "REPEAT"]
  val get_REPLACE: 'tags this -> GLenum.t [@@js.get "REPLACE"]
  val get_RGB: 'tags this -> GLenum.t [@@js.get "RGB"]
  val get_RGB565: 'tags this -> GLenum.t [@@js.get "RGB565"]
  val get_RGB5_A1: 'tags this -> GLenum.t [@@js.get "RGB5_A1"]
  val get_RGBA: 'tags this -> GLenum.t [@@js.get "RGBA"]
  val get_RGBA4: 'tags this -> GLenum.t [@@js.get "RGBA4"]
  val get_SAMPLER_2D: 'tags this -> GLenum.t [@@js.get "SAMPLER_2D"]
  val get_SAMPLER_CUBE: 'tags this -> GLenum.t [@@js.get "SAMPLER_CUBE"]
  val get_SAMPLES: 'tags this -> GLenum.t [@@js.get "SAMPLES"]
  val get_SAMPLE_ALPHA_TO_COVERAGE: 'tags this -> GLenum.t [@@js.get "SAMPLE_ALPHA_TO_COVERAGE"]
  val get_SAMPLE_BUFFERS: 'tags this -> GLenum.t [@@js.get "SAMPLE_BUFFERS"]
  val get_SAMPLE_COVERAGE: 'tags this -> GLenum.t [@@js.get "SAMPLE_COVERAGE"]
  val get_SAMPLE_COVERAGE_INVERT: 'tags this -> GLenum.t [@@js.get "SAMPLE_COVERAGE_INVERT"]
  val get_SAMPLE_COVERAGE_VALUE: 'tags this -> GLenum.t [@@js.get "SAMPLE_COVERAGE_VALUE"]
  val get_SCISSOR_BOX: 'tags this -> GLenum.t [@@js.get "SCISSOR_BOX"]
  val get_SCISSOR_TEST: 'tags this -> GLenum.t [@@js.get "SCISSOR_TEST"]
  val get_SHADER_TYPE: 'tags this -> GLenum.t [@@js.get "SHADER_TYPE"]
  val get_SHADING_LANGUAGE_VERSION: 'tags this -> GLenum.t [@@js.get "SHADING_LANGUAGE_VERSION"]
  val get_SHORT: 'tags this -> GLenum.t [@@js.get "SHORT"]
  val get_SRC_ALPHA: 'tags this -> GLenum.t [@@js.get "SRC_ALPHA"]
  val get_SRC_ALPHA_SATURATE: 'tags this -> GLenum.t [@@js.get "SRC_ALPHA_SATURATE"]
  val get_SRC_COLOR: 'tags this -> GLenum.t [@@js.get "SRC_COLOR"]
  val get_STATIC_DRAW: 'tags this -> GLenum.t [@@js.get "STATIC_DRAW"]
  val get_STENCIL_ATTACHMENT: 'tags this -> GLenum.t [@@js.get "STENCIL_ATTACHMENT"]
  val get_STENCIL_BACK_FAIL: 'tags this -> GLenum.t [@@js.get "STENCIL_BACK_FAIL"]
  val get_STENCIL_BACK_FUNC: 'tags this -> GLenum.t [@@js.get "STENCIL_BACK_FUNC"]
  val get_STENCIL_BACK_PASS_DEPTH_FAIL: 'tags this -> GLenum.t [@@js.get "STENCIL_BACK_PASS_DEPTH_FAIL"]
  val get_STENCIL_BACK_PASS_DEPTH_PASS: 'tags this -> GLenum.t [@@js.get "STENCIL_BACK_PASS_DEPTH_PASS"]
  val get_STENCIL_BACK_REF: 'tags this -> GLenum.t [@@js.get "STENCIL_BACK_REF"]
  val get_STENCIL_BACK_VALUE_MASK: 'tags this -> GLenum.t [@@js.get "STENCIL_BACK_VALUE_MASK"]
  val get_STENCIL_BACK_WRITEMASK: 'tags this -> GLenum.t [@@js.get "STENCIL_BACK_WRITEMASK"]
  val get_STENCIL_BITS: 'tags this -> GLenum.t [@@js.get "STENCIL_BITS"]
  val get_STENCIL_BUFFER_BIT: 'tags this -> GLenum.t [@@js.get "STENCIL_BUFFER_BIT"]
  val get_STENCIL_CLEAR_VALUE: 'tags this -> GLenum.t [@@js.get "STENCIL_CLEAR_VALUE"]
  val get_STENCIL_FAIL: 'tags this -> GLenum.t [@@js.get "STENCIL_FAIL"]
  val get_STENCIL_FUNC: 'tags this -> GLenum.t [@@js.get "STENCIL_FUNC"]
  val get_STENCIL_INDEX8: 'tags this -> GLenum.t [@@js.get "STENCIL_INDEX8"]
  val get_STENCIL_PASS_DEPTH_FAIL: 'tags this -> GLenum.t [@@js.get "STENCIL_PASS_DEPTH_FAIL"]
  val get_STENCIL_PASS_DEPTH_PASS: 'tags this -> GLenum.t [@@js.get "STENCIL_PASS_DEPTH_PASS"]
  val get_STENCIL_REF: 'tags this -> GLenum.t [@@js.get "STENCIL_REF"]
  val get_STENCIL_TEST: 'tags this -> GLenum.t [@@js.get "STENCIL_TEST"]
  val get_STENCIL_VALUE_MASK: 'tags this -> GLenum.t [@@js.get "STENCIL_VALUE_MASK"]
  val get_STENCIL_WRITEMASK: 'tags this -> GLenum.t [@@js.get "STENCIL_WRITEMASK"]
  val get_STREAM_DRAW: 'tags this -> GLenum.t [@@js.get "STREAM_DRAW"]
  val get_SUBPIXEL_BITS: 'tags this -> GLenum.t [@@js.get "SUBPIXEL_BITS"]
  val get_TEXTURE: 'tags this -> GLenum.t [@@js.get "TEXTURE"]
  val get_TEXTURE0: 'tags this -> GLenum.t [@@js.get "TEXTURE0"]
  val get_TEXTURE1: 'tags this -> GLenum.t [@@js.get "TEXTURE1"]
  val get_TEXTURE10: 'tags this -> GLenum.t [@@js.get "TEXTURE10"]
  val get_TEXTURE11: 'tags this -> GLenum.t [@@js.get "TEXTURE11"]
  val get_TEXTURE12: 'tags this -> GLenum.t [@@js.get "TEXTURE12"]
  val get_TEXTURE13: 'tags this -> GLenum.t [@@js.get "TEXTURE13"]
  val get_TEXTURE14: 'tags this -> GLenum.t [@@js.get "TEXTURE14"]
  val get_TEXTURE15: 'tags this -> GLenum.t [@@js.get "TEXTURE15"]
  val get_TEXTURE16: 'tags this -> GLenum.t [@@js.get "TEXTURE16"]
  val get_TEXTURE17: 'tags this -> GLenum.t [@@js.get "TEXTURE17"]
  val get_TEXTURE18: 'tags this -> GLenum.t [@@js.get "TEXTURE18"]
  val get_TEXTURE19: 'tags this -> GLenum.t [@@js.get "TEXTURE19"]
  val get_TEXTURE2: 'tags this -> GLenum.t [@@js.get "TEXTURE2"]
  val get_TEXTURE20: 'tags this -> GLenum.t [@@js.get "TEXTURE20"]
  val get_TEXTURE21: 'tags this -> GLenum.t [@@js.get "TEXTURE21"]
  val get_TEXTURE22: 'tags this -> GLenum.t [@@js.get "TEXTURE22"]
  val get_TEXTURE23: 'tags this -> GLenum.t [@@js.get "TEXTURE23"]
  val get_TEXTURE24: 'tags this -> GLenum.t [@@js.get "TEXTURE24"]
  val get_TEXTURE25: 'tags this -> GLenum.t [@@js.get "TEXTURE25"]
  val get_TEXTURE26: 'tags this -> GLenum.t [@@js.get "TEXTURE26"]
  val get_TEXTURE27: 'tags this -> GLenum.t [@@js.get "TEXTURE27"]
  val get_TEXTURE28: 'tags this -> GLenum.t [@@js.get "TEXTURE28"]
  val get_TEXTURE29: 'tags this -> GLenum.t [@@js.get "TEXTURE29"]
  val get_TEXTURE3: 'tags this -> GLenum.t [@@js.get "TEXTURE3"]
  val get_TEXTURE30: 'tags this -> GLenum.t [@@js.get "TEXTURE30"]
  val get_TEXTURE31: 'tags this -> GLenum.t [@@js.get "TEXTURE31"]
  val get_TEXTURE4: 'tags this -> GLenum.t [@@js.get "TEXTURE4"]
  val get_TEXTURE5: 'tags this -> GLenum.t [@@js.get "TEXTURE5"]
  val get_TEXTURE6: 'tags this -> GLenum.t [@@js.get "TEXTURE6"]
  val get_TEXTURE7: 'tags this -> GLenum.t [@@js.get "TEXTURE7"]
  val get_TEXTURE8: 'tags this -> GLenum.t [@@js.get "TEXTURE8"]
  val get_TEXTURE9: 'tags this -> GLenum.t [@@js.get "TEXTURE9"]
  val get_TEXTURE_2D: 'tags this -> GLenum.t [@@js.get "TEXTURE_2D"]
  val get_TEXTURE_BINDING_2D: 'tags this -> GLenum.t [@@js.get "TEXTURE_BINDING_2D"]
  val get_TEXTURE_BINDING_CUBE_MAP: 'tags this -> GLenum.t [@@js.get "TEXTURE_BINDING_CUBE_MAP"]
  val get_TEXTURE_CUBE_MAP: 'tags this -> GLenum.t [@@js.get "TEXTURE_CUBE_MAP"]
  val get_TEXTURE_CUBE_MAP_NEGATIVE_X: 'tags this -> GLenum.t [@@js.get "TEXTURE_CUBE_MAP_NEGATIVE_X"]
  val get_TEXTURE_CUBE_MAP_NEGATIVE_Y: 'tags this -> GLenum.t [@@js.get "TEXTURE_CUBE_MAP_NEGATIVE_Y"]
  val get_TEXTURE_CUBE_MAP_NEGATIVE_Z: 'tags this -> GLenum.t [@@js.get "TEXTURE_CUBE_MAP_NEGATIVE_Z"]
  val get_TEXTURE_CUBE_MAP_POSITIVE_X: 'tags this -> GLenum.t [@@js.get "TEXTURE_CUBE_MAP_POSITIVE_X"]
  val get_TEXTURE_CUBE_MAP_POSITIVE_Y: 'tags this -> GLenum.t [@@js.get "TEXTURE_CUBE_MAP_POSITIVE_Y"]
  val get_TEXTURE_CUBE_MAP_POSITIVE_Z: 'tags this -> GLenum.t [@@js.get "TEXTURE_CUBE_MAP_POSITIVE_Z"]
  val get_TEXTURE_MAG_FILTER: 'tags this -> GLenum.t [@@js.get "TEXTURE_MAG_FILTER"]
  val get_TEXTURE_MIN_FILTER: 'tags this -> GLenum.t [@@js.get "TEXTURE_MIN_FILTER"]
  val get_TEXTURE_WRAP_S: 'tags this -> GLenum.t [@@js.get "TEXTURE_WRAP_S"]
  val get_TEXTURE_WRAP_T: 'tags this -> GLenum.t [@@js.get "TEXTURE_WRAP_T"]
  val get_TRIANGLES: 'tags this -> GLenum.t [@@js.get "TRIANGLES"]
  val get_TRIANGLE_FAN: 'tags this -> GLenum.t [@@js.get "TRIANGLE_FAN"]
  val get_TRIANGLE_STRIP: 'tags this -> GLenum.t [@@js.get "TRIANGLE_STRIP"]
  val get_UNPACK_ALIGNMENT: 'tags this -> GLenum.t [@@js.get "UNPACK_ALIGNMENT"]
  val get_UNPACK_COLORSPACE_CONVERSION_WEBGL: 'tags this -> GLenum.t [@@js.get "UNPACK_COLORSPACE_CONVERSION_WEBGL"]
  val get_UNPACK_FLIP_Y_WEBGL: 'tags this -> GLenum.t [@@js.get "UNPACK_FLIP_Y_WEBGL"]
  val get_UNPACK_PREMULTIPLY_ALPHA_WEBGL: 'tags this -> GLenum.t [@@js.get "UNPACK_PREMULTIPLY_ALPHA_WEBGL"]
  val get_UNSIGNED_BYTE: 'tags this -> GLenum.t [@@js.get "UNSIGNED_BYTE"]
  val get_UNSIGNED_INT: 'tags this -> GLenum.t [@@js.get "UNSIGNED_INT"]
  val get_UNSIGNED_SHORT: 'tags this -> GLenum.t [@@js.get "UNSIGNED_SHORT"]
  val get_UNSIGNED_SHORT_4_4_4_4: 'tags this -> GLenum.t [@@js.get "UNSIGNED_SHORT_4_4_4_4"]
  val get_UNSIGNED_SHORT_5_5_5_1: 'tags this -> GLenum.t [@@js.get "UNSIGNED_SHORT_5_5_5_1"]
  val get_UNSIGNED_SHORT_5_6_5: 'tags this -> GLenum.t [@@js.get "UNSIGNED_SHORT_5_6_5"]
  val get_VALIDATE_STATUS: 'tags this -> GLenum.t [@@js.get "VALIDATE_STATUS"]
  val get_VENDOR: 'tags this -> GLenum.t [@@js.get "VENDOR"]
  val get_VERSION: 'tags this -> GLenum.t [@@js.get "VERSION"]
  val get_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: 'tags this -> GLenum.t [@@js.get "VERTEX_ATTRIB_ARRAY_BUFFER_BINDING"]
  val get_VERTEX_ATTRIB_ARRAY_ENABLED: 'tags this -> GLenum.t [@@js.get "VERTEX_ATTRIB_ARRAY_ENABLED"]
  val get_VERTEX_ATTRIB_ARRAY_NORMALIZED: 'tags this -> GLenum.t [@@js.get "VERTEX_ATTRIB_ARRAY_NORMALIZED"]
  val get_VERTEX_ATTRIB_ARRAY_POINTER: 'tags this -> GLenum.t [@@js.get "VERTEX_ATTRIB_ARRAY_POINTER"]
  val get_VERTEX_ATTRIB_ARRAY_SIZE: 'tags this -> GLenum.t [@@js.get "VERTEX_ATTRIB_ARRAY_SIZE"]
  val get_VERTEX_ATTRIB_ARRAY_STRIDE: 'tags this -> GLenum.t [@@js.get "VERTEX_ATTRIB_ARRAY_STRIDE"]
  val get_VERTEX_ATTRIB_ARRAY_TYPE: 'tags this -> GLenum.t [@@js.get "VERTEX_ATTRIB_ARRAY_TYPE"]
  val get_VERTEX_SHADER: 'tags this -> GLenum.t [@@js.get "VERTEX_SHADER"]
  val get_VIEWPORT: 'tags this -> GLenum.t [@@js.get "VIEWPORT"]
  val get_ZERO: 'tags this -> GLenum.t [@@js.get "ZERO"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
and WebGLRenderingContextOverloads : sig
  type t = [`WebGLRenderingContextOverloads] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`WebGLRenderingContextOverloads]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`WebGLRenderingContextOverloads]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `WebGLRenderingContextOverloads ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val uniform1fv: 'tags this -> location:WebGLUniformLocation.t option -> v:GLfloat.t Iterable.t_1 -> unit [@@js.call "uniform1fv"]
  val uniform1iv: 'tags this -> location:WebGLUniformLocation.t option -> v:GLint.t Iterable.t_1 -> unit [@@js.call "uniform1iv"]
  val uniform2fv: 'tags this -> location:WebGLUniformLocation.t option -> v:GLfloat.t Iterable.t_1 -> unit [@@js.call "uniform2fv"]
  val uniform2iv: 'tags this -> location:WebGLUniformLocation.t option -> v:GLint.t Iterable.t_1 -> unit [@@js.call "uniform2iv"]
  val uniform3fv: 'tags this -> location:WebGLUniformLocation.t option -> v:GLfloat.t Iterable.t_1 -> unit [@@js.call "uniform3fv"]
  val uniform3iv: 'tags this -> location:WebGLUniformLocation.t option -> v:GLint.t Iterable.t_1 -> unit [@@js.call "uniform3iv"]
  val uniform4fv: 'tags this -> location:WebGLUniformLocation.t option -> v:GLfloat.t Iterable.t_1 -> unit [@@js.call "uniform4fv"]
  val uniform4iv: 'tags this -> location:WebGLUniformLocation.t option -> v:GLint.t Iterable.t_1 -> unit [@@js.call "uniform4iv"]
  val uniformMatrix2fv: 'tags this -> location:WebGLUniformLocation.t option -> transpose:GLboolean.t -> value:GLfloat.t Iterable.t_1 -> unit [@@js.call "uniformMatrix2fv"]
  val uniformMatrix3fv: 'tags this -> location:WebGLUniformLocation.t option -> transpose:GLboolean.t -> value:GLfloat.t Iterable.t_1 -> unit [@@js.call "uniformMatrix3fv"]
  val uniformMatrix4fv: 'tags this -> location:WebGLUniformLocation.t option -> transpose:GLboolean.t -> value:GLfloat.t Iterable.t_1 -> unit [@@js.call "uniformMatrix4fv"]
  val bufferData: 'tags this -> target:GLenum.t -> size:GLsizeiptr.t -> usage:GLenum.t -> unit [@@js.call "bufferData"]
  val bufferData': 'tags this -> target:GLenum.t -> data:BufferSource.t option -> usage:GLenum.t -> unit [@@js.call "bufferData"]
  val bufferSubData: 'tags this -> target:GLenum.t -> offset:GLintptr.t -> data:BufferSource.t -> unit [@@js.call "bufferSubData"]
  val compressedTexImage2D: 'tags this -> target:GLenum.t -> level:GLint.t -> internalformat:GLenum.t -> width:GLsizei.t -> height:GLsizei.t -> border:GLint.t -> data:ArrayBufferView.t_0 -> unit [@@js.call "compressedTexImage2D"]
  val compressedTexSubImage2D: 'tags this -> target:GLenum.t -> level:GLint.t -> xoffset:GLint.t -> yoffset:GLint.t -> width:GLsizei.t -> height:GLsizei.t -> format:GLenum.t -> data:ArrayBufferView.t_0 -> unit [@@js.call "compressedTexSubImage2D"]
  val readPixels: 'tags this -> x:GLint.t -> y:GLint.t -> width:GLsizei.t -> height:GLsizei.t -> format:GLenum.t -> type_:GLenum.t -> pixels:ArrayBufferView.t_0 option -> unit [@@js.call "readPixels"]
  val texImage2D: 'tags this -> target:GLenum.t -> level:GLint.t -> internalformat:GLint.t -> width:GLsizei.t -> height:GLsizei.t -> border:GLint.t -> format:GLenum.t -> type_:GLenum.t -> pixels:ArrayBufferView.t_0 option -> unit [@@js.call "texImage2D"]
  val texImage2D': 'tags this -> target:GLenum.t -> level:GLint.t -> internalformat:GLint.t -> format:GLenum.t -> type_:GLenum.t -> source:TexImageSource.t -> unit [@@js.call "texImage2D"]
  val texSubImage2D: 'tags this -> target:GLenum.t -> level:GLint.t -> xoffset:GLint.t -> yoffset:GLint.t -> width:GLsizei.t -> height:GLsizei.t -> format:GLenum.t -> type_:GLenum.t -> pixels:ArrayBufferView.t_0 option -> unit [@@js.call "texSubImage2D"]
  val texSubImage2D': 'tags this -> target:GLenum.t -> level:GLint.t -> xoffset:GLint.t -> yoffset:GLint.t -> format:GLenum.t -> type_:GLenum.t -> source:TexImageSource.t -> unit [@@js.call "texSubImage2D"]
  val uniform1fv': 'tags this -> location:WebGLUniformLocation.t option -> v:Float32List.t -> unit [@@js.call "uniform1fv"]
  val uniform1iv': 'tags this -> location:WebGLUniformLocation.t option -> v:Int32List.t -> unit [@@js.call "uniform1iv"]
  val uniform2fv': 'tags this -> location:WebGLUniformLocation.t option -> v:Float32List.t -> unit [@@js.call "uniform2fv"]
  val uniform2iv': 'tags this -> location:WebGLUniformLocation.t option -> v:Int32List.t -> unit [@@js.call "uniform2iv"]
  val uniform3fv': 'tags this -> location:WebGLUniformLocation.t option -> v:Float32List.t -> unit [@@js.call "uniform3fv"]
  val uniform3iv': 'tags this -> location:WebGLUniformLocation.t option -> v:Int32List.t -> unit [@@js.call "uniform3iv"]
  val uniform4fv': 'tags this -> location:WebGLUniformLocation.t option -> v:Float32List.t -> unit [@@js.call "uniform4fv"]
  val uniform4iv': 'tags this -> location:WebGLUniformLocation.t option -> v:Int32List.t -> unit [@@js.call "uniform4iv"]
  val uniformMatrix2fv': 'tags this -> location:WebGLUniformLocation.t option -> transpose:GLboolean.t -> value:Float32List.t -> unit [@@js.call "uniformMatrix2fv"]
  val uniformMatrix3fv': 'tags this -> location:WebGLUniformLocation.t option -> transpose:GLboolean.t -> value:Float32List.t -> unit [@@js.call "uniformMatrix3fv"]
  val uniformMatrix4fv': 'tags this -> location:WebGLUniformLocation.t option -> transpose:GLboolean.t -> value:Float32List.t -> unit [@@js.call "uniformMatrix4fv"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** Events that occur due to the user moving a mouse wheel or similar input device. *)
and[@js.scope "WheelEvent"] WheelEvent : sig
  type t = [`Event | `MouseEvent | `UIEvent | `WheelEvent] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Event | `MouseEvent | `UIEvent | `WheelEvent]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Event | `MouseEvent | `UIEvent | `WheelEvent]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `WheelEvent ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_deltaMode: 'tags this -> float [@@js.get "deltaMode"]
  val get_deltaX: 'tags this -> float [@@js.get "deltaX"]
  val get_deltaY: 'tags this -> float [@@js.get "deltaY"]
  val get_deltaZ: 'tags this -> float [@@js.get "deltaZ"]
  val get_DOM_DELTA_LINE: 'tags this -> float [@@js.get "DOM_DELTA_LINE"]
  val get_DOM_DELTA_PAGE: 'tags this -> float [@@js.get "DOM_DELTA_PAGE"]
  val get_DOM_DELTA_PIXEL: 'tags this -> float [@@js.get "DOM_DELTA_PIXEL"]
  val create: deltaMode:float -> deltaX:float -> deltaY:float -> deltaZ:float -> dom_delta_line:(float[@js "DOM_DELTA_LINE"]) -> dom_delta_page:(float[@js "DOM_DELTA_PAGE"]) -> dom_delta_pixel:(float[@js "DOM_DELTA_PIXEL"]) -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': type_:string -> ?eventInitDict:WheelEventInit.t -> unit -> t [@@js.create]
  val dom_delta_line: unit -> float [@@js.get "DOM_DELTA_LINE"]
  val dom_delta_page: unit -> float [@@js.get "DOM_DELTA_PAGE"]
  val dom_delta_pixel: unit -> float [@@js.get "DOM_DELTA_PIXEL"]
end
and WheelEventInit : sig
  type t = [`EventInit | `EventModifierInit | `MouseEventInit | `UIEventInit | `WheelEventInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventInit | `EventModifierInit | `MouseEventInit | `UIEventInit | `WheelEventInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventInit | `EventModifierInit | `MouseEventInit | `UIEventInit | `WheelEventInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `WheelEventInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_deltaMode: 'tags this -> float option [@@js.get "deltaMode"]
  val set_deltaMode: 'tags this -> float -> unit [@@js.set "deltaMode"]
  val get_deltaX: 'tags this -> float option [@@js.get "deltaX"]
  val set_deltaX: 'tags this -> float -> unit [@@js.set "deltaX"]
  val get_deltaY: 'tags this -> float option [@@js.get "deltaY"]
  val set_deltaY: 'tags this -> float -> unit [@@js.set "deltaY"]
  val get_deltaZ: 'tags this -> float option [@@js.get "deltaZ"]
  val set_deltaZ: 'tags this -> float -> unit [@@js.set "deltaZ"]
  val create: ?deltaMode:float -> ?deltaX:float -> ?deltaY:float -> ?deltaZ:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** A window containing a DOM document; the document property points to the DOM document loaded in that window. *)
and[@js.scope "Window"] Window : sig
  type t = [`AnimationFrameProvider | `EventTarget | `GlobalEventHandlers | `Window | `WindowEventHandlers | `WindowLocalStorage | `WindowOrWorkerGlobalScope | `WindowSessionStorage | t ArrayLike.tags_1] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AnimationFrameProvider | `EventTarget | `GlobalEventHandlers | `Window | `WindowEventHandlers | `WindowLocalStorage | `WindowOrWorkerGlobalScope | `WindowSessionStorage | t ArrayLike.tags_1]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AnimationFrameProvider | `EventTarget | `GlobalEventHandlers | `Window | `WindowEventHandlers | `WindowLocalStorage | `WindowOrWorkerGlobalScope | `WindowSessionStorage | t ArrayLike.tags_1]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `Window ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** @deprecated This is a legacy alias of `navigator`. *)
  val get_clientInformation: 'tags this -> Navigator.t [@@js.get "clientInformation"]
  
  (** Returns true if the window has been closed, false otherwise. *)
  val get_closed: 'tags this -> bool [@@js.get "closed"]
  
  (** Defines a new custom element, mapping the given name to the given constructor as an autonomous custom element. *)
  val get_customElements: 'tags this -> CustomElementRegistry.t [@@js.get "customElements"]
  val get_devicePixelRatio: 'tags this -> float [@@js.get "devicePixelRatio"]
  val get_document: 'tags this -> Document.t [@@js.get "document"]
  
  (** @deprecated  *)
  val get_event: 'tags this -> Event.t option [@@js.get "event"]
  
  (** @deprecated  *)
  val get_external: 'tags this -> External.t [@@js.get "external"]
  val get_frameElement: 'tags this -> Element.t option [@@js.get "frameElement"]
  val get_frames: 'tags this -> WindowProxy.t [@@js.get "frames"]
  val get_history: 'tags this -> History.t [@@js.get "history"]
  val get_innerHeight: 'tags this -> float [@@js.get "innerHeight"]
  val get_innerWidth: 'tags this -> float [@@js.get "innerWidth"]
  val get_length: 'tags this -> float [@@js.get "length"]
  val get_location: 'tags this -> Location.t [@@js.get "location"]
  val set_location: 'tags this -> ([`U1 of string | `U2 of Location.t] [@js.union]) -> unit [@@js.set "location"]
  
  (** Returns true if the location bar is visible; otherwise, returns false. *)
  val get_locationbar: 'tags this -> BarProp.t [@@js.get "locationbar"]
  
  (** Returns true if the menu bar is visible; otherwise, returns false. *)
  val get_menubar: 'tags this -> BarProp.t [@@js.get "menubar"]
  val get_name: 'tags this -> string [@@js.get "name"]
  val set_name: 'tags this -> string -> unit [@@js.set "name"]
  val get_navigator: 'tags this -> Navigator.t [@@js.get "navigator"]
  
  (** Available only in secure contexts. *)
  val get_ondevicemotion: 'tags this -> (this:t -> ev:DeviceMotionEvent.t -> any) option [@@js.get "ondevicemotion"]
  
  (** Available only in secure contexts. *)
  val set_ondevicemotion: 'tags this -> (this:t -> ev:DeviceMotionEvent.t -> any) option -> unit [@@js.set "ondevicemotion"]
  
  (** Available only in secure contexts. *)
  val get_ondeviceorientation: 'tags this -> (this:t -> ev:DeviceOrientationEvent.t -> any) option [@@js.get "ondeviceorientation"]
  
  (** Available only in secure contexts. *)
  val set_ondeviceorientation: 'tags this -> (this:t -> ev:DeviceOrientationEvent.t -> any) option -> unit [@@js.set "ondeviceorientation"]
  
  (** @deprecated  *)
  val get_onorientationchange: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onorientationchange"]
  
  (** @deprecated  *)
  val set_onorientationchange: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onorientationchange"]
  val get_opener: 'tags this -> any [@@js.get "opener"]
  val set_opener: 'tags this -> any -> unit [@@js.set "opener"]
  
  (** @deprecated  *)
  val get_orientation: 'tags this -> float [@@js.get "orientation"]
  val get_outerHeight: 'tags this -> float [@@js.get "outerHeight"]
  val get_outerWidth: 'tags this -> float [@@js.get "outerWidth"]
  
  (** @deprecated This is a legacy alias of `scrollX`. *)
  val get_pageXOffset: 'tags this -> float [@@js.get "pageXOffset"]
  
  (** @deprecated This is a legacy alias of `scrollY`. *)
  val get_pageYOffset: 'tags this -> float [@@js.get "pageYOffset"]
  
  (**
    Refers to either the parent WindowProxy, or itself.
    
    It can rarely be null e.g. for contentWindow of an iframe that is already removed from the parent.
  *)
  val get_parent: 'tags this -> WindowProxy.t [@@js.get "parent"]
  
  (** Returns true if the personal bar is visible; otherwise, returns false. *)
  val get_personalbar: 'tags this -> BarProp.t [@@js.get "personalbar"]
  val get_screen: 'tags this -> Screen.t [@@js.get "screen"]
  val get_screenLeft: 'tags this -> float [@@js.get "screenLeft"]
  val get_screenTop: 'tags this -> float [@@js.get "screenTop"]
  val get_screenX: 'tags this -> float [@@js.get "screenX"]
  val get_screenY: 'tags this -> float [@@js.get "screenY"]
  val get_scrollX: 'tags this -> float [@@js.get "scrollX"]
  val get_scrollY: 'tags this -> float [@@js.get "scrollY"]
  
  (** Returns true if the scrollbars are visible; otherwise, returns false. *)
  val get_scrollbars: 'tags this -> BarProp.t [@@js.get "scrollbars"]
  val get_self: 'tags this -> (t, (* FIXME: unknown type 'typeof globalThis' *)any) intersection2 [@@js.get "self"]
  val get_speechSynthesis: 'tags this -> SpeechSynthesis.t [@@js.get "speechSynthesis"]
  
  (** @deprecated  *)
  val get_status: 'tags this -> string [@@js.get "status"]
  
  (** @deprecated  *)
  val set_status: 'tags this -> string -> unit [@@js.set "status"]
  
  (** Returns true if the status bar is visible; otherwise, returns false. *)
  val get_statusbar: 'tags this -> BarProp.t [@@js.get "statusbar"]
  
  (** Returns true if the toolbar is visible; otherwise, returns false. *)
  val get_toolbar: 'tags this -> BarProp.t [@@js.get "toolbar"]
  val get_top: 'tags this -> WindowProxy.t option [@@js.get "top"]
  val get_visualViewport: 'tags this -> VisualViewport.t [@@js.get "visualViewport"]
  val get_window: 'tags this -> (t, (* FIXME: unknown type 'typeof globalThis' *)any) intersection2 [@@js.get "window"]
  val alert: 'tags this -> ?message:any -> unit -> unit [@@js.call "alert"]
  val blur: 'tags this -> unit [@@js.call "blur"]
  val cancelIdleCallback: 'tags this -> handle:float -> unit [@@js.call "cancelIdleCallback"]
  
  (** @deprecated  *)
  val captureEvents: 'tags this -> unit [@@js.call "captureEvents"]
  
  (** Closes the window. *)
  val close: 'tags this -> unit [@@js.call "close"]
  val confirm: 'tags this -> ?message:string -> unit -> bool [@@js.call "confirm"]
  
  (** Moves the focus to the window's browsing context, if any. *)
  val focus: 'tags this -> unit [@@js.call "focus"]
  val getComputedStyle: 'tags this -> elt:Element.t -> ?pseudoElt:string option -> unit -> CSSStyleDeclaration.t [@@js.call "getComputedStyle"]
  val getSelection: 'tags this -> Selection.t option [@@js.call "getSelection"]
  val matchMedia: 'tags this -> query:string -> MediaQueryList.t [@@js.call "matchMedia"]
  val moveBy: 'tags this -> x:float -> y:float -> unit [@@js.call "moveBy"]
  val moveTo: 'tags this -> x:float -> y:float -> unit [@@js.call "moveTo"]
  val open_: 'tags this -> ?url:([`U1 of string | `U2 of URL.t] [@js.union]) -> ?target:string -> ?features:string -> unit -> WindowProxy.t option [@@js.call "open"]
  
  (**
    Posts a message to the given window. Messages can be structured objects, e.g. nested objects and arrays, can contain JavaScript values (strings, numbers, Date objects, etc), and can contain certain data objects such as File Blob, FileList, and ArrayBuffer objects.
    
    Objects listed in the transfer member of options are transferred, not just cloned, meaning that they are no longer usable on the sending side.
    
    A target origin can be specified using the targetOrigin member of options. If not provided, it defaults to "/". This default restricts the message to same-origin targets only.
    
    If the origin of the target window doesn't match the given target origin, the message is discarded, to avoid information leakage. To send the message to the target regardless of origin, set the target origin to "*".
    
    Throws a "DataCloneError" DOMException if transfer array contains duplicate objects or if message could not be cloned.
  *)
  val postMessage: 'tags this -> message:any -> targetOrigin:string -> ?transfer:Transferable.t list -> unit -> unit [@@js.call "postMessage"]
  
  (**
    Posts a message to the given window. Messages can be structured objects, e.g. nested objects and arrays, can contain JavaScript values (strings, numbers, Date objects, etc), and can contain certain data objects such as File Blob, FileList, and ArrayBuffer objects.
    
    Objects listed in the transfer member of options are transferred, not just cloned, meaning that they are no longer usable on the sending side.
    
    A target origin can be specified using the targetOrigin member of options. If not provided, it defaults to "/". This default restricts the message to same-origin targets only.
    
    If the origin of the target window doesn't match the given target origin, the message is discarded, to avoid information leakage. To send the message to the target regardless of origin, set the target origin to "*".
    
    Throws a "DataCloneError" DOMException if transfer array contains duplicate objects or if message could not be cloned.
  *)
  val postMessage': 'tags this -> message:any -> ?options:WindowPostMessageOptions.t -> unit -> unit [@@js.call "postMessage"]
  val print: 'tags this -> unit [@@js.call "print"]
  val prompt: 'tags this -> ?message:string -> ?_default:string -> unit -> string option [@@js.call "prompt"]
  
  (** @deprecated  *)
  val releaseEvents: 'tags this -> unit [@@js.call "releaseEvents"]
  val requestIdleCallback: 'tags this -> callback:IdleRequestCallback.t -> ?options:IdleRequestOptions.t -> unit -> float [@@js.call "requestIdleCallback"]
  val resizeBy: 'tags this -> x:float -> y:float -> unit [@@js.call "resizeBy"]
  val resizeTo: 'tags this -> width:float -> height:float -> unit [@@js.call "resizeTo"]
  val scroll: 'tags this -> ?options:ScrollToOptions.t -> unit -> unit [@@js.call "scroll"]
  val scroll': 'tags this -> x:float -> y:float -> unit [@@js.call "scroll"]
  val scrollBy: 'tags this -> ?options:ScrollToOptions.t -> unit -> unit [@@js.call "scrollBy"]
  val scrollBy': 'tags this -> x:float -> y:float -> unit [@@js.call "scrollBy"]
  val scrollTo: 'tags this -> ?options:ScrollToOptions.t -> unit -> unit [@@js.call "scrollTo"]
  val scrollTo': 'tags this -> x:float -> y:float -> unit [@@js.call "scrollTo"]
  
  (** Cancels the document load. *)
  val stop: 'tags this -> unit [@@js.call "stop"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'WindowEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'WindowEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val get: 'tags this -> float -> t [@@js.index_get]
  val set: 'tags this -> float -> t -> unit [@@js.index_set]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
and WindowEventHandlers : sig
  type t = [`WindowEventHandlers] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`WindowEventHandlers]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`WindowEventHandlers]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `WindowEventHandlers ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_onafterprint: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onafterprint"]
  val set_onafterprint: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onafterprint"]
  val get_onbeforeprint: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onbeforeprint"]
  val set_onbeforeprint: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onbeforeprint"]
  val get_onbeforeunload: 'tags this -> (this:t -> ev:BeforeUnloadEvent.t -> any) option [@@js.get "onbeforeunload"]
  val set_onbeforeunload: 'tags this -> (this:t -> ev:BeforeUnloadEvent.t -> any) option -> unit [@@js.set "onbeforeunload"]
  val get_ongamepadconnected: 'tags this -> (this:t -> ev:GamepadEvent.t -> any) option [@@js.get "ongamepadconnected"]
  val set_ongamepadconnected: 'tags this -> (this:t -> ev:GamepadEvent.t -> any) option -> unit [@@js.set "ongamepadconnected"]
  val get_ongamepaddisconnected: 'tags this -> (this:t -> ev:GamepadEvent.t -> any) option [@@js.get "ongamepaddisconnected"]
  val set_ongamepaddisconnected: 'tags this -> (this:t -> ev:GamepadEvent.t -> any) option -> unit [@@js.set "ongamepaddisconnected"]
  val get_onhashchange: 'tags this -> (this:t -> ev:HashChangeEvent.t -> any) option [@@js.get "onhashchange"]
  val set_onhashchange: 'tags this -> (this:t -> ev:HashChangeEvent.t -> any) option -> unit [@@js.set "onhashchange"]
  val get_onlanguagechange: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onlanguagechange"]
  val set_onlanguagechange: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onlanguagechange"]
  val get_onmessage: 'tags this -> (this:t -> ev:MessageEvent.t_0 -> any) option [@@js.get "onmessage"]
  val set_onmessage: 'tags this -> (this:t -> ev:MessageEvent.t_0 -> any) option -> unit [@@js.set "onmessage"]
  val get_onmessageerror: 'tags this -> (this:t -> ev:MessageEvent.t_0 -> any) option [@@js.get "onmessageerror"]
  val set_onmessageerror: 'tags this -> (this:t -> ev:MessageEvent.t_0 -> any) option -> unit [@@js.set "onmessageerror"]
  val get_onoffline: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onoffline"]
  val set_onoffline: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onoffline"]
  val get_ononline: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "ononline"]
  val set_ononline: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "ononline"]
  val get_onpagehide: 'tags this -> (this:t -> ev:PageTransitionEvent.t -> any) option [@@js.get "onpagehide"]
  val set_onpagehide: 'tags this -> (this:t -> ev:PageTransitionEvent.t -> any) option -> unit [@@js.set "onpagehide"]
  val get_onpageshow: 'tags this -> (this:t -> ev:PageTransitionEvent.t -> any) option [@@js.get "onpageshow"]
  val set_onpageshow: 'tags this -> (this:t -> ev:PageTransitionEvent.t -> any) option -> unit [@@js.set "onpageshow"]
  val get_onpopstate: 'tags this -> (this:t -> ev:PopStateEvent.t -> any) option [@@js.get "onpopstate"]
  val set_onpopstate: 'tags this -> (this:t -> ev:PopStateEvent.t -> any) option -> unit [@@js.set "onpopstate"]
  val get_onrejectionhandled: 'tags this -> (this:t -> ev:PromiseRejectionEvent.t -> any) option [@@js.get "onrejectionhandled"]
  val set_onrejectionhandled: 'tags this -> (this:t -> ev:PromiseRejectionEvent.t -> any) option -> unit [@@js.set "onrejectionhandled"]
  val get_onstorage: 'tags this -> (this:t -> ev:StorageEvent.t -> any) option [@@js.get "onstorage"]
  val set_onstorage: 'tags this -> (this:t -> ev:StorageEvent.t -> any) option -> unit [@@js.set "onstorage"]
  val get_onunhandledrejection: 'tags this -> (this:t -> ev:PromiseRejectionEvent.t -> any) option [@@js.get "onunhandledrejection"]
  val set_onunhandledrejection: 'tags this -> (this:t -> ev:PromiseRejectionEvent.t -> any) option -> unit [@@js.set "onunhandledrejection"]
  val get_onunload: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onunload"]
  val set_onunload: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onunload"]
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'WindowEventHandlersEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'WindowEventHandlersEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
and WindowOrWorkerGlobalScope : sig
  type t = [`WindowOrWorkerGlobalScope] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`WindowOrWorkerGlobalScope]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`WindowOrWorkerGlobalScope]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `WindowOrWorkerGlobalScope ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Available only in secure contexts. *)
  val get_caches: 'tags this -> CacheStorage.t [@@js.get "caches"]
  val get_crossOriginIsolated: 'tags this -> bool [@@js.get "crossOriginIsolated"]
  val get_crypto: 'tags this -> Crypto.t [@@js.get "crypto"]
  val get_indexedDB: 'tags this -> IDBFactory.t [@@js.get "indexedDB"]
  val get_isSecureContext: 'tags this -> bool [@@js.get "isSecureContext"]
  val get_origin: 'tags this -> string [@@js.get "origin"]
  val get_performance: 'tags this -> Performance.t [@@js.get "performance"]
  val atob: 'tags this -> data:string -> string [@@js.call "atob"]
  val btoa: 'tags this -> data:string -> string [@@js.call "btoa"]
  val clearInterval: 'tags this -> ?id:float -> unit -> unit [@@js.call "clearInterval"]
  val clearTimeout: 'tags this -> ?id:float -> unit -> unit [@@js.call "clearTimeout"]
  val createImageBitmap: 'tags this -> image:ImageBitmapSource.t -> ?options:ImageBitmapOptions.t -> unit -> ImageBitmap.t Promise.t_1 [@@js.call "createImageBitmap"]
  val createImageBitmap': 'tags this -> image:ImageBitmapSource.t -> sx:float -> sy:float -> sw:float -> sh:float -> ?options:ImageBitmapOptions.t -> unit -> ImageBitmap.t Promise.t_1 [@@js.call "createImageBitmap"]
  val fetch: 'tags this -> input:RequestInfo.t -> ?init:RequestInit.t -> unit -> Response.t Promise.t_1 [@@js.call "fetch"]
  val queueMicrotask: 'tags this -> callback:VoidFunction.t -> unit [@@js.call "queueMicrotask"]
  val reportError: 'tags this -> e:any -> unit [@@js.call "reportError"]
  val setInterval: 'tags this -> handler:TimerHandler.t -> ?timeout:float -> arguments:(any list [@js.variadic]) -> unit -> float [@@js.call "setInterval"]
  val setTimeout: 'tags this -> handler:TimerHandler.t -> ?timeout:float -> arguments:(any list [@js.variadic]) -> unit -> float [@@js.call "setTimeout"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
and WindowPostMessageOptions : sig
  type t = [`StructuredSerializeOptions | `WindowPostMessageOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`StructuredSerializeOptions | `WindowPostMessageOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`StructuredSerializeOptions | `WindowPostMessageOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `WindowPostMessageOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_targetOrigin: 'tags this -> string option [@@js.get "targetOrigin"]
  val set_targetOrigin: 'tags this -> string -> unit [@@js.set "targetOrigin"]
  val create: ?targetOrigin:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
and WindowProxy : sig
  type t = Window.t
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end

(** An XML document. It inherits from the generic Document and does not add any specific methods or properties to it: nevertheless, several algorithms behave differently with the two types of documents. *)
and[@js.scope "XMLDocument"] XMLDocument : sig
  type t = [`Document | `DocumentAndElementEventHandlers | `DocumentOrShadowRoot | `EventTarget | `FontFaceSource | `GlobalEventHandlers | `Node | `NonElementParentNode | `ParentNode | `XMLDocument | `XPathEvaluatorBase] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Document | `DocumentAndElementEventHandlers | `DocumentOrShadowRoot | `EventTarget | `FontFaceSource | `GlobalEventHandlers | `Node | `NonElementParentNode | `ParentNode | `XMLDocument | `XPathEvaluatorBase]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Document | `DocumentAndElementEventHandlers | `DocumentOrShadowRoot | `EventTarget | `FontFaceSource | `GlobalEventHandlers | `Node | `NonElementParentNode | `ParentNode | `XMLDocument | `XPathEvaluatorBase]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `XMLDocument ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'DocumentEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'DocumentEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
and XMLHttpRequestBodyInit : sig
  type t = ([`String of string | `Other of (Blob.t, BufferSource.t, FormData.t, URLSearchParams.t) union4] [@js.union on_field "dummy"]) Primitive.t
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
and XPathEvaluatorBase : sig
  type t = [`XPathEvaluatorBase] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`XPathEvaluatorBase]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`XPathEvaluatorBase]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `XPathEvaluatorBase ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val createExpression: 'tags this -> expression:string -> ?resolver:XPathNSResolver.t option -> unit -> XPathExpression.t [@@js.call "createExpression"]
  val createNSResolver: 'tags this -> nodeResolver:Node.t -> XPathNSResolver.t [@@js.call "createNSResolver"]
  val evaluate: 'tags this -> expression:string -> contextNode:Node.t -> ?resolver:XPathNSResolver.t option -> ?type_:float -> ?result:XPathResult.t option -> unit -> XPathResult.t [@@js.call "evaluate"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** This interface is a compiled XPath expression that can be evaluated on a document or specific node to return information its DOM tree. *)
and[@js.scope "XPathExpression"] XPathExpression : sig
  type t = [`XPathExpression] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`XPathExpression]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`XPathExpression]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `XPathExpression ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val evaluate: 'tags this -> contextNode:Node.t -> ?type_:float -> ?result:XPathResult.t option -> unit -> XPathResult.t [@@js.call "evaluate"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** The results generated by evaluating an XPath expression within the context of a given node. *)
and[@js.scope "XPathResult"] XPathResult : sig
  type t = [`XPathResult] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`XPathResult]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`XPathResult]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `XPathResult ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_booleanValue: 'tags this -> bool [@@js.get "booleanValue"]
  val get_invalidIteratorState: 'tags this -> bool [@@js.get "invalidIteratorState"]
  val get_numberValue: 'tags this -> float [@@js.get "numberValue"]
  val get_resultType: 'tags this -> float [@@js.get "resultType"]
  val get_singleNodeValue: 'tags this -> Node.t option [@@js.get "singleNodeValue"]
  val get_snapshotLength: 'tags this -> float [@@js.get "snapshotLength"]
  val get_stringValue: 'tags this -> string [@@js.get "stringValue"]
  val iterateNext: 'tags this -> Node.t option [@@js.call "iterateNext"]
  val snapshotItem: 'tags this -> index:float -> Node.t option [@@js.call "snapshotItem"]
  val get_ANY_TYPE: 'tags this -> float [@@js.get "ANY_TYPE"]
  val get_ANY_UNORDERED_NODE_TYPE: 'tags this -> float [@@js.get "ANY_UNORDERED_NODE_TYPE"]
  val get_BOOLEAN_TYPE: 'tags this -> float [@@js.get "BOOLEAN_TYPE"]
  val get_FIRST_ORDERED_NODE_TYPE: 'tags this -> float [@@js.get "FIRST_ORDERED_NODE_TYPE"]
  val get_NUMBER_TYPE: 'tags this -> float [@@js.get "NUMBER_TYPE"]
  val get_ORDERED_NODE_ITERATOR_TYPE: 'tags this -> float [@@js.get "ORDERED_NODE_ITERATOR_TYPE"]
  val get_ORDERED_NODE_SNAPSHOT_TYPE: 'tags this -> float [@@js.get "ORDERED_NODE_SNAPSHOT_TYPE"]
  val get_STRING_TYPE: 'tags this -> float [@@js.get "STRING_TYPE"]
  val get_UNORDERED_NODE_ITERATOR_TYPE: 'tags this -> float [@@js.get "UNORDERED_NODE_ITERATOR_TYPE"]
  val get_UNORDERED_NODE_SNAPSHOT_TYPE: 'tags this -> float [@@js.get "UNORDERED_NODE_SNAPSHOT_TYPE"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
  val any_type: unit -> float [@@js.get "ANY_TYPE"]
  val any_unordered_node_type: unit -> float [@@js.get "ANY_UNORDERED_NODE_TYPE"]
  val boolean_type: unit -> float [@@js.get "BOOLEAN_TYPE"]
  val first_ordered_node_type: unit -> float [@@js.get "FIRST_ORDERED_NODE_TYPE"]
  val number_type: unit -> float [@@js.get "NUMBER_TYPE"]
  val ordered_node_iterator_type: unit -> float [@@js.get "ORDERED_NODE_ITERATOR_TYPE"]
  val ordered_node_snapshot_type: unit -> float [@@js.get "ORDERED_NODE_SNAPSHOT_TYPE"]
  val string_type: unit -> float [@@js.get "STRING_TYPE"]
  val unordered_node_iterator_type: unit -> float [@@js.get "UNORDERED_NODE_ITERATOR_TYPE"]
  val unordered_node_snapshot_type: unit -> float [@@js.get "UNORDERED_NODE_SNAPSHOT_TYPE"]
end
module[@js.scope "navigator"] NavigatorStatic : sig
  
  (** Available only in secure contexts. *)
  val requestMediaKeySystemAccess: keySystem:string -> supportedConfigurations:MediaKeySystemConfiguration.t Iterable.t_1 -> MediaKeySystemAccess.t Promise.t_1 [@@js.global "requestMediaKeySystemAccess"]
  val vibrate: float Iterable.t_1 -> bool [@@js.global "vibrate"]
  
  (** Available only in secure contexts. *)
  val clipboard: unit -> Clipboard.t [@@js.get "clipboard"]
  
  (** Available only in secure contexts. *)
  val credentials: unit -> CredentialsContainer.t [@@js.get "credentials"]
  val doNotTrack: unit -> string option [@@js.get "doNotTrack"]
  val geolocation: unit -> Geolocation.t [@@js.get "geolocation"]
  val maxTouchPoints: unit -> float [@@js.get "maxTouchPoints"]
  val mediaCapabilities: unit -> MediaCapabilities.t [@@js.get "mediaCapabilities"]
  
  (** Available only in secure contexts. *)
  val mediaDevices: unit -> MediaDevices.t [@@js.get "mediaDevices"]
  val mediaSession: unit -> MediaSession.t [@@js.get "mediaSession"]
  val permissions: unit -> Permissions.t [@@js.get "permissions"]
  
  (** Available only in secure contexts. *)
  val serviceWorker: unit -> ServiceWorkerContainer.t [@@js.get "serviceWorker"]
  
  (** Available only in secure contexts. *)
  val canShare: ?data:ShareData.t -> unit -> bool [@@js.global "canShare"]
  val getGamepads: unit -> Gamepad.t option list [@@js.global "getGamepads"]
  
  (** Available only in secure contexts. *)
  val requestMediaKeySystemAccess': keySystem:string -> supportedConfigurations:MediaKeySystemConfiguration.t list -> MediaKeySystemAccess.t Promise.t_1 [@@js.global "requestMediaKeySystemAccess"]
  val sendBeacon: url:([`U1 of string | `U2 of URL.t] [@js.union]) -> ?data:BodyInit.t option -> unit -> bool [@@js.global "sendBeacon"]
  
  (** Available only in secure contexts. *)
  val share: ?data:ShareData.t -> unit -> unit Promise.t_1 [@@js.global "share"]
  val vibrate': VibratePattern.t -> bool [@@js.global "vibrate"]
end
module[@js.scope "menubar"] MenubarStatic : sig
  val visible: unit -> bool [@@js.get "visible"]
end
module[@js.scope "locationbar"] LocationbarStatic : sig
  val visible: unit -> bool [@@js.get "visible"]
end
module[@js.scope "location"] LocationStatic : sig
  
  (** Returns a DOMStringList object listing the origins of the ancestor browsing contexts, from the parent browsing context to the top-level browsing context. *)
  val ancestorOrigins: unit -> DOMStringList.t [@@js.get "ancestorOrigins"]
  
  (**
    Returns the Location object's URL's fragment (includes leading "#" if non-empty).
    
    Can be set, to navigate to the same URL with a changed fragment (ignores leading "#").
  *)
  val hash: unit -> string [@@js.get "hash"]
  
  (**
    Returns the Location object's URL's host and port (if different from the default port for the scheme).
    
    Can be set, to navigate to the same URL with a changed host and port.
  *)
  val host: unit -> string [@@js.get "host"]
  
  (**
    Returns the Location object's URL's host.
    
    Can be set, to navigate to the same URL with a changed host.
  *)
  val hostname: unit -> string [@@js.get "hostname"]
  
  (**
    Returns the Location object's URL.
    
    Can be set, to navigate to the given URL.
  *)
  val href: unit -> string [@@js.get "href"]
  val toString: unit -> string [@@js.global "toString"]
  
  (** Returns the Location object's URL's origin. *)
  val origin: unit -> string [@@js.get "origin"]
  
  (**
    Returns the Location object's URL's path.
    
    Can be set, to navigate to the same URL with a changed path.
  *)
  val pathname: unit -> string [@@js.get "pathname"]
  
  (**
    Returns the Location object's URL's port.
    
    Can be set, to navigate to the same URL with a changed port.
  *)
  val port: unit -> string [@@js.get "port"]
  
  (**
    Returns the Location object's URL's scheme.
    
    Can be set, to navigate to the same URL with a changed scheme.
  *)
  val protocol: unit -> string [@@js.get "protocol"]
  
  (**
    Returns the Location object's URL's query (includes leading "?" if non-empty).
    
    Can be set, to navigate to the same URL with a changed query (ignores leading "?").
  *)
  val search: unit -> string [@@js.get "search"]
  
  (** Navigates to the given URL. *)
  val assign: ([`U1 of string | `U2 of URL.t] [@js.union]) -> unit [@@js.global "assign"]
  
  (** Reloads the current page. *)
  val reload: unit -> unit [@@js.global "reload"]
  
  (** Removes the current page from the session history and navigates to the given URL. *)
  val replace: ([`U1 of string | `U2 of URL.t] [@js.union]) -> unit [@@js.global "replace"]
end
module[@js.scope "localStorage"] LocalStorageStatic : sig
  
  (** Returns the number of key/value pairs. *)
  val length: unit -> float [@@js.get "length"]
  
  (**
    Removes all key/value pairs, if there are any.
    
    Dispatches a storage event on Window objects holding an equivalent Storage object.
  *)
  val clear: unit -> unit [@@js.global "clear"]
  
  (** Returns the current value associated with the given key, or null if the given key does not exist. *)
  val getItem: string -> string option [@@js.global "getItem"]
  
  (** Returns the name of the nth key, or null if n is greater than or equal to the number of key/value pairs. *)
  val key: float -> string option [@@js.global "key"]
  
  (**
    Removes the key/value pair with the given key, if a key/value pair with the given key exists.
    
    Dispatches a storage event on Window objects holding an equivalent Storage object.
  *)
  val removeItem: string -> unit [@@js.global "removeItem"]
  
  (**
    Sets the value of the pair identified by key to value, creating a new key/value pair if none existed for key previously.
    
    Throws a "QuotaExceededError" DOMException exception if the new value couldn't be set. (Setting could fail if, e.g., the user has disabled storage for the site, or if the quota has been exceeded.)
    
    Dispatches a storage event on Window objects holding an equivalent Storage object.
  *)
  val setItem: key:string -> value:string -> unit [@@js.global "setItem"]
  (* unsupported indexer of type: (~name:String -> Any) *)
end
module[@js.scope "indexedDB"] IndexedDBStatic : sig
  
  (**
    Compares two values as keys. Returns -1 if key1 precedes key2, 1 if key2 precedes key1, and 0 if the keys are equal.
    
    Throws a "DataError" DOMException if either input is not a valid key.
  *)
  val cmp: first:any -> second:any -> float [@@js.global "cmp"]
  val databases: unit -> IDBDatabaseInfo.t list Promise.t_1 [@@js.global "databases"]
  
  (** Attempts to delete the named database. If the database already exists and there are open connections that don't close in response to a versionchange event, the request will be blocked until all they close. If the request is successful request's result will be null. *)
  val deleteDatabase: string -> IDBOpenDBRequest.t [@@js.global "deleteDatabase"]
  
  (** Attempts to open a connection to the named database with the current version, or 1 if it does not already exist. If the request is successful request's result will be the connection. *)
  val open_: name:string -> ?version:float -> unit -> IDBOpenDBRequest.t [@@js.global "open"]
end
module[@js.scope "history"] HistoryStatic : sig
  val length: unit -> float [@@js.get "length"]
  val scrollRestoration: unit -> ScrollRestoration.t [@@js.get "scrollRestoration"]
  val state: unit -> any [@@js.get "state"]
  val back: unit -> unit [@@js.global "back"]
  val forward: unit -> unit [@@js.global "forward"]
  val go: ?delta:float -> unit -> unit [@@js.global "go"]
  val pushState: data:any -> unused:string -> ?url:([`Null | `U1 of string | `U2 of URL.t] [@js.union]) -> unit -> unit [@@js.global "pushState"]
  val replaceState: data:any -> unused:string -> ?url:([`Null | `U1 of string | `U2 of URL.t] [@js.union]) -> unit -> unit [@@js.global "replaceState"]
end
module[@js.scope "external"] ExternalStatic : sig
  
  (** @deprecated  *)
  val addSearchProvider: unit -> unit [@@js.global "AddSearchProvider"]
  
  (** @deprecated  *)
  val isSearchProviderInstalled: unit -> unit [@@js.global "IsSearchProviderInstalled"]
end
module[@js.scope "document"] DocumentStatic : sig
  
  (** Sets or gets the URL for the current document. *)
  val url: unit -> string [@@js.get "URL"]
  
  (**
    Sets or gets the color of all active links in the document.
    @deprecated 
  *)
  val alinkColor: unit -> string [@@js.get "alinkColor"]
  
  (**
    Returns a reference to the collection of elements contained by the object.
    @deprecated 
  *)
  val all: unit -> HTMLAllCollection.t [@@js.get "all"]
  
  (**
    Retrieves a collection of all a objects that have a name and/or id property. Objects in this collection are in HTML source order.
    @deprecated 
  *)
  val anchors: unit -> HTMLAnchorElement.t HTMLCollectionOf.t [@@js.get "anchors"]
  
  (**
    Retrieves a collection of all applet objects in the document.
    @deprecated 
  *)
  val applets: unit -> HTMLCollection.t [@@js.get "applets"]
  
  (**
    Deprecated. Sets or retrieves a value that indicates the background color behind the object.
    @deprecated 
  *)
  val bgColor: unit -> string [@@js.get "bgColor"]
  
  (** Specifies the beginning and end of the document body. *)
  val body: unit -> HTMLElement.t [@@js.get "body"]
  
  (** Returns document's encoding. *)
  val characterSet: unit -> string [@@js.get "characterSet"]
  
  (**
    Gets or sets the character set used to encode the object.
    @deprecated This is a legacy alias of `characterSet`.
  *)
  val charset: unit -> string [@@js.get "charset"]
  
  (** Gets a value that indicates whether standards-compliant mode is switched on for the object. *)
  val compatMode: unit -> string [@@js.get "compatMode"]
  
  (** Returns document's content type. *)
  val contentType: unit -> string [@@js.get "contentType"]
  
  (**
    Returns the HTTP cookies that apply to the Document. If there are no cookies or cookies can't be applied to this resource, the empty string will be returned.
    
    Can be set, to add a new cookie to the element's set of HTTP cookies.
    
    If the contents are sandboxed into a unique origin (e.g. in an iframe with the sandbox attribute), a "SecurityError" DOMException will be thrown on getting and setting.
  *)
  val cookie: unit -> string [@@js.get "cookie"]
  
  (**
    Returns the script element, or the SVG script element, that is currently executing, as long as the element represents a classic script. In the case of reentrant script execution, returns the one that most recently started executing amongst those that have not yet finished executing.
    
    Returns null if the Document is not currently executing a script or SVG script element (e.g., because the running script is an event handler, or a timeout), or if the currently executing script or SVG script element represents a module script.
  *)
  val currentScript: unit -> HTMLOrSVGScriptElement.t option [@@js.get "currentScript"]
  
  (** Returns the Window object of the active document. *)
  val defaultView: unit -> (WindowProxy.t, (* FIXME: unknown type 'typeof globalThis' *)any) intersection2 option [@@js.get "defaultView"]
  
  (** Sets or gets a value that indicates whether the document can be edited. *)
  val designMode: unit -> string [@@js.get "designMode"]
  
  (** Sets or retrieves a value that indicates the reading order of the object. *)
  val dir: unit -> string [@@js.get "dir"]
  
  (** Gets an object representing the document type declaration associated with the current document. *)
  val doctype: unit -> DocumentType.t option [@@js.get "doctype"]
  
  (** Gets a reference to the root node of the document. *)
  val documentElement: unit -> HTMLElement.t [@@js.get "documentElement"]
  
  (** Returns document's URL. *)
  val documentURI: unit -> string [@@js.get "documentURI"]
  
  (** Sets or gets the security domain of the document. *)
  val domain: unit -> string [@@js.get "domain"]
  
  (** Retrieves a collection of all embed objects in the document. *)
  val embeds: unit -> HTMLEmbedElement.t HTMLCollectionOf.t [@@js.get "embeds"]
  
  (**
    Sets or gets the foreground (text) color of the document.
    @deprecated 
  *)
  val fgColor: unit -> string [@@js.get "fgColor"]
  
  (** Retrieves a collection, in source order, of all form objects in the document. *)
  val forms: unit -> HTMLFormElement.t HTMLCollectionOf.t [@@js.get "forms"]
  
  (** @deprecated  *)
  val fullscreen: unit -> bool [@@js.get "fullscreen"]
  
  (** Returns true if document has the ability to display elements fullscreen and fullscreen is supported, or false otherwise. *)
  val fullscreenEnabled: unit -> bool [@@js.get "fullscreenEnabled"]
  
  (** Returns the head element. *)
  val head: unit -> HTMLHeadElement.t [@@js.get "head"]
  val hidden: unit -> bool [@@js.get "hidden"]
  
  (** Retrieves a collection, in source order, of img objects in the document. *)
  val images: unit -> HTMLImageElement.t HTMLCollectionOf.t [@@js.get "images"]
  
  (** Gets the implementation object of the current document. *)
  val implementation: unit -> DOMImplementation.t [@@js.get "implementation"]
  
  (**
    Returns the character encoding used to create the webpage that is loaded into the document object.
    @deprecated This is a legacy alias of `characterSet`.
  *)
  val inputEncoding: unit -> string [@@js.get "inputEncoding"]
  
  (** Gets the date that the page was last modified, if the page supplies one. *)
  val lastModified: unit -> string [@@js.get "lastModified"]
  
  (**
    Sets or gets the color of the document links.
    @deprecated 
  *)
  val linkColor: unit -> string [@@js.get "linkColor"]
  
  (** Retrieves a collection of all a objects that specify the href property and all area objects in the document. *)
  val links: unit -> (HTMLAnchorElement.t, HTMLAreaElement.t) union2 HTMLCollectionOf.t [@@js.get "links"]
  
  (** Contains information about the current URL. *)
  val location: unit -> Location.t [@@js.get "location"]
  val onfullscreenchange: unit -> (this:Document.t -> ev:Event.t -> any) option [@@js.get "onfullscreenchange"]
  val onfullscreenerror: unit -> (this:Document.t -> ev:Event.t -> any) option [@@js.get "onfullscreenerror"]
  val onpointerlockchange: unit -> (this:Document.t -> ev:Event.t -> any) option [@@js.get "onpointerlockchange"]
  val onpointerlockerror: unit -> (this:Document.t -> ev:Event.t -> any) option [@@js.get "onpointerlockerror"]
  
  (**
    Fires when the state of the object has changed.
    @param ev The event
  *)
  val onreadystatechange: unit -> (this:Document.t -> ev:Event.t -> any) option [@@js.get "onreadystatechange"]
  val onvisibilitychange: unit -> (this:Document.t -> ev:Event.t -> any) option [@@js.get "onvisibilitychange"]
  
  (** Returns the node document. Returns null for documents. *)
  val ownerDocument: unit -> null [@@js.get "ownerDocument"]
  val pictureInPictureEnabled: unit -> bool [@@js.get "pictureInPictureEnabled"]
  
  (** Return an HTMLCollection of the embed elements in the Document. *)
  val plugins: unit -> HTMLEmbedElement.t HTMLCollectionOf.t [@@js.get "plugins"]
  
  (** Retrieves a value that indicates the current state of the object. *)
  val readyState: unit -> DocumentReadyState.t [@@js.get "readyState"]
  
  (** Gets the URL of the location that referred the user to the current page. *)
  val referrer: unit -> string [@@js.get "referrer"]
  
  (** @deprecated  *)
  val rootElement: unit -> SVGSVGElement.t option [@@js.get "rootElement"]
  
  (** Retrieves a collection of all script objects in the document. *)
  val scripts: unit -> HTMLScriptElement.t HTMLCollectionOf.t [@@js.get "scripts"]
  val scrollingElement: unit -> Element.t option [@@js.get "scrollingElement"]
  val timeline: unit -> DocumentTimeline.t [@@js.get "timeline"]
  
  (** Contains the title of the document. *)
  val title: unit -> string [@@js.get "title"]
  val visibilityState: unit -> DocumentVisibilityState.t [@@js.get "visibilityState"]
  
  (**
    Sets or gets the color of the links that the user has visited.
    @deprecated 
  *)
  val vlinkColor: unit -> string [@@js.get "vlinkColor"]
  
  (**
    Moves node from another document and returns it.
    
    If node is a document, throws a "NotSupportedError" DOMException or, if node is a shadow root, throws a "HierarchyRequestError" DOMException.
  *)
  val adoptNode: 'T -> 'T [@@js.global "adoptNode"]
  
  (** @deprecated  *)
  val captureEvents: unit -> unit [@@js.global "captureEvents"]
  
  (** @deprecated  *)
  val caretRangeFromPoint: x:float -> y:float -> Range.t option [@@js.global "caretRangeFromPoint"]
  
  (** @deprecated  *)
  val clear: unit -> unit [@@js.global "clear"]
  
  (** Closes an output stream and forces the sent data to display. *)
  val close: unit -> unit [@@js.global "close"]
  
  (**
    Creates an attribute object with a specified name.
    @param name String that sets the attribute object's name.
  *)
  val createAttribute: string -> Attr.t [@@js.global "createAttribute"]
  val createAttributeNS: namespace:string option -> qualifiedName:string -> Attr.t [@@js.global "createAttributeNS"]
  
  (** Returns a CDATASection node whose data is data. *)
  val createCDATASection: string -> CDATASection.t [@@js.global "createCDATASection"]
  
  (**
    Creates a comment object with the specified data.
    @param data Sets the comment object's data.
  *)
  val createComment: string -> Comment.t [@@js.global "createComment"]
  
  (** Creates a new document. *)
  val createDocumentFragment: unit -> DocumentFragment.t [@@js.global "createDocumentFragment"]
  
  (**
    Creates an instance of the element for the specified tag.
    @param tagName The name of an element.
  *)
  val createElement: tagName:'K -> ?options:ElementCreationOptions.t -> unit -> (* FIXME: unknown type 'HTMLElementTagNameMap[K]' *)any [@@js.global "createElement"]
  
  (** @deprecated  *)
  val createElement': tagName:'K -> ?options:ElementCreationOptions.t -> unit -> (* FIXME: unknown type 'HTMLElementDeprecatedTagNameMap[K]' *)any [@@js.global "createElement"]
  
  (** Creates an instance of the element for the specified tag. *)
  val createElement'': tagName:string -> ?options:ElementCreationOptions.t -> unit -> HTMLElement.t [@@js.global "createElement"]
  
  (**
    Returns an element with namespace namespace. Its namespace prefix will be everything before ":" (U+003E) in qualifiedName or null. Its local name will be everything after ":" (U+003E) in qualifiedName or qualifiedName.
    
    If localName does not match the Name production an "InvalidCharacterError" DOMException will be thrown.
    
    If one of the following conditions is true a "NamespaceError" DOMException will be thrown:
    
    localName does not match the QName production.
    Namespace prefix is not null and namespace is the empty string.
    Namespace prefix is "xml" and namespace is not the XML namespace.
    qualifiedName or namespace prefix is "xmlns" and namespace is not the XMLNS namespace.
    namespace is the XMLNS namespace and neither qualifiedName nor namespace prefix is "xmlns".
    
    When supplied, options's is can be used to create a customized built-in element.
  *)
  val createElementNS: namespaceURI:([`L_s403_http___www_w3_org_1999_xhtml[@js "http://www.w3.org/1999/xhtml"]] [@js.enum]) -> qualifiedName:string -> HTMLElement.t [@@js.global "createElementNS"]
  
  (**
    Returns an element with namespace namespace. Its namespace prefix will be everything before ":" (U+003E) in qualifiedName or null. Its local name will be everything after ":" (U+003E) in qualifiedName or qualifiedName.
    
    If localName does not match the Name production an "InvalidCharacterError" DOMException will be thrown.
    
    If one of the following conditions is true a "NamespaceError" DOMException will be thrown:
    
    localName does not match the QName production.
    Namespace prefix is not null and namespace is the empty string.
    Namespace prefix is "xml" and namespace is not the XML namespace.
    qualifiedName or namespace prefix is "xmlns" and namespace is not the XMLNS namespace.
    namespace is the XMLNS namespace and neither qualifiedName nor namespace prefix is "xmlns".
    
    When supplied, options's is can be used to create a customized built-in element.
  *)
  val createElementNS': namespaceURI:([`L_s404_http___www_w3_org_2000_svg[@js "http://www.w3.org/2000/svg"]] [@js.enum]) -> qualifiedName:'K -> (* FIXME: unknown type 'SVGElementTagNameMap[K]' *)any [@@js.global "createElementNS"]
  
  (**
    Returns an element with namespace namespace. Its namespace prefix will be everything before ":" (U+003E) in qualifiedName or null. Its local name will be everything after ":" (U+003E) in qualifiedName or qualifiedName.
    
    If localName does not match the Name production an "InvalidCharacterError" DOMException will be thrown.
    
    If one of the following conditions is true a "NamespaceError" DOMException will be thrown:
    
    localName does not match the QName production.
    Namespace prefix is not null and namespace is the empty string.
    Namespace prefix is "xml" and namespace is not the XML namespace.
    qualifiedName or namespace prefix is "xmlns" and namespace is not the XMLNS namespace.
    namespace is the XMLNS namespace and neither qualifiedName nor namespace prefix is "xmlns".
    
    When supplied, options's is can be used to create a customized built-in element.
  *)
  val createElementNS'': namespaceURI:([`L_s404_http___www_w3_org_2000_svg[@js "http://www.w3.org/2000/svg"]] [@js.enum]) -> qualifiedName:string -> SVGElement.t [@@js.global "createElementNS"]
  
  (**
    Returns an element with namespace namespace. Its namespace prefix will be everything before ":" (U+003E) in qualifiedName or null. Its local name will be everything after ":" (U+003E) in qualifiedName or qualifiedName.
    
    If localName does not match the Name production an "InvalidCharacterError" DOMException will be thrown.
    
    If one of the following conditions is true a "NamespaceError" DOMException will be thrown:
    
    localName does not match the QName production.
    Namespace prefix is not null and namespace is the empty string.
    Namespace prefix is "xml" and namespace is not the XML namespace.
    qualifiedName or namespace prefix is "xmlns" and namespace is not the XMLNS namespace.
    namespace is the XMLNS namespace and neither qualifiedName nor namespace prefix is "xmlns".
    
    When supplied, options's is can be used to create a customized built-in element.
  *)
  val createElementNS''': namespaceURI:string option -> qualifiedName:string -> ?options:ElementCreationOptions.t -> unit -> Element.t [@@js.global "createElementNS"]
  
  (**
    Returns an element with namespace namespace. Its namespace prefix will be everything before ":" (U+003E) in qualifiedName or null. Its local name will be everything after ":" (U+003E) in qualifiedName or qualifiedName.
    
    If localName does not match the Name production an "InvalidCharacterError" DOMException will be thrown.
    
    If one of the following conditions is true a "NamespaceError" DOMException will be thrown:
    
    localName does not match the QName production.
    Namespace prefix is not null and namespace is the empty string.
    Namespace prefix is "xml" and namespace is not the XML namespace.
    qualifiedName or namespace prefix is "xmlns" and namespace is not the XMLNS namespace.
    namespace is the XMLNS namespace and neither qualifiedName nor namespace prefix is "xmlns".
    
    When supplied, options's is can be used to create a customized built-in element.
  *)
  val createElementNS'''': namespace:string option -> qualifiedName:string -> ?options:([`U1 of string | `U2 of ElementCreationOptions.t] [@js.union]) -> unit -> Element.t [@@js.global "createElementNS"]
  val createEvent: ([`L_s5_AnimationEvent[@js "AnimationEvent"]] [@js.enum]) -> AnimationEvent.t [@@js.global "createEvent"]
  val createEvent': ([`L_s6_AnimationPlaybackEvent[@js "AnimationPlaybackEvent"]] [@js.enum]) -> AnimationPlaybackEvent.t [@@js.global "createEvent"]
  val createEvent'': ([`L_s7_AudioProcessingEvent[@js "AudioProcessingEvent"]] [@js.enum]) -> AudioProcessingEvent.t [@@js.global "createEvent"]
  val createEvent''': ([`L_s8_BeforeUnloadEvent[@js "BeforeUnloadEvent"]] [@js.enum]) -> BeforeUnloadEvent.t [@@js.global "createEvent"]
  val createEvent'''': ([`L_s9_BlobEvent[@js "BlobEvent"]] [@js.enum]) -> BlobEvent.t [@@js.global "createEvent"]
  val createEvent''''': ([`L_s10_ClipboardEvent[@js "ClipboardEvent"]] [@js.enum]) -> ClipboardEvent.t [@@js.global "createEvent"]
  val createEvent'''''': ([`L_s11_CloseEvent[@js "CloseEvent"]] [@js.enum]) -> CloseEvent.t [@@js.global "createEvent"]
  val createEvent''''''': ([`L_s12_CompositionEvent[@js "CompositionEvent"]] [@js.enum]) -> CompositionEvent.t [@@js.global "createEvent"]
  val createEvent'''''''': ([`L_s13_CustomEvent[@js "CustomEvent"]] [@js.enum]) -> CustomEvent.t_0 [@@js.global "createEvent"]
  val createEvent''''''''': ([`L_s14_DeviceMotionEvent[@js "DeviceMotionEvent"]] [@js.enum]) -> DeviceMotionEvent.t [@@js.global "createEvent"]
  val createEvent'''''''''': ([`L_s15_DeviceOrientationEvent[@js "DeviceOrientationEvent"]] [@js.enum]) -> DeviceOrientationEvent.t [@@js.global "createEvent"]
  val createEvent''''''''''': ([`L_s16_DragEvent[@js "DragEvent"]] [@js.enum]) -> DragEvent.t [@@js.global "createEvent"]
  val createEvent'''''''''''': ([`L_s25_ErrorEvent[@js "ErrorEvent"]] [@js.enum]) -> ErrorEvent.t [@@js.global "createEvent"]
  val createEvent''''''''''''': ([`L_s26_FocusEvent[@js "FocusEvent"]] [@js.enum]) -> FocusEvent.t [@@js.global "createEvent"]
  val createEvent'''''''''''''': ([`L_s27_FontFaceSetLoadEvent[@js "FontFaceSetLoadEvent"]] [@js.enum]) -> FontFaceSetLoadEvent.t [@@js.global "createEvent"]
  val createEvent''''''''''''''': ([`L_s28_FormDataEvent[@js "FormDataEvent"]] [@js.enum]) -> FormDataEvent.t [@@js.global "createEvent"]
  val createEvent'''''''''''''''': ([`L_s29_GamepadEvent[@js "GamepadEvent"]] [@js.enum]) -> GamepadEvent.t [@@js.global "createEvent"]
  val createEvent''''''''''''''''': ([`L_s31_HashChangeEvent[@js "HashChangeEvent"]] [@js.enum]) -> HashChangeEvent.t [@@js.global "createEvent"]
  val createEvent'''''''''''''''''': ([`L_s32_IDBVersionChangeEvent[@js "IDBVersionChangeEvent"]] [@js.enum]) -> IDBVersionChangeEvent.t [@@js.global "createEvent"]
  val createEvent''''''''''''''''''': ([`L_s33_InputEvent[@js "InputEvent"]] [@js.enum]) -> InputEvent.t [@@js.global "createEvent"]
  val createEvent'''''''''''''''''''': ([`L_s35_KeyboardEvent[@js "KeyboardEvent"]] [@js.enum]) -> KeyboardEvent.t [@@js.global "createEvent"]
  val createEvent''''''''''''''''''''': ([`L_s36_MediaEncryptedEvent[@js "MediaEncryptedEvent"]] [@js.enum]) -> MediaEncryptedEvent.t [@@js.global "createEvent"]
  val createEvent'''''''''''''''''''''': ([`L_s37_MediaKeyMessageEvent[@js "MediaKeyMessageEvent"]] [@js.enum]) -> MediaKeyMessageEvent.t [@@js.global "createEvent"]
  val createEvent''''''''''''''''''''''': ([`L_s38_MediaQueryListEvent[@js "MediaQueryListEvent"]] [@js.enum]) -> MediaQueryListEvent.t [@@js.global "createEvent"]
  val createEvent'''''''''''''''''''''''': ([`L_s39_MediaRecorderErrorEvent[@js "MediaRecorderErrorEvent"]] [@js.enum]) -> MediaRecorderErrorEvent.t [@@js.global "createEvent"]
  val createEvent''''''''''''''''''''''''': ([`L_s40_MediaStreamTrackEvent[@js "MediaStreamTrackEvent"]] [@js.enum]) -> MediaStreamTrackEvent.t [@@js.global "createEvent"]
  val createEvent'''''''''''''''''''''''''': ([`L_s41_MessageEvent[@js "MessageEvent"]] [@js.enum]) -> MessageEvent.t_0 [@@js.global "createEvent"]
  val createEvent''''''''''''''''''''''''''': ([`L_s42_MouseEvent[@js "MouseEvent"]] [@js.enum]) -> MouseEvent.t [@@js.global "createEvent"]
  val createEvent'''''''''''''''''''''''''''': ([`L_s43_MouseEvents[@js "MouseEvents"]] [@js.enum]) -> MouseEvent.t [@@js.global "createEvent"]
  val createEvent''''''''''''''''''''''''''''': ([`L_s44_MutationEvent[@js "MutationEvent"]] [@js.enum]) -> MutationEvent.t [@@js.global "createEvent"]
  val createEvent'''''''''''''''''''''''''''''': ([`L_s45_MutationEvents[@js "MutationEvents"]] [@js.enum]) -> MutationEvent.t [@@js.global "createEvent"]
  val createEvent''''''''''''''''''''''''''''''': ([`L_s54_OfflineAudioCompletionEvent[@js "OfflineAudioCompletionEvent"]] [@js.enum]) -> OfflineAudioCompletionEvent.t [@@js.global "createEvent"]
  val createEvent'''''''''''''''''''''''''''''''': ([`L_s55_PageTransitionEvent[@js "PageTransitionEvent"]] [@js.enum]) -> PageTransitionEvent.t [@@js.global "createEvent"]
  val createEvent''''''''''''''''''''''''''''''''': ([`L_s56_PaymentMethodChangeEvent[@js "PaymentMethodChangeEvent"]] [@js.enum]) -> PaymentMethodChangeEvent.t [@@js.global "createEvent"]
  val createEvent'''''''''''''''''''''''''''''''''': ([`L_s57_PaymentRequestUpdateEvent[@js "PaymentRequestUpdateEvent"]] [@js.enum]) -> PaymentRequestUpdateEvent.t [@@js.global "createEvent"]
  val createEvent''''''''''''''''''''''''''''''''''': ([`L_s58_PointerEvent[@js "PointerEvent"]] [@js.enum]) -> PointerEvent.t [@@js.global "createEvent"]
  val createEvent'''''''''''''''''''''''''''''''''''': ([`L_s59_PopStateEvent[@js "PopStateEvent"]] [@js.enum]) -> PopStateEvent.t [@@js.global "createEvent"]
  val createEvent''''''''''''''''''''''''''''''''''''': ([`L_s60_ProgressEvent[@js "ProgressEvent"]] [@js.enum]) -> ProgressEvent.t_0 [@@js.global "createEvent"]
  val createEvent'''''''''''''''''''''''''''''''''''''': ([`L_s61_PromiseRejectionEvent[@js "PromiseRejectionEvent"]] [@js.enum]) -> PromiseRejectionEvent.t [@@js.global "createEvent"]
  val createEvent''''''''''''''''''''''''''''''''''''''': ([`L_s62_RTCDTMFToneChangeEvent[@js "RTCDTMFToneChangeEvent"]] [@js.enum]) -> RTCDTMFToneChangeEvent.t [@@js.global "createEvent"]
  val createEvent'''''''''''''''''''''''''''''''''''''''': ([`L_s63_RTCDataChannelEvent[@js "RTCDataChannelEvent"]] [@js.enum]) -> RTCDataChannelEvent.t [@@js.global "createEvent"]
  val createEvent''''''''''''''''''''''''''''''''''''''''': ([`L_s64_RTCPeerConnectionIceErrorEvent[@js "RTCPeerConnectionIceErrorEvent"]] [@js.enum]) -> RTCPeerConnectionIceErrorEvent.t [@@js.global "createEvent"]
  val createEvent'''''''''''''''''''''''''''''''''''''''''': ([`L_s65_RTCPeerConnectionIceEvent[@js "RTCPeerConnectionIceEvent"]] [@js.enum]) -> RTCPeerConnectionIceEvent.t [@@js.global "createEvent"]
  val createEvent''''''''''''''''''''''''''''''''''''''''''': ([`L_s66_RTCTrackEvent[@js "RTCTrackEvent"]] [@js.enum]) -> RTCTrackEvent.t [@@js.global "createEvent"]
  val createEvent'''''''''''''''''''''''''''''''''''''''''''': ([`L_s67_SecurityPolicyViolationEvent[@js "SecurityPolicyViolationEvent"]] [@js.enum]) -> SecurityPolicyViolationEvent.t [@@js.global "createEvent"]
  val createEvent''''''''''''''''''''''''''''''''''''''''''''': ([`L_s68_SpeechSynthesisErrorEvent[@js "SpeechSynthesisErrorEvent"]] [@js.enum]) -> SpeechSynthesisErrorEvent.t [@@js.global "createEvent"]
  val createEvent'''''''''''''''''''''''''''''''''''''''''''''': ([`L_s69_SpeechSynthesisEvent[@js "SpeechSynthesisEvent"]] [@js.enum]) -> SpeechSynthesisEvent.t [@@js.global "createEvent"]
  val createEvent''''''''''''''''''''''''''''''''''''''''''''''': ([`L_s70_StorageEvent[@js "StorageEvent"]] [@js.enum]) -> StorageEvent.t [@@js.global "createEvent"]
  val createEvent'''''''''''''''''''''''''''''''''''''''''''''''': ([`L_s71_SubmitEvent[@js "SubmitEvent"]] [@js.enum]) -> SubmitEvent.t [@@js.global "createEvent"]
  val createEvent''''''''''''''''''''''''''''''''''''''''''''''''': ([`L_s72_TouchEvent[@js "TouchEvent"]] [@js.enum]) -> TouchEvent.t [@@js.global "createEvent"]
  val createEvent'''''''''''''''''''''''''''''''''''''''''''''''''': ([`L_s73_TrackEvent[@js "TrackEvent"]] [@js.enum]) -> TrackEvent.t [@@js.global "createEvent"]
  val createEvent''''''''''''''''''''''''''''''''''''''''''''''''''': ([`L_s74_TransitionEvent[@js "TransitionEvent"]] [@js.enum]) -> TransitionEvent.t [@@js.global "createEvent"]
  val createEvent'''''''''''''''''''''''''''''''''''''''''''''''''''': ([`L_s75_UIEvent[@js "UIEvent"]] [@js.enum]) -> UIEvent.t [@@js.global "createEvent"]
  val createEvent''''''''''''''''''''''''''''''''''''''''''''''''''''': ([`L_s76_UIEvents[@js "UIEvents"]] [@js.enum]) -> UIEvent.t [@@js.global "createEvent"]
  val createEvent'''''''''''''''''''''''''''''''''''''''''''''''''''''': ([`L_s89_WebGLContextEvent[@js "WebGLContextEvent"]] [@js.enum]) -> WebGLContextEvent.t [@@js.global "createEvent"]
  val createEvent''''''''''''''''''''''''''''''''''''''''''''''''''''''': ([`L_s90_WheelEvent[@js "WheelEvent"]] [@js.enum]) -> WheelEvent.t [@@js.global "createEvent"]
  val createEvent'''''''''''''''''''''''''''''''''''''''''''''''''''''''': string -> Event.t [@@js.global "createEvent"]
  
  (**
    Creates a NodeIterator object that you can use to traverse filtered lists of nodes or elements in a document.
    @param root The root element or node to start traversing on.
    @param whatToShow The type of nodes or elements to appear in the node list
    @param filter A custom NodeFilter function to use. For more information, see filter. Use null for no filter.
  *)
  val createNodeIterator: root:Node.t -> ?whatToShow:float -> ?filter:NodeFilter.t option -> unit -> NodeIterator.t [@@js.global "createNodeIterator"]
  
  (** Returns a ProcessingInstruction node whose target is target and data is data. If target does not match the Name production an "InvalidCharacterError" DOMException will be thrown. If data contains "?>" an "InvalidCharacterError" DOMException will be thrown. *)
  val createProcessingInstruction: target:string -> data:string -> ProcessingInstruction.t [@@js.global "createProcessingInstruction"]
  
  (** Returns an empty range object that has both of its boundary points positioned at the beginning of the document. *)
  val createRange: unit -> Range.t [@@js.global "createRange"]
  
  (**
    Creates a text string from the specified value.
    @param data String that specifies the nodeValue property of the text node.
  *)
  val createTextNode: string -> Text.t [@@js.global "createTextNode"]
  
  (**
    Creates a TreeWalker object that you can use to traverse filtered lists of nodes or elements in a document.
    @param root The root element or node to start traversing on.
    @param whatToShow The type of nodes or elements to appear in the node list. For more information, see whatToShow.
    @param filter A custom NodeFilter function to use.
  *)
  val createTreeWalker: root:Node.t -> ?whatToShow:float -> ?filter:NodeFilter.t option -> unit -> TreeWalker.t [@@js.global "createTreeWalker"]
  
  (**
    Executes a command on the current document, current selection, or the given range.
    @param commandId String that specifies the command to execute. This command can be any of the command identifiers that can be executed in script.
    @param showUI Display the user interface, defaults to false.
    @param value Value to assign.
    @deprecated 
  *)
  val execCommand: commandId:string -> ?showUI:bool -> ?value:string -> unit -> bool [@@js.global "execCommand"]
  
  (** Stops document's fullscreen element from being displayed fullscreen and resolves promise when done. *)
  val exitFullscreen: unit -> unit Promise.t_1 [@@js.global "exitFullscreen"]
  val exitPictureInPicture: unit -> unit Promise.t_1 [@@js.global "exitPictureInPicture"]
  val exitPointerLock: unit -> unit [@@js.global "exitPointerLock"]
  
  (**
    Returns a reference to the first object with the specified value of the ID attribute.
    @param elementId String that specifies the ID value.
  *)
  val getElementById: string -> HTMLElement.t option [@@js.global "getElementById"]
  
  (** Returns a HTMLCollection of the elements in the object on which the method was invoked (a document or an element) that have all the classes given by classNames. The classNames argument is interpreted as a space-separated list of classes. *)
  val getElementsByClassName: string -> Element.t HTMLCollectionOf.t [@@js.global "getElementsByClassName"]
  
  (**
    Gets a collection of objects based on the value of the NAME or ID attribute.
    @param elementName Gets a collection of objects based on the value of the NAME or ID attribute.
  *)
  val getElementsByName: string -> HTMLElement.t NodeListOf.t [@@js.global "getElementsByName"]
  
  (**
    Retrieves a collection of objects based on the specified element name.
    @param name Specifies the name of an element.
  *)
  val getElementsByTagName: 'K -> (* FIXME: unknown type 'HTMLElementTagNameMap[K]' *)any HTMLCollectionOf.t [@@js.global "getElementsByTagName"]
  
  (** Retrieves a collection of objects based on the specified element name. *)
  val getElementsByTagName': 'K -> (* FIXME: unknown type 'SVGElementTagNameMap[K]' *)any HTMLCollectionOf.t [@@js.global "getElementsByTagName"]
  
  (** Retrieves a collection of objects based on the specified element name. *)
  val getElementsByTagName'': string -> Element.t HTMLCollectionOf.t [@@js.global "getElementsByTagName"]
  
  (**
    If namespace and localName are "*" returns a HTMLCollection of all descendant elements.
    
    If only namespace is "*" returns a HTMLCollection of all descendant elements whose local name is localName.
    
    If only localName is "*" returns a HTMLCollection of all descendant elements whose namespace is namespace.
    
    Otherwise, returns a HTMLCollection of all descendant elements whose namespace is namespace and local name is localName.
  *)
  val getElementsByTagNameNS: namespaceURI:([`L_s403_http___www_w3_org_1999_xhtml[@js "http://www.w3.org/1999/xhtml"]] [@js.enum]) -> localName:string -> HTMLElement.t HTMLCollectionOf.t [@@js.global "getElementsByTagNameNS"]
  
  (**
    If namespace and localName are "*" returns a HTMLCollection of all descendant elements.
    
    If only namespace is "*" returns a HTMLCollection of all descendant elements whose local name is localName.
    
    If only localName is "*" returns a HTMLCollection of all descendant elements whose namespace is namespace.
    
    Otherwise, returns a HTMLCollection of all descendant elements whose namespace is namespace and local name is localName.
  *)
  val getElementsByTagNameNS': namespaceURI:([`L_s404_http___www_w3_org_2000_svg[@js "http://www.w3.org/2000/svg"]] [@js.enum]) -> localName:string -> SVGElement.t HTMLCollectionOf.t [@@js.global "getElementsByTagNameNS"]
  
  (**
    If namespace and localName are "*" returns a HTMLCollection of all descendant elements.
    
    If only namespace is "*" returns a HTMLCollection of all descendant elements whose local name is localName.
    
    If only localName is "*" returns a HTMLCollection of all descendant elements whose namespace is namespace.
    
    Otherwise, returns a HTMLCollection of all descendant elements whose namespace is namespace and local name is localName.
  *)
  val getElementsByTagNameNS'': namespace:string option -> localName:string -> Element.t HTMLCollectionOf.t [@@js.global "getElementsByTagNameNS"]
  
  (** Returns an object representing the current selection of the document that is loaded into the object displaying a webpage. *)
  val getSelection: unit -> Selection.t option [@@js.global "getSelection"]
  
  (** Gets a value indicating whether the object currently has focus. *)
  val hasFocus: unit -> bool [@@js.global "hasFocus"]
  val hasStorageAccess: unit -> bool Promise.t_1 [@@js.global "hasStorageAccess"]
  
  (**
    Returns a copy of node. If deep is true, the copy also includes the node's descendants.
    
    If node is a document or a shadow root, throws a "NotSupportedError" DOMException.
  *)
  val importNode: node:'T -> ?deep:bool -> unit -> 'T [@@js.global "importNode"]
  
  (**
    Opens a new window and loads a document specified by a given URL. Also, opens a new window that uses the url parameter and the name parameter to collect the output of the write method and the writeln method.
    @param url Specifies a MIME type for the document.
    @param name Specifies the name of the window. This name is used as the value for the TARGET attribute on a form or an anchor element.
    @param features Contains a list of items separated by commas. Each item consists of an option and a value, separated by an equals sign (for example, "fullscreen=yes, toolbar=yes"). The following values are supported.
    @param replace Specifies whether the existing entry for the document is replaced in the history list.
  *)
  val open_: ?unused1:string -> ?unused2:string -> unit -> Document.t [@@js.global "open"]
  
  (** Opens a new window and loads a document specified by a given URL. Also, opens a new window that uses the url parameter and the name parameter to collect the output of the write method and the writeln method. *)
  val open_': url:([`U1 of string | `U2 of URL.t] [@js.union]) -> name:string -> features:string -> WindowProxy.t option [@@js.global "open"]
  
  (**
    Returns a Boolean value that indicates whether a specified command can be successfully executed using execCommand, given the current state of the document.
    @param commandId Specifies a command identifier.
    @deprecated 
  *)
  val queryCommandEnabled: string -> bool [@@js.global "queryCommandEnabled"]
  
  (**
    Returns a Boolean value that indicates whether the specified command is in the indeterminate state.
    @param commandId String that specifies a command identifier.
  *)
  val queryCommandIndeterm: string -> bool [@@js.global "queryCommandIndeterm"]
  
  (**
    Returns a Boolean value that indicates the current state of the command.
    @param commandId String that specifies a command identifier.
    @deprecated 
  *)
  val queryCommandState: string -> bool [@@js.global "queryCommandState"]
  
  (**
    Returns a Boolean value that indicates whether the current command is supported on the current range.
    @param commandId Specifies a command identifier.
    @deprecated 
  *)
  val queryCommandSupported: string -> bool [@@js.global "queryCommandSupported"]
  
  (**
    Returns the current value of the document, range, or current selection for the given command.
    @param commandId String that specifies a command identifier.
  *)
  val queryCommandValue: string -> string [@@js.global "queryCommandValue"]
  
  (** @deprecated  *)
  val releaseEvents: unit -> unit [@@js.global "releaseEvents"]
  val requestStorageAccess: unit -> unit Promise.t_1 [@@js.global "requestStorageAccess"]
  
  (**
    Writes one or more HTML expressions to a document in the specified window.
    @param content Specifies the text and HTML tags to write.
  *)
  val write: (string list [@js.variadic]) -> unit [@@js.global "write"]
  
  (**
    Writes one or more HTML expressions, followed by a carriage return, to a document in the specified window.
    @param content The text and HTML tags to write.
  *)
  val writeln: (string list [@js.variadic]) -> unit [@@js.global "writeln"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: type_:'K -> listener:(this:Document.t -> ev:(* FIXME: unknown type 'DocumentEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.global "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.global "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: type_:'K -> listener:(this:Document.t -> ev:(* FIXME: unknown type 'DocumentEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.global "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.global "removeEventListener"]
end
module[@js.scope "customElements"] CustomElementsStatic : sig
  val define: name:string -> constructor:CustomElementConstructor.t -> ?options:ElementDefinitionOptions.t -> unit -> unit [@@js.global "define"]
  val get_: string -> CustomElementConstructor.t option [@@js.global "get"]
  val upgrade: Node.t -> unit [@@js.global "upgrade"]
  val whenDefined: string -> CustomElementConstructor.t Promise.t_1 [@@js.global "whenDefined"]
end
module[@js.scope "crypto"] CryptoStatic : sig
  
  (** Available only in secure contexts. *)
  val subtle: unit -> SubtleCrypto.t [@@js.get "subtle"]
  val getRandomValues: 'T -> 'T [@@js.global "getRandomValues"]
  
  (** Available only in secure contexts. *)
  val randomUUID: unit -> string [@@js.global "randomUUID"]
end
module[@js.scope "console"] ConsoleStatic : sig
  
  (**
    `console.assert()` writes a message if `value` is \[falsy\](https://developer.mozilla.org/en-US/docs/Glossary/Falsy) or omitted. It only
    writes a message and does not otherwise affect execution. The output always
    starts with `"Assertion failed"`. If provided, `message` is formatted using `util.format()`.
    
    If `value` is \[truthy\](https://developer.mozilla.org/en-US/docs/Glossary/Truthy), nothing happens.
    
    ```js
    console.assert(true, 'does nothing');
    
    console.assert(false, 'Whoops %s work', 'didn\'t');
    // Assertion failed: Whoops didn't work
    
    console.assert();
    // Assertion failed
    ```
  *)
  val assert_: ?condition:bool -> data:(any list [@js.variadic]) -> unit -> unit [@@js.global "assert"]
  
  (**
    When `stdout` is a TTY, calling `console.clear()` will attempt to clear the
    TTY. When `stdout` is not a TTY, this method does nothing.
    
    The specific operation of `console.clear()` can vary across operating systems
    and terminal types. For most Linux operating systems, `console.clear()`operates similarly to the `clear` shell command. On Windows, `console.clear()`will clear only the output in the
    current terminal viewport for the Node.js
    binary.
  *)
  val clear: unit -> unit [@@js.global "clear"]
  
  (**
    Maintains an internal counter specific to `label` and outputs to `stdout` the
    number of times `console.count()` has been called with the given `label`.
    
    ```js
    > console.count()
    default: 1
    undefined
    > console.count('default')
    default: 2
    undefined
    > console.count('abc')
    abc: 1
    undefined
    > console.count('xyz')
    xyz: 1
    undefined
    > console.count('abc')
    abc: 2
    undefined
    > console.count()
    default: 3
    undefined
    >
    ```
  *)
  val count: ?label:string -> unit -> unit [@@js.global "count"]
  
  (**
    Resets the internal counter specific to `label`.
    
    ```js
    > console.count('abc');
    abc: 1
    undefined
    > console.countReset('abc');
    undefined
    > console.count('abc');
    abc: 1
    undefined
    >
    ```
  *)
  val countReset: ?label:string -> unit -> unit [@@js.global "countReset"]
  
  (**
    The `console.debug()` function is an alias for 
    \{\@link 
    log
    \}
    .
  *)
  val debug: (any list [@js.variadic]) -> unit [@@js.global "debug"]
  
  (**
    Uses `util.inspect()` on `obj` and prints the resulting string to `stdout`.
    This function bypasses any custom `inspect()` function defined on `obj`.
  *)
  val dir: ?item:any -> ?options:any -> unit -> unit [@@js.global "dir"]
  
  (**
    This method calls `console.log()` passing it the arguments received.
    This method does not produce any XML formatting.
  *)
  val dirxml: (any list [@js.variadic]) -> unit [@@js.global "dirxml"]
  
  (**
    Prints to `stderr` with newline. Multiple arguments can be passed, with the
    first used as the primary message and all additional used as substitution
    values similar to \[`printf(3)`\](http://man7.org/linux/man-pages/man3/printf.3.html) (the arguments are all passed to `util.format()`).
    
    ```js
    const code = 5;
    console.error('error #%d', code);
    // Prints: error #5, to stderr
    console.error('error', code);
    // Prints: error 5, to stderr
    ```
    
    If formatting elements (e.g. `%d`) are not found in the first string then `util.inspect()` is called on each argument and the resulting string
    values are concatenated. See `util.format()` for more information.
  *)
  val error: (any list [@js.variadic]) -> unit [@@js.global "error"]
  
  (**
    Increases indentation of subsequent lines by spaces for `groupIndentation`length.
    
    If one or more `label`s are provided, those are printed first without the
    additional indentation.
  *)
  val group: (any list [@js.variadic]) -> unit [@@js.global "group"]
  
  (**
    An alias for 
    \{\@link 
    group
    \}
    .
  *)
  val groupCollapsed: (any list [@js.variadic]) -> unit [@@js.global "groupCollapsed"]
  
  (** Decreases indentation of subsequent lines by spaces for `groupIndentation`length. *)
  val groupEnd: unit -> unit [@@js.global "groupEnd"]
  
  (**
    The `console.info()` function is an alias for 
    \{\@link 
    log
    \}
    .
  *)
  val info: (any list [@js.variadic]) -> unit [@@js.global "info"]
  
  (**
    Prints to `stdout` with newline. Multiple arguments can be passed, with the
    first used as the primary message and all additional used as substitution
    values similar to \[`printf(3)`\](http://man7.org/linux/man-pages/man3/printf.3.html) (the arguments are all passed to `util.format()`).
    
    ```js
    const count = 5;
    console.log('count: %d', count);
    // Prints: count: 5, to stdout
    console.log('count:', count);
    // Prints: count: 5, to stdout
    ```
    
    See `util.format()` for more information.
  *)
  val log: (any list [@js.variadic]) -> unit [@@js.global "log"]
  
  (**
    Try to construct a table with the columns of the properties of `tabularData`(or use `properties`) and rows of `tabularData` and log it. Falls back to just
    logging the argument if it can’t be parsed as tabular.
    
    ```js
    // These can't be parsed as tabular data
    console.table(Symbol());
    // Symbol()
    
    console.table(undefined);
    // undefined
    
    console.table(\[\{ a: 1, b: 'Y' \}, \{ a: 'Z', b: 2 \}\]);
    // ┌─────────┬─────┬─────┐
    // │ (index) │  a  │  b  │
    // ├─────────┼─────┼─────┤
    // │    0    │  1  │ 'Y' │
    // │    1    │ 'Z' │  2  │
    // └─────────┴─────┴─────┘
    
    console.table(\[\{ a: 1, b: 'Y' \}, \{ a: 'Z', b: 2 \}\], \['a'\]);
    // ┌─────────┬─────┐
    // │ (index) │  a  │
    // ├─────────┼─────┤
    // │    0    │  1  │
    // │    1    │ 'Z' │
    // └─────────┴─────┘
    ```
  *)
  val table: ?tabularData:any -> ?properties:string list -> unit -> unit [@@js.global "table"]
  
  (**
    Starts a timer that can be used to compute the duration of an operation. Timers
    are identified by a unique `label`. Use the same `label` when calling 
    \{\@link 
    timeEnd
    \}
     to stop the timer and output the elapsed time in
    suitable time units to `stdout`. For example, if the elapsed
    time is 3869ms, `console.timeEnd()` displays "3.869s".
  *)
  val time: ?label:string -> unit -> unit [@@js.global "time"]
  
  (**
    Stops a timer that was previously started by calling 
    \{\@link 
    time
    \}
     and
    prints the result to `stdout`:
    
    ```js
    console.time('100-elements');
    for (let i = 0; i < 100; i++) \{\}
    console.timeEnd('100-elements');
    // prints 100-elements: 225.438ms
    ```
  *)
  val timeEnd: ?label:string -> unit -> unit [@@js.global "timeEnd"]
  
  (**
    For a timer that was previously started by calling 
    \{\@link 
    time
    \}
    , prints
    the elapsed time and other `data` arguments to `stdout`:
    
    ```js
    console.time('process');
    const value = expensiveProcess1(); // Returns 42
    console.timeLog('process', value);
    // Prints "process: 365.227ms 42".
    doExpensiveProcess2(value);
    console.timeEnd('process');
    ```
  *)
  val timeLog: ?label:string -> data:(any list [@js.variadic]) -> unit -> unit [@@js.global "timeLog"]
  
  (**
    This method does not display anything unless used in the inspector.
     Adds an event with the label `label` to the Timeline panel of the inspector.
  *)
  val timeStamp: ?label:string -> unit -> unit [@@js.global "timeStamp"]
  
  (**
    Prints to `stderr` the string `'Trace: '`, followed by the `util.format()` formatted message and stack trace to the current position in the code.
    
    ```js
    console.trace('Show me');
    // Prints: (stack trace will vary based on where trace is called)
    //  Trace: Show me
    //    at repl:2:9
    //    at REPLServer.defaultEval (repl.js:248:27)
    //    at bound (domain.js:287:14)
    //    at REPLServer.runBound \[as eval\] (domain.js:300:12)
    //    at REPLServer.<anonymous> (repl.js:412:12)
    //    at emitOne (events.js:82:20)
    //    at REPLServer.emit (events.js:169:7)
    //    at REPLServer.Interface._onLine (readline.js:210:10)
    //    at REPLServer.Interface._line (readline.js:549:8)
    //    at REPLServer.Interface._ttyWrite (readline.js:826:14)
    ```
  *)
  val trace: (any list [@js.variadic]) -> unit [@@js.global "trace"]
  
  (**
    The `console.warn()` function is an alias for 
    \{\@link 
    error
    \}
    .
  *)
  val warn: (any list [@js.variadic]) -> unit [@@js.global "warn"]
end
module[@js.scope "clientInformation"] ClientInformationStatic : sig
  
  (** Available only in secure contexts. *)
  val requestMediaKeySystemAccess: keySystem:string -> supportedConfigurations:MediaKeySystemConfiguration.t Iterable.t_1 -> MediaKeySystemAccess.t Promise.t_1 [@@js.global "requestMediaKeySystemAccess"]
  val vibrate: float Iterable.t_1 -> bool [@@js.global "vibrate"]
  
  (** Available only in secure contexts. *)
  val clipboard: unit -> Clipboard.t [@@js.get "clipboard"]
  
  (** Available only in secure contexts. *)
  val credentials: unit -> CredentialsContainer.t [@@js.get "credentials"]
  val doNotTrack: unit -> string option [@@js.get "doNotTrack"]
  val geolocation: unit -> Geolocation.t [@@js.get "geolocation"]
  val maxTouchPoints: unit -> float [@@js.get "maxTouchPoints"]
  val mediaCapabilities: unit -> MediaCapabilities.t [@@js.get "mediaCapabilities"]
  
  (** Available only in secure contexts. *)
  val mediaDevices: unit -> MediaDevices.t [@@js.get "mediaDevices"]
  val mediaSession: unit -> MediaSession.t [@@js.get "mediaSession"]
  val permissions: unit -> Permissions.t [@@js.get "permissions"]
  
  (** Available only in secure contexts. *)
  val serviceWorker: unit -> ServiceWorkerContainer.t [@@js.get "serviceWorker"]
  
  (** Available only in secure contexts. *)
  val canShare: ?data:ShareData.t -> unit -> bool [@@js.global "canShare"]
  val getGamepads: unit -> Gamepad.t option list [@@js.global "getGamepads"]
  
  (** Available only in secure contexts. *)
  val requestMediaKeySystemAccess': keySystem:string -> supportedConfigurations:MediaKeySystemConfiguration.t list -> MediaKeySystemAccess.t Promise.t_1 [@@js.global "requestMediaKeySystemAccess"]
  val sendBeacon: url:([`U1 of string | `U2 of URL.t] [@js.union]) -> ?data:BodyInit.t option -> unit -> bool [@@js.global "sendBeacon"]
  
  (** Available only in secure contexts. *)
  val share: ?data:ShareData.t -> unit -> unit Promise.t_1 [@@js.global "share"]
  val vibrate': VibratePattern.t -> bool [@@js.global "vibrate"]
end
module[@js.scope "caches"] CachesStatic : sig
  val delete: string -> bool Promise.t_1 [@@js.global "delete"]
  val has: string -> bool Promise.t_1 [@@js.global "has"]
  val keys: unit -> string list Promise.t_1 [@@js.global "keys"]
  val match_: request:RequestInfo.t -> ?options:MultiCacheQueryOptions.t -> unit -> Response.t option Promise.t_1 [@@js.global "match"]
  val open_: string -> Cache.t Promise.t_1 [@@js.global "open"]
end

(** An XSLTProcessor applies an XSLT stylesheet transformation to an XML document to produce a new XML document as output. It has methods to load the XSLT stylesheet, to manipulate <xsl:param> parameter values, and to apply the transformation to documents. *)
module[@js.scope "XSLTProcessor"] XSLTProcessor : sig
  type t = [`XSLTProcessor] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`XSLTProcessor]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`XSLTProcessor]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `XSLTProcessor ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val clearParameters: 'tags this -> unit [@@js.call "clearParameters"]
  val getParameter: 'tags this -> namespaceURI:string option -> localName:string -> any [@@js.call "getParameter"]
  val importStylesheet: 'tags this -> style:Node.t -> unit [@@js.call "importStylesheet"]
  val removeParameter: 'tags this -> namespaceURI:string option -> localName:string -> unit [@@js.call "removeParameter"]
  val reset: 'tags this -> unit [@@js.call "reset"]
  val setParameter: 'tags this -> namespaceURI:string option -> localName:string -> value:any -> unit [@@js.call "setParameter"]
  val transformToDocument: 'tags this -> source:Node.t -> Document.t [@@js.call "transformToDocument"]
  val transformToFragment: 'tags this -> source:Node.t -> output:Document.t -> DocumentFragment.t [@@js.call "transformToFragment"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** The XPathEvaluator interface allows to compile and evaluate XPath expressions. *)
module[@js.scope "XPathEvaluator"] XPathEvaluator : sig
  type t = [`XPathEvaluator | `XPathEvaluatorBase] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`XPathEvaluator | `XPathEvaluatorBase]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`XPathEvaluator | `XPathEvaluatorBase]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `XPathEvaluator ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Provides the serializeToString() method to construct an XML string representing a DOM tree. *)
module[@js.scope "XMLSerializer"] XMLSerializer : sig
  type t = [`XMLSerializer] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`XMLSerializer]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`XMLSerializer]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `XMLSerializer ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val serializeToString: 'tags this -> root:Node.t -> string [@@js.call "serializeToString"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module XMLHttpRequestResponseType : sig
  type t = ([`L_s0[@js ""] | `L_s127_arraybuffer[@js "arraybuffer"] | `L_s161_blob[@js "blob"] | `L_s272_document[@js "document"] | `L_s440_json[@js "json"] | `L_s787_text[@js "text"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end

(** Use XMLHttpRequest (XHR) objects to interact with servers. You can retrieve data from a URL without having to do a full page refresh. This enables a Web page to update just part of a page without disrupting what the user is doing. *)
module[@js.scope "XMLHttpRequest"] rec XMLHttpRequest : sig
  type t = [`EventTarget | `XMLHttpRequest | `XMLHttpRequestEventTarget] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventTarget | `XMLHttpRequest | `XMLHttpRequestEventTarget]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventTarget | `XMLHttpRequest | `XMLHttpRequestEventTarget]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `XMLHttpRequest ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_onreadystatechange: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onreadystatechange"]
  val set_onreadystatechange: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onreadystatechange"]
  
  (** Returns client's state. *)
  val get_readyState: 'tags this -> float [@@js.get "readyState"]
  
  (** Returns the response body. *)
  val get_response: 'tags this -> any [@@js.get "response"]
  
  (**
    Returns response as text.
    
    Throws an "InvalidStateError" DOMException if responseType is not the empty string or "text".
  *)
  val get_responseText: 'tags this -> string [@@js.get "responseText"]
  
  (**
    Returns the response type.
    
    Can be set to change the response type. Values are: the empty string (default), "arraybuffer", "blob", "document", "json", and "text".
    
    When set: setting to "document" is ignored if current global object is not a Window object.
    
    When set: throws an "InvalidStateError" DOMException if state is loading or done.
    
    When set: throws an "InvalidAccessError" DOMException if the synchronous flag is set and current global object is a Window object.
  *)
  val get_responseType: 'tags this -> XMLHttpRequestResponseType.t [@@js.get "responseType"]
  
  (**
    Returns the response type.
    
    Can be set to change the response type. Values are: the empty string (default), "arraybuffer", "blob", "document", "json", and "text".
    
    When set: setting to "document" is ignored if current global object is not a Window object.
    
    When set: throws an "InvalidStateError" DOMException if state is loading or done.
    
    When set: throws an "InvalidAccessError" DOMException if the synchronous flag is set and current global object is a Window object.
  *)
  val set_responseType: 'tags this -> XMLHttpRequestResponseType.t -> unit [@@js.set "responseType"]
  val get_responseURL: 'tags this -> string [@@js.get "responseURL"]
  
  (**
    Returns the response as document.
    
    Throws an "InvalidStateError" DOMException if responseType is not the empty string or "document".
  *)
  val get_responseXML: 'tags this -> Document.t option [@@js.get "responseXML"]
  val get_status: 'tags this -> float [@@js.get "status"]
  val get_statusText: 'tags this -> string [@@js.get "statusText"]
  
  (**
    Can be set to a time in milliseconds. When set to a non-zero value will cause fetching to terminate after the given time has passed. When the time has passed, the request has not yet completed, and this's synchronous flag is unset, a timeout event will then be dispatched, or a "TimeoutError" DOMException will be thrown otherwise (for the send() method).
    
    When set: throws an "InvalidAccessError" DOMException if the synchronous flag is set and current global object is a Window object.
  *)
  val get_timeout: 'tags this -> float [@@js.get "timeout"]
  
  (**
    Can be set to a time in milliseconds. When set to a non-zero value will cause fetching to terminate after the given time has passed. When the time has passed, the request has not yet completed, and this's synchronous flag is unset, a timeout event will then be dispatched, or a "TimeoutError" DOMException will be thrown otherwise (for the send() method).
    
    When set: throws an "InvalidAccessError" DOMException if the synchronous flag is set and current global object is a Window object.
  *)
  val set_timeout: 'tags this -> float -> unit [@@js.set "timeout"]
  
  (** Returns the associated XMLHttpRequestUpload object. It can be used to gather transmission information when data is transferred to a server. *)
  val get_upload: 'tags this -> XMLHttpRequestUpload.t [@@js.get "upload"]
  
  (**
    True when credentials are to be included in a cross-origin request. False when they are to be excluded in a cross-origin request and when cookies are to be ignored in its response. Initially false.
    
    When set: throws an "InvalidStateError" DOMException if state is not unsent or opened, or if the send() flag is set.
  *)
  val get_withCredentials: 'tags this -> bool [@@js.get "withCredentials"]
  
  (**
    True when credentials are to be included in a cross-origin request. False when they are to be excluded in a cross-origin request and when cookies are to be ignored in its response. Initially false.
    
    When set: throws an "InvalidStateError" DOMException if state is not unsent or opened, or if the send() flag is set.
  *)
  val set_withCredentials: 'tags this -> bool -> unit [@@js.set "withCredentials"]
  
  (** Cancels any network activity. *)
  val abort: 'tags this -> unit [@@js.call "abort"]
  val getAllResponseHeaders: 'tags this -> string [@@js.call "getAllResponseHeaders"]
  val getResponseHeader: 'tags this -> name:string -> string option [@@js.call "getResponseHeader"]
  
  (**
    Sets the request method, request URL, and synchronous flag.
    
    Throws a "SyntaxError" DOMException if either method is not a valid method or url cannot be parsed.
    
    Throws a "SecurityError" DOMException if method is a case-insensitive match for `CONNECT`, `TRACE`, or `TRACK`.
    
    Throws an "InvalidAccessError" DOMException if async is false, current global object is a Window object, and the timeout attribute is not zero or the responseType attribute is not the empty string.
  *)
  val open_: 'tags this -> method_:string -> url:([`U1 of string | `U2 of URL.t] [@js.union]) -> unit [@@js.call "open"]
  
  (**
    Sets the request method, request URL, and synchronous flag.
    
    Throws a "SyntaxError" DOMException if either method is not a valid method or url cannot be parsed.
    
    Throws a "SecurityError" DOMException if method is a case-insensitive match for `CONNECT`, `TRACE`, or `TRACK`.
    
    Throws an "InvalidAccessError" DOMException if async is false, current global object is a Window object, and the timeout attribute is not zero or the responseType attribute is not the empty string.
  *)
  val open_': 'tags this -> method_:string -> url:([`U1 of string | `U2 of URL.t] [@js.union]) -> async:bool -> ?username:string option -> ?password:string option -> unit -> unit [@@js.call "open"]
  
  (**
    Acts as if the `Content-Type` header value for a response is mime. (It does not change the header.)
    
    Throws an "InvalidStateError" DOMException if state is loading or done.
  *)
  val overrideMimeType: 'tags this -> mime:string -> unit [@@js.call "overrideMimeType"]
  
  (**
    Initiates the request. The body argument provides the request body, if any, and is ignored if the request method is GET or HEAD.
    
    Throws an "InvalidStateError" DOMException if either state is not opened or the send() flag is set.
  *)
  val send: 'tags this -> ?body:([`Null | `U1 of Document.t | `U2 of XMLHttpRequestBodyInit.t] [@js.union]) -> unit -> unit [@@js.call "send"]
  
  (**
    Combines a header in author request headers.
    
    Throws an "InvalidStateError" DOMException if either state is not opened or the send() flag is set.
    
    Throws a "SyntaxError" DOMException if name is not a header name or if value is not a header value.
  *)
  val setRequestHeader: 'tags this -> name:string -> value:string -> unit [@@js.call "setRequestHeader"]
  val get_DONE: 'tags this -> float [@@js.get "DONE"]
  val get_HEADERS_RECEIVED: 'tags this -> float [@@js.get "HEADERS_RECEIVED"]
  val get_LOADING: 'tags this -> float [@@js.get "LOADING"]
  val get_OPENED: 'tags this -> float [@@js.get "OPENED"]
  val get_UNSENT: 'tags this -> float [@@js.get "UNSENT"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'XMLHttpRequestEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'XMLHttpRequestEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
  val done_: unit -> float [@@js.get "DONE"]
  val headers_received: unit -> float [@@js.get "HEADERS_RECEIVED"]
  val loading: unit -> float [@@js.get "LOADING"]
  val opened: unit -> float [@@js.get "OPENED"]
  val unsent: unit -> float [@@js.get "UNSENT"]
end
and[@js.scope "XMLHttpRequestEventTarget"] XMLHttpRequestEventTarget : sig
  type t = [`EventTarget | `XMLHttpRequestEventTarget] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventTarget | `XMLHttpRequestEventTarget]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventTarget | `XMLHttpRequestEventTarget]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `XMLHttpRequestEventTarget ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_onabort: 'tags this -> (this:XMLHttpRequest.t -> ev:ProgressEvent.t_0 -> any) option [@@js.get "onabort"]
  val set_onabort: 'tags this -> (this:XMLHttpRequest.t -> ev:ProgressEvent.t_0 -> any) option -> unit [@@js.set "onabort"]
  val get_onerror: 'tags this -> (this:XMLHttpRequest.t -> ev:ProgressEvent.t_0 -> any) option [@@js.get "onerror"]
  val set_onerror: 'tags this -> (this:XMLHttpRequest.t -> ev:ProgressEvent.t_0 -> any) option -> unit [@@js.set "onerror"]
  val get_onload: 'tags this -> (this:XMLHttpRequest.t -> ev:ProgressEvent.t_0 -> any) option [@@js.get "onload"]
  val set_onload: 'tags this -> (this:XMLHttpRequest.t -> ev:ProgressEvent.t_0 -> any) option -> unit [@@js.set "onload"]
  val get_onloadend: 'tags this -> (this:XMLHttpRequest.t -> ev:ProgressEvent.t_0 -> any) option [@@js.get "onloadend"]
  val set_onloadend: 'tags this -> (this:XMLHttpRequest.t -> ev:ProgressEvent.t_0 -> any) option -> unit [@@js.set "onloadend"]
  val get_onloadstart: 'tags this -> (this:XMLHttpRequest.t -> ev:ProgressEvent.t_0 -> any) option [@@js.get "onloadstart"]
  val set_onloadstart: 'tags this -> (this:XMLHttpRequest.t -> ev:ProgressEvent.t_0 -> any) option -> unit [@@js.set "onloadstart"]
  val get_onprogress: 'tags this -> (this:XMLHttpRequest.t -> ev:ProgressEvent.t_0 -> any) option [@@js.get "onprogress"]
  val set_onprogress: 'tags this -> (this:XMLHttpRequest.t -> ev:ProgressEvent.t_0 -> any) option -> unit [@@js.set "onprogress"]
  val get_ontimeout: 'tags this -> (this:XMLHttpRequest.t -> ev:ProgressEvent.t_0 -> any) option [@@js.get "ontimeout"]
  val set_ontimeout: 'tags this -> (this:XMLHttpRequest.t -> ev:ProgressEvent.t_0 -> any) option -> unit [@@js.set "ontimeout"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'XMLHttpRequestEventTargetEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'XMLHttpRequestEventTargetEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
and[@js.scope "XMLHttpRequestUpload"] XMLHttpRequestUpload : sig
  type t = [`EventTarget | `XMLHttpRequestEventTarget | `XMLHttpRequestUpload] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventTarget | `XMLHttpRequestEventTarget | `XMLHttpRequestUpload]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventTarget | `XMLHttpRequestEventTarget | `XMLHttpRequestUpload]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `XMLHttpRequestUpload ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'XMLHttpRequestEventTargetEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'XMLHttpRequestEventTargetEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module XMLHttpRequestEventTargetEventMap : sig
  type t = [`XMLHttpRequestEventTargetEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`XMLHttpRequestEventTargetEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`XMLHttpRequestEventTargetEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `XMLHttpRequestEventTargetEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_abort: 'tags this -> XMLHttpRequestEventTarget.t ProgressEvent.t [@@js.get "abort"]
  val set_abort: 'tags this -> XMLHttpRequestEventTarget.t ProgressEvent.t -> unit [@@js.set "abort"]
  val get_error: 'tags this -> XMLHttpRequestEventTarget.t ProgressEvent.t [@@js.get "error"]
  val set_error: 'tags this -> XMLHttpRequestEventTarget.t ProgressEvent.t -> unit [@@js.set "error"]
  val get_load: 'tags this -> XMLHttpRequestEventTarget.t ProgressEvent.t [@@js.get "load"]
  val set_load: 'tags this -> XMLHttpRequestEventTarget.t ProgressEvent.t -> unit [@@js.set "load"]
  val get_loadend: 'tags this -> XMLHttpRequestEventTarget.t ProgressEvent.t [@@js.get "loadend"]
  val set_loadend: 'tags this -> XMLHttpRequestEventTarget.t ProgressEvent.t -> unit [@@js.set "loadend"]
  val get_loadstart: 'tags this -> XMLHttpRequestEventTarget.t ProgressEvent.t [@@js.get "loadstart"]
  val set_loadstart: 'tags this -> XMLHttpRequestEventTarget.t ProgressEvent.t -> unit [@@js.set "loadstart"]
  val get_progress: 'tags this -> XMLHttpRequestEventTarget.t ProgressEvent.t [@@js.get "progress"]
  val set_progress: 'tags this -> XMLHttpRequestEventTarget.t ProgressEvent.t -> unit [@@js.set "progress"]
  val get_timeout: 'tags this -> XMLHttpRequestEventTarget.t ProgressEvent.t [@@js.get "timeout"]
  val set_timeout: 'tags this -> XMLHttpRequestEventTarget.t ProgressEvent.t -> unit [@@js.set "timeout"]
  val create: abort:XMLHttpRequestEventTarget.t ProgressEvent.t -> error:XMLHttpRequestEventTarget.t ProgressEvent.t -> load:XMLHttpRequestEventTarget.t ProgressEvent.t -> loadend:XMLHttpRequestEventTarget.t ProgressEvent.t -> loadstart:XMLHttpRequestEventTarget.t ProgressEvent.t -> progress:XMLHttpRequestEventTarget.t ProgressEvent.t -> timeout:XMLHttpRequestEventTarget.t ProgressEvent.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module XMLHttpRequestEventMap : sig
  type t = [`XMLHttpRequestEventMap | `XMLHttpRequestEventTargetEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`XMLHttpRequestEventMap | `XMLHttpRequestEventTargetEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`XMLHttpRequestEventMap | `XMLHttpRequestEventTargetEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `XMLHttpRequestEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_readystatechange: 'tags this -> Event.t [@@js.get "readystatechange"]
  val set_readystatechange: 'tags this -> Event.t -> unit [@@js.set "readystatechange"]
  val create: readystatechange:Event.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module AbstractWorkerEventMap : sig
  type t = [`AbstractWorkerEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AbstractWorkerEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AbstractWorkerEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `AbstractWorkerEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_error: 'tags this -> ErrorEvent.t [@@js.get "error"]
  val set_error: 'tags this -> ErrorEvent.t -> unit [@@js.set "error"]
  val create: error:ErrorEvent.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module WorkerEventMap : sig
  type t = [`AbstractWorkerEventMap | `WorkerEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AbstractWorkerEventMap | `WorkerEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AbstractWorkerEventMap | `WorkerEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `WorkerEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_message: 'tags this -> MessageEvent.t_0 [@@js.get "message"]
  val set_message: 'tags this -> MessageEvent.t_0 -> unit [@@js.set "message"]
  val get_messageerror: 'tags this -> MessageEvent.t_0 [@@js.get "messageerror"]
  val set_messageerror: 'tags this -> MessageEvent.t_0 -> unit [@@js.set "messageerror"]
  val create: message:MessageEvent.t_0 -> messageerror:MessageEvent.t_0 -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module WorkerOptions : sig
  type t = [`WorkerOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`WorkerOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`WorkerOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `WorkerOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_credentials: 'tags this -> RequestCredentials.t option [@@js.get "credentials"]
  val set_credentials: 'tags this -> RequestCredentials.t -> unit [@@js.set "credentials"]
  val get_name: 'tags this -> string option [@@js.get "name"]
  val set_name: 'tags this -> string -> unit [@@js.set "name"]
  val get_type: 'tags this -> WorkerType.t option [@@js.get "type"]
  val set_type: 'tags this -> WorkerType.t -> unit [@@js.set "type"]
  val create: ?credentials:RequestCredentials.t -> ?name:string -> ?type_:(WorkerType.t[@js "type"]) -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** This Web Workers API interface represents a background task that can be easily created and can send messages back to its creator. Creating a worker is as simple as calling the Worker() constructor and specifying a script to be run in the worker thread. *)
module[@js.scope "Worker"] Worker : sig
  type t = [`AbstractWorker | `EventTarget | `Worker] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AbstractWorker | `EventTarget | `Worker]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AbstractWorker | `EventTarget | `Worker]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `Worker ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_onmessage: 'tags this -> (this:t -> ev:MessageEvent.t_0 -> any) option [@@js.get "onmessage"]
  val set_onmessage: 'tags this -> (this:t -> ev:MessageEvent.t_0 -> any) option -> unit [@@js.set "onmessage"]
  val get_onmessageerror: 'tags this -> (this:t -> ev:MessageEvent.t_0 -> any) option [@@js.get "onmessageerror"]
  val set_onmessageerror: 'tags this -> (this:t -> ev:MessageEvent.t_0 -> any) option -> unit [@@js.set "onmessageerror"]
  
  (** Clones message and transmits it to worker's global environment. transfer can be passed as a list of objects that are to be transferred rather than cloned. *)
  val postMessage: 'tags this -> message:any -> transfer:Transferable.t list -> unit [@@js.call "postMessage"]
  
  (** Clones message and transmits it to worker's global environment. transfer can be passed as a list of objects that are to be transferred rather than cloned. *)
  val postMessage': 'tags this -> message:any -> ?options:StructuredSerializeOptions.t -> unit -> unit [@@js.call "postMessage"]
  
  (** Aborts worker's associated global environment. *)
  val terminate: 'tags this -> unit [@@js.call "terminate"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'WorkerEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'WorkerEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: scriptURL:([`U1 of string | `U2 of URL.t] [@js.union]) -> ?options:WorkerOptions.t -> unit -> t [@@js.create]
end
module WindowEventHandlersEventMap : sig
  type t = [`WindowEventHandlersEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`WindowEventHandlersEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`WindowEventHandlersEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `WindowEventHandlersEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_afterprint: 'tags this -> Event.t [@@js.get "afterprint"]
  val set_afterprint: 'tags this -> Event.t -> unit [@@js.set "afterprint"]
  val get_beforeprint: 'tags this -> Event.t [@@js.get "beforeprint"]
  val set_beforeprint: 'tags this -> Event.t -> unit [@@js.set "beforeprint"]
  val get_beforeunload: 'tags this -> BeforeUnloadEvent.t [@@js.get "beforeunload"]
  val set_beforeunload: 'tags this -> BeforeUnloadEvent.t -> unit [@@js.set "beforeunload"]
  val get_gamepadconnected: 'tags this -> GamepadEvent.t [@@js.get "gamepadconnected"]
  val set_gamepadconnected: 'tags this -> GamepadEvent.t -> unit [@@js.set "gamepadconnected"]
  val get_gamepaddisconnected: 'tags this -> GamepadEvent.t [@@js.get "gamepaddisconnected"]
  val set_gamepaddisconnected: 'tags this -> GamepadEvent.t -> unit [@@js.set "gamepaddisconnected"]
  val get_hashchange: 'tags this -> HashChangeEvent.t [@@js.get "hashchange"]
  val set_hashchange: 'tags this -> HashChangeEvent.t -> unit [@@js.set "hashchange"]
  val get_languagechange: 'tags this -> Event.t [@@js.get "languagechange"]
  val set_languagechange: 'tags this -> Event.t -> unit [@@js.set "languagechange"]
  val get_message: 'tags this -> MessageEvent.t_0 [@@js.get "message"]
  val set_message: 'tags this -> MessageEvent.t_0 -> unit [@@js.set "message"]
  val get_messageerror: 'tags this -> MessageEvent.t_0 [@@js.get "messageerror"]
  val set_messageerror: 'tags this -> MessageEvent.t_0 -> unit [@@js.set "messageerror"]
  val get_offline: 'tags this -> Event.t [@@js.get "offline"]
  val set_offline: 'tags this -> Event.t -> unit [@@js.set "offline"]
  val get_online: 'tags this -> Event.t [@@js.get "online"]
  val set_online: 'tags this -> Event.t -> unit [@@js.set "online"]
  val get_pagehide: 'tags this -> PageTransitionEvent.t [@@js.get "pagehide"]
  val set_pagehide: 'tags this -> PageTransitionEvent.t -> unit [@@js.set "pagehide"]
  val get_pageshow: 'tags this -> PageTransitionEvent.t [@@js.get "pageshow"]
  val set_pageshow: 'tags this -> PageTransitionEvent.t -> unit [@@js.set "pageshow"]
  val get_popstate: 'tags this -> PopStateEvent.t [@@js.get "popstate"]
  val set_popstate: 'tags this -> PopStateEvent.t -> unit [@@js.set "popstate"]
  val get_rejectionhandled: 'tags this -> PromiseRejectionEvent.t [@@js.get "rejectionhandled"]
  val set_rejectionhandled: 'tags this -> PromiseRejectionEvent.t -> unit [@@js.set "rejectionhandled"]
  val get_storage: 'tags this -> StorageEvent.t [@@js.get "storage"]
  val set_storage: 'tags this -> StorageEvent.t -> unit [@@js.set "storage"]
  val get_unhandledrejection: 'tags this -> PromiseRejectionEvent.t [@@js.get "unhandledrejection"]
  val set_unhandledrejection: 'tags this -> PromiseRejectionEvent.t -> unit [@@js.set "unhandledrejection"]
  val get_unload: 'tags this -> Event.t [@@js.get "unload"]
  val set_unload: 'tags this -> Event.t -> unit [@@js.set "unload"]
  val create: afterprint:Event.t -> beforeprint:Event.t -> beforeunload:BeforeUnloadEvent.t -> gamepadconnected:GamepadEvent.t -> gamepaddisconnected:GamepadEvent.t -> hashchange:HashChangeEvent.t -> languagechange:Event.t -> message:MessageEvent.t_0 -> messageerror:MessageEvent.t_0 -> offline:Event.t -> online:Event.t -> pagehide:PageTransitionEvent.t -> pageshow:PageTransitionEvent.t -> popstate:PopStateEvent.t -> rejectionhandled:PromiseRejectionEvent.t -> storage:StorageEvent.t -> unhandledrejection:PromiseRejectionEvent.t -> unload:Event.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module GlobalEventHandlersEventMap : sig
  type t = [`GlobalEventHandlersEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`GlobalEventHandlersEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`GlobalEventHandlersEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `GlobalEventHandlersEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_abort: 'tags this -> UIEvent.t [@@js.get "abort"]
  val set_abort: 'tags this -> UIEvent.t -> unit [@@js.set "abort"]
  val get_animationcancel: 'tags this -> AnimationEvent.t [@@js.get "animationcancel"]
  val set_animationcancel: 'tags this -> AnimationEvent.t -> unit [@@js.set "animationcancel"]
  val get_animationend: 'tags this -> AnimationEvent.t [@@js.get "animationend"]
  val set_animationend: 'tags this -> AnimationEvent.t -> unit [@@js.set "animationend"]
  val get_animationiteration: 'tags this -> AnimationEvent.t [@@js.get "animationiteration"]
  val set_animationiteration: 'tags this -> AnimationEvent.t -> unit [@@js.set "animationiteration"]
  val get_animationstart: 'tags this -> AnimationEvent.t [@@js.get "animationstart"]
  val set_animationstart: 'tags this -> AnimationEvent.t -> unit [@@js.set "animationstart"]
  val get_auxclick: 'tags this -> MouseEvent.t [@@js.get "auxclick"]
  val set_auxclick: 'tags this -> MouseEvent.t -> unit [@@js.set "auxclick"]
  val get_beforeinput: 'tags this -> InputEvent.t [@@js.get "beforeinput"]
  val set_beforeinput: 'tags this -> InputEvent.t -> unit [@@js.set "beforeinput"]
  val get_blur: 'tags this -> FocusEvent.t [@@js.get "blur"]
  val set_blur: 'tags this -> FocusEvent.t -> unit [@@js.set "blur"]
  val get_canplay: 'tags this -> Event.t [@@js.get "canplay"]
  val set_canplay: 'tags this -> Event.t -> unit [@@js.set "canplay"]
  val get_canplaythrough: 'tags this -> Event.t [@@js.get "canplaythrough"]
  val set_canplaythrough: 'tags this -> Event.t -> unit [@@js.set "canplaythrough"]
  val get_change: 'tags this -> Event.t [@@js.get "change"]
  val set_change: 'tags this -> Event.t -> unit [@@js.set "change"]
  val get_click: 'tags this -> MouseEvent.t [@@js.get "click"]
  val set_click: 'tags this -> MouseEvent.t -> unit [@@js.set "click"]
  val get_close: 'tags this -> Event.t [@@js.get "close"]
  val set_close: 'tags this -> Event.t -> unit [@@js.set "close"]
  val get_compositionend: 'tags this -> CompositionEvent.t [@@js.get "compositionend"]
  val set_compositionend: 'tags this -> CompositionEvent.t -> unit [@@js.set "compositionend"]
  val get_compositionstart: 'tags this -> CompositionEvent.t [@@js.get "compositionstart"]
  val set_compositionstart: 'tags this -> CompositionEvent.t -> unit [@@js.set "compositionstart"]
  val get_compositionupdate: 'tags this -> CompositionEvent.t [@@js.get "compositionupdate"]
  val set_compositionupdate: 'tags this -> CompositionEvent.t -> unit [@@js.set "compositionupdate"]
  val get_contextmenu: 'tags this -> MouseEvent.t [@@js.get "contextmenu"]
  val set_contextmenu: 'tags this -> MouseEvent.t -> unit [@@js.set "contextmenu"]
  val get_cuechange: 'tags this -> Event.t [@@js.get "cuechange"]
  val set_cuechange: 'tags this -> Event.t -> unit [@@js.set "cuechange"]
  val get_dblclick: 'tags this -> MouseEvent.t [@@js.get "dblclick"]
  val set_dblclick: 'tags this -> MouseEvent.t -> unit [@@js.set "dblclick"]
  val get_drag: 'tags this -> DragEvent.t [@@js.get "drag"]
  val set_drag: 'tags this -> DragEvent.t -> unit [@@js.set "drag"]
  val get_dragend: 'tags this -> DragEvent.t [@@js.get "dragend"]
  val set_dragend: 'tags this -> DragEvent.t -> unit [@@js.set "dragend"]
  val get_dragenter: 'tags this -> DragEvent.t [@@js.get "dragenter"]
  val set_dragenter: 'tags this -> DragEvent.t -> unit [@@js.set "dragenter"]
  val get_dragleave: 'tags this -> DragEvent.t [@@js.get "dragleave"]
  val set_dragleave: 'tags this -> DragEvent.t -> unit [@@js.set "dragleave"]
  val get_dragover: 'tags this -> DragEvent.t [@@js.get "dragover"]
  val set_dragover: 'tags this -> DragEvent.t -> unit [@@js.set "dragover"]
  val get_dragstart: 'tags this -> DragEvent.t [@@js.get "dragstart"]
  val set_dragstart: 'tags this -> DragEvent.t -> unit [@@js.set "dragstart"]
  val get_drop: 'tags this -> DragEvent.t [@@js.get "drop"]
  val set_drop: 'tags this -> DragEvent.t -> unit [@@js.set "drop"]
  val get_durationchange: 'tags this -> Event.t [@@js.get "durationchange"]
  val set_durationchange: 'tags this -> Event.t -> unit [@@js.set "durationchange"]
  val get_emptied: 'tags this -> Event.t [@@js.get "emptied"]
  val set_emptied: 'tags this -> Event.t -> unit [@@js.set "emptied"]
  val get_ended: 'tags this -> Event.t [@@js.get "ended"]
  val set_ended: 'tags this -> Event.t -> unit [@@js.set "ended"]
  val get_error: 'tags this -> ErrorEvent.t [@@js.get "error"]
  val set_error: 'tags this -> ErrorEvent.t -> unit [@@js.set "error"]
  val get_focus: 'tags this -> FocusEvent.t [@@js.get "focus"]
  val set_focus: 'tags this -> FocusEvent.t -> unit [@@js.set "focus"]
  val get_focusin: 'tags this -> FocusEvent.t [@@js.get "focusin"]
  val set_focusin: 'tags this -> FocusEvent.t -> unit [@@js.set "focusin"]
  val get_focusout: 'tags this -> FocusEvent.t [@@js.get "focusout"]
  val set_focusout: 'tags this -> FocusEvent.t -> unit [@@js.set "focusout"]
  val get_formdata: 'tags this -> FormDataEvent.t [@@js.get "formdata"]
  val set_formdata: 'tags this -> FormDataEvent.t -> unit [@@js.set "formdata"]
  val get_gotpointercapture: 'tags this -> PointerEvent.t [@@js.get "gotpointercapture"]
  val set_gotpointercapture: 'tags this -> PointerEvent.t -> unit [@@js.set "gotpointercapture"]
  val get_input: 'tags this -> Event.t [@@js.get "input"]
  val set_input: 'tags this -> Event.t -> unit [@@js.set "input"]
  val get_invalid: 'tags this -> Event.t [@@js.get "invalid"]
  val set_invalid: 'tags this -> Event.t -> unit [@@js.set "invalid"]
  val get_keydown: 'tags this -> KeyboardEvent.t [@@js.get "keydown"]
  val set_keydown: 'tags this -> KeyboardEvent.t -> unit [@@js.set "keydown"]
  val get_keypress: 'tags this -> KeyboardEvent.t [@@js.get "keypress"]
  val set_keypress: 'tags this -> KeyboardEvent.t -> unit [@@js.set "keypress"]
  val get_keyup: 'tags this -> KeyboardEvent.t [@@js.get "keyup"]
  val set_keyup: 'tags this -> KeyboardEvent.t -> unit [@@js.set "keyup"]
  val get_load: 'tags this -> Event.t [@@js.get "load"]
  val set_load: 'tags this -> Event.t -> unit [@@js.set "load"]
  val get_loadeddata: 'tags this -> Event.t [@@js.get "loadeddata"]
  val set_loadeddata: 'tags this -> Event.t -> unit [@@js.set "loadeddata"]
  val get_loadedmetadata: 'tags this -> Event.t [@@js.get "loadedmetadata"]
  val set_loadedmetadata: 'tags this -> Event.t -> unit [@@js.set "loadedmetadata"]
  val get_loadstart: 'tags this -> Event.t [@@js.get "loadstart"]
  val set_loadstart: 'tags this -> Event.t -> unit [@@js.set "loadstart"]
  val get_lostpointercapture: 'tags this -> PointerEvent.t [@@js.get "lostpointercapture"]
  val set_lostpointercapture: 'tags this -> PointerEvent.t -> unit [@@js.set "lostpointercapture"]
  val get_mousedown: 'tags this -> MouseEvent.t [@@js.get "mousedown"]
  val set_mousedown: 'tags this -> MouseEvent.t -> unit [@@js.set "mousedown"]
  val get_mouseenter: 'tags this -> MouseEvent.t [@@js.get "mouseenter"]
  val set_mouseenter: 'tags this -> MouseEvent.t -> unit [@@js.set "mouseenter"]
  val get_mouseleave: 'tags this -> MouseEvent.t [@@js.get "mouseleave"]
  val set_mouseleave: 'tags this -> MouseEvent.t -> unit [@@js.set "mouseleave"]
  val get_mousemove: 'tags this -> MouseEvent.t [@@js.get "mousemove"]
  val set_mousemove: 'tags this -> MouseEvent.t -> unit [@@js.set "mousemove"]
  val get_mouseout: 'tags this -> MouseEvent.t [@@js.get "mouseout"]
  val set_mouseout: 'tags this -> MouseEvent.t -> unit [@@js.set "mouseout"]
  val get_mouseover: 'tags this -> MouseEvent.t [@@js.get "mouseover"]
  val set_mouseover: 'tags this -> MouseEvent.t -> unit [@@js.set "mouseover"]
  val get_mouseup: 'tags this -> MouseEvent.t [@@js.get "mouseup"]
  val set_mouseup: 'tags this -> MouseEvent.t -> unit [@@js.set "mouseup"]
  val get_pause: 'tags this -> Event.t [@@js.get "pause"]
  val set_pause: 'tags this -> Event.t -> unit [@@js.set "pause"]
  val get_play: 'tags this -> Event.t [@@js.get "play"]
  val set_play: 'tags this -> Event.t -> unit [@@js.set "play"]
  val get_playing: 'tags this -> Event.t [@@js.get "playing"]
  val set_playing: 'tags this -> Event.t -> unit [@@js.set "playing"]
  val get_pointercancel: 'tags this -> PointerEvent.t [@@js.get "pointercancel"]
  val set_pointercancel: 'tags this -> PointerEvent.t -> unit [@@js.set "pointercancel"]
  val get_pointerdown: 'tags this -> PointerEvent.t [@@js.get "pointerdown"]
  val set_pointerdown: 'tags this -> PointerEvent.t -> unit [@@js.set "pointerdown"]
  val get_pointerenter: 'tags this -> PointerEvent.t [@@js.get "pointerenter"]
  val set_pointerenter: 'tags this -> PointerEvent.t -> unit [@@js.set "pointerenter"]
  val get_pointerleave: 'tags this -> PointerEvent.t [@@js.get "pointerleave"]
  val set_pointerleave: 'tags this -> PointerEvent.t -> unit [@@js.set "pointerleave"]
  val get_pointermove: 'tags this -> PointerEvent.t [@@js.get "pointermove"]
  val set_pointermove: 'tags this -> PointerEvent.t -> unit [@@js.set "pointermove"]
  val get_pointerout: 'tags this -> PointerEvent.t [@@js.get "pointerout"]
  val set_pointerout: 'tags this -> PointerEvent.t -> unit [@@js.set "pointerout"]
  val get_pointerover: 'tags this -> PointerEvent.t [@@js.get "pointerover"]
  val set_pointerover: 'tags this -> PointerEvent.t -> unit [@@js.set "pointerover"]
  val get_pointerup: 'tags this -> PointerEvent.t [@@js.get "pointerup"]
  val set_pointerup: 'tags this -> PointerEvent.t -> unit [@@js.set "pointerup"]
  val get_progress: 'tags this -> ProgressEvent.t_0 [@@js.get "progress"]
  val set_progress: 'tags this -> ProgressEvent.t_0 -> unit [@@js.set "progress"]
  val get_ratechange: 'tags this -> Event.t [@@js.get "ratechange"]
  val set_ratechange: 'tags this -> Event.t -> unit [@@js.set "ratechange"]
  val get_reset: 'tags this -> Event.t [@@js.get "reset"]
  val set_reset: 'tags this -> Event.t -> unit [@@js.set "reset"]
  val get_resize: 'tags this -> UIEvent.t [@@js.get "resize"]
  val set_resize: 'tags this -> UIEvent.t -> unit [@@js.set "resize"]
  val get_scroll: 'tags this -> Event.t [@@js.get "scroll"]
  val set_scroll: 'tags this -> Event.t -> unit [@@js.set "scroll"]
  val get_securitypolicyviolation: 'tags this -> SecurityPolicyViolationEvent.t [@@js.get "securitypolicyviolation"]
  val set_securitypolicyviolation: 'tags this -> SecurityPolicyViolationEvent.t -> unit [@@js.set "securitypolicyviolation"]
  val get_seeked: 'tags this -> Event.t [@@js.get "seeked"]
  val set_seeked: 'tags this -> Event.t -> unit [@@js.set "seeked"]
  val get_seeking: 'tags this -> Event.t [@@js.get "seeking"]
  val set_seeking: 'tags this -> Event.t -> unit [@@js.set "seeking"]
  val get_select: 'tags this -> Event.t [@@js.get "select"]
  val set_select: 'tags this -> Event.t -> unit [@@js.set "select"]
  val get_selectionchange: 'tags this -> Event.t [@@js.get "selectionchange"]
  val set_selectionchange: 'tags this -> Event.t -> unit [@@js.set "selectionchange"]
  val get_selectstart: 'tags this -> Event.t [@@js.get "selectstart"]
  val set_selectstart: 'tags this -> Event.t -> unit [@@js.set "selectstart"]
  val get_slotchange: 'tags this -> Event.t [@@js.get "slotchange"]
  val set_slotchange: 'tags this -> Event.t -> unit [@@js.set "slotchange"]
  val get_stalled: 'tags this -> Event.t [@@js.get "stalled"]
  val set_stalled: 'tags this -> Event.t -> unit [@@js.set "stalled"]
  val get_submit: 'tags this -> SubmitEvent.t [@@js.get "submit"]
  val set_submit: 'tags this -> SubmitEvent.t -> unit [@@js.set "submit"]
  val get_suspend: 'tags this -> Event.t [@@js.get "suspend"]
  val set_suspend: 'tags this -> Event.t -> unit [@@js.set "suspend"]
  val get_timeupdate: 'tags this -> Event.t [@@js.get "timeupdate"]
  val set_timeupdate: 'tags this -> Event.t -> unit [@@js.set "timeupdate"]
  val get_toggle: 'tags this -> Event.t [@@js.get "toggle"]
  val set_toggle: 'tags this -> Event.t -> unit [@@js.set "toggle"]
  val get_touchcancel: 'tags this -> TouchEvent.t [@@js.get "touchcancel"]
  val set_touchcancel: 'tags this -> TouchEvent.t -> unit [@@js.set "touchcancel"]
  val get_touchend: 'tags this -> TouchEvent.t [@@js.get "touchend"]
  val set_touchend: 'tags this -> TouchEvent.t -> unit [@@js.set "touchend"]
  val get_touchmove: 'tags this -> TouchEvent.t [@@js.get "touchmove"]
  val set_touchmove: 'tags this -> TouchEvent.t -> unit [@@js.set "touchmove"]
  val get_touchstart: 'tags this -> TouchEvent.t [@@js.get "touchstart"]
  val set_touchstart: 'tags this -> TouchEvent.t -> unit [@@js.set "touchstart"]
  val get_transitioncancel: 'tags this -> TransitionEvent.t [@@js.get "transitioncancel"]
  val set_transitioncancel: 'tags this -> TransitionEvent.t -> unit [@@js.set "transitioncancel"]
  val get_transitionend: 'tags this -> TransitionEvent.t [@@js.get "transitionend"]
  val set_transitionend: 'tags this -> TransitionEvent.t -> unit [@@js.set "transitionend"]
  val get_transitionrun: 'tags this -> TransitionEvent.t [@@js.get "transitionrun"]
  val set_transitionrun: 'tags this -> TransitionEvent.t -> unit [@@js.set "transitionrun"]
  val get_transitionstart: 'tags this -> TransitionEvent.t [@@js.get "transitionstart"]
  val set_transitionstart: 'tags this -> TransitionEvent.t -> unit [@@js.set "transitionstart"]
  val get_volumechange: 'tags this -> Event.t [@@js.get "volumechange"]
  val set_volumechange: 'tags this -> Event.t -> unit [@@js.set "volumechange"]
  val get_waiting: 'tags this -> Event.t [@@js.get "waiting"]
  val set_waiting: 'tags this -> Event.t -> unit [@@js.set "waiting"]
  val get_webkitanimationend: 'tags this -> Event.t [@@js.get "webkitanimationend"]
  val set_webkitanimationend: 'tags this -> Event.t -> unit [@@js.set "webkitanimationend"]
  val get_webkitanimationiteration: 'tags this -> Event.t [@@js.get "webkitanimationiteration"]
  val set_webkitanimationiteration: 'tags this -> Event.t -> unit [@@js.set "webkitanimationiteration"]
  val get_webkitanimationstart: 'tags this -> Event.t [@@js.get "webkitanimationstart"]
  val set_webkitanimationstart: 'tags this -> Event.t -> unit [@@js.set "webkitanimationstart"]
  val get_webkittransitionend: 'tags this -> Event.t [@@js.get "webkittransitionend"]
  val set_webkittransitionend: 'tags this -> Event.t -> unit [@@js.set "webkittransitionend"]
  val get_wheel: 'tags this -> WheelEvent.t [@@js.get "wheel"]
  val set_wheel: 'tags this -> WheelEvent.t -> unit [@@js.set "wheel"]
  val create: abort:UIEvent.t -> animationcancel:AnimationEvent.t -> animationend:AnimationEvent.t -> animationiteration:AnimationEvent.t -> animationstart:AnimationEvent.t -> auxclick:MouseEvent.t -> beforeinput:InputEvent.t -> blur:FocusEvent.t -> canplay:Event.t -> canplaythrough:Event.t -> change:Event.t -> click:MouseEvent.t -> close:Event.t -> compositionend:CompositionEvent.t -> compositionstart:CompositionEvent.t -> compositionupdate:CompositionEvent.t -> contextmenu:MouseEvent.t -> cuechange:Event.t -> dblclick:MouseEvent.t -> drag:DragEvent.t -> dragend:DragEvent.t -> dragenter:DragEvent.t -> dragleave:DragEvent.t -> dragover:DragEvent.t -> dragstart:DragEvent.t -> drop:DragEvent.t -> durationchange:Event.t -> emptied:Event.t -> ended:Event.t -> error:ErrorEvent.t -> focus:FocusEvent.t -> focusin:FocusEvent.t -> focusout:FocusEvent.t -> formdata:FormDataEvent.t -> gotpointercapture:PointerEvent.t -> input:Event.t -> invalid:Event.t -> keydown:KeyboardEvent.t -> keypress:KeyboardEvent.t -> keyup:KeyboardEvent.t -> load:Event.t -> loadeddata:Event.t -> loadedmetadata:Event.t -> loadstart:Event.t -> lostpointercapture:PointerEvent.t -> mousedown:MouseEvent.t -> mouseenter:MouseEvent.t -> mouseleave:MouseEvent.t -> mousemove:MouseEvent.t -> mouseout:MouseEvent.t -> mouseover:MouseEvent.t -> mouseup:MouseEvent.t -> pause:Event.t -> play:Event.t -> playing:Event.t -> pointercancel:PointerEvent.t -> pointerdown:PointerEvent.t -> pointerenter:PointerEvent.t -> pointerleave:PointerEvent.t -> pointermove:PointerEvent.t -> pointerout:PointerEvent.t -> pointerover:PointerEvent.t -> pointerup:PointerEvent.t -> progress:ProgressEvent.t_0 -> ratechange:Event.t -> reset:Event.t -> resize:UIEvent.t -> scroll:Event.t -> securitypolicyviolation:SecurityPolicyViolationEvent.t -> seeked:Event.t -> seeking:Event.t -> select:Event.t -> selectionchange:Event.t -> selectstart:Event.t -> slotchange:Event.t -> stalled:Event.t -> submit:SubmitEvent.t -> suspend:Event.t -> timeupdate:Event.t -> toggle:Event.t -> touchcancel:TouchEvent.t -> touchend:TouchEvent.t -> touchmove:TouchEvent.t -> touchstart:TouchEvent.t -> transitioncancel:TransitionEvent.t -> transitionend:TransitionEvent.t -> transitionrun:TransitionEvent.t -> transitionstart:TransitionEvent.t -> volumechange:Event.t -> waiting:Event.t -> webkitanimationend:Event.t -> webkitanimationiteration:Event.t -> webkitanimationstart:Event.t -> webkittransitionend:Event.t -> wheel:WheelEvent.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module WindowEventMap : sig
  type t = [`GlobalEventHandlersEventMap | `WindowEventHandlersEventMap | `WindowEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`GlobalEventHandlersEventMap | `WindowEventHandlersEventMap | `WindowEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`GlobalEventHandlersEventMap | `WindowEventHandlersEventMap | `WindowEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `WindowEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_devicemotion: 'tags this -> DeviceMotionEvent.t [@@js.get "devicemotion"]
  val set_devicemotion: 'tags this -> DeviceMotionEvent.t -> unit [@@js.set "devicemotion"]
  val get_deviceorientation: 'tags this -> DeviceOrientationEvent.t [@@js.get "deviceorientation"]
  val set_deviceorientation: 'tags this -> DeviceOrientationEvent.t -> unit [@@js.set "deviceorientation"]
  val get_gamepadconnected: 'tags this -> GamepadEvent.t [@@js.get "gamepadconnected"]
  val set_gamepadconnected: 'tags this -> GamepadEvent.t -> unit [@@js.set "gamepadconnected"]
  val get_gamepaddisconnected: 'tags this -> GamepadEvent.t [@@js.get "gamepaddisconnected"]
  val set_gamepaddisconnected: 'tags this -> GamepadEvent.t -> unit [@@js.set "gamepaddisconnected"]
  val get_orientationchange: 'tags this -> Event.t [@@js.get "orientationchange"]
  val set_orientationchange: 'tags this -> Event.t -> unit [@@js.set "orientationchange"]
  val create: devicemotion:DeviceMotionEvent.t -> deviceorientation:DeviceOrientationEvent.t -> gamepadconnected:GamepadEvent.t -> gamepaddisconnected:GamepadEvent.t -> orientationchange:Event.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module WebSocketEventMap : sig
  type t = [`WebSocketEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`WebSocketEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`WebSocketEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `WebSocketEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_close: 'tags this -> CloseEvent.t [@@js.get "close"]
  val set_close: 'tags this -> CloseEvent.t -> unit [@@js.set "close"]
  val get_error: 'tags this -> Event.t [@@js.get "error"]
  val set_error: 'tags this -> Event.t -> unit [@@js.set "error"]
  val get_message: 'tags this -> MessageEvent.t_0 [@@js.get "message"]
  val set_message: 'tags this -> MessageEvent.t_0 -> unit [@@js.set "message"]
  val get_open: 'tags this -> Event.t [@@js.get "open"]
  val set_open: 'tags this -> Event.t -> unit [@@js.set "open"]
  val create: close:CloseEvent.t -> error:Event.t -> message:MessageEvent.t_0 -> open_:(Event.t[@js "open"]) -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** Provides the API for creating and managing a WebSocket connection to a server, as well as for sending and receiving data on the connection. *)
module[@js.scope "WebSocket"] WebSocket : sig
  type t = [`EventTarget | `WebSocket] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventTarget | `WebSocket]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventTarget | `WebSocket]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `WebSocket ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    Returns a string that indicates how binary data from the WebSocket object is exposed to scripts:
    
    Can be set, to change how binary data is returned. The default is "blob".
  *)
  val get_binaryType: 'tags this -> BinaryType.t [@@js.get "binaryType"]
  
  (**
    Returns a string that indicates how binary data from the WebSocket object is exposed to scripts:
    
    Can be set, to change how binary data is returned. The default is "blob".
  *)
  val set_binaryType: 'tags this -> BinaryType.t -> unit [@@js.set "binaryType"]
  
  (**
    Returns the number of bytes of application data (UTF-8 text and binary data) that have been queued using send() but not yet been transmitted to the network.
    
    If the WebSocket connection is closed, this attribute's value will only increase with each call to the send() method. (The number does not reset to zero once the connection closes.)
  *)
  val get_bufferedAmount: 'tags this -> float [@@js.get "bufferedAmount"]
  
  (** Returns the extensions selected by the server, if any. *)
  val get_extensions: 'tags this -> string [@@js.get "extensions"]
  val get_onclose: 'tags this -> (this:t -> ev:CloseEvent.t -> any) option [@@js.get "onclose"]
  val set_onclose: 'tags this -> (this:t -> ev:CloseEvent.t -> any) option -> unit [@@js.set "onclose"]
  val get_onerror: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onerror"]
  val set_onerror: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onerror"]
  val get_onmessage: 'tags this -> (this:t -> ev:MessageEvent.t_0 -> any) option [@@js.get "onmessage"]
  val set_onmessage: 'tags this -> (this:t -> ev:MessageEvent.t_0 -> any) option -> unit [@@js.set "onmessage"]
  val get_onopen: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onopen"]
  val set_onopen: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onopen"]
  
  (** Returns the subprotocol selected by the server, if any. It can be used in conjunction with the array form of the constructor's second argument to perform subprotocol negotiation. *)
  val get_protocol: 'tags this -> string [@@js.get "protocol"]
  
  (** Returns the state of the WebSocket object's connection. It can have the values described below. *)
  val get_readyState: 'tags this -> float [@@js.get "readyState"]
  
  (** Returns the URL that was used to establish the WebSocket connection. *)
  val get_url: 'tags this -> string [@@js.get "url"]
  
  (** Closes the WebSocket connection, optionally using code as the the WebSocket connection close code and reason as the the WebSocket connection close reason. *)
  val close: 'tags this -> ?code:float -> ?reason:string -> unit -> unit [@@js.call "close"]
  
  (** Transmits data using the WebSocket connection. data can be a string, a Blob, an ArrayBuffer, or an ArrayBufferView. *)
  val send: 'tags this -> data:([`U1 of string | `U2 of ArrayBufferLike.t_0 | `U3 of Blob.t | `U4 of ArrayBufferView.t_0] [@js.union]) -> unit [@@js.call "send"]
  val get_CLOSED: 'tags this -> float [@@js.get "CLOSED"]
  val get_CLOSING: 'tags this -> float [@@js.get "CLOSING"]
  val get_CONNECTING: 'tags this -> float [@@js.get "CONNECTING"]
  val get_OPEN: 'tags this -> float [@@js.get "OPEN"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'WebSocketEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'WebSocketEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: url:([`U1 of string | `U2 of URL.t] [@js.union]) -> ?protocols:([`U1 of string | `U2 of string list] [@js.union]) -> unit -> t [@@js.create]
  val closed: unit -> float [@@js.get "CLOSED"]
  val closing: unit -> float [@@js.get "CLOSING"]
  val connecting: unit -> float [@@js.get "CONNECTING"]
  val open_: unit -> float [@@js.get "OPEN"]
end
module[@js.scope "WebKitCSSMatrix"] WebKitCSSMatrix : sig
  type t = DOMMatrix.t
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val prototype: unit -> DOMMatrix.t [@@js.get "prototype"]
  val create: ?init:([`U1 of string | `U2 of float list] [@js.union]) -> unit -> DOMMatrix.t [@@js.create]
  val fromFloat32Array: Float32Array.t_0 -> DOMMatrix.t [@@js.global "fromFloat32Array"]
  val fromFloat64Array: Float64Array.t_0 -> DOMMatrix.t [@@js.global "fromFloat64Array"]
  val fromMatrix: ?other:DOMMatrixInit.t -> unit -> DOMMatrix.t [@@js.global "fromMatrix"]
end
module[@js.scope "WebAssembly"] WebAssembly : sig
  module ImportExportKind : sig
    type t = ([`L_s365_function[@js "function"] | `L_s372_global[@js "global"] | `L_s507_memory[@js "memory"] | `L_s781_table[@js "table"]] [@js.enum])
    type t_0 = t
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
  end
  module ModuleImportDescriptor : sig
    type t = [`WebAssembly_ModuleImportDescriptor] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type t_0 = t
    [@@@js.stop]
    type tags = [`WebAssembly_ModuleImportDescriptor]
    type tags_0 = tags
    [@@@js.start]
    [@@@js.implem 
      type tags = [`WebAssembly_ModuleImportDescriptor]
      type tags_0 = tags
    ]
    type 'tags this = 'tags intf constraint 'tags = [> `WebAssembly_ModuleImportDescriptor ]
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_kind: 'tags this -> ImportExportKind.t [@@js.get "kind"]
    val set_kind: 'tags this -> ImportExportKind.t -> unit [@@js.set "kind"]
    val get_module: 'tags this -> string [@@js.get "module"]
    val set_module: 'tags this -> string -> unit [@@js.set "module"]
    val get_name: 'tags this -> string [@@js.get "name"]
    val set_name: 'tags this -> string -> unit [@@js.set "name"]
    val create: kind:ImportExportKind.t -> module_:(string[@js "module"]) -> name:string -> unit -> t [@@js.builder]
    val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  end
  module ModuleExportDescriptor : sig
    type t = [`WebAssembly_ModuleExportDescriptor] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type t_0 = t
    [@@@js.stop]
    type tags = [`WebAssembly_ModuleExportDescriptor]
    type tags_0 = tags
    [@@@js.start]
    [@@@js.implem 
      type tags = [`WebAssembly_ModuleExportDescriptor]
      type tags_0 = tags
    ]
    type 'tags this = 'tags intf constraint 'tags = [> `WebAssembly_ModuleExportDescriptor ]
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_kind: 'tags this -> ImportExportKind.t [@@js.get "kind"]
    val set_kind: 'tags this -> ImportExportKind.t -> unit [@@js.set "kind"]
    val get_name: 'tags this -> string [@@js.get "name"]
    val set_name: 'tags this -> string -> unit [@@js.set "name"]
    val create: kind:ImportExportKind.t -> name:string -> unit -> t [@@js.builder]
    val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  end
  module[@js.scope "Module"] Module : sig
    type t = [`WebAssembly_Module] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type t_0 = t
    [@@@js.stop]
    type tags = [`WebAssembly_Module]
    type tags_0 = tags
    [@@@js.start]
    [@@@js.implem 
      type tags = [`WebAssembly_Module]
      type tags_0 = tags
    ]
    type 'tags this = 'tags intf constraint 'tags = [> `WebAssembly_Module ]
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
    val prototype: unit -> t [@@js.get "prototype"]
    val create: BufferSource.t -> t [@@js.create]
    val customSections: moduleObject:t -> sectionName:string -> ArrayBuffer.t_0 list [@@js.global "customSections"]
    val exports: t -> ModuleExportDescriptor.t list [@@js.global "exports"]
    val imports: t -> ModuleImportDescriptor.t list [@@js.global "imports"]
  end
  module TableKind : sig
    type t = ([`L_s122_anyfunc[@js "anyfunc"] | `L_s308_externref[@js "externref"]] [@js.enum])
    type t_0 = t
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
  end
  module TableDescriptor : sig
    type t = [`WebAssembly_TableDescriptor] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type t_0 = t
    [@@@js.stop]
    type tags = [`WebAssembly_TableDescriptor]
    type tags_0 = tags
    [@@@js.start]
    [@@@js.implem 
      type tags = [`WebAssembly_TableDescriptor]
      type tags_0 = tags
    ]
    type 'tags this = 'tags intf constraint 'tags = [> `WebAssembly_TableDescriptor ]
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_element: 'tags this -> TableKind.t [@@js.get "element"]
    val set_element: 'tags this -> TableKind.t -> unit [@@js.set "element"]
    val get_initial: 'tags this -> float [@@js.get "initial"]
    val set_initial: 'tags this -> float -> unit [@@js.set "initial"]
    val get_maximum: 'tags this -> float option [@@js.get "maximum"]
    val set_maximum: 'tags this -> float -> unit [@@js.set "maximum"]
    val create: element:TableKind.t -> initial:float -> ?maximum:float -> unit -> t [@@js.builder]
    val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  end
  module[@js.scope "Table"] Table : sig
    type t = [`WebAssembly_Table] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type t_0 = t
    [@@@js.stop]
    type tags = [`WebAssembly_Table]
    type tags_0 = tags
    [@@@js.start]
    [@@@js.implem 
      type tags = [`WebAssembly_Table]
      type tags_0 = tags
    ]
    type 'tags this = 'tags intf constraint 'tags = [> `WebAssembly_Table ]
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_length: 'tags this -> float [@@js.get "length"]
    val get_: 'tags this -> index:float -> any [@@js.call "get"]
    val grow: 'tags this -> delta:float -> ?value:any -> unit -> float [@@js.call "grow"]
    val set_: 'tags this -> index:float -> ?value:any -> unit -> unit [@@js.call "set"]
    val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
    val prototype: unit -> t [@@js.get "prototype"]
    val create: descriptor:TableDescriptor.t -> ?value:any -> unit -> t [@@js.create]
  end
  module MemoryDescriptor : sig
    type t = [`WebAssembly_MemoryDescriptor] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type t_0 = t
    [@@@js.stop]
    type tags = [`WebAssembly_MemoryDescriptor]
    type tags_0 = tags
    [@@@js.start]
    [@@@js.implem 
      type tags = [`WebAssembly_MemoryDescriptor]
      type tags_0 = tags
    ]
    type 'tags this = 'tags intf constraint 'tags = [> `WebAssembly_MemoryDescriptor ]
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_initial: 'tags this -> float [@@js.get "initial"]
    val set_initial: 'tags this -> float -> unit [@@js.set "initial"]
    val get_maximum: 'tags this -> float option [@@js.get "maximum"]
    val set_maximum: 'tags this -> float -> unit [@@js.set "maximum"]
    val get_shared: 'tags this -> bool option [@@js.get "shared"]
    val set_shared: 'tags this -> bool -> unit [@@js.set "shared"]
    val create: initial:float -> ?maximum:float -> ?shared:bool -> unit -> t [@@js.builder]
    val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  end
  module[@js.scope "Memory"] Memory : sig
    type t = [`WebAssembly_Memory] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type t_0 = t
    [@@@js.stop]
    type tags = [`WebAssembly_Memory]
    type tags_0 = tags
    [@@@js.start]
    [@@@js.implem 
      type tags = [`WebAssembly_Memory]
      type tags_0 = tags
    ]
    type 'tags this = 'tags intf constraint 'tags = [> `WebAssembly_Memory ]
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_buffer: 'tags this -> ArrayBuffer.t_0 [@@js.get "buffer"]
    val grow: 'tags this -> delta:float -> float [@@js.call "grow"]
    val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
    val prototype: unit -> t [@@js.get "prototype"]
    val create: MemoryDescriptor.t -> t [@@js.create]
  end
  module ValueType : sig
    type t = ([`L_s122_anyfunc[@js "anyfunc"] | `L_s308_externref[@js "externref"] | `L_s311_f32[@js "f32"] | `L_s312_f64[@js "f64"] | `L_s407_i32[@js "i32"] | `L_s408_i64[@js "i64"] | `L_s846_v128[@js "v128"]] [@js.enum])
    type t_0 = t
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
  end
  module GlobalDescriptor : sig
    type t = [`WebAssembly_GlobalDescriptor] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type t_0 = t
    [@@@js.stop]
    type tags = [`WebAssembly_GlobalDescriptor]
    type tags_0 = tags
    [@@@js.start]
    [@@@js.implem 
      type tags = [`WebAssembly_GlobalDescriptor]
      type tags_0 = tags
    ]
    type 'tags this = 'tags intf constraint 'tags = [> `WebAssembly_GlobalDescriptor ]
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_mutable: 'tags this -> bool option [@@js.get "mutable"]
    val set_mutable: 'tags this -> bool -> unit [@@js.set "mutable"]
    val get_value: 'tags this -> ValueType.t [@@js.get "value"]
    val set_value: 'tags this -> ValueType.t -> unit [@@js.set "value"]
    val create: ?mutable_:(bool[@js "mutable"]) -> value:ValueType.t -> unit -> t [@@js.builder]
    val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  end
  module[@js.scope "Global"] Global : sig
    type t = [`WebAssembly_Global] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type t_0 = t
    [@@@js.stop]
    type tags = [`WebAssembly_Global]
    type tags_0 = tags
    [@@@js.start]
    [@@@js.implem 
      type tags = [`WebAssembly_Global]
      type tags_0 = tags
    ]
    type 'tags this = 'tags intf constraint 'tags = [> `WebAssembly_Global ]
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_value: 'tags this -> any [@@js.get "value"]
    val set_value: 'tags this -> any -> unit [@@js.set "value"]
    val valueOf: 'tags this -> any [@@js.call "valueOf"]
    val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
    val prototype: unit -> t [@@js.get "prototype"]
    val create: descriptor:GlobalDescriptor.t -> ?v:any -> unit -> t [@@js.create]
  end
  module ExportValue : sig
    type t = (untyped_function, Global.t, Memory.t, Table.t) union4
    type t_0 = t
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
  end
  module ImportValue : sig
    type t = ([`Number of float | `Other of ExportValue.t] [@js.union on_field "dummy"]) Primitive.t
    type t_0 = t
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
  end
  module ModuleImports : sig
    type t = (string, ImportValue.t) Record.t_2
    type t_0 = t
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
  end
  module Imports : sig
    type t = (string, ModuleImports.t) Record.t_2
    type t_0 = t
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
  end
  module Exports : sig
    type t = (string, ExportValue.t) Record.t_2
    type t_0 = t
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
  end
  module[@js.scope "Instance"] Instance : sig
    type t = [`WebAssembly_Instance] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type t_0 = t
    [@@@js.stop]
    type tags = [`WebAssembly_Instance]
    type tags_0 = tags
    [@@@js.start]
    [@@@js.implem 
      type tags = [`WebAssembly_Instance]
      type tags_0 = tags
    ]
    type 'tags this = 'tags intf constraint 'tags = [> `WebAssembly_Instance ]
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_exports: 'tags this -> Exports.t [@@js.get "exports"]
    val create: exports:Exports.t -> unit -> t [@@js.builder]
    val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
    val prototype: unit -> t [@@js.get "prototype"]
    val create': module_:Module.t -> ?importObject:Imports.t -> unit -> t [@@js.create]
  end
  module WebAssemblyInstantiatedSource : sig
    type t = [`WebAssembly_WebAssemblyInstantiatedSource] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type t_0 = t
    [@@@js.stop]
    type tags = [`WebAssembly_WebAssemblyInstantiatedSource]
    type tags_0 = tags
    [@@@js.start]
    [@@@js.implem 
      type tags = [`WebAssembly_WebAssemblyInstantiatedSource]
      type tags_0 = tags
    ]
    type 'tags this = 'tags intf constraint 'tags = [> `WebAssembly_WebAssemblyInstantiatedSource ]
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_instance: 'tags this -> Instance.t [@@js.get "instance"]
    val set_instance: 'tags this -> Instance.t -> unit [@@js.set "instance"]
    val get_module: 'tags this -> Module.t [@@js.get "module"]
    val set_module: 'tags this -> Module.t -> unit [@@js.set "module"]
    val create: instance:Instance.t -> module_:(Module.t[@js "module"]) -> unit -> t [@@js.builder]
    val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  end
  module[@js.scope "RuntimeError"] RuntimeError : sig
    type t = [`WebAssembly_RuntimeError] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type t_0 = t
    [@@@js.stop]
    type tags = [`WebAssembly_RuntimeError]
    type tags_0 = tags
    [@@@js.start]
    [@@@js.implem 
      type tags = [`WebAssembly_RuntimeError]
      type tags_0 = tags
    ]
    type 'tags this = 'tags intf constraint 'tags = [> `WebAssembly_RuntimeError ]
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
    val prototype: unit -> t [@@js.get "prototype"]
    val create: ?message:string -> unit -> t [@@js.create]
    val invoke: ?message:string -> unit -> t [@@js.invoke]
  end
  module[@js.scope "LinkError"] LinkError : sig
    type t = [`WebAssembly_LinkError] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type t_0 = t
    [@@@js.stop]
    type tags = [`WebAssembly_LinkError]
    type tags_0 = tags
    [@@@js.start]
    [@@@js.implem 
      type tags = [`WebAssembly_LinkError]
      type tags_0 = tags
    ]
    type 'tags this = 'tags intf constraint 'tags = [> `WebAssembly_LinkError ]
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
    val prototype: unit -> t [@@js.get "prototype"]
    val create: ?message:string -> unit -> t [@@js.create]
    val invoke: ?message:string -> unit -> t [@@js.invoke]
  end
  module[@js.scope "CompileError"] CompileError : sig
    type t = [`WebAssembly_CompileError] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type t_0 = t
    [@@@js.stop]
    type tags = [`WebAssembly_CompileError]
    type tags_0 = tags
    [@@@js.start]
    [@@@js.implem 
      type tags = [`WebAssembly_CompileError]
      type tags_0 = tags
    ]
    type 'tags this = 'tags intf constraint 'tags = [> `WebAssembly_CompileError ]
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
    val prototype: unit -> t [@@js.get "prototype"]
    val create: ?message:string -> unit -> t [@@js.create]
    val invoke: ?message:string -> unit -> t [@@js.invoke]
  end
  val compile: BufferSource.t -> Module.t Promise.t_1 [@@js.global "compile"]
  val compileStreaming: (Response.t, Response.t PromiseLike.t_1) union2 -> Module.t Promise.t_1 [@@js.global "compileStreaming"]
  val instantiate: bytes:BufferSource.t -> ?importObject:Imports.t -> unit -> WebAssemblyInstantiatedSource.t Promise.t_1 [@@js.global "instantiate"]
  val instantiate': moduleObject:Module.t -> ?importObject:Imports.t -> unit -> Instance.t Promise.t_1 [@@js.global "instantiate"]
  val instantiateStreaming: source:(Response.t, Response.t PromiseLike.t_1) union2 -> ?importObject:Imports.t -> unit -> WebAssemblyInstantiatedSource.t Promise.t_1 [@@js.global "instantiateStreaming"]
  val validate: BufferSource.t -> bool [@@js.global "validate"]
end
module WEBGL_multi_draw : sig
  type t = [`WEBGL_multi_draw] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`WEBGL_multi_draw]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`WEBGL_multi_draw]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `WEBGL_multi_draw ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val multiDrawArraysInstancedWEBGL: 'tags this -> mode:GLenum.t -> firstsList:([`U1 of Int32Array.t_0 | `U2 of GLint.t Iterable.t_1] [@js.union]) -> firstsOffset:GLuint.t -> countsList:([`U1 of Int32Array.t_0 | `U2 of GLsizei.t Iterable.t_1] [@js.union]) -> countsOffset:GLuint.t -> instanceCountsList:([`U1 of Int32Array.t_0 | `U2 of GLsizei.t Iterable.t_1] [@js.union]) -> instanceCountsOffset:GLuint.t -> drawcount:GLsizei.t -> unit [@@js.call "multiDrawArraysInstancedWEBGL"]
  val multiDrawArraysWEBGL: 'tags this -> mode:GLenum.t -> firstsList:([`U1 of Int32Array.t_0 | `U2 of GLint.t Iterable.t_1] [@js.union]) -> firstsOffset:GLuint.t -> countsList:([`U1 of Int32Array.t_0 | `U2 of GLsizei.t Iterable.t_1] [@js.union]) -> countsOffset:GLuint.t -> drawcount:GLsizei.t -> unit [@@js.call "multiDrawArraysWEBGL"]
  val multiDrawElementsInstancedWEBGL: 'tags this -> mode:GLenum.t -> countsList:([`U1 of Int32Array.t_0 | `U2 of GLint.t Iterable.t_1] [@js.union]) -> countsOffset:GLuint.t -> type_:GLenum.t -> offsetsList:([`U1 of Int32Array.t_0 | `U2 of GLsizei.t Iterable.t_1] [@js.union]) -> offsetsOffset:GLuint.t -> instanceCountsList:([`U1 of Int32Array.t_0 | `U2 of GLsizei.t Iterable.t_1] [@js.union]) -> instanceCountsOffset:GLuint.t -> drawcount:GLsizei.t -> unit [@@js.call "multiDrawElementsInstancedWEBGL"]
  val multiDrawElementsWEBGL: 'tags this -> mode:GLenum.t -> countsList:([`U1 of Int32Array.t_0 | `U2 of GLint.t Iterable.t_1] [@js.union]) -> countsOffset:GLuint.t -> type_:GLenum.t -> offsetsList:([`U1 of Int32Array.t_0 | `U2 of GLsizei.t Iterable.t_1] [@js.union]) -> offsetsOffset:GLuint.t -> drawcount:GLsizei.t -> unit [@@js.call "multiDrawElementsWEBGL"]
  val multiDrawArraysInstancedWEBGL': 'tags this -> mode:GLenum.t -> firstsList:([`U1 of Int32Array.t_0 | `U2 of GLint.t list] [@js.union]) -> firstsOffset:GLuint.t -> countsList:([`U1 of Int32Array.t_0 | `U2 of GLsizei.t list] [@js.union]) -> countsOffset:GLuint.t -> instanceCountsList:([`U1 of Int32Array.t_0 | `U2 of GLsizei.t list] [@js.union]) -> instanceCountsOffset:GLuint.t -> drawcount:GLsizei.t -> unit [@@js.call "multiDrawArraysInstancedWEBGL"]
  val multiDrawArraysWEBGL': 'tags this -> mode:GLenum.t -> firstsList:([`U1 of Int32Array.t_0 | `U2 of GLint.t list] [@js.union]) -> firstsOffset:GLuint.t -> countsList:([`U1 of Int32Array.t_0 | `U2 of GLsizei.t list] [@js.union]) -> countsOffset:GLuint.t -> drawcount:GLsizei.t -> unit [@@js.call "multiDrawArraysWEBGL"]
  val multiDrawElementsInstancedWEBGL': 'tags this -> mode:GLenum.t -> countsList:([`U1 of Int32Array.t_0 | `U2 of GLint.t list] [@js.union]) -> countsOffset:GLuint.t -> type_:GLenum.t -> offsetsList:([`U1 of Int32Array.t_0 | `U2 of GLsizei.t list] [@js.union]) -> offsetsOffset:GLuint.t -> instanceCountsList:([`U1 of Int32Array.t_0 | `U2 of GLsizei.t list] [@js.union]) -> instanceCountsOffset:GLuint.t -> drawcount:GLsizei.t -> unit [@@js.call "multiDrawElementsInstancedWEBGL"]
  val multiDrawElementsWEBGL': 'tags this -> mode:GLenum.t -> countsList:([`U1 of Int32Array.t_0 | `U2 of GLint.t list] [@js.union]) -> countsOffset:GLuint.t -> type_:GLenum.t -> offsetsList:([`U1 of Int32Array.t_0 | `U2 of GLsizei.t list] [@js.union]) -> offsetsOffset:GLuint.t -> drawcount:GLsizei.t -> unit [@@js.call "multiDrawElementsWEBGL"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module VisualViewportEventMap : sig
  type t = [`VisualViewportEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`VisualViewportEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`VisualViewportEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `VisualViewportEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_resize: 'tags this -> Event.t [@@js.get "resize"]
  val set_resize: 'tags this -> Event.t -> unit [@@js.set "resize"]
  val get_scroll: 'tags this -> Event.t [@@js.get "scroll"]
  val set_scroll: 'tags this -> Event.t -> unit [@@js.set "scroll"]
  val create: resize:Event.t -> scroll:Event.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module VideoFacingModeEnum : sig
  type t = ([`L_s296_environment[@js "environment"] | `L_s456_left[@js "left"] | `L_s680_right[@js "right"] | `L_s845_user[@js "user"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module ScrollSetting : sig
  type t = ([`L_s0[@js ""] | `L_s835_up[@js "up"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module[@js.scope "VTTRegion"] VTTRegion : sig
  type t = [`VTTRegion] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`VTTRegion]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`VTTRegion]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `VTTRegion ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_id: 'tags this -> string [@@js.get "id"]
  val set_id: 'tags this -> string -> unit [@@js.set "id"]
  val get_lines: 'tags this -> float [@@js.get "lines"]
  val set_lines: 'tags this -> float -> unit [@@js.set "lines"]
  val get_regionAnchorX: 'tags this -> float [@@js.get "regionAnchorX"]
  val set_regionAnchorX: 'tags this -> float -> unit [@@js.set "regionAnchorX"]
  val get_regionAnchorY: 'tags this -> float [@@js.get "regionAnchorY"]
  val set_regionAnchorY: 'tags this -> float -> unit [@@js.set "regionAnchorY"]
  val get_scroll: 'tags this -> ScrollSetting.t [@@js.get "scroll"]
  val set_scroll: 'tags this -> ScrollSetting.t -> unit [@@js.set "scroll"]
  val get_viewportAnchorX: 'tags this -> float [@@js.get "viewportAnchorX"]
  val set_viewportAnchorX: 'tags this -> float -> unit [@@js.set "viewportAnchorX"]
  val get_viewportAnchorY: 'tags this -> float [@@js.get "viewportAnchorY"]
  val set_viewportAnchorY: 'tags this -> float -> unit [@@js.set "viewportAnchorY"]
  val get_width: 'tags this -> float [@@js.get "width"]
  val set_width: 'tags this -> float -> unit [@@js.set "width"]
  val create: id:string -> lines:float -> regionAnchorX:float -> regionAnchorY:float -> scroll:ScrollSetting.t -> viewportAnchorX:float -> viewportAnchorY:float -> width:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end
module PositionAlignSetting : sig
  type t = ([`L_s141_auto[@js "auto"] | `L_s185_center[@js "center"] | `L_s465_line_left[@js "line-left"] | `L_s466_line_right[@js "line-right"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module AutoKeyword : sig
  type t = ([`L_s141_auto[@js "auto"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module LineAndPositionSetting : sig
  type t = ([`Number of float | `Other of AutoKeyword.t] [@js.union on_field "dummy"]) Primitive.t
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module LineAlignSetting : sig
  type t = ([`L_s185_center[@js "center"] | `L_s290_end[@js "end"] | `L_s754_start[@js "start"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module DirectionSetting : sig
  type t = ([`L_s0[@js ""] | `L_s488_lr[@js "lr"] | `L_s681_rl[@js "rl"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module AlignSetting : sig
  type t = ([`L_s185_center[@js "center"] | `L_s290_end[@js "end"] | `L_s456_left[@js "left"] | `L_s680_right[@js "right"] | `L_s754_start[@js "start"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module[@js.scope "VTTCue"] VTTCue : sig
  type t = [`EventTarget | `TextTrackCue | `VTTCue] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventTarget | `TextTrackCue | `VTTCue]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventTarget | `TextTrackCue | `VTTCue]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `VTTCue ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_align: 'tags this -> AlignSetting.t [@@js.get "align"]
  val set_align: 'tags this -> AlignSetting.t -> unit [@@js.set "align"]
  val get_line: 'tags this -> LineAndPositionSetting.t [@@js.get "line"]
  val set_line: 'tags this -> LineAndPositionSetting.t -> unit [@@js.set "line"]
  val get_lineAlign: 'tags this -> LineAlignSetting.t [@@js.get "lineAlign"]
  val set_lineAlign: 'tags this -> LineAlignSetting.t -> unit [@@js.set "lineAlign"]
  val get_position: 'tags this -> LineAndPositionSetting.t [@@js.get "position"]
  val set_position: 'tags this -> LineAndPositionSetting.t -> unit [@@js.set "position"]
  val get_positionAlign: 'tags this -> PositionAlignSetting.t [@@js.get "positionAlign"]
  val set_positionAlign: 'tags this -> PositionAlignSetting.t -> unit [@@js.set "positionAlign"]
  val get_region: 'tags this -> VTTRegion.t option [@@js.get "region"]
  val set_region: 'tags this -> VTTRegion.t option -> unit [@@js.set "region"]
  val get_size: 'tags this -> float [@@js.get "size"]
  val set_size: 'tags this -> float -> unit [@@js.set "size"]
  val get_snapToLines: 'tags this -> bool [@@js.get "snapToLines"]
  val set_snapToLines: 'tags this -> bool -> unit [@@js.set "snapToLines"]
  val get_text: 'tags this -> string [@@js.get "text"]
  val set_text: 'tags this -> string -> unit [@@js.set "text"]
  val get_vertical: 'tags this -> DirectionSetting.t [@@js.get "vertical"]
  val set_vertical: 'tags this -> DirectionSetting.t -> unit [@@js.set "vertical"]
  val getCueAsHTML: 'tags this -> DocumentFragment.t [@@js.call "getCueAsHTML"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'TextTrackCueEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'TextTrackCueEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: startTime:float -> endTime:float -> text:string -> t [@@js.create]
end
module[@js.scope "TransformStreamDefaultController"] TransformStreamDefaultController : sig
  type 'O t = [`TransformStreamDefaultController of 'O] intf [@@js.custom { of_js=(fun _O -> Obj.magic); to_js=(fun _O -> Obj.magic) }]
  type 'O t_1 = 'O t
  type t_0 = any t
  [@@@js.stop]
  type 'O tags = [`TransformStreamDefaultController of 'O]
  type 'O tags_1 = 'O tags
  type tags_0 = any tags
  [@@@js.start]
  [@@@js.implem 
    type 'O tags = [`TransformStreamDefaultController of 'O]
    type 'O tags_1 = 'O tags
    type tags_0 = any tags
  ]
  type ('tags, 'O) this = 'tags intf constraint 'tags = [> `TransformStreamDefaultController of 'O ]
  val t_to_js: ('O -> Ojs.t) -> 'O t -> Ojs.t
  val t_of_js: (Ojs.t -> 'O) -> Ojs.t -> 'O t
  val t_1_to_js: ('O -> Ojs.t) -> 'O t_1 -> Ojs.t
  val t_1_of_js: (Ojs.t -> 'O) -> Ojs.t -> 'O t_1
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_desiredSize: ('tags, 'O) this -> float option [@@js.get "desiredSize"]
  val enqueue: ('tags, 'O) this -> ?chunk:'O -> unit -> unit [@@js.call "enqueue"]
  val error: ('tags, 'O) this -> ?reason:any -> unit -> unit [@@js.call "error"]
  val terminate: ('tags, 'O) this -> unit [@@js.call "terminate"]
  val cast_from: ('tags, 'O) this -> 'O t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t_0 [@@js.get "prototype"]
  val create: unit -> t_0 [@@js.create]
end
module TransformerTransformCallback : sig
  type ('I, 'O) t = [`TransformerTransformCallback of ('I * 'O)] intf [@@js.custom { of_js=(fun _I _O -> Obj.magic); to_js=(fun _I _O -> Obj.magic) }]
  type ('I, 'O) t_2 = ('I, 'O) t
  [@@@js.stop]
  type ('I, 'O) tags = [`TransformerTransformCallback of ('I * 'O)]
  type ('I, 'O) tags_2 = ('I, 'O) tags
  [@@@js.start]
  [@@@js.implem 
    type ('I, 'O) tags = [`TransformerTransformCallback of ('I * 'O)]
    type ('I, 'O) tags_2 = ('I, 'O) tags
  ]
  type ('tags, 'I, 'O) this = 'tags intf constraint 'tags = [> `TransformerTransformCallback of ('I * 'O) ]
  val t_to_js: ('I -> Ojs.t) -> ('O -> Ojs.t) -> ('I, 'O) t -> Ojs.t
  val t_of_js: (Ojs.t -> 'I) -> (Ojs.t -> 'O) -> Ojs.t -> ('I, 'O) t
  val t_2_to_js: ('I -> Ojs.t) -> ('O -> Ojs.t) -> ('I, 'O) t_2 -> Ojs.t
  val t_2_of_js: (Ojs.t -> 'I) -> (Ojs.t -> 'O) -> Ojs.t -> ('I, 'O) t_2
  val apply: ('tags, 'I, 'O) this -> chunk:'I -> controller:'O TransformStreamDefaultController.t -> (unit, unit PromiseLike.t_1) union2 [@@js.apply]
  val cast_from: ('tags, 'I, 'O) this -> ('I, 'O) t [@@js.custom let cast_from = Obj.magic]
end
module TransformerStartCallback : sig
  type 'O t = [`TransformerStartCallback of 'O] intf [@@js.custom { of_js=(fun _O -> Obj.magic); to_js=(fun _O -> Obj.magic) }]
  type 'O t_1 = 'O t
  [@@@js.stop]
  type 'O tags = [`TransformerStartCallback of 'O]
  type 'O tags_1 = 'O tags
  [@@@js.start]
  [@@@js.implem 
    type 'O tags = [`TransformerStartCallback of 'O]
    type 'O tags_1 = 'O tags
  ]
  type ('tags, 'O) this = 'tags intf constraint 'tags = [> `TransformerStartCallback of 'O ]
  val t_to_js: ('O -> Ojs.t) -> 'O t -> Ojs.t
  val t_of_js: (Ojs.t -> 'O) -> Ojs.t -> 'O t
  val t_1_to_js: ('O -> Ojs.t) -> 'O t_1 -> Ojs.t
  val t_1_of_js: (Ojs.t -> 'O) -> Ojs.t -> 'O t_1
  val apply: ('tags, 'O) this -> controller:'O TransformStreamDefaultController.t -> any [@@js.apply]
  val cast_from: ('tags, 'O) this -> 'O t [@@js.custom let cast_from = Obj.magic]
end
module TransformerFlushCallback : sig
  type 'O t = [`TransformerFlushCallback of 'O] intf [@@js.custom { of_js=(fun _O -> Obj.magic); to_js=(fun _O -> Obj.magic) }]
  type 'O t_1 = 'O t
  [@@@js.stop]
  type 'O tags = [`TransformerFlushCallback of 'O]
  type 'O tags_1 = 'O tags
  [@@@js.start]
  [@@@js.implem 
    type 'O tags = [`TransformerFlushCallback of 'O]
    type 'O tags_1 = 'O tags
  ]
  type ('tags, 'O) this = 'tags intf constraint 'tags = [> `TransformerFlushCallback of 'O ]
  val t_to_js: ('O -> Ojs.t) -> 'O t -> Ojs.t
  val t_of_js: (Ojs.t -> 'O) -> Ojs.t -> 'O t
  val t_1_to_js: ('O -> Ojs.t) -> 'O t_1 -> Ojs.t
  val t_1_of_js: (Ojs.t -> 'O) -> Ojs.t -> 'O t_1
  val apply: ('tags, 'O) this -> controller:'O TransformStreamDefaultController.t -> (unit, unit PromiseLike.t_1) union2 [@@js.apply]
  val cast_from: ('tags, 'O) this -> 'O t [@@js.custom let cast_from = Obj.magic]
end
module Transformer : sig
  type ('I, 'O) t = [`Transformer of ('I * 'O)] intf [@@js.custom { of_js=(fun _I _O -> Obj.magic); to_js=(fun _I _O -> Obj.magic) }]
  type ('I, 'O) t_2 = ('I, 'O) t
  type 'I t_1 = ('I, any) t
  type t_0 = (any, any) t
  [@@@js.stop]
  type ('I, 'O) tags = [`Transformer of ('I * 'O)]
  type ('I, 'O) tags_2 = ('I, 'O) tags
  type 'I tags_1 = ('I, any) tags
  type tags_0 = (any, any) tags
  [@@@js.start]
  [@@@js.implem 
    type ('I, 'O) tags = [`Transformer of ('I * 'O)]
    type ('I, 'O) tags_2 = ('I, 'O) tags
    type 'I tags_1 = ('I, any) tags
    type tags_0 = (any, any) tags
  ]
  type ('tags, 'I, 'O) this = 'tags intf constraint 'tags = [> `Transformer of ('I * 'O) ]
  val t_to_js: ('I -> Ojs.t) -> ('O -> Ojs.t) -> ('I, 'O) t -> Ojs.t
  val t_of_js: (Ojs.t -> 'I) -> (Ojs.t -> 'O) -> Ojs.t -> ('I, 'O) t
  val t_2_to_js: ('I -> Ojs.t) -> ('O -> Ojs.t) -> ('I, 'O) t_2 -> Ojs.t
  val t_2_of_js: (Ojs.t -> 'I) -> (Ojs.t -> 'O) -> Ojs.t -> ('I, 'O) t_2
  val t_1_to_js: ('I -> Ojs.t) -> 'I t_1 -> Ojs.t
  val t_1_of_js: (Ojs.t -> 'I) -> Ojs.t -> 'I t_1
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_flush: ('tags, 'I, 'O) this -> 'O TransformerFlushCallback.t option [@@js.get "flush"]
  val set_flush: ('tags, 'I, 'O) this -> 'O TransformerFlushCallback.t -> unit [@@js.set "flush"]
  val get_readableType: ('tags, 'I, 'O) this -> undefined [@@js.get "readableType"]
  val set_readableType: ('tags, 'I, 'O) this -> undefined -> unit [@@js.set "readableType"]
  val get_start: ('tags, 'I, 'O) this -> 'O TransformerStartCallback.t option [@@js.get "start"]
  val set_start: ('tags, 'I, 'O) this -> 'O TransformerStartCallback.t -> unit [@@js.set "start"]
  val get_transform: ('tags, 'I, 'O) this -> ('I, 'O) TransformerTransformCallback.t option [@@js.get "transform"]
  val set_transform: ('tags, 'I, 'O) this -> ('I, 'O) TransformerTransformCallback.t -> unit [@@js.set "transform"]
  val get_writableType: ('tags, 'I, 'O) this -> undefined [@@js.get "writableType"]
  val set_writableType: ('tags, 'I, 'O) this -> undefined -> unit [@@js.set "writableType"]
  val create: ?flush:'O TransformerFlushCallback.t -> ?readableType:never -> ?start:'O TransformerStartCallback.t -> ?transform:('I, 'O) TransformerTransformCallback.t -> ?writableType:never -> unit -> ('I, 'O) t [@@js.builder]
  val cast_from: ('tags, 'I, 'O) this -> ('I, 'O) t [@@js.custom let cast_from = Obj.magic]
end
module[@js.scope "TransformStream"] TransformStream : sig
  type ('I, 'O) t = [`TransformStream of ('I * 'O)] intf [@@js.custom { of_js=(fun _I _O -> Obj.magic); to_js=(fun _I _O -> Obj.magic) }]
  type ('I, 'O) t_2 = ('I, 'O) t
  type 'I t_1 = ('I, any) t
  type t_0 = (any, any) t
  [@@@js.stop]
  type ('I, 'O) tags = [`TransformStream of ('I * 'O)]
  type ('I, 'O) tags_2 = ('I, 'O) tags
  type 'I tags_1 = ('I, any) tags
  type tags_0 = (any, any) tags
  [@@@js.start]
  [@@@js.implem 
    type ('I, 'O) tags = [`TransformStream of ('I * 'O)]
    type ('I, 'O) tags_2 = ('I, 'O) tags
    type 'I tags_1 = ('I, any) tags
    type tags_0 = (any, any) tags
  ]
  type ('tags, 'I, 'O) this = 'tags intf constraint 'tags = [> `TransformStream of ('I * 'O) ]
  val t_to_js: ('I -> Ojs.t) -> ('O -> Ojs.t) -> ('I, 'O) t -> Ojs.t
  val t_of_js: (Ojs.t -> 'I) -> (Ojs.t -> 'O) -> Ojs.t -> ('I, 'O) t
  val t_2_to_js: ('I -> Ojs.t) -> ('O -> Ojs.t) -> ('I, 'O) t_2 -> Ojs.t
  val t_2_of_js: (Ojs.t -> 'I) -> (Ojs.t -> 'O) -> Ojs.t -> ('I, 'O) t_2
  val t_1_to_js: ('I -> Ojs.t) -> 'I t_1 -> Ojs.t
  val t_1_of_js: (Ojs.t -> 'I) -> Ojs.t -> 'I t_1
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_readable: ('tags, 'I, 'O) this -> 'O ReadableStream.t [@@js.get "readable"]
  val get_writable: ('tags, 'I, 'O) this -> 'I WritableStream.t [@@js.get "writable"]
  val create: readable:'O ReadableStream.t -> writable:'I WritableStream.t -> unit -> ('I, 'O) t [@@js.builder]
  val cast_from: ('tags, 'I, 'O) this -> ('I, 'O) t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t_0 [@@js.get "prototype"]
  val create': ?transformer:('I, 'O) Transformer.t -> ?writableStrategy:'I QueuingStrategy.t -> ?readableStrategy:'O QueuingStrategy.t -> unit -> ('I, 'O) t [@@js.create]
end
module TextTrackListEventMap : sig
  type t = [`TextTrackListEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`TextTrackListEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`TextTrackListEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `TextTrackListEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_addtrack: 'tags this -> TrackEvent.t [@@js.get "addtrack"]
  val set_addtrack: 'tags this -> TrackEvent.t -> unit [@@js.set "addtrack"]
  val get_change: 'tags this -> Event.t [@@js.get "change"]
  val set_change: 'tags this -> Event.t -> unit [@@js.set "change"]
  val get_removetrack: 'tags this -> TrackEvent.t [@@js.get "removetrack"]
  val set_removetrack: 'tags this -> TrackEvent.t -> unit [@@js.set "removetrack"]
  val create: addtrack:TrackEvent.t -> change:Event.t -> removetrack:TrackEvent.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module TextTrackEventMap : sig
  type t = [`TextTrackEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`TextTrackEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`TextTrackEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `TextTrackEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_cuechange: 'tags this -> Event.t [@@js.get "cuechange"]
  val set_cuechange: 'tags this -> Event.t -> unit [@@js.set "cuechange"]
  val create: cuechange:Event.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module TextTrackCueEventMap : sig
  type t = [`TextTrackCueEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`TextTrackCueEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`TextTrackCueEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `TextTrackCueEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_enter: 'tags this -> Event.t [@@js.get "enter"]
  val set_enter: 'tags this -> Event.t -> unit [@@js.set "enter"]
  val get_exit: 'tags this -> Event.t [@@js.get "exit"]
  val set_exit: 'tags this -> Event.t -> unit [@@js.set "exit"]
  val create: enter:Event.t -> exit:Event.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module TextEncoderCommon : sig
  type t = [`TextEncoderCommon] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`TextEncoderCommon]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`TextEncoderCommon]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `TextEncoderCommon ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Returns "utf-8". *)
  val get_encoding: 'tags this -> string [@@js.get "encoding"]
  val create: encoding:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module GenericTransformStream : sig
  type t = [`GenericTransformStream] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`GenericTransformStream]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`GenericTransformStream]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `GenericTransformStream ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_readable: 'tags this -> ReadableStream.t_0 [@@js.get "readable"]
  val get_writable: 'tags this -> WritableStream.t_0 [@@js.get "writable"]
  val create: readable:ReadableStream.t_0 -> writable:WritableStream.t_0 -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module[@js.scope "TextEncoderStream"] TextEncoderStream : sig
  type t = [`GenericTransformStream | `TextEncoderCommon | `TextEncoderStream] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`GenericTransformStream | `TextEncoderCommon | `TextEncoderStream]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`GenericTransformStream | `TextEncoderCommon | `TextEncoderStream]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `TextEncoderStream ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_readable: 'tags this -> Uint8Array.t_0 ReadableStream.t [@@js.get "readable"]
  val get_writable: 'tags this -> string WritableStream.t [@@js.get "writable"]
  val create: readable:Uint8Array.t_0 ReadableStream.t -> writable:string WritableStream.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end
module TextEncoderEncodeIntoResult : sig
  type t = [`TextEncoderEncodeIntoResult] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`TextEncoderEncodeIntoResult]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`TextEncoderEncodeIntoResult]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `TextEncoderEncodeIntoResult ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_read: 'tags this -> float option [@@js.get "read"]
  val set_read: 'tags this -> float -> unit [@@js.set "read"]
  val get_written: 'tags this -> float option [@@js.get "written"]
  val set_written: 'tags this -> float -> unit [@@js.set "written"]
  val create: ?read:float -> ?written:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** TextEncoder takes a stream of code points as input and emits a stream of bytes. For a more scalable, non-native library, see StringView – a C-like representation of strings based on typed arrays. *)
module[@js.scope "TextEncoder"] TextEncoder : sig
  type t = [`TextEncoder | `TextEncoderCommon] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`TextEncoder | `TextEncoderCommon]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`TextEncoder | `TextEncoderCommon]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `TextEncoder ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Returns the result of running UTF-8's encoder. *)
  val encode: 'tags this -> ?input:string -> unit -> Uint8Array.t_0 [@@js.call "encode"]
  
  (** Runs the UTF-8 encoder on source, stores the result of that operation into destination, and returns the progress made as an object wherein read is the number of converted code units of source and written is the number of bytes modified in destination. *)
  val encodeInto: 'tags this -> source:string -> destination:Uint8Array.t_0 -> TextEncoderEncodeIntoResult.t [@@js.call "encodeInto"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module TextDecoderOptions : sig
  type t = [`TextDecoderOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`TextDecoderOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`TextDecoderOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `TextDecoderOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_fatal: 'tags this -> bool option [@@js.get "fatal"]
  val set_fatal: 'tags this -> bool -> unit [@@js.set "fatal"]
  val get_ignoreBOM: 'tags this -> bool option [@@js.get "ignoreBOM"]
  val set_ignoreBOM: 'tags this -> bool -> unit [@@js.set "ignoreBOM"]
  val create: ?fatal:bool -> ?ignoreBOM:bool -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module TextDecoderCommon : sig
  type t = [`TextDecoderCommon] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`TextDecoderCommon]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`TextDecoderCommon]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `TextDecoderCommon ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Returns encoding's name, lowercased. *)
  val get_encoding: 'tags this -> string [@@js.get "encoding"]
  
  (** Returns true if error mode is "fatal", otherwise false. *)
  val get_fatal: 'tags this -> bool [@@js.get "fatal"]
  
  (** Returns the value of ignore BOM. *)
  val get_ignoreBOM: 'tags this -> bool [@@js.get "ignoreBOM"]
  val create: encoding:string -> fatal:bool -> ignoreBOM:bool -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module[@js.scope "TextDecoderStream"] TextDecoderStream : sig
  type t = [`GenericTransformStream | `TextDecoderCommon | `TextDecoderStream] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`GenericTransformStream | `TextDecoderCommon | `TextDecoderStream]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`GenericTransformStream | `TextDecoderCommon | `TextDecoderStream]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `TextDecoderStream ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_readable: 'tags this -> string ReadableStream.t [@@js.get "readable"]
  val get_writable: 'tags this -> BufferSource.t WritableStream.t [@@js.get "writable"]
  val create: readable:string ReadableStream.t -> writable:BufferSource.t WritableStream.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': ?label:string -> ?options:TextDecoderOptions.t -> unit -> t [@@js.create]
end
module TextDecodeOptions : sig
  type t = [`TextDecodeOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`TextDecodeOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`TextDecodeOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `TextDecodeOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_stream: 'tags this -> bool option [@@js.get "stream"]
  val set_stream: 'tags this -> bool -> unit [@@js.set "stream"]
  val create: ?stream:bool -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** A decoder for a specific method, that is a specific character encoding, like utf-8, iso-8859-2, koi8, cp1261, gbk, etc. A decoder takes a stream of bytes as input and emits a stream of code points. For a more scalable, non-native library, see StringView – a C-like representation of strings based on typed arrays. *)
module[@js.scope "TextDecoder"] TextDecoder : sig
  type t = [`TextDecoder | `TextDecoderCommon] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`TextDecoder | `TextDecoderCommon]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`TextDecoder | `TextDecoderCommon]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `TextDecoder ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    Returns the result of running encoding's decoder. The method can be invoked zero or more times with options's stream set to true, and then once without options's stream (or set to false), to process a fragmented input. If the invocation without options's stream (or set to false) has no input, it's clearest to omit both arguments.
    
    ```
    var string = "", decoder = new TextDecoder(encoding), buffer;
    while(buffer = next_chunk()) \{
      string += decoder.decode(buffer, \{stream:true\});
    \}
    string += decoder.decode(); // end-of-queue
    ```
    
    If the error mode is "fatal" and encoding's decoder returns error, throws a TypeError.
  *)
  val decode: 'tags this -> ?input:BufferSource.t -> ?options:TextDecodeOptions.t -> unit -> string [@@js.call "decode"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: ?label:string -> ?options:TextDecoderOptions.t -> unit -> t [@@js.create]
end

(** @deprecated  *)
module StyleMedia : sig
  type t = [`StyleMedia] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`StyleMedia]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`StyleMedia]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `StyleMedia ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_type: 'tags this -> string [@@js.get "type"]
  val set_type: 'tags this -> string -> unit [@@js.set "type"]
  val matchMedium: 'tags this -> mediaquery:string -> bool [@@js.call "matchMedium"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module SpeechSynthesisUtteranceEventMap : sig
  type t = [`SpeechSynthesisUtteranceEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`SpeechSynthesisUtteranceEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`SpeechSynthesisUtteranceEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SpeechSynthesisUtteranceEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_boundary: 'tags this -> SpeechSynthesisEvent.t [@@js.get "boundary"]
  val set_boundary: 'tags this -> SpeechSynthesisEvent.t -> unit [@@js.set "boundary"]
  val get_end: 'tags this -> SpeechSynthesisEvent.t [@@js.get "end"]
  val set_end: 'tags this -> SpeechSynthesisEvent.t -> unit [@@js.set "end"]
  val get_error: 'tags this -> SpeechSynthesisErrorEvent.t [@@js.get "error"]
  val set_error: 'tags this -> SpeechSynthesisErrorEvent.t -> unit [@@js.set "error"]
  val get_mark: 'tags this -> SpeechSynthesisEvent.t [@@js.get "mark"]
  val set_mark: 'tags this -> SpeechSynthesisEvent.t -> unit [@@js.set "mark"]
  val get_pause: 'tags this -> SpeechSynthesisEvent.t [@@js.get "pause"]
  val set_pause: 'tags this -> SpeechSynthesisEvent.t -> unit [@@js.set "pause"]
  val get_resume: 'tags this -> SpeechSynthesisEvent.t [@@js.get "resume"]
  val set_resume: 'tags this -> SpeechSynthesisEvent.t -> unit [@@js.set "resume"]
  val get_start: 'tags this -> SpeechSynthesisEvent.t [@@js.get "start"]
  val set_start: 'tags this -> SpeechSynthesisEvent.t -> unit [@@js.set "start"]
  val create: boundary:SpeechSynthesisEvent.t -> end_:(SpeechSynthesisEvent.t[@js "end"]) -> error:SpeechSynthesisErrorEvent.t -> mark:SpeechSynthesisEvent.t -> pause:SpeechSynthesisEvent.t -> resume:SpeechSynthesisEvent.t -> start:SpeechSynthesisEvent.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module SpeechSynthesisEventMap : sig
  type t = [`SpeechSynthesisEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`SpeechSynthesisEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`SpeechSynthesisEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SpeechSynthesisEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_voiceschanged: 'tags this -> Event.t [@@js.get "voiceschanged"]
  val set_voiceschanged: 'tags this -> Event.t -> unit [@@js.set "voiceschanged"]
  val create: voiceschanged:Event.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module[@js.scope "SpeechRecognitionAlternative"] SpeechRecognitionAlternative : sig
  type t = [`SpeechRecognitionAlternative] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`SpeechRecognitionAlternative]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`SpeechRecognitionAlternative]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SpeechRecognitionAlternative ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_confidence: 'tags this -> float [@@js.get "confidence"]
  val get_transcript: 'tags this -> string [@@js.get "transcript"]
  val create: confidence:float -> transcript:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end
module[@js.scope "SpeechRecognitionResult"] SpeechRecognitionResult : sig
  type t = [`SpeechRecognitionResult | SpeechRecognitionAlternative.t ArrayLike.tags_1 | SpeechRecognitionAlternative.t IterableIterator.tags_1] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`SpeechRecognitionResult | SpeechRecognitionAlternative.t ArrayLike.tags_1 | SpeechRecognitionAlternative.t IterableIterator.tags_1]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`SpeechRecognitionResult | SpeechRecognitionAlternative.t ArrayLike.tags_1 | SpeechRecognitionAlternative.t IterableIterator.tags_1]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SpeechRecognitionResult ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  (* [Symbol.iterator]: unit -> SpeechRecognitionAlternative.t IterableIterator.t_1 *)
  val get_isFinal: 'tags this -> bool [@@js.get "isFinal"]
  val get_length: 'tags this -> float [@@js.get "length"]
  val item: 'tags this -> index:float -> SpeechRecognitionAlternative.t [@@js.call "item"]
  val get: 'tags this -> float -> SpeechRecognitionAlternative.t [@@js.index_get]
  val set: 'tags this -> float -> SpeechRecognitionAlternative.t -> unit [@@js.index_set]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module[@js.scope "SpeechRecognitionResultList"] SpeechRecognitionResultList : sig
  type t = [`SpeechRecognitionResultList | SpeechRecognitionResult.t ArrayLike.tags_1 | SpeechRecognitionResult.t IterableIterator.tags_1] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`SpeechRecognitionResultList | SpeechRecognitionResult.t ArrayLike.tags_1 | SpeechRecognitionResult.t IterableIterator.tags_1]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`SpeechRecognitionResultList | SpeechRecognitionResult.t ArrayLike.tags_1 | SpeechRecognitionResult.t IterableIterator.tags_1]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SpeechRecognitionResultList ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  (* [Symbol.iterator]: unit -> SpeechRecognitionResult.t IterableIterator.t_1 *)
  val get_length: 'tags this -> float [@@js.get "length"]
  val item: 'tags this -> index:float -> SpeechRecognitionResult.t [@@js.call "item"]
  val get: 'tags this -> float -> SpeechRecognitionResult.t [@@js.index_get]
  val set: 'tags this -> float -> SpeechRecognitionResult.t -> unit [@@js.index_set]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module SourceBufferListEventMap : sig
  type t = [`SourceBufferListEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`SourceBufferListEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`SourceBufferListEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SourceBufferListEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_addsourcebuffer: 'tags this -> Event.t [@@js.get "addsourcebuffer"]
  val set_addsourcebuffer: 'tags this -> Event.t -> unit [@@js.set "addsourcebuffer"]
  val get_removesourcebuffer: 'tags this -> Event.t [@@js.get "removesourcebuffer"]
  val set_removesourcebuffer: 'tags this -> Event.t -> unit [@@js.set "removesourcebuffer"]
  val create: addsourcebuffer:Event.t -> removesourcebuffer:Event.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module SourceBufferEventMap : sig
  type t = [`SourceBufferEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`SourceBufferEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`SourceBufferEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SourceBufferEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_abort: 'tags this -> Event.t [@@js.get "abort"]
  val set_abort: 'tags this -> Event.t -> unit [@@js.set "abort"]
  val get_error: 'tags this -> Event.t [@@js.get "error"]
  val set_error: 'tags this -> Event.t -> unit [@@js.set "error"]
  val get_update: 'tags this -> Event.t [@@js.get "update"]
  val set_update: 'tags this -> Event.t -> unit [@@js.set "update"]
  val get_updateend: 'tags this -> Event.t [@@js.get "updateend"]
  val set_updateend: 'tags this -> Event.t -> unit [@@js.set "updateend"]
  val get_updatestart: 'tags this -> Event.t [@@js.get "updatestart"]
  val set_updatestart: 'tags this -> Event.t -> unit [@@js.set "updatestart"]
  val create: abort:Event.t -> error:Event.t -> update:Event.t -> updateend:Event.t -> updatestart:Event.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module[@js.scope "SharedWorker"] SharedWorker : sig
  type t = [`AbstractWorker | `EventTarget | `SharedWorker] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AbstractWorker | `EventTarget | `SharedWorker]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AbstractWorker | `EventTarget | `SharedWorker]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SharedWorker ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Returns sharedWorker's MessagePort object which can be used to communicate with the global environment. *)
  val get_port: 'tags this -> MessagePort.t [@@js.get "port"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'AbstractWorkerEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'AbstractWorkerEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: scriptURL:([`U1 of string | `U2 of URL.t] [@js.union]) -> ?options:([`U1 of string | `U2 of WorkerOptions.t] [@js.union]) -> unit -> t [@@js.create]
end
module ShadowRootEventMap : sig
  type t = [`ShadowRootEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ShadowRootEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ShadowRootEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ShadowRootEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_slotchange: 'tags this -> Event.t [@@js.get "slotchange"]
  val set_slotchange: 'tags this -> Event.t -> unit [@@js.set "slotchange"]
  val create: slotchange:Event.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module ServiceWorkerRegistrationEventMap : sig
  type t = [`ServiceWorkerRegistrationEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ServiceWorkerRegistrationEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ServiceWorkerRegistrationEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ServiceWorkerRegistrationEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_updatefound: 'tags this -> Event.t [@@js.get "updatefound"]
  val set_updatefound: 'tags this -> Event.t -> unit [@@js.set "updatefound"]
  val create: updatefound:Event.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module ServiceWorkerEventMap : sig
  type t = [`AbstractWorkerEventMap | `ServiceWorkerEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AbstractWorkerEventMap | `ServiceWorkerEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AbstractWorkerEventMap | `ServiceWorkerEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ServiceWorkerEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_statechange: 'tags this -> Event.t [@@js.get "statechange"]
  val set_statechange: 'tags this -> Event.t -> unit [@@js.set "statechange"]
  val create: statechange:Event.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module ServiceWorkerContainerEventMap : sig
  type t = [`ServiceWorkerContainerEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ServiceWorkerContainerEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ServiceWorkerContainerEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ServiceWorkerContainerEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_controllerchange: 'tags this -> Event.t [@@js.get "controllerchange"]
  val set_controllerchange: 'tags this -> Event.t -> unit [@@js.set "controllerchange"]
  val get_message: 'tags this -> MessageEvent.t_0 [@@js.get "message"]
  val set_message: 'tags this -> MessageEvent.t_0 -> unit [@@js.set "message"]
  val get_messageerror: 'tags this -> MessageEvent.t_0 [@@js.get "messageerror"]
  val set_messageerror: 'tags this -> MessageEvent.t_0 -> unit [@@js.set "messageerror"]
  val create: controllerchange:Event.t -> message:MessageEvent.t_0 -> messageerror:MessageEvent.t_0 -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module ScriptProcessorNodeEventMap : sig
  type t = [`ScriptProcessorNodeEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ScriptProcessorNodeEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ScriptProcessorNodeEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ScriptProcessorNodeEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_audioprocess: 'tags this -> AudioProcessingEvent.t [@@js.get "audioprocess"]
  val set_audioprocess: 'tags this -> AudioProcessingEvent.t -> unit [@@js.set "audioprocess"]
  val create: audioprocess:AudioProcessingEvent.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module ScreenOrientationEventMap : sig
  type t = [`ScreenOrientationEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ScreenOrientationEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ScreenOrientationEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ScreenOrientationEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_change: 'tags this -> Event.t [@@js.get "change"]
  val set_change: 'tags this -> Event.t -> unit [@@js.set "change"]
  val create: change:Event.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** A commonly used set of constants used for reflecting gradientUnits, patternContentUnits and other similar attributes. *)
module[@js.scope "SVGUnitTypes"] SVGUnitTypes : sig
  type t = [`SVGUnitTypes] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`SVGUnitTypes]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`SVGUnitTypes]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGUnitTypes ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_SVG_UNIT_TYPE_OBJECTBOUNDINGBOX: 'tags this -> float [@@js.get "SVG_UNIT_TYPE_OBJECTBOUNDINGBOX"]
  val get_SVG_UNIT_TYPE_UNKNOWN: 'tags this -> float [@@js.get "SVG_UNIT_TYPE_UNKNOWN"]
  val get_SVG_UNIT_TYPE_USERSPACEONUSE: 'tags this -> float [@@js.get "SVG_UNIT_TYPE_USERSPACEONUSE"]
  val create: svg_unit_type_objectboundingbox:(float[@js "SVG_UNIT_TYPE_OBJECTBOUNDINGBOX"]) -> svg_unit_type_unknown:(float[@js "SVG_UNIT_TYPE_UNKNOWN"]) -> svg_unit_type_userspaceonuse:(float[@js "SVG_UNIT_TYPE_USERSPACEONUSE"]) -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
  val svg_unit_type_objectboundingbox: unit -> float [@@js.get "SVG_UNIT_TYPE_OBJECTBOUNDINGBOX"]
  val svg_unit_type_unknown: unit -> float [@@js.get "SVG_UNIT_TYPE_UNKNOWN"]
  val svg_unit_type_userspaceonuse: unit -> float [@@js.get "SVG_UNIT_TYPE_USERSPACEONUSE"]
end
module ElementEventMap : sig
  type t = [`ElementEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ElementEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ElementEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ElementEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_fullscreenchange: 'tags this -> Event.t [@@js.get "fullscreenchange"]
  val set_fullscreenchange: 'tags this -> Event.t -> unit [@@js.set "fullscreenchange"]
  val get_fullscreenerror: 'tags this -> Event.t [@@js.get "fullscreenerror"]
  val set_fullscreenerror: 'tags this -> Event.t -> unit [@@js.set "fullscreenerror"]
  val create: fullscreenchange:Event.t -> fullscreenerror:Event.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module DocumentAndElementEventHandlersEventMap : sig
  type t = [`DocumentAndElementEventHandlersEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`DocumentAndElementEventHandlersEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`DocumentAndElementEventHandlersEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `DocumentAndElementEventHandlersEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_copy: 'tags this -> ClipboardEvent.t [@@js.get "copy"]
  val set_copy: 'tags this -> ClipboardEvent.t -> unit [@@js.set "copy"]
  val get_cut: 'tags this -> ClipboardEvent.t [@@js.get "cut"]
  val set_cut: 'tags this -> ClipboardEvent.t -> unit [@@js.set "cut"]
  val get_paste: 'tags this -> ClipboardEvent.t [@@js.get "paste"]
  val set_paste: 'tags this -> ClipboardEvent.t -> unit [@@js.set "paste"]
  val create: copy:ClipboardEvent.t -> cut:ClipboardEvent.t -> paste:ClipboardEvent.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module SVGElementEventMap : sig
  type t = [`DocumentAndElementEventHandlersEventMap | `ElementEventMap | `GlobalEventHandlersEventMap | `SVGElementEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`DocumentAndElementEventHandlersEventMap | `ElementEventMap | `GlobalEventHandlersEventMap | `SVGElementEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`DocumentAndElementEventHandlersEventMap | `ElementEventMap | `GlobalEventHandlersEventMap | `SVGElementEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGElementEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module SVGSVGElementEventMap : sig
  type t = [`DocumentAndElementEventHandlersEventMap | `ElementEventMap | `GlobalEventHandlersEventMap | `SVGElementEventMap | `SVGSVGElementEventMap | `WindowEventHandlersEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`DocumentAndElementEventHandlersEventMap | `ElementEventMap | `GlobalEventHandlersEventMap | `SVGElementEventMap | `SVGSVGElementEventMap | `WindowEventHandlersEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`DocumentAndElementEventHandlersEventMap | `ElementEventMap | `GlobalEventHandlersEventMap | `SVGElementEventMap | `SVGSVGElementEventMap | `WindowEventHandlersEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGSVGElementEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module[@js.scope "SVGRect"] SVGRect : sig
  type t = DOMRect.t
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val prototype: unit -> DOMRect.t [@@js.get "prototype"]
  val create: ?x:float -> ?y:float -> ?width:float -> ?height:float -> unit -> DOMRect.t [@@js.create]
  val fromRect: ?other:DOMRectInit.t -> unit -> DOMRect.t [@@js.global "fromRect"]
end
module[@js.scope "SVGPoint"] SVGPoint : sig
  type t = DOMPoint.t
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val prototype: unit -> DOMPoint.t [@@js.get "prototype"]
  val create: ?x:float -> ?y:float -> ?z:float -> ?w:float -> unit -> DOMPoint.t [@@js.create]
  val fromPoint: ?other:DOMPointInit.t -> unit -> DOMPoint.t [@@js.global "fromPoint"]
end
module[@js.scope "SVGMatrix"] SVGMatrix : sig
  type t = DOMMatrix.t
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val prototype: unit -> DOMMatrix.t [@@js.get "prototype"]
  val create: ?init:([`U1 of string | `U2 of float list] [@js.union]) -> unit -> DOMMatrix.t [@@js.create]
  val fromFloat32Array: Float32Array.t_0 -> DOMMatrix.t [@@js.global "fromFloat32Array"]
  val fromFloat64Array: Float64Array.t_0 -> DOMMatrix.t [@@js.global "fromFloat64Array"]
  val fromMatrix: ?other:DOMMatrixInit.t -> unit -> DOMMatrix.t [@@js.global "fromMatrix"]
end
module RsaKeyAlgorithm : sig
  type t = [`KeyAlgorithm | `RsaKeyAlgorithm] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`KeyAlgorithm | `RsaKeyAlgorithm]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`KeyAlgorithm | `RsaKeyAlgorithm]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RsaKeyAlgorithm ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_modulusLength: 'tags this -> float [@@js.get "modulusLength"]
  val set_modulusLength: 'tags this -> float -> unit [@@js.set "modulusLength"]
  val get_publicExponent: 'tags this -> BigInteger.t [@@js.get "publicExponent"]
  val set_publicExponent: 'tags this -> BigInteger.t -> unit [@@js.set "publicExponent"]
  val create: modulusLength:float -> publicExponent:BigInteger.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module RsaHashedKeyAlgorithm : sig
  type t = [`KeyAlgorithm | `RsaHashedKeyAlgorithm | `RsaKeyAlgorithm] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`KeyAlgorithm | `RsaHashedKeyAlgorithm | `RsaKeyAlgorithm]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`KeyAlgorithm | `RsaHashedKeyAlgorithm | `RsaKeyAlgorithm]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RsaHashedKeyAlgorithm ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_hash: 'tags this -> KeyAlgorithm.t [@@js.get "hash"]
  val set_hash: 'tags this -> KeyAlgorithm.t -> unit [@@js.set "hash"]
  val create: hash:KeyAlgorithm.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module ResizeObserverBoxOptions : sig
  type t = ([`L_s167_border_box[@js "border-box"] | `L_s219_content_box[@js "content-box"] | `L_s254_device_pixel_content_box[@js "device-pixel-content-box"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module ResizeObserverOptions : sig
  type t = [`ResizeObserverOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ResizeObserverOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ResizeObserverOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ResizeObserverOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_box: 'tags this -> ResizeObserverBoxOptions.t option [@@js.get "box"]
  val set_box: 'tags this -> ResizeObserverBoxOptions.t -> unit [@@js.set "box"]
  val create: ?box:ResizeObserverBoxOptions.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module[@js.scope "ResizeObserverSize"] ResizeObserverSize : sig
  type t = [`ResizeObserverSize] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ResizeObserverSize]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ResizeObserverSize]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ResizeObserverSize ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_blockSize: 'tags this -> float [@@js.get "blockSize"]
  val get_inlineSize: 'tags this -> float [@@js.get "inlineSize"]
  val create: blockSize:float -> inlineSize:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end
module[@js.scope "ResizeObserverEntry"] ResizeObserverEntry : sig
  type t = [`ResizeObserverEntry] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ResizeObserverEntry]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ResizeObserverEntry]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ResizeObserverEntry ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_borderBoxSize: 'tags this -> ResizeObserverSize.t list [@@js.get "borderBoxSize"]
  val get_contentBoxSize: 'tags this -> ResizeObserverSize.t list [@@js.get "contentBoxSize"]
  val get_contentRect: 'tags this -> DOMRectReadOnly.t [@@js.get "contentRect"]
  val get_devicePixelContentBoxSize: 'tags this -> ResizeObserverSize.t list [@@js.get "devicePixelContentBoxSize"]
  val get_target: 'tags this -> Element.t [@@js.get "target"]
  val create: borderBoxSize:ResizeObserverSize.t list -> contentBoxSize:ResizeObserverSize.t list -> contentRect:DOMRectReadOnly.t -> devicePixelContentBoxSize:ResizeObserverSize.t list -> target:Element.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end
module[@js.scope "ResizeObserver"] rec ResizeObserver : sig
  type t = [`ResizeObserver] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ResizeObserver]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ResizeObserver]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ResizeObserver ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val disconnect: 'tags this -> unit [@@js.call "disconnect"]
  val observe: 'tags this -> target:Element.t -> ?options:ResizeObserverOptions.t -> unit -> unit [@@js.call "observe"]
  val unobserve: 'tags this -> target:Element.t -> unit [@@js.call "unobserve"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: ResizeObserverCallback.t -> t [@@js.create]
end
and ResizeObserverCallback : sig
  type t = [`ResizeObserverCallback] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ResizeObserverCallback]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ResizeObserverCallback]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ResizeObserverCallback ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val apply: 'tags this -> entries:ResizeObserverEntry.t list -> observer:ResizeObserver.t -> unit [@@js.apply]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module RemotePlaybackEventMap : sig
  type t = [`RemotePlaybackEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`RemotePlaybackEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`RemotePlaybackEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RemotePlaybackEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_connect: 'tags this -> Event.t [@@js.get "connect"]
  val set_connect: 'tags this -> Event.t -> unit [@@js.set "connect"]
  val get_connecting: 'tags this -> Event.t [@@js.get "connecting"]
  val set_connecting: 'tags this -> Event.t -> unit [@@js.set "connecting"]
  val get_disconnect: 'tags this -> Event.t [@@js.get "disconnect"]
  val set_disconnect: 'tags this -> Event.t -> unit [@@js.set "disconnect"]
  val create: connect:Event.t -> connecting:Event.t -> disconnect:Event.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module ReadableStreamReader : sig
  type 'T t = 'T ReadableStreamDefaultReader.t
  type 'T t_1 = 'T t
  val t_to_js: ('T -> Ojs.t) -> 'T t -> Ojs.t
  val t_of_js: (Ojs.t -> 'T) -> Ojs.t -> 'T t
  val t_1_to_js: ('T -> Ojs.t) -> 'T t_1 -> Ojs.t
  val t_1_of_js: (Ojs.t -> 'T) -> Ojs.t -> 'T t_1
end
module RTCStatsType : sig
  type t = ([`L_s178_candidate_pair[@js "candidate-pair"] | `L_s186_certificate[@js "certificate"] | `L_s203_codec[@js "codec"] | `L_s227_csrc[@js "csrc"] | `L_s233_data_channel[@js "data-channel"] | `L_s422_inbound_rtp[@js "inbound-rtp"] | `L_s482_local_candidate[@js "local-candidate"] | `L_s505_media_source[@js "media-source"] | `L_s574_outbound_rtp[@js "outbound-rtp"] | `L_s596_peer_connection[@js "peer-connection"] | `L_s663_remote_candidate[@js "remote-candidate"] | `L_s664_remote_inbound_rtp[@js "remote-inbound-rtp"] | `L_s665_remote_outbound_rtp[@js "remote-outbound-rtp"] | `L_s811_track[@js "track"] | `L_s817_transport[@js "transport"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module RTCStats : sig
  type t = [`RTCStats] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`RTCStats]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`RTCStats]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RTCStats ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_id: 'tags this -> string [@@js.get "id"]
  val set_id: 'tags this -> string -> unit [@@js.set "id"]
  val get_timestamp: 'tags this -> DOMHighResTimeStamp.t [@@js.get "timestamp"]
  val set_timestamp: 'tags this -> DOMHighResTimeStamp.t -> unit [@@js.set "timestamp"]
  val get_type: 'tags this -> RTCStatsType.t [@@js.get "type"]
  val set_type: 'tags this -> RTCStatsType.t -> unit [@@js.set "type"]
  val create: id:string -> timestamp:DOMHighResTimeStamp.t -> type_:(RTCStatsType.t[@js "type"]) -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module RTCTransportStats : sig
  type t = [`RTCStats | `RTCTransportStats] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`RTCStats | `RTCTransportStats]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`RTCStats | `RTCTransportStats]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RTCTransportStats ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_bytesReceived: 'tags this -> float option [@@js.get "bytesReceived"]
  val set_bytesReceived: 'tags this -> float -> unit [@@js.set "bytesReceived"]
  val get_bytesSent: 'tags this -> float option [@@js.get "bytesSent"]
  val set_bytesSent: 'tags this -> float -> unit [@@js.set "bytesSent"]
  val get_dtlsCipher: 'tags this -> string option [@@js.get "dtlsCipher"]
  val set_dtlsCipher: 'tags this -> string -> unit [@@js.set "dtlsCipher"]
  val get_dtlsState: 'tags this -> RTCDtlsTransportState.t [@@js.get "dtlsState"]
  val set_dtlsState: 'tags this -> RTCDtlsTransportState.t -> unit [@@js.set "dtlsState"]
  val get_localCertificateId: 'tags this -> string option [@@js.get "localCertificateId"]
  val set_localCertificateId: 'tags this -> string -> unit [@@js.set "localCertificateId"]
  val get_remoteCertificateId: 'tags this -> string option [@@js.get "remoteCertificateId"]
  val set_remoteCertificateId: 'tags this -> string -> unit [@@js.set "remoteCertificateId"]
  val get_rtcpTransportStatsId: 'tags this -> string option [@@js.get "rtcpTransportStatsId"]
  val set_rtcpTransportStatsId: 'tags this -> string -> unit [@@js.set "rtcpTransportStatsId"]
  val get_selectedCandidatePairId: 'tags this -> string option [@@js.get "selectedCandidatePairId"]
  val set_selectedCandidatePairId: 'tags this -> string -> unit [@@js.set "selectedCandidatePairId"]
  val get_srtpCipher: 'tags this -> string option [@@js.get "srtpCipher"]
  val set_srtpCipher: 'tags this -> string -> unit [@@js.set "srtpCipher"]
  val get_tlsVersion: 'tags this -> string option [@@js.get "tlsVersion"]
  val set_tlsVersion: 'tags this -> string -> unit [@@js.set "tlsVersion"]
  val create: ?bytesReceived:float -> ?bytesSent:float -> ?dtlsCipher:string -> dtlsState:RTCDtlsTransportState.t -> ?localCertificateId:string -> ?remoteCertificateId:string -> ?rtcpTransportStatsId:string -> ?selectedCandidatePairId:string -> ?srtpCipher:string -> ?tlsVersion:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module RTCPeerConnectionEventMap : sig
  type t = [`RTCPeerConnectionEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`RTCPeerConnectionEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`RTCPeerConnectionEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RTCPeerConnectionEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_connectionstatechange: 'tags this -> Event.t [@@js.get "connectionstatechange"]
  val set_connectionstatechange: 'tags this -> Event.t -> unit [@@js.set "connectionstatechange"]
  val get_datachannel: 'tags this -> RTCDataChannelEvent.t [@@js.get "datachannel"]
  val set_datachannel: 'tags this -> RTCDataChannelEvent.t -> unit [@@js.set "datachannel"]
  val get_icecandidate: 'tags this -> RTCPeerConnectionIceEvent.t [@@js.get "icecandidate"]
  val set_icecandidate: 'tags this -> RTCPeerConnectionIceEvent.t -> unit [@@js.set "icecandidate"]
  val get_icecandidateerror: 'tags this -> Event.t [@@js.get "icecandidateerror"]
  val set_icecandidateerror: 'tags this -> Event.t -> unit [@@js.set "icecandidateerror"]
  val get_iceconnectionstatechange: 'tags this -> Event.t [@@js.get "iceconnectionstatechange"]
  val set_iceconnectionstatechange: 'tags this -> Event.t -> unit [@@js.set "iceconnectionstatechange"]
  val get_icegatheringstatechange: 'tags this -> Event.t [@@js.get "icegatheringstatechange"]
  val set_icegatheringstatechange: 'tags this -> Event.t -> unit [@@js.set "icegatheringstatechange"]
  val get_negotiationneeded: 'tags this -> Event.t [@@js.get "negotiationneeded"]
  val set_negotiationneeded: 'tags this -> Event.t -> unit [@@js.set "negotiationneeded"]
  val get_signalingstatechange: 'tags this -> Event.t [@@js.get "signalingstatechange"]
  val set_signalingstatechange: 'tags this -> Event.t -> unit [@@js.set "signalingstatechange"]
  val get_track: 'tags this -> RTCTrackEvent.t [@@js.get "track"]
  val set_track: 'tags this -> RTCTrackEvent.t -> unit [@@js.set "track"]
  val create: connectionstatechange:Event.t -> datachannel:RTCDataChannelEvent.t -> icecandidate:RTCPeerConnectionIceEvent.t -> icecandidateerror:Event.t -> iceconnectionstatechange:Event.t -> icegatheringstatechange:Event.t -> negotiationneeded:Event.t -> signalingstatechange:Event.t -> track:RTCTrackEvent.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module RTCSignalingState : sig
  type t = ([`L_s199_closed[@js "closed"] | `L_s386_have_local_offer[@js "have-local-offer"] | `L_s387_have_local_pranswer[@js "have-local-pranswer"] | `L_s388_have_remote_offer[@js "have-remote-offer"] | `L_s389_have_remote_pranswer[@js "have-remote-pranswer"] | `L_s751_stable[@js "stable"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module RTCSdpType : sig
  type t = ([`L_s120_answer[@js "answer"] | `L_s556_offer[@js "offer"] | `L_s626_pranswer[@js "pranswer"] | `L_s682_rollback[@js "rollback"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module RTCSessionDescriptionInit : sig
  type t = [`RTCSessionDescriptionInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`RTCSessionDescriptionInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`RTCSessionDescriptionInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RTCSessionDescriptionInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_sdp: 'tags this -> string option [@@js.get "sdp"]
  val set_sdp: 'tags this -> string -> unit [@@js.set "sdp"]
  val get_type: 'tags this -> RTCSdpType.t [@@js.get "type"]
  val set_type: 'tags this -> RTCSdpType.t -> unit [@@js.set "type"]
  val create: ?sdp:string -> type_:(RTCSdpType.t[@js "type"]) -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module RTCSessionDescriptionCallback : sig
  type t = [`RTCSessionDescriptionCallback] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`RTCSessionDescriptionCallback]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`RTCSessionDescriptionCallback]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RTCSessionDescriptionCallback ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val apply: 'tags this -> description:RTCSessionDescriptionInit.t -> unit [@@js.apply]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** One end of a connection—or potential connection—and how it's configured. Each RTCSessionDescription consists of a description type indicating which part of the offer/answer negotiation process it describes and of the SDP descriptor of the session. *)
module[@js.scope "RTCSessionDescription"] RTCSessionDescription : sig
  type t = [`RTCSessionDescription] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`RTCSessionDescription]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`RTCSessionDescription]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RTCSessionDescription ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_sdp: 'tags this -> string [@@js.get "sdp"]
  val get_type: 'tags this -> RTCSdpType.t [@@js.get "type"]
  val toJSON: 'tags this -> any [@@js.call "toJSON"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: RTCSessionDescriptionInit.t -> t [@@js.create]
end
module RTCRtpTransceiverInit : sig
  type t = [`RTCRtpTransceiverInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`RTCRtpTransceiverInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`RTCRtpTransceiverInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RTCRtpTransceiverInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_direction: 'tags this -> RTCRtpTransceiverDirection.t option [@@js.get "direction"]
  val set_direction: 'tags this -> RTCRtpTransceiverDirection.t -> unit [@@js.set "direction"]
  val get_sendEncodings: 'tags this -> RTCRtpEncodingParameters.t list option [@@js.get "sendEncodings"]
  val set_sendEncodings: 'tags this -> RTCRtpEncodingParameters.t list -> unit [@@js.set "sendEncodings"]
  val get_streams: 'tags this -> MediaStream.t list option [@@js.get "streams"]
  val set_streams: 'tags this -> MediaStream.t list -> unit [@@js.set "streams"]
  val create: ?direction:RTCRtpTransceiverDirection.t -> ?sendEncodings:RTCRtpEncodingParameters.t list -> ?streams:MediaStream.t list -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module RTCPeerConnectionState : sig
  type t = ([`L_s199_closed[@js "closed"] | `L_s216_connected[@js "connected"] | `L_s217_connecting[@js "connecting"] | `L_s266_disconnected[@js "disconnected"] | `L_s314_failed[@js "failed"] | `L_s538_new[@js "new"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module RTCPeerConnectionErrorCallback : sig
  type t = [`RTCPeerConnectionErrorCallback] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`RTCPeerConnectionErrorCallback]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`RTCPeerConnectionErrorCallback]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RTCPeerConnectionErrorCallback ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val apply: 'tags this -> error:DOMException.t -> unit [@@js.apply]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module RTCOfferAnswerOptions : sig
  type t = [`RTCOfferAnswerOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`RTCOfferAnswerOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`RTCOfferAnswerOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RTCOfferAnswerOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module RTCOfferOptions : sig
  type t = [`RTCOfferAnswerOptions | `RTCOfferOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`RTCOfferAnswerOptions | `RTCOfferOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`RTCOfferAnswerOptions | `RTCOfferOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RTCOfferOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_iceRestart: 'tags this -> bool option [@@js.get "iceRestart"]
  val set_iceRestart: 'tags this -> bool -> unit [@@js.set "iceRestart"]
  val get_offerToReceiveAudio: 'tags this -> bool option [@@js.get "offerToReceiveAudio"]
  val set_offerToReceiveAudio: 'tags this -> bool -> unit [@@js.set "offerToReceiveAudio"]
  val get_offerToReceiveVideo: 'tags this -> bool option [@@js.get "offerToReceiveVideo"]
  val set_offerToReceiveVideo: 'tags this -> bool -> unit [@@js.set "offerToReceiveVideo"]
  val create: ?iceRestart:bool -> ?offerToReceiveAudio:bool -> ?offerToReceiveVideo:bool -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module RTCLocalSessionDescriptionInit : sig
  type t = [`RTCLocalSessionDescriptionInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`RTCLocalSessionDescriptionInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`RTCLocalSessionDescriptionInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RTCLocalSessionDescriptionInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_sdp: 'tags this -> string option [@@js.get "sdp"]
  val set_sdp: 'tags this -> string -> unit [@@js.set "sdp"]
  val get_type: 'tags this -> RTCSdpType.t option [@@js.get "type"]
  val set_type: 'tags this -> RTCSdpType.t -> unit [@@js.set "type"]
  val create: ?sdp:string -> ?type_:(RTCSdpType.t[@js "type"]) -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module RTCIceGatheringState : sig
  type t = ([`L_s209_complete[@js "complete"] | `L_s369_gathering[@js "gathering"] | `L_s538_new[@js "new"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module RTCIceConnectionState : sig
  type t = ([`L_s190_checking[@js "checking"] | `L_s199_closed[@js "closed"] | `L_s210_completed[@js "completed"] | `L_s216_connected[@js "connected"] | `L_s266_disconnected[@js "disconnected"] | `L_s314_failed[@js "failed"] | `L_s538_new[@js "new"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module RTCDataChannelInit : sig
  type t = [`RTCDataChannelInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`RTCDataChannelInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`RTCDataChannelInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RTCDataChannelInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_id: 'tags this -> float option [@@js.get "id"]
  val set_id: 'tags this -> float -> unit [@@js.set "id"]
  val get_maxPacketLifeTime: 'tags this -> float option [@@js.get "maxPacketLifeTime"]
  val set_maxPacketLifeTime: 'tags this -> float -> unit [@@js.set "maxPacketLifeTime"]
  val get_maxRetransmits: 'tags this -> float option [@@js.get "maxRetransmits"]
  val set_maxRetransmits: 'tags this -> float -> unit [@@js.set "maxRetransmits"]
  val get_negotiated: 'tags this -> bool option [@@js.get "negotiated"]
  val set_negotiated: 'tags this -> bool -> unit [@@js.set "negotiated"]
  val get_ordered: 'tags this -> bool option [@@js.get "ordered"]
  val set_ordered: 'tags this -> bool -> unit [@@js.set "ordered"]
  val get_protocol: 'tags this -> string option [@@js.get "protocol"]
  val set_protocol: 'tags this -> string -> unit [@@js.set "protocol"]
  val create: ?id:float -> ?maxPacketLifeTime:float -> ?maxRetransmits:float -> ?negotiated:bool -> ?ordered:bool -> ?protocol:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module RTCRtcpMuxPolicy : sig
  type t = ([`L_s672_require[@js "require"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module RTCIceTransportPolicy : sig
  type t = ([`L_s106_all[@js "all"] | `L_s659_relay[@js "relay"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module RTCIceCredentialType : sig
  type t = ([`L_s588_password[@js "password"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module RTCIceServer : sig
  type t = [`RTCIceServer] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`RTCIceServer]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`RTCIceServer]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RTCIceServer ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_credential: 'tags this -> string option [@@js.get "credential"]
  val set_credential: 'tags this -> string -> unit [@@js.set "credential"]
  val get_credentialType: 'tags this -> RTCIceCredentialType.t option [@@js.get "credentialType"]
  val set_credentialType: 'tags this -> RTCIceCredentialType.t -> unit [@@js.set "credentialType"]
  val get_urls: 'tags this -> ([`String of string | `Other of string list] [@js.union on_field "dummy"]) Primitive.t [@@js.get "urls"]
  val set_urls: 'tags this -> ([`U1 of string | `U2 of string list] [@js.union]) -> unit [@@js.set "urls"]
  val get_username: 'tags this -> string option [@@js.get "username"]
  val set_username: 'tags this -> string -> unit [@@js.set "username"]
  val create: ?credential:string -> ?credentialType:RTCIceCredentialType.t -> urls:([`String of string | `Other of string list] [@js.union on_field "dummy"]) Primitive.t -> ?username:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module RTCDtlsFingerprint : sig
  type t = [`RTCDtlsFingerprint] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`RTCDtlsFingerprint]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`RTCDtlsFingerprint]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RTCDtlsFingerprint ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_algorithm: 'tags this -> string option [@@js.get "algorithm"]
  val set_algorithm: 'tags this -> string -> unit [@@js.set "algorithm"]
  val get_value: 'tags this -> string option [@@js.get "value"]
  val set_value: 'tags this -> string -> unit [@@js.set "value"]
  val create: ?algorithm:string -> ?value:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module[@js.scope "RTCCertificate"] RTCCertificate : sig
  type t = [`RTCCertificate] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`RTCCertificate]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`RTCCertificate]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RTCCertificate ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_expires: 'tags this -> EpochTimeStamp.t [@@js.get "expires"]
  val getFingerprints: 'tags this -> RTCDtlsFingerprint.t list [@@js.call "getFingerprints"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module RTCBundlePolicy : sig
  type t = ([`L_s147_balanced[@js "balanced"] | `L_s502_max_bundle[@js "max-bundle"] | `L_s503_max_compat[@js "max-compat"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module RTCConfiguration : sig
  type t = [`RTCConfiguration] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`RTCConfiguration]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`RTCConfiguration]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RTCConfiguration ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_bundlePolicy: 'tags this -> RTCBundlePolicy.t option [@@js.get "bundlePolicy"]
  val set_bundlePolicy: 'tags this -> RTCBundlePolicy.t -> unit [@@js.set "bundlePolicy"]
  val get_certificates: 'tags this -> RTCCertificate.t list option [@@js.get "certificates"]
  val set_certificates: 'tags this -> RTCCertificate.t list -> unit [@@js.set "certificates"]
  val get_iceCandidatePoolSize: 'tags this -> float option [@@js.get "iceCandidatePoolSize"]
  val set_iceCandidatePoolSize: 'tags this -> float -> unit [@@js.set "iceCandidatePoolSize"]
  val get_iceServers: 'tags this -> RTCIceServer.t list option [@@js.get "iceServers"]
  val set_iceServers: 'tags this -> RTCIceServer.t list -> unit [@@js.set "iceServers"]
  val get_iceTransportPolicy: 'tags this -> RTCIceTransportPolicy.t option [@@js.get "iceTransportPolicy"]
  val set_iceTransportPolicy: 'tags this -> RTCIceTransportPolicy.t -> unit [@@js.set "iceTransportPolicy"]
  val get_rtcpMuxPolicy: 'tags this -> RTCRtcpMuxPolicy.t option [@@js.get "rtcpMuxPolicy"]
  val set_rtcpMuxPolicy: 'tags this -> RTCRtcpMuxPolicy.t -> unit [@@js.set "rtcpMuxPolicy"]
  val create: ?bundlePolicy:RTCBundlePolicy.t -> ?certificates:RTCCertificate.t list -> ?iceCandidatePoolSize:float -> ?iceServers:RTCIceServer.t list -> ?iceTransportPolicy:RTCIceTransportPolicy.t -> ?rtcpMuxPolicy:RTCRtcpMuxPolicy.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module RTCAnswerOptions : sig
  type t = [`RTCAnswerOptions | `RTCOfferAnswerOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`RTCAnswerOptions | `RTCOfferAnswerOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`RTCAnswerOptions | `RTCOfferAnswerOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RTCAnswerOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** A WebRTC connection between the local computer and a remote peer. It provides methods to connect to a remote peer, maintain and monitor the connection, and close the connection once it's no longer needed. *)
module[@js.scope "RTCPeerConnection"] RTCPeerConnection : sig
  type t = [`EventTarget | `RTCPeerConnection] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventTarget | `RTCPeerConnection]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventTarget | `RTCPeerConnection]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RTCPeerConnection ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_canTrickleIceCandidates: 'tags this -> bool option [@@js.get "canTrickleIceCandidates"]
  val get_connectionState: 'tags this -> RTCPeerConnectionState.t [@@js.get "connectionState"]
  val get_currentLocalDescription: 'tags this -> RTCSessionDescription.t option [@@js.get "currentLocalDescription"]
  val get_currentRemoteDescription: 'tags this -> RTCSessionDescription.t option [@@js.get "currentRemoteDescription"]
  val get_iceConnectionState: 'tags this -> RTCIceConnectionState.t [@@js.get "iceConnectionState"]
  val get_iceGatheringState: 'tags this -> RTCIceGatheringState.t [@@js.get "iceGatheringState"]
  val get_localDescription: 'tags this -> RTCSessionDescription.t option [@@js.get "localDescription"]
  val get_onconnectionstatechange: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onconnectionstatechange"]
  val set_onconnectionstatechange: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onconnectionstatechange"]
  val get_ondatachannel: 'tags this -> (this:t -> ev:RTCDataChannelEvent.t -> any) option [@@js.get "ondatachannel"]
  val set_ondatachannel: 'tags this -> (this:t -> ev:RTCDataChannelEvent.t -> any) option -> unit [@@js.set "ondatachannel"]
  val get_onicecandidate: 'tags this -> (this:t -> ev:RTCPeerConnectionIceEvent.t -> any) option [@@js.get "onicecandidate"]
  val set_onicecandidate: 'tags this -> (this:t -> ev:RTCPeerConnectionIceEvent.t -> any) option -> unit [@@js.set "onicecandidate"]
  val get_onicecandidateerror: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onicecandidateerror"]
  val set_onicecandidateerror: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onicecandidateerror"]
  val get_oniceconnectionstatechange: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "oniceconnectionstatechange"]
  val set_oniceconnectionstatechange: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "oniceconnectionstatechange"]
  val get_onicegatheringstatechange: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onicegatheringstatechange"]
  val set_onicegatheringstatechange: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onicegatheringstatechange"]
  val get_onnegotiationneeded: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onnegotiationneeded"]
  val set_onnegotiationneeded: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onnegotiationneeded"]
  val get_onsignalingstatechange: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onsignalingstatechange"]
  val set_onsignalingstatechange: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onsignalingstatechange"]
  val get_ontrack: 'tags this -> (this:t -> ev:RTCTrackEvent.t -> any) option [@@js.get "ontrack"]
  val set_ontrack: 'tags this -> (this:t -> ev:RTCTrackEvent.t -> any) option -> unit [@@js.set "ontrack"]
  val get_pendingLocalDescription: 'tags this -> RTCSessionDescription.t option [@@js.get "pendingLocalDescription"]
  val get_pendingRemoteDescription: 'tags this -> RTCSessionDescription.t option [@@js.get "pendingRemoteDescription"]
  val get_remoteDescription: 'tags this -> RTCSessionDescription.t option [@@js.get "remoteDescription"]
  val get_signalingState: 'tags this -> RTCSignalingState.t [@@js.get "signalingState"]
  val addIceCandidate: 'tags this -> ?candidate:RTCIceCandidateInit.t -> unit -> unit Promise.t_1 [@@js.call "addIceCandidate"]
  
  (** @deprecated  *)
  val addIceCandidate': 'tags this -> candidate:RTCIceCandidateInit.t -> successCallback:VoidFunction.t -> failureCallback:RTCPeerConnectionErrorCallback.t -> unit Promise.t_1 [@@js.call "addIceCandidate"]
  val addTrack: 'tags this -> track:MediaStreamTrack.t -> streams:(MediaStream.t list [@js.variadic]) -> RTCRtpSender.t [@@js.call "addTrack"]
  val addTransceiver: 'tags this -> trackOrKind:([`U1 of MediaStreamTrack.t | `U2 of string] [@js.union]) -> ?init:RTCRtpTransceiverInit.t -> unit -> RTCRtpTransceiver.t [@@js.call "addTransceiver"]
  val close: 'tags this -> unit [@@js.call "close"]
  val createAnswer: 'tags this -> ?options:RTCAnswerOptions.t -> unit -> RTCSessionDescriptionInit.t Promise.t_1 [@@js.call "createAnswer"]
  
  (** @deprecated  *)
  val createAnswer': 'tags this -> successCallback:RTCSessionDescriptionCallback.t -> failureCallback:RTCPeerConnectionErrorCallback.t -> unit Promise.t_1 [@@js.call "createAnswer"]
  val createDataChannel: 'tags this -> label:string -> ?dataChannelDict:RTCDataChannelInit.t -> unit -> RTCDataChannel.t [@@js.call "createDataChannel"]
  val createOffer: 'tags this -> ?options:RTCOfferOptions.t -> unit -> RTCSessionDescriptionInit.t Promise.t_1 [@@js.call "createOffer"]
  
  (** @deprecated  *)
  val createOffer': 'tags this -> successCallback:RTCSessionDescriptionCallback.t -> failureCallback:RTCPeerConnectionErrorCallback.t -> ?options:RTCOfferOptions.t -> unit -> unit Promise.t_1 [@@js.call "createOffer"]
  val getConfiguration: 'tags this -> RTCConfiguration.t [@@js.call "getConfiguration"]
  val getReceivers: 'tags this -> RTCRtpReceiver.t list [@@js.call "getReceivers"]
  val getSenders: 'tags this -> RTCRtpSender.t list [@@js.call "getSenders"]
  val getStats: 'tags this -> ?selector:MediaStreamTrack.t option -> unit -> RTCStatsReport.t Promise.t_1 [@@js.call "getStats"]
  val getTransceivers: 'tags this -> RTCRtpTransceiver.t list [@@js.call "getTransceivers"]
  val removeTrack: 'tags this -> sender:RTCRtpSender.t -> unit [@@js.call "removeTrack"]
  val restartIce: 'tags this -> unit [@@js.call "restartIce"]
  val setConfiguration: 'tags this -> ?configuration:RTCConfiguration.t -> unit -> unit [@@js.call "setConfiguration"]
  val setLocalDescription: 'tags this -> ?description:RTCLocalSessionDescriptionInit.t -> unit -> unit Promise.t_1 [@@js.call "setLocalDescription"]
  
  (** @deprecated  *)
  val setLocalDescription': 'tags this -> description:RTCLocalSessionDescriptionInit.t -> successCallback:VoidFunction.t -> failureCallback:RTCPeerConnectionErrorCallback.t -> unit Promise.t_1 [@@js.call "setLocalDescription"]
  val setRemoteDescription: 'tags this -> description:RTCSessionDescriptionInit.t -> unit Promise.t_1 [@@js.call "setRemoteDescription"]
  
  (** @deprecated  *)
  val setRemoteDescription': 'tags this -> description:RTCSessionDescriptionInit.t -> successCallback:VoidFunction.t -> failureCallback:RTCPeerConnectionErrorCallback.t -> unit Promise.t_1 [@@js.call "setRemoteDescription"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'RTCPeerConnectionEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'RTCPeerConnectionEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: ?configuration:RTCConfiguration.t -> unit -> t [@@js.create]
  val generateCertificate: AlgorithmIdentifier.t -> RTCCertificate.t Promise.t_1 [@@js.global "generateCertificate"]
end
module RTCRtpStreamStats : sig
  type t = [`RTCRtpStreamStats | `RTCStats] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`RTCRtpStreamStats | `RTCStats]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`RTCRtpStreamStats | `RTCStats]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RTCRtpStreamStats ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_codecId: 'tags this -> string option [@@js.get "codecId"]
  val set_codecId: 'tags this -> string -> unit [@@js.set "codecId"]
  val get_kind: 'tags this -> string [@@js.get "kind"]
  val set_kind: 'tags this -> string -> unit [@@js.set "kind"]
  val get_ssrc: 'tags this -> float [@@js.get "ssrc"]
  val set_ssrc: 'tags this -> float -> unit [@@js.set "ssrc"]
  val get_transportId: 'tags this -> string option [@@js.get "transportId"]
  val set_transportId: 'tags this -> string -> unit [@@js.set "transportId"]
  val create: ?codecId:string -> kind:string -> ssrc:float -> ?transportId:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module RTCSentRtpStreamStats : sig
  type t = [`RTCRtpStreamStats | `RTCSentRtpStreamStats | `RTCStats] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`RTCRtpStreamStats | `RTCSentRtpStreamStats | `RTCStats]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`RTCRtpStreamStats | `RTCSentRtpStreamStats | `RTCStats]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RTCSentRtpStreamStats ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_bytesSent: 'tags this -> float option [@@js.get "bytesSent"]
  val set_bytesSent: 'tags this -> float -> unit [@@js.set "bytesSent"]
  val get_packetsSent: 'tags this -> float option [@@js.get "packetsSent"]
  val set_packetsSent: 'tags this -> float -> unit [@@js.set "packetsSent"]
  val create: ?bytesSent:float -> ?packetsSent:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module RTCOutboundRtpStreamStats : sig
  type t = [`RTCOutboundRtpStreamStats | `RTCRtpStreamStats | `RTCSentRtpStreamStats | `RTCStats] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`RTCOutboundRtpStreamStats | `RTCRtpStreamStats | `RTCSentRtpStreamStats | `RTCStats]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`RTCOutboundRtpStreamStats | `RTCRtpStreamStats | `RTCSentRtpStreamStats | `RTCStats]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RTCOutboundRtpStreamStats ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_firCount: 'tags this -> float option [@@js.get "firCount"]
  val set_firCount: 'tags this -> float -> unit [@@js.set "firCount"]
  val get_framesEncoded: 'tags this -> float option [@@js.get "framesEncoded"]
  val set_framesEncoded: 'tags this -> float -> unit [@@js.set "framesEncoded"]
  val get_nackCount: 'tags this -> float option [@@js.get "nackCount"]
  val set_nackCount: 'tags this -> float -> unit [@@js.set "nackCount"]
  val get_pliCount: 'tags this -> float option [@@js.get "pliCount"]
  val set_pliCount: 'tags this -> float -> unit [@@js.set "pliCount"]
  val get_qpSum: 'tags this -> float option [@@js.get "qpSum"]
  val set_qpSum: 'tags this -> float -> unit [@@js.set "qpSum"]
  val get_remoteId: 'tags this -> string option [@@js.get "remoteId"]
  val set_remoteId: 'tags this -> string -> unit [@@js.set "remoteId"]
  val create: ?firCount:float -> ?framesEncoded:float -> ?nackCount:float -> ?pliCount:float -> ?qpSum:float -> ?remoteId:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module RTCReceivedRtpStreamStats : sig
  type t = [`RTCReceivedRtpStreamStats | `RTCRtpStreamStats | `RTCStats] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`RTCReceivedRtpStreamStats | `RTCRtpStreamStats | `RTCStats]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`RTCReceivedRtpStreamStats | `RTCRtpStreamStats | `RTCStats]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RTCReceivedRtpStreamStats ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_jitter: 'tags this -> float option [@@js.get "jitter"]
  val set_jitter: 'tags this -> float -> unit [@@js.set "jitter"]
  val get_packetsDiscarded: 'tags this -> float option [@@js.get "packetsDiscarded"]
  val set_packetsDiscarded: 'tags this -> float -> unit [@@js.set "packetsDiscarded"]
  val get_packetsLost: 'tags this -> float option [@@js.get "packetsLost"]
  val set_packetsLost: 'tags this -> float -> unit [@@js.set "packetsLost"]
  val get_packetsReceived: 'tags this -> float option [@@js.get "packetsReceived"]
  val set_packetsReceived: 'tags this -> float -> unit [@@js.set "packetsReceived"]
  val create: ?jitter:float -> ?packetsDiscarded:float -> ?packetsLost:float -> ?packetsReceived:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module RTCInboundRtpStreamStats : sig
  type t = [`RTCInboundRtpStreamStats | `RTCReceivedRtpStreamStats | `RTCRtpStreamStats | `RTCStats] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`RTCInboundRtpStreamStats | `RTCReceivedRtpStreamStats | `RTCRtpStreamStats | `RTCStats]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`RTCInboundRtpStreamStats | `RTCReceivedRtpStreamStats | `RTCRtpStreamStats | `RTCStats]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RTCInboundRtpStreamStats ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_firCount: 'tags this -> float option [@@js.get "firCount"]
  val set_firCount: 'tags this -> float -> unit [@@js.set "firCount"]
  val get_framesDecoded: 'tags this -> float option [@@js.get "framesDecoded"]
  val set_framesDecoded: 'tags this -> float -> unit [@@js.set "framesDecoded"]
  val get_nackCount: 'tags this -> float option [@@js.get "nackCount"]
  val set_nackCount: 'tags this -> float -> unit [@@js.set "nackCount"]
  val get_pliCount: 'tags this -> float option [@@js.get "pliCount"]
  val set_pliCount: 'tags this -> float -> unit [@@js.set "pliCount"]
  val get_qpSum: 'tags this -> float option [@@js.get "qpSum"]
  val set_qpSum: 'tags this -> float -> unit [@@js.set "qpSum"]
  val get_remoteId: 'tags this -> string option [@@js.get "remoteId"]
  val set_remoteId: 'tags this -> string -> unit [@@js.set "remoteId"]
  val create: ?firCount:float -> ?framesDecoded:float -> ?nackCount:float -> ?pliCount:float -> ?qpSum:float -> ?remoteId:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module RTCIceTransportState : sig
  type t = ([`L_s190_checking[@js "checking"] | `L_s199_closed[@js "closed"] | `L_s210_completed[@js "completed"] | `L_s216_connected[@js "connected"] | `L_s266_disconnected[@js "disconnected"] | `L_s314_failed[@js "failed"] | `L_s538_new[@js "new"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module RTCIceGathererState : sig
  type t = ([`L_s209_complete[@js "complete"] | `L_s369_gathering[@js "gathering"] | `L_s538_new[@js "new"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end

(** Provides access to information about the ICE transport layer over which the data is being sent and received. *)
module[@js.scope "RTCIceTransport"] RTCIceTransport : sig
  type t = [`EventTarget | `RTCIceTransport] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventTarget | `RTCIceTransport]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventTarget | `RTCIceTransport]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RTCIceTransport ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_gatheringState: 'tags this -> RTCIceGathererState.t [@@js.get "gatheringState"]
  val get_state: 'tags this -> RTCIceTransportState.t [@@js.get "state"]
  val create: gatheringState:RTCIceGathererState.t -> state:RTCIceTransportState.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end
module RTCStatsIceCandidatePairState : sig
  type t = ([`L_s314_failed[@js "failed"] | `L_s362_frozen[@js "frozen"] | `L_s420_in_progress[@js "in-progress"] | `L_s428_inprogress[@js "inprogress"] | `L_s769_succeeded[@js "succeeded"] | `L_s860_waiting[@js "waiting"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module RTCIceCandidatePairStats : sig
  type t = [`RTCIceCandidatePairStats | `RTCStats] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`RTCIceCandidatePairStats | `RTCStats]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`RTCIceCandidatePairStats | `RTCStats]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RTCIceCandidatePairStats ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_availableIncomingBitrate: 'tags this -> float option [@@js.get "availableIncomingBitrate"]
  val set_availableIncomingBitrate: 'tags this -> float -> unit [@@js.set "availableIncomingBitrate"]
  val get_availableOutgoingBitrate: 'tags this -> float option [@@js.get "availableOutgoingBitrate"]
  val set_availableOutgoingBitrate: 'tags this -> float -> unit [@@js.set "availableOutgoingBitrate"]
  val get_bytesReceived: 'tags this -> float option [@@js.get "bytesReceived"]
  val set_bytesReceived: 'tags this -> float -> unit [@@js.set "bytesReceived"]
  val get_bytesSent: 'tags this -> float option [@@js.get "bytesSent"]
  val set_bytesSent: 'tags this -> float -> unit [@@js.set "bytesSent"]
  val get_currentRoundTripTime: 'tags this -> float option [@@js.get "currentRoundTripTime"]
  val set_currentRoundTripTime: 'tags this -> float -> unit [@@js.set "currentRoundTripTime"]
  val get_localCandidateId: 'tags this -> string [@@js.get "localCandidateId"]
  val set_localCandidateId: 'tags this -> string -> unit [@@js.set "localCandidateId"]
  val get_nominated: 'tags this -> bool option [@@js.get "nominated"]
  val set_nominated: 'tags this -> bool -> unit [@@js.set "nominated"]
  val get_remoteCandidateId: 'tags this -> string [@@js.get "remoteCandidateId"]
  val set_remoteCandidateId: 'tags this -> string -> unit [@@js.set "remoteCandidateId"]
  val get_requestsReceived: 'tags this -> float option [@@js.get "requestsReceived"]
  val set_requestsReceived: 'tags this -> float -> unit [@@js.set "requestsReceived"]
  val get_requestsSent: 'tags this -> float option [@@js.get "requestsSent"]
  val set_requestsSent: 'tags this -> float -> unit [@@js.set "requestsSent"]
  val get_responsesReceived: 'tags this -> float option [@@js.get "responsesReceived"]
  val set_responsesReceived: 'tags this -> float -> unit [@@js.set "responsesReceived"]
  val get_responsesSent: 'tags this -> float option [@@js.get "responsesSent"]
  val set_responsesSent: 'tags this -> float -> unit [@@js.set "responsesSent"]
  val get_state: 'tags this -> RTCStatsIceCandidatePairState.t [@@js.get "state"]
  val set_state: 'tags this -> RTCStatsIceCandidatePairState.t -> unit [@@js.set "state"]
  val get_totalRoundTripTime: 'tags this -> float option [@@js.get "totalRoundTripTime"]
  val set_totalRoundTripTime: 'tags this -> float -> unit [@@js.set "totalRoundTripTime"]
  val get_transportId: 'tags this -> string [@@js.get "transportId"]
  val set_transportId: 'tags this -> string -> unit [@@js.set "transportId"]
  val create: ?availableIncomingBitrate:float -> ?availableOutgoingBitrate:float -> ?bytesReceived:float -> ?bytesSent:float -> ?currentRoundTripTime:float -> localCandidateId:string -> ?nominated:bool -> remoteCandidateId:string -> ?requestsReceived:float -> ?requestsSent:float -> ?responsesReceived:float -> ?responsesSent:float -> state:RTCStatsIceCandidatePairState.t -> ?totalRoundTripTime:float -> transportId:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module RTCDtlsTransportEventMap : sig
  type t = [`RTCDtlsTransportEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`RTCDtlsTransportEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`RTCDtlsTransportEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RTCDtlsTransportEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_statechange: 'tags this -> Event.t [@@js.get "statechange"]
  val set_statechange: 'tags this -> Event.t -> unit [@@js.set "statechange"]
  val create: statechange:Event.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module RTCDataChannelEventMap : sig
  type t = [`RTCDataChannelEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`RTCDataChannelEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`RTCDataChannelEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RTCDataChannelEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_bufferedamountlow: 'tags this -> Event.t [@@js.get "bufferedamountlow"]
  val set_bufferedamountlow: 'tags this -> Event.t -> unit [@@js.set "bufferedamountlow"]
  val get_close: 'tags this -> Event.t [@@js.get "close"]
  val set_close: 'tags this -> Event.t -> unit [@@js.set "close"]
  val get_error: 'tags this -> Event.t [@@js.get "error"]
  val set_error: 'tags this -> Event.t -> unit [@@js.set "error"]
  val get_message: 'tags this -> MessageEvent.t_0 [@@js.get "message"]
  val set_message: 'tags this -> MessageEvent.t_0 -> unit [@@js.set "message"]
  val get_open: 'tags this -> Event.t [@@js.get "open"]
  val set_open: 'tags this -> Event.t -> unit [@@js.set "open"]
  val create: bufferedamountlow:Event.t -> close:Event.t -> error:Event.t -> message:MessageEvent.t_0 -> open_:(Event.t[@js "open"]) -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module RTCDTMFSenderEventMap : sig
  type t = [`RTCDTMFSenderEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`RTCDTMFSenderEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`RTCDTMFSenderEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RTCDTMFSenderEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_tonechange: 'tags this -> RTCDTMFToneChangeEvent.t [@@js.get "tonechange"]
  val set_tonechange: 'tags this -> RTCDTMFToneChangeEvent.t -> unit [@@js.set "tonechange"]
  val create: tonechange:RTCDTMFToneChangeEvent.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module RTCCertificateExpiration : sig
  type t = [`RTCCertificateExpiration] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`RTCCertificateExpiration]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`RTCCertificateExpiration]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `RTCCertificateExpiration ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_expires: 'tags this -> float option [@@js.get "expires"]
  val set_expires: 'tags this -> float -> unit [@@js.set "expires"]
  val create: ?expires:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** Available only in secure contexts. *)
module[@js.scope "AuthenticatorResponse"] AuthenticatorResponse : sig
  type t = [`AuthenticatorResponse] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AuthenticatorResponse]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AuthenticatorResponse]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `AuthenticatorResponse ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_clientDataJSON: 'tags this -> ArrayBuffer.t_0 [@@js.get "clientDataJSON"]
  val create: clientDataJSON:ArrayBuffer.t_0 -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end
module UvmEntry : sig
  type t = float list
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module UvmEntries : sig
  type t = UvmEntry.t list
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module CredentialPropertiesOutput : sig
  type t = [`CredentialPropertiesOutput] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`CredentialPropertiesOutput]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`CredentialPropertiesOutput]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `CredentialPropertiesOutput ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_rk: 'tags this -> bool option [@@js.get "rk"]
  val set_rk: 'tags this -> bool -> unit [@@js.set "rk"]
  val create: ?rk:bool -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module AuthenticationExtensionsClientOutputs : sig
  type t = [`AuthenticationExtensionsClientOutputs] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AuthenticationExtensionsClientOutputs]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AuthenticationExtensionsClientOutputs]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `AuthenticationExtensionsClientOutputs ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_appid: 'tags this -> bool option [@@js.get "appid"]
  val set_appid: 'tags this -> bool -> unit [@@js.set "appid"]
  val get_credProps: 'tags this -> CredentialPropertiesOutput.t option [@@js.get "credProps"]
  val set_credProps: 'tags this -> CredentialPropertiesOutput.t -> unit [@@js.set "credProps"]
  val get_uvm: 'tags this -> UvmEntries.t option [@@js.get "uvm"]
  val set_uvm: 'tags this -> UvmEntries.t -> unit [@@js.set "uvm"]
  val create: ?appid:bool -> ?credProps:CredentialPropertiesOutput.t -> ?uvm:UvmEntries.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** Available only in secure contexts. *)
module[@js.scope "PublicKeyCredential"] PublicKeyCredential : sig
  type t = [`Credential | `PublicKeyCredential] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Credential | `PublicKeyCredential]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Credential | `PublicKeyCredential]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PublicKeyCredential ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_rawId: 'tags this -> ArrayBuffer.t_0 [@@js.get "rawId"]
  val get_response: 'tags this -> AuthenticatorResponse.t [@@js.get "response"]
  val getClientExtensionResults: 'tags this -> AuthenticationExtensionsClientOutputs.t [@@js.call "getClientExtensionResults"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
  val isUserVerifyingPlatformAuthenticatorAvailable: unit -> bool Promise.t_1 [@@js.global "isUserVerifyingPlatformAuthenticatorAvailable"]
end
module PictureInPictureWindowEventMap : sig
  type t = [`PictureInPictureWindowEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`PictureInPictureWindowEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`PictureInPictureWindowEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PictureInPictureWindowEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_resize: 'tags this -> Event.t [@@js.get "resize"]
  val set_resize: 'tags this -> Event.t -> unit [@@js.set "resize"]
  val create: resize:Event.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module PermissionStatusEventMap : sig
  type t = [`PermissionStatusEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`PermissionStatusEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`PermissionStatusEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PermissionStatusEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_change: 'tags this -> Event.t [@@js.get "change"]
  val set_change: 'tags this -> Event.t -> unit [@@js.set "change"]
  val create: change:Event.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module[@js.scope "PerformancePaintTiming"] PerformancePaintTiming : sig
  type t = [`PerformanceEntry | `PerformancePaintTiming] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`PerformanceEntry | `PerformancePaintTiming]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`PerformanceEntry | `PerformancePaintTiming]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PerformancePaintTiming ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module PerformanceObserverInit : sig
  type t = [`PerformanceObserverInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`PerformanceObserverInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`PerformanceObserverInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PerformanceObserverInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_buffered: 'tags this -> bool option [@@js.get "buffered"]
  val set_buffered: 'tags this -> bool -> unit [@@js.set "buffered"]
  val get_entryTypes: 'tags this -> string list option [@@js.get "entryTypes"]
  val set_entryTypes: 'tags this -> string list -> unit [@@js.set "entryTypes"]
  val get_type: 'tags this -> string option [@@js.get "type"]
  val set_type: 'tags this -> string -> unit [@@js.set "type"]
  val create: ?buffered:bool -> ?entryTypes:string list -> ?type_:(string[@js "type"]) -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module[@js.scope "PerformanceObserverEntryList"] PerformanceObserverEntryList : sig
  type t = [`PerformanceObserverEntryList] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`PerformanceObserverEntryList]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`PerformanceObserverEntryList]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PerformanceObserverEntryList ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val getEntries: 'tags this -> PerformanceEntryList.t [@@js.call "getEntries"]
  val getEntriesByName: 'tags this -> name:string -> ?type_:string -> unit -> PerformanceEntryList.t [@@js.call "getEntriesByName"]
  val getEntriesByType: 'tags this -> type_:string -> PerformanceEntryList.t [@@js.call "getEntriesByType"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module[@js.scope "PerformanceObserver"] rec PerformanceObserver : sig
  type t = [`PerformanceObserver] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`PerformanceObserver]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`PerformanceObserver]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PerformanceObserver ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val disconnect: 'tags this -> unit [@@js.call "disconnect"]
  val observe: 'tags this -> ?options:PerformanceObserverInit.t -> unit -> unit [@@js.call "observe"]
  val takeRecords: 'tags this -> PerformanceEntryList.t [@@js.call "takeRecords"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: PerformanceObserverCallback.t -> t [@@js.create]
  val supportedEntryTypes: unit -> string list [@@js.get "supportedEntryTypes"]
end
and PerformanceObserverCallback : sig
  type t = [`PerformanceObserverCallback] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`PerformanceObserverCallback]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`PerformanceObserverCallback]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PerformanceObserverCallback ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val apply: 'tags this -> entries:PerformanceObserverEntryList.t -> observer:PerformanceObserver.t -> unit [@@js.apply]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module[@js.scope "PerformanceServerTiming"] PerformanceServerTiming : sig
  type t = [`PerformanceServerTiming] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`PerformanceServerTiming]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`PerformanceServerTiming]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PerformanceServerTiming ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_description: 'tags this -> string [@@js.get "description"]
  val get_duration: 'tags this -> DOMHighResTimeStamp.t [@@js.get "duration"]
  val get_name: 'tags this -> string [@@js.get "name"]
  val toJSON: 'tags this -> any [@@js.call "toJSON"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Enables retrieval and analysis of detailed network timing data regarding the loading of an application's resources. An application can use the timing metrics to determine, for example, the length of time it takes to fetch a specific resource, such as an XMLHttpRequest, <SVG>, image, or script. *)
module[@js.scope "PerformanceResourceTiming"] PerformanceResourceTiming : sig
  type t = [`PerformanceEntry | `PerformanceResourceTiming] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`PerformanceEntry | `PerformanceResourceTiming]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`PerformanceEntry | `PerformanceResourceTiming]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PerformanceResourceTiming ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_connectEnd: 'tags this -> DOMHighResTimeStamp.t [@@js.get "connectEnd"]
  val get_connectStart: 'tags this -> DOMHighResTimeStamp.t [@@js.get "connectStart"]
  val get_decodedBodySize: 'tags this -> float [@@js.get "decodedBodySize"]
  val get_domainLookupEnd: 'tags this -> DOMHighResTimeStamp.t [@@js.get "domainLookupEnd"]
  val get_domainLookupStart: 'tags this -> DOMHighResTimeStamp.t [@@js.get "domainLookupStart"]
  val get_encodedBodySize: 'tags this -> float [@@js.get "encodedBodySize"]
  val get_fetchStart: 'tags this -> DOMHighResTimeStamp.t [@@js.get "fetchStart"]
  val get_initiatorType: 'tags this -> string [@@js.get "initiatorType"]
  val get_nextHopProtocol: 'tags this -> string [@@js.get "nextHopProtocol"]
  val get_redirectEnd: 'tags this -> DOMHighResTimeStamp.t [@@js.get "redirectEnd"]
  val get_redirectStart: 'tags this -> DOMHighResTimeStamp.t [@@js.get "redirectStart"]
  val get_requestStart: 'tags this -> DOMHighResTimeStamp.t [@@js.get "requestStart"]
  val get_responseEnd: 'tags this -> DOMHighResTimeStamp.t [@@js.get "responseEnd"]
  val get_responseStart: 'tags this -> DOMHighResTimeStamp.t [@@js.get "responseStart"]
  val get_secureConnectionStart: 'tags this -> DOMHighResTimeStamp.t [@@js.get "secureConnectionStart"]
  val get_serverTiming: 'tags this -> PerformanceServerTiming.t list [@@js.get "serverTiming"]
  val get_transferSize: 'tags this -> float [@@js.get "transferSize"]
  val get_workerStart: 'tags this -> DOMHighResTimeStamp.t [@@js.get "workerStart"]
  val toJSON: 'tags this -> any [@@js.call "toJSON"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module NavigationType : sig
  type t = ([`L_s144_back_forward[@js "back_forward"] | `L_s534_navigate[@js "navigate"] | `L_s630_prerender[@js "prerender"] | `L_s662_reload[@js "reload"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end

(** Provides methods and properties to store and retrieve metrics regarding the browser's document navigation events. For example, this interface can be used to determine how much time it takes to load or unload a document. *)
module[@js.scope "PerformanceNavigationTiming"] PerformanceNavigationTiming : sig
  type t = [`PerformanceEntry | `PerformanceNavigationTiming | `PerformanceResourceTiming] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`PerformanceEntry | `PerformanceNavigationTiming | `PerformanceResourceTiming]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`PerformanceEntry | `PerformanceNavigationTiming | `PerformanceResourceTiming]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PerformanceNavigationTiming ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_domComplete: 'tags this -> DOMHighResTimeStamp.t [@@js.get "domComplete"]
  val get_domContentLoadedEventEnd: 'tags this -> DOMHighResTimeStamp.t [@@js.get "domContentLoadedEventEnd"]
  val get_domContentLoadedEventStart: 'tags this -> DOMHighResTimeStamp.t [@@js.get "domContentLoadedEventStart"]
  val get_domInteractive: 'tags this -> DOMHighResTimeStamp.t [@@js.get "domInteractive"]
  val get_loadEventEnd: 'tags this -> DOMHighResTimeStamp.t [@@js.get "loadEventEnd"]
  val get_loadEventStart: 'tags this -> DOMHighResTimeStamp.t [@@js.get "loadEventStart"]
  val get_redirectCount: 'tags this -> float [@@js.get "redirectCount"]
  val get_type: 'tags this -> NavigationType.t [@@js.get "type"]
  val get_unloadEventEnd: 'tags this -> DOMHighResTimeStamp.t [@@js.get "unloadEventEnd"]
  val get_unloadEventStart: 'tags this -> DOMHighResTimeStamp.t [@@js.get "unloadEventStart"]
  val toJSON: 'tags this -> any [@@js.call "toJSON"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module[@js.scope "PerformanceEventTiming"] PerformanceEventTiming : sig
  type t = [`PerformanceEntry | `PerformanceEventTiming] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`PerformanceEntry | `PerformanceEventTiming]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`PerformanceEntry | `PerformanceEventTiming]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PerformanceEventTiming ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_cancelable: 'tags this -> bool [@@js.get "cancelable"]
  val get_processingEnd: 'tags this -> DOMHighResTimeStamp.t [@@js.get "processingEnd"]
  val get_processingStart: 'tags this -> DOMHighResTimeStamp.t [@@js.get "processingStart"]
  val get_target: 'tags this -> Node.t option [@@js.get "target"]
  val toJSON: 'tags this -> any [@@js.call "toJSON"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module PerformanceEventMap : sig
  type t = [`PerformanceEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`PerformanceEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`PerformanceEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PerformanceEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_resourcetimingbufferfull: 'tags this -> Event.t [@@js.get "resourcetimingbufferfull"]
  val set_resourcetimingbufferfull: 'tags this -> Event.t -> unit [@@js.set "resourcetimingbufferfull"]
  val create: resourcetimingbufferfull:Event.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module PaymentRequestEventMap : sig
  type t = [`PaymentRequestEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`PaymentRequestEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`PaymentRequestEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PaymentRequestEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_paymentmethodchange: 'tags this -> Event.t [@@js.get "paymentmethodchange"]
  val set_paymentmethodchange: 'tags this -> Event.t -> unit [@@js.set "paymentmethodchange"]
  val create: paymentmethodchange:Event.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module PaymentValidationErrors : sig
  type t = [`PaymentValidationErrors] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`PaymentValidationErrors]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`PaymentValidationErrors]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PaymentValidationErrors ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_error: 'tags this -> string option [@@js.get "error"]
  val set_error: 'tags this -> string -> unit [@@js.set "error"]
  val get_paymentMethod: 'tags this -> any option [@@js.get "paymentMethod"]
  val set_paymentMethod: 'tags this -> any -> unit [@@js.set "paymentMethod"]
  val create: ?error:string -> ?paymentMethod:any -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module PaymentComplete : sig
  type t = ([`L_s313_fail[@js "fail"] | `L_s770_success[@js "success"] | `L_s828_unknown[@js "unknown"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end

(**
  This Payment Request API interface is returned after a user selects a payment method and approves a payment request.
  Available only in secure contexts.
*)
module[@js.scope "PaymentResponse"] PaymentResponse : sig
  type t = [`EventTarget | `PaymentResponse] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventTarget | `PaymentResponse]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventTarget | `PaymentResponse]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PaymentResponse ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_details: 'tags this -> any [@@js.get "details"]
  val get_methodName: 'tags this -> string [@@js.get "methodName"]
  val get_requestId: 'tags this -> string [@@js.get "requestId"]
  val complete: 'tags this -> ?result:PaymentComplete.t -> unit -> unit Promise.t_1 [@@js.call "complete"]
  val retry: 'tags this -> ?errorFields:PaymentValidationErrors.t -> unit -> unit Promise.t_1 [@@js.call "retry"]
  val toJSON: 'tags this -> any [@@js.call "toJSON"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module PaymentMethodData : sig
  type t = [`PaymentMethodData] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`PaymentMethodData]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`PaymentMethodData]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PaymentMethodData ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_data: 'tags this -> any option [@@js.get "data"]
  val set_data: 'tags this -> any -> unit [@@js.set "data"]
  val get_supportedMethods: 'tags this -> string [@@js.get "supportedMethods"]
  val set_supportedMethods: 'tags this -> string -> unit [@@js.set "supportedMethods"]
  val create: ?data:any -> supportedMethods:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module PaymentDetailsInit : sig
  type t = [`PaymentDetailsBase | `PaymentDetailsInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`PaymentDetailsBase | `PaymentDetailsInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`PaymentDetailsBase | `PaymentDetailsInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PaymentDetailsInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_id: 'tags this -> string option [@@js.get "id"]
  val set_id: 'tags this -> string -> unit [@@js.set "id"]
  val get_total: 'tags this -> PaymentItem.t [@@js.get "total"]
  val set_total: 'tags this -> PaymentItem.t -> unit [@@js.set "total"]
  val create: ?id:string -> total:PaymentItem.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(**
  This Payment Request API interface is the primary access point into the API, and lets web content and apps accept payments from the end user.
  Available only in secure contexts.
*)
module[@js.scope "PaymentRequest"] PaymentRequest : sig
  type t = [`EventTarget | `PaymentRequest] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventTarget | `PaymentRequest]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventTarget | `PaymentRequest]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PaymentRequest ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_id: 'tags this -> string [@@js.get "id"]
  val get_onpaymentmethodchange: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onpaymentmethodchange"]
  val set_onpaymentmethodchange: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onpaymentmethodchange"]
  val abort: 'tags this -> unit Promise.t_1 [@@js.call "abort"]
  val canMakePayment: 'tags this -> bool Promise.t_1 [@@js.call "canMakePayment"]
  val show: 'tags this -> ?detailsPromise:([`U1 of PaymentDetailsUpdate.t | `U2 of PaymentDetailsUpdate.t PromiseLike.t_1] [@js.union]) -> unit -> PaymentResponse.t Promise.t_1 [@@js.call "show"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'PaymentRequestEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'PaymentRequestEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: methodData:PaymentMethodData.t list -> details:PaymentDetailsInit.t -> t [@@js.create]
end
module[@js.scope "OverconstrainedError"] OverconstrainedError : sig
  type t = [`OverconstrainedError] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`OverconstrainedError]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`OverconstrainedError]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `OverconstrainedError ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_constraint: 'tags this -> string [@@js.get "constraint"]
  val create: constraint_:(string[@js "constraint"]) -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': constraint_:string -> ?message:string -> unit -> t [@@js.create]
end

(** <option> elements and inherits all classes and methods of the HTMLElement interface. *)
module[@js.scope "HTMLOptionElement"] HTMLOptionElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOptionElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOptionElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOptionElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLOptionElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Sets or retrieves the status of an option. *)
  val get_defaultSelected: 'tags this -> bool [@@js.get "defaultSelected"]
  
  (** Sets or retrieves the status of an option. *)
  val set_defaultSelected: 'tags this -> bool -> unit [@@js.set "defaultSelected"]
  val get_disabled: 'tags this -> bool [@@js.get "disabled"]
  val set_disabled: 'tags this -> bool -> unit [@@js.set "disabled"]
  
  (** Retrieves a reference to the form that the object is embedded in. *)
  val get_form: 'tags this -> HTMLFormElement.t option [@@js.get "form"]
  
  (** Sets or retrieves the ordinal position of an option in a list box. *)
  val get_index: 'tags this -> float [@@js.get "index"]
  
  (** Sets or retrieves a value that you can use to implement your own label functionality for the object. *)
  val get_label: 'tags this -> string [@@js.get "label"]
  
  (** Sets or retrieves a value that you can use to implement your own label functionality for the object. *)
  val set_label: 'tags this -> string -> unit [@@js.set "label"]
  
  (** Sets or retrieves whether the option in the list box is the default item. *)
  val get_selected: 'tags this -> bool [@@js.get "selected"]
  
  (** Sets or retrieves whether the option in the list box is the default item. *)
  val set_selected: 'tags this -> bool -> unit [@@js.set "selected"]
  
  (** Sets or retrieves the text string specified by the option tag. *)
  val get_text: 'tags this -> string [@@js.get "text"]
  
  (** Sets or retrieves the text string specified by the option tag. *)
  val set_text: 'tags this -> string -> unit [@@js.set "text"]
  
  (** Sets or retrieves the value which is returned to the server when the form control is submitted. *)
  val get_value: 'tags this -> string [@@js.get "value"]
  
  (** Sets or retrieves the value which is returned to the server when the form control is submitted. *)
  val set_value: 'tags this -> string -> unit [@@js.set "value"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module[@js.scope "Option"] Option : sig
  val create: ?text:string -> ?value:string -> ?defaultSelected:bool -> ?selected:bool -> unit -> HTMLOptionElement.t [@@js.create]
end
module OnBeforeUnloadEventHandlerNonNull : sig
  type t = [`OnBeforeUnloadEventHandlerNonNull] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`OnBeforeUnloadEventHandlerNonNull]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`OnBeforeUnloadEventHandlerNonNull]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `OnBeforeUnloadEventHandlerNonNull ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val apply: 'tags this -> event:Event.t -> string option [@@js.apply]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module OnBeforeUnloadEventHandler : sig
  type t = OnBeforeUnloadEventHandlerNonNull.t option
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module BaseAudioContextEventMap : sig
  type t = [`BaseAudioContextEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`BaseAudioContextEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`BaseAudioContextEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `BaseAudioContextEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_statechange: 'tags this -> Event.t [@@js.get "statechange"]
  val set_statechange: 'tags this -> Event.t -> unit [@@js.set "statechange"]
  val create: statechange:Event.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module OfflineAudioContextEventMap : sig
  type t = [`BaseAudioContextEventMap | `OfflineAudioContextEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`BaseAudioContextEventMap | `OfflineAudioContextEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`BaseAudioContextEventMap | `OfflineAudioContextEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `OfflineAudioContextEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_complete: 'tags this -> OfflineAudioCompletionEvent.t [@@js.get "complete"]
  val set_complete: 'tags this -> OfflineAudioCompletionEvent.t -> unit [@@js.set "complete"]
  val create: complete:OfflineAudioCompletionEvent.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module OfflineAudioContextOptions : sig
  type t = [`OfflineAudioContextOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`OfflineAudioContextOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`OfflineAudioContextOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `OfflineAudioContextOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_length: 'tags this -> float [@@js.get "length"]
  val set_length: 'tags this -> float -> unit [@@js.set "length"]
  val get_numberOfChannels: 'tags this -> float option [@@js.get "numberOfChannels"]
  val set_numberOfChannels: 'tags this -> float -> unit [@@js.set "numberOfChannels"]
  val get_sampleRate: 'tags this -> float [@@js.get "sampleRate"]
  val set_sampleRate: 'tags this -> float -> unit [@@js.set "sampleRate"]
  val create: length:float -> ?numberOfChannels:float -> sampleRate:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module OverSampleType : sig
  type t = ([`L_s2_2x[@js "2x"] | `L_s3_4x[@js "4x"] | `L_s548_none[@js "none"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module ChannelInterpretation : sig
  type t = ([`L_s268_discrete[@js "discrete"] | `L_s746_speakers[@js "speakers"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module ChannelCountMode : sig
  type t = ([`L_s194_clamped_max[@js "clamped-max"] | `L_s306_explicit[@js "explicit"] | `L_s501_max[@js "max"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module AudioNodeOptions : sig
  type t = [`AudioNodeOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AudioNodeOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AudioNodeOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `AudioNodeOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_channelCount: 'tags this -> float option [@@js.get "channelCount"]
  val set_channelCount: 'tags this -> float -> unit [@@js.set "channelCount"]
  val get_channelCountMode: 'tags this -> ChannelCountMode.t option [@@js.get "channelCountMode"]
  val set_channelCountMode: 'tags this -> ChannelCountMode.t -> unit [@@js.set "channelCountMode"]
  val get_channelInterpretation: 'tags this -> ChannelInterpretation.t option [@@js.get "channelInterpretation"]
  val set_channelInterpretation: 'tags this -> ChannelInterpretation.t -> unit [@@js.set "channelInterpretation"]
  val create: ?channelCount:float -> ?channelCountMode:ChannelCountMode.t -> ?channelInterpretation:ChannelInterpretation.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module WaveShaperOptions : sig
  type t = [`AudioNodeOptions | `WaveShaperOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AudioNodeOptions | `WaveShaperOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AudioNodeOptions | `WaveShaperOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `WaveShaperOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_curve: 'tags this -> (float list, Float32Array.t_0) union2 option [@@js.get "curve"]
  val set_curve: 'tags this -> ([`U1 of float list | `U2 of Float32Array.t_0] [@js.union]) -> unit [@@js.set "curve"]
  val get_oversample: 'tags this -> OverSampleType.t option [@@js.get "oversample"]
  val set_oversample: 'tags this -> OverSampleType.t -> unit [@@js.set "oversample"]
  val create: ?curve:(float list, Float32Array.t_0) union2 -> ?oversample:OverSampleType.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module StereoPannerOptions : sig
  type t = [`AudioNodeOptions | `StereoPannerOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AudioNodeOptions | `StereoPannerOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AudioNodeOptions | `StereoPannerOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `StereoPannerOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_pan: 'tags this -> float option [@@js.get "pan"]
  val set_pan: 'tags this -> float -> unit [@@js.set "pan"]
  val create: ?pan:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module PanningModelType : sig
  type t = ([`L_s297_equalpower[@js "equalpower"] | `L_s30_HRTF[@js "HRTF"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module DistanceModelType : sig
  type t = ([`L_s307_exponential[@js "exponential"] | `L_s439_inverse[@js "inverse"] | `L_s467_linear[@js "linear"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module PannerOptions : sig
  type t = [`AudioNodeOptions | `PannerOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AudioNodeOptions | `PannerOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AudioNodeOptions | `PannerOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PannerOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_coneInnerAngle: 'tags this -> float option [@@js.get "coneInnerAngle"]
  val set_coneInnerAngle: 'tags this -> float -> unit [@@js.set "coneInnerAngle"]
  val get_coneOuterAngle: 'tags this -> float option [@@js.get "coneOuterAngle"]
  val set_coneOuterAngle: 'tags this -> float -> unit [@@js.set "coneOuterAngle"]
  val get_coneOuterGain: 'tags this -> float option [@@js.get "coneOuterGain"]
  val set_coneOuterGain: 'tags this -> float -> unit [@@js.set "coneOuterGain"]
  val get_distanceModel: 'tags this -> DistanceModelType.t option [@@js.get "distanceModel"]
  val set_distanceModel: 'tags this -> DistanceModelType.t -> unit [@@js.set "distanceModel"]
  val get_maxDistance: 'tags this -> float option [@@js.get "maxDistance"]
  val set_maxDistance: 'tags this -> float -> unit [@@js.set "maxDistance"]
  val get_orientationX: 'tags this -> float option [@@js.get "orientationX"]
  val set_orientationX: 'tags this -> float -> unit [@@js.set "orientationX"]
  val get_orientationY: 'tags this -> float option [@@js.get "orientationY"]
  val set_orientationY: 'tags this -> float -> unit [@@js.set "orientationY"]
  val get_orientationZ: 'tags this -> float option [@@js.get "orientationZ"]
  val set_orientationZ: 'tags this -> float -> unit [@@js.set "orientationZ"]
  val get_panningModel: 'tags this -> PanningModelType.t option [@@js.get "panningModel"]
  val set_panningModel: 'tags this -> PanningModelType.t -> unit [@@js.set "panningModel"]
  val get_positionX: 'tags this -> float option [@@js.get "positionX"]
  val set_positionX: 'tags this -> float -> unit [@@js.set "positionX"]
  val get_positionY: 'tags this -> float option [@@js.get "positionY"]
  val set_positionY: 'tags this -> float -> unit [@@js.set "positionY"]
  val get_positionZ: 'tags this -> float option [@@js.get "positionZ"]
  val set_positionZ: 'tags this -> float -> unit [@@js.set "positionZ"]
  val get_refDistance: 'tags this -> float option [@@js.get "refDistance"]
  val set_refDistance: 'tags this -> float -> unit [@@js.set "refDistance"]
  val get_rolloffFactor: 'tags this -> float option [@@js.get "rolloffFactor"]
  val set_rolloffFactor: 'tags this -> float -> unit [@@js.set "rolloffFactor"]
  val create: ?coneInnerAngle:float -> ?coneOuterAngle:float -> ?coneOuterGain:float -> ?distanceModel:DistanceModelType.t -> ?maxDistance:float -> ?orientationX:float -> ?orientationY:float -> ?orientationZ:float -> ?panningModel:PanningModelType.t -> ?positionX:float -> ?positionY:float -> ?positionZ:float -> ?refDistance:float -> ?rolloffFactor:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module PeriodicWaveConstraints : sig
  type t = [`PeriodicWaveConstraints] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`PeriodicWaveConstraints]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`PeriodicWaveConstraints]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PeriodicWaveConstraints ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_disableNormalization: 'tags this -> bool option [@@js.get "disableNormalization"]
  val set_disableNormalization: 'tags this -> bool -> unit [@@js.set "disableNormalization"]
  val create: ?disableNormalization:bool -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module PeriodicWaveOptions : sig
  type t = [`PeriodicWaveConstraints | `PeriodicWaveOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`PeriodicWaveConstraints | `PeriodicWaveOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`PeriodicWaveConstraints | `PeriodicWaveOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PeriodicWaveOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_imag: 'tags this -> (float list, Float32Array.t_0) union2 option [@@js.get "imag"]
  val set_imag: 'tags this -> ([`U1 of float list | `U2 of Float32Array.t_0] [@js.union]) -> unit [@@js.set "imag"]
  val get_real: 'tags this -> (float list, Float32Array.t_0) union2 option [@@js.get "real"]
  val set_real: 'tags this -> ([`U1 of float list | `U2 of Float32Array.t_0] [@js.union]) -> unit [@@js.set "real"]
  val create: ?imag:(float list, Float32Array.t_0) union2 -> ?real:(float list, Float32Array.t_0) union2 -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module OscillatorType : sig
  type t = ([`L_s229_custom[@js "custom"] | `L_s695_sawtooth[@js "sawtooth"] | `L_s725_sine[@js "sine"] | `L_s748_square[@js "square"] | `L_s818_triangle[@js "triangle"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module IIRFilterOptions : sig
  type t = [`AudioNodeOptions | `IIRFilterOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AudioNodeOptions | `IIRFilterOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AudioNodeOptions | `IIRFilterOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `IIRFilterOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_feedback: 'tags this -> float list [@@js.get "feedback"]
  val set_feedback: 'tags this -> float list -> unit [@@js.set "feedback"]
  val get_feedforward: 'tags this -> float list [@@js.get "feedforward"]
  val set_feedforward: 'tags this -> float list -> unit [@@js.set "feedforward"]
  val create: feedback:float list -> feedforward:float list -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module GainOptions : sig
  type t = [`AudioNodeOptions | `GainOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AudioNodeOptions | `GainOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AudioNodeOptions | `GainOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `GainOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_gain: 'tags this -> float option [@@js.get "gain"]
  val set_gain: 'tags this -> float -> unit [@@js.set "gain"]
  val create: ?gain:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module DynamicsCompressorOptions : sig
  type t = [`AudioNodeOptions | `DynamicsCompressorOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AudioNodeOptions | `DynamicsCompressorOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AudioNodeOptions | `DynamicsCompressorOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `DynamicsCompressorOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_attack: 'tags this -> float option [@@js.get "attack"]
  val set_attack: 'tags this -> float -> unit [@@js.set "attack"]
  val get_knee: 'tags this -> float option [@@js.get "knee"]
  val set_knee: 'tags this -> float -> unit [@@js.set "knee"]
  val get_ratio: 'tags this -> float option [@@js.get "ratio"]
  val set_ratio: 'tags this -> float -> unit [@@js.set "ratio"]
  val get_release: 'tags this -> float option [@@js.get "release"]
  val set_release: 'tags this -> float -> unit [@@js.set "release"]
  val get_threshold: 'tags this -> float option [@@js.get "threshold"]
  val set_threshold: 'tags this -> float -> unit [@@js.set "threshold"]
  val create: ?attack:float -> ?knee:float -> ?ratio:float -> ?release:float -> ?threshold:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module DelayOptions : sig
  type t = [`AudioNodeOptions | `DelayOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AudioNodeOptions | `DelayOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AudioNodeOptions | `DelayOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `DelayOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_delayTime: 'tags this -> float option [@@js.get "delayTime"]
  val set_delayTime: 'tags this -> float -> unit [@@js.set "delayTime"]
  val get_maxDelayTime: 'tags this -> float option [@@js.get "maxDelayTime"]
  val set_maxDelayTime: 'tags this -> float -> unit [@@js.set "maxDelayTime"]
  val create: ?delayTime:float -> ?maxDelayTime:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module DecodeSuccessCallback : sig
  type t = [`DecodeSuccessCallback] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`DecodeSuccessCallback]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`DecodeSuccessCallback]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `DecodeSuccessCallback ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val apply: 'tags this -> decodedData:AudioBuffer.t -> unit [@@js.apply]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module DecodeErrorCallback : sig
  type t = [`DecodeErrorCallback] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`DecodeErrorCallback]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`DecodeErrorCallback]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `DecodeErrorCallback ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val apply: 'tags this -> error:DOMException.t -> unit [@@js.apply]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module ConvolverOptions : sig
  type t = [`AudioNodeOptions | `ConvolverOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AudioNodeOptions | `ConvolverOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AudioNodeOptions | `ConvolverOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ConvolverOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_buffer: 'tags this -> AudioBuffer.t option option [@@js.get "buffer"]
  val set_buffer: 'tags this -> AudioBuffer.t option -> unit [@@js.set "buffer"]
  val get_disableNormalization: 'tags this -> bool option [@@js.get "disableNormalization"]
  val set_disableNormalization: 'tags this -> bool -> unit [@@js.set "disableNormalization"]
  val create: ?buffer:AudioBuffer.t -> ?disableNormalization:bool -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module ConstantSourceOptions : sig
  type t = [`ConstantSourceOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ConstantSourceOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ConstantSourceOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ConstantSourceOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_offset: 'tags this -> float option [@@js.get "offset"]
  val set_offset: 'tags this -> float -> unit [@@js.set "offset"]
  val create: ?offset:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module ChannelSplitterOptions : sig
  type t = [`AudioNodeOptions | `ChannelSplitterOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AudioNodeOptions | `ChannelSplitterOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AudioNodeOptions | `ChannelSplitterOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ChannelSplitterOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_numberOfOutputs: 'tags this -> float option [@@js.get "numberOfOutputs"]
  val set_numberOfOutputs: 'tags this -> float -> unit [@@js.set "numberOfOutputs"]
  val create: ?numberOfOutputs:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module ChannelMergerOptions : sig
  type t = [`AudioNodeOptions | `ChannelMergerOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AudioNodeOptions | `ChannelMergerOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AudioNodeOptions | `ChannelMergerOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ChannelMergerOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_numberOfInputs: 'tags this -> float option [@@js.get "numberOfInputs"]
  val set_numberOfInputs: 'tags this -> float -> unit [@@js.set "numberOfInputs"]
  val create: ?numberOfInputs:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module BiquadFilterType : sig
  type t = ([`L_s109_allpass[@js "allpass"] | `L_s148_bandpass[@js "bandpass"] | `L_s397_highpass[@js "highpass"] | `L_s398_highshelf[@js "highshelf"] | `L_s486_lowpass[@js "lowpass"] | `L_s487_lowshelf[@js "lowshelf"] | `L_s553_notch[@js "notch"] | `L_s595_peaking[@js "peaking"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module BiquadFilterOptions : sig
  type t = [`AudioNodeOptions | `BiquadFilterOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AudioNodeOptions | `BiquadFilterOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AudioNodeOptions | `BiquadFilterOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `BiquadFilterOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_Q: 'tags this -> float option [@@js.get "Q"]
  val set_Q: 'tags this -> float -> unit [@@js.set "Q"]
  val get_detune: 'tags this -> float option [@@js.get "detune"]
  val set_detune: 'tags this -> float -> unit [@@js.set "detune"]
  val get_frequency: 'tags this -> float option [@@js.get "frequency"]
  val set_frequency: 'tags this -> float -> unit [@@js.set "frequency"]
  val get_gain: 'tags this -> float option [@@js.get "gain"]
  val set_gain: 'tags this -> float -> unit [@@js.set "gain"]
  val get_type: 'tags this -> BiquadFilterType.t option [@@js.get "type"]
  val set_type: 'tags this -> BiquadFilterType.t -> unit [@@js.set "type"]
  val create: ?q:(float[@js "Q"]) -> ?detune:float -> ?frequency:float -> ?gain:float -> ?type_:(BiquadFilterType.t[@js "type"]) -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module WorkletOptions : sig
  type t = [`WorkletOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`WorkletOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`WorkletOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `WorkletOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_credentials: 'tags this -> RequestCredentials.t option [@@js.get "credentials"]
  val set_credentials: 'tags this -> RequestCredentials.t -> unit [@@js.set "credentials"]
  val create: ?credentials:RequestCredentials.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** Available only in secure contexts. *)
module[@js.scope "Worklet"] Worklet : sig
  type t = [`Worklet] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Worklet]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Worklet]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `Worklet ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    Loads and executes the module script given by moduleURL into all of worklet's global scopes. It can also create additional global scopes as part of this process, depending on the worklet type. The returned promise will fulfill once the script has been successfully loaded and run in all global scopes.
    
    The credentials option can be set to a credentials mode to modify the script-fetching process. It defaults to "same-origin".
    
    Any failures in fetching the script or its dependencies will cause the returned promise to be rejected with an "AbortError" DOMException. Any errors in parsing the script or its dependencies will cause the returned promise to be rejected with the exception generated during parsing.
  *)
  val addModule: 'tags this -> moduleURL:([`U1 of string | `U2 of URL.t] [@js.union]) -> ?options:WorkletOptions.t -> unit -> unit Promise.t_1 [@@js.call "addModule"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Available only in secure contexts. *)
module[@js.scope "AudioWorklet"] AudioWorklet : sig
  type t = [`AudioWorklet | `Worklet] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AudioWorklet | `Worklet]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AudioWorklet | `Worklet]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `AudioWorklet ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module AutomationRate : sig
  type t = ([`L_s442_k_rate[@js "k-rate"] | `L_s92_a_rate[@js "a-rate"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end

(** The Web Audio API's AudioParam interface represents an audio-related parameter, usually a parameter of an AudioNode (such as GainNode.gain). *)
module[@js.scope "AudioParam"] AudioParam : sig
  type t = [`AudioParam] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AudioParam]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AudioParam]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `AudioParam ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val setValueCurveAtTime: 'tags this -> values:float Iterable.t_1 -> startTime:float -> duration:float -> t [@@js.call "setValueCurveAtTime"]
  val get_automationRate: 'tags this -> AutomationRate.t [@@js.get "automationRate"]
  val set_automationRate: 'tags this -> AutomationRate.t -> unit [@@js.set "automationRate"]
  val get_defaultValue: 'tags this -> float [@@js.get "defaultValue"]
  val get_maxValue: 'tags this -> float [@@js.get "maxValue"]
  val get_minValue: 'tags this -> float [@@js.get "minValue"]
  val get_value: 'tags this -> float [@@js.get "value"]
  val set_value: 'tags this -> float -> unit [@@js.set "value"]
  val cancelAndHoldAtTime: 'tags this -> cancelTime:float -> t [@@js.call "cancelAndHoldAtTime"]
  val cancelScheduledValues: 'tags this -> cancelTime:float -> t [@@js.call "cancelScheduledValues"]
  val exponentialRampToValueAtTime: 'tags this -> value:float -> endTime:float -> t [@@js.call "exponentialRampToValueAtTime"]
  val linearRampToValueAtTime: 'tags this -> value:float -> endTime:float -> t [@@js.call "linearRampToValueAtTime"]
  val setTargetAtTime: 'tags this -> target:float -> startTime:float -> timeConstant:float -> t [@@js.call "setTargetAtTime"]
  val setValueAtTime: 'tags this -> value:float -> startTime:float -> t [@@js.call "setValueAtTime"]
  val setValueCurveAtTime': 'tags this -> values:([`U1 of float list | `U2 of Float32Array.t_0] [@js.union]) -> startTime:float -> duration:float -> t [@@js.call "setValueCurveAtTime"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** The position and orientation of the unique person listening to the audio scene, and is used in audio spatialization. All PannerNodes spatialize in relation to the AudioListener stored in the BaseAudioContext.listener attribute. *)
module[@js.scope "AudioListener"] AudioListener : sig
  type t = [`AudioListener] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AudioListener]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AudioListener]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `AudioListener ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_forwardX: 'tags this -> AudioParam.t [@@js.get "forwardX"]
  val get_forwardY: 'tags this -> AudioParam.t [@@js.get "forwardY"]
  val get_forwardZ: 'tags this -> AudioParam.t [@@js.get "forwardZ"]
  val get_positionX: 'tags this -> AudioParam.t [@@js.get "positionX"]
  val get_positionY: 'tags this -> AudioParam.t [@@js.get "positionY"]
  val get_positionZ: 'tags this -> AudioParam.t [@@js.get "positionZ"]
  val get_upX: 'tags this -> AudioParam.t [@@js.get "upX"]
  val get_upY: 'tags this -> AudioParam.t [@@js.get "upY"]
  val get_upZ: 'tags this -> AudioParam.t [@@js.get "upZ"]
  
  (** @deprecated  *)
  val setOrientation: 'tags this -> x:float -> y:float -> z:float -> xUp:float -> yUp:float -> zUp:float -> unit [@@js.call "setOrientation"]
  
  (** @deprecated  *)
  val setPosition: 'tags this -> x:float -> y:float -> z:float -> unit [@@js.call "setPosition"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module AudioContextState : sig
  type t = ([`L_s199_closed[@js "closed"] | `L_s690_running[@js "running"] | `L_s774_suspended[@js "suspended"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module AudioBufferSourceOptions : sig
  type t = [`AudioBufferSourceOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AudioBufferSourceOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AudioBufferSourceOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `AudioBufferSourceOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_buffer: 'tags this -> AudioBuffer.t option option [@@js.get "buffer"]
  val set_buffer: 'tags this -> AudioBuffer.t option -> unit [@@js.set "buffer"]
  val get_detune: 'tags this -> float option [@@js.get "detune"]
  val set_detune: 'tags this -> float -> unit [@@js.set "detune"]
  val get_loop: 'tags this -> bool option [@@js.get "loop"]
  val set_loop: 'tags this -> bool -> unit [@@js.set "loop"]
  val get_loopEnd: 'tags this -> float option [@@js.get "loopEnd"]
  val set_loopEnd: 'tags this -> float -> unit [@@js.set "loopEnd"]
  val get_loopStart: 'tags this -> float option [@@js.get "loopStart"]
  val set_loopStart: 'tags this -> float -> unit [@@js.set "loopStart"]
  val get_playbackRate: 'tags this -> float option [@@js.get "playbackRate"]
  val set_playbackRate: 'tags this -> float -> unit [@@js.set "playbackRate"]
  val create: ?buffer:AudioBuffer.t -> ?detune:float -> ?loop:bool -> ?loopEnd:float -> ?loopStart:float -> ?playbackRate:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module AnalyserOptions : sig
  type t = [`AnalyserOptions | `AudioNodeOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AnalyserOptions | `AudioNodeOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AnalyserOptions | `AudioNodeOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `AnalyserOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_fftSize: 'tags this -> float option [@@js.get "fftSize"]
  val set_fftSize: 'tags this -> float -> unit [@@js.set "fftSize"]
  val get_maxDecibels: 'tags this -> float option [@@js.get "maxDecibels"]
  val set_maxDecibels: 'tags this -> float -> unit [@@js.set "maxDecibels"]
  val get_minDecibels: 'tags this -> float option [@@js.get "minDecibels"]
  val set_minDecibels: 'tags this -> float -> unit [@@js.set "minDecibels"]
  val get_smoothingTimeConstant: 'tags this -> float option [@@js.get "smoothingTimeConstant"]
  val set_smoothingTimeConstant: 'tags this -> float -> unit [@@js.set "smoothingTimeConstant"]
  val create: ?fftSize:float -> ?maxDecibels:float -> ?minDecibels:float -> ?smoothingTimeConstant:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** A node able to provide real-time frequency and time-domain analysis information. It is an AudioNode that passes the audio stream unchanged from the input to the output, but allows you to take the generated data, process it, and create audio visualizations. *)
module[@js.scope "AnalyserNode"] rec AnalyserNode : sig
  type t = [`AnalyserNode | `AudioNode | `EventTarget] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AnalyserNode | `AudioNode | `EventTarget]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AnalyserNode | `AudioNode | `EventTarget]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `AnalyserNode ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_fftSize: 'tags this -> float [@@js.get "fftSize"]
  val set_fftSize: 'tags this -> float -> unit [@@js.set "fftSize"]
  val get_frequencyBinCount: 'tags this -> float [@@js.get "frequencyBinCount"]
  val get_maxDecibels: 'tags this -> float [@@js.get "maxDecibels"]
  val set_maxDecibels: 'tags this -> float -> unit [@@js.set "maxDecibels"]
  val get_minDecibels: 'tags this -> float [@@js.get "minDecibels"]
  val set_minDecibels: 'tags this -> float -> unit [@@js.set "minDecibels"]
  val get_smoothingTimeConstant: 'tags this -> float [@@js.get "smoothingTimeConstant"]
  val set_smoothingTimeConstant: 'tags this -> float -> unit [@@js.set "smoothingTimeConstant"]
  val getByteFrequencyData: 'tags this -> array:Uint8Array.t_0 -> unit [@@js.call "getByteFrequencyData"]
  val getByteTimeDomainData: 'tags this -> array:Uint8Array.t_0 -> unit [@@js.call "getByteTimeDomainData"]
  val getFloatFrequencyData: 'tags this -> array:Float32Array.t_0 -> unit [@@js.call "getFloatFrequencyData"]
  val getFloatTimeDomainData: 'tags this -> array:Float32Array.t_0 -> unit [@@js.call "getFloatTimeDomainData"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: context:BaseAudioContext.t -> ?options:AnalyserOptions.t -> unit -> t [@@js.create]
end

(** An AudioScheduledSourceNode which represents an audio source consisting of in-memory audio data, stored in an AudioBuffer. It's especially useful for playing back audio which has particularly stringent timing accuracy requirements, such as for sounds that must match a specific rhythm and can be kept in memory rather than being played from disk or the network. *)
and[@js.scope "AudioBufferSourceNode"] AudioBufferSourceNode : sig
  type t = [`AudioBufferSourceNode | `AudioNode | `AudioScheduledSourceNode | `EventTarget] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AudioBufferSourceNode | `AudioNode | `AudioScheduledSourceNode | `EventTarget]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AudioBufferSourceNode | `AudioNode | `AudioScheduledSourceNode | `EventTarget]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `AudioBufferSourceNode ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_buffer: 'tags this -> AudioBuffer.t option [@@js.get "buffer"]
  val set_buffer: 'tags this -> AudioBuffer.t option -> unit [@@js.set "buffer"]
  val get_detune: 'tags this -> AudioParam.t [@@js.get "detune"]
  val get_loop: 'tags this -> bool [@@js.get "loop"]
  val set_loop: 'tags this -> bool -> unit [@@js.set "loop"]
  val get_loopEnd: 'tags this -> float [@@js.get "loopEnd"]
  val set_loopEnd: 'tags this -> float -> unit [@@js.set "loopEnd"]
  val get_loopStart: 'tags this -> float [@@js.get "loopStart"]
  val set_loopStart: 'tags this -> float -> unit [@@js.set "loopStart"]
  val get_playbackRate: 'tags this -> AudioParam.t [@@js.get "playbackRate"]
  val start: 'tags this -> ?when_:float -> ?offset:float -> ?duration:float -> unit -> unit [@@js.call "start"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'AudioScheduledSourceNodeEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'AudioScheduledSourceNodeEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: context:BaseAudioContext.t -> ?options:AudioBufferSourceOptions.t -> unit -> t [@@js.create]
end

(** AudioDestinationNode has no output (as it is the output, no more AudioNode can be linked after it in the audio graph) and one input. The number of channels in the input must be between 0 and the maxChannelCount value or an exception is raised. *)
and[@js.scope "AudioDestinationNode"] AudioDestinationNode : sig
  type t = [`AudioDestinationNode | `AudioNode | `EventTarget] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AudioDestinationNode | `AudioNode | `EventTarget]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AudioDestinationNode | `AudioNode | `EventTarget]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `AudioDestinationNode ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_maxChannelCount: 'tags this -> float [@@js.get "maxChannelCount"]
  val create: maxChannelCount:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end

(** A generic interface for representing an audio processing module. Examples include: *)
and[@js.scope "AudioNode"] AudioNode : sig
  type t = [`AudioNode | `EventTarget] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AudioNode | `EventTarget]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AudioNode | `EventTarget]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `AudioNode ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_channelCount: 'tags this -> float [@@js.get "channelCount"]
  val set_channelCount: 'tags this -> float -> unit [@@js.set "channelCount"]
  val get_channelCountMode: 'tags this -> ChannelCountMode.t [@@js.get "channelCountMode"]
  val set_channelCountMode: 'tags this -> ChannelCountMode.t -> unit [@@js.set "channelCountMode"]
  val get_channelInterpretation: 'tags this -> ChannelInterpretation.t [@@js.get "channelInterpretation"]
  val set_channelInterpretation: 'tags this -> ChannelInterpretation.t -> unit [@@js.set "channelInterpretation"]
  val get_context: 'tags this -> BaseAudioContext.t [@@js.get "context"]
  val get_numberOfInputs: 'tags this -> float [@@js.get "numberOfInputs"]
  val get_numberOfOutputs: 'tags this -> float [@@js.get "numberOfOutputs"]
  val connect: 'tags this -> destinationNode:t -> ?output:float -> ?input:float -> unit -> t [@@js.call "connect"]
  val connect': 'tags this -> destinationParam:AudioParam.t -> ?output:float -> unit -> unit [@@js.call "connect"]
  val disconnect: 'tags this -> unit [@@js.call "disconnect"]
  val disconnect': 'tags this -> output:float -> unit [@@js.call "disconnect"]
  val disconnect'': 'tags this -> destinationNode:t -> unit [@@js.call "disconnect"]
  val disconnect''': 'tags this -> destinationNode:t -> output:float -> unit [@@js.call "disconnect"]
  val disconnect'''': 'tags this -> destinationNode:t -> output:float -> input:float -> unit [@@js.call "disconnect"]
  val disconnect''''': 'tags this -> destinationParam:AudioParam.t -> unit [@@js.call "disconnect"]
  val disconnect'''''': 'tags this -> destinationParam:AudioParam.t -> output:float -> unit [@@js.call "disconnect"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
and[@js.scope "AudioScheduledSourceNode"] AudioScheduledSourceNode : sig
  type t = [`AudioNode | `AudioScheduledSourceNode | `EventTarget] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AudioNode | `AudioScheduledSourceNode | `EventTarget]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AudioNode | `AudioScheduledSourceNode | `EventTarget]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `AudioScheduledSourceNode ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_onended: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onended"]
  val set_onended: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onended"]
  val start: 'tags this -> ?when_:float -> unit -> unit [@@js.call "start"]
  val stop: 'tags this -> ?when_:float -> unit -> unit [@@js.call "stop"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'AudioScheduledSourceNodeEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'AudioScheduledSourceNodeEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
and[@js.scope "BaseAudioContext"] BaseAudioContext : sig
  type t = [`BaseAudioContext | `EventTarget] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`BaseAudioContext | `EventTarget]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`BaseAudioContext | `EventTarget]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `BaseAudioContext ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val createIIRFilter: 'tags this -> feedforward:float Iterable.t_1 -> feedback:float Iterable.t_1 -> IIRFilterNode.t [@@js.call "createIIRFilter"]
  val createPeriodicWave: 'tags this -> real:float Iterable.t_1 -> imag:float Iterable.t_1 -> ?constraints:PeriodicWaveConstraints.t -> unit -> PeriodicWave.t [@@js.call "createPeriodicWave"]
  
  (** Available only in secure contexts. *)
  val get_audioWorklet: 'tags this -> AudioWorklet.t [@@js.get "audioWorklet"]
  val get_currentTime: 'tags this -> float [@@js.get "currentTime"]
  val get_destination: 'tags this -> AudioDestinationNode.t [@@js.get "destination"]
  val get_listener: 'tags this -> AudioListener.t [@@js.get "listener"]
  val get_onstatechange: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onstatechange"]
  val set_onstatechange: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onstatechange"]
  val get_sampleRate: 'tags this -> float [@@js.get "sampleRate"]
  val get_state: 'tags this -> AudioContextState.t [@@js.get "state"]
  val createAnalyser: 'tags this -> AnalyserNode.t [@@js.call "createAnalyser"]
  val createBiquadFilter: 'tags this -> BiquadFilterNode.t [@@js.call "createBiquadFilter"]
  val createBuffer: 'tags this -> numberOfChannels:float -> length:float -> sampleRate:float -> AudioBuffer.t [@@js.call "createBuffer"]
  val createBufferSource: 'tags this -> AudioBufferSourceNode.t [@@js.call "createBufferSource"]
  val createChannelMerger: 'tags this -> ?numberOfInputs:float -> unit -> ChannelMergerNode.t [@@js.call "createChannelMerger"]
  val createChannelSplitter: 'tags this -> ?numberOfOutputs:float -> unit -> ChannelSplitterNode.t [@@js.call "createChannelSplitter"]
  val createConstantSource: 'tags this -> ConstantSourceNode.t [@@js.call "createConstantSource"]
  val createConvolver: 'tags this -> ConvolverNode.t [@@js.call "createConvolver"]
  val createDelay: 'tags this -> ?maxDelayTime:float -> unit -> DelayNode.t [@@js.call "createDelay"]
  val createDynamicsCompressor: 'tags this -> DynamicsCompressorNode.t [@@js.call "createDynamicsCompressor"]
  val createGain: 'tags this -> GainNode.t [@@js.call "createGain"]
  val createIIRFilter': 'tags this -> feedforward:float list -> feedback:float list -> IIRFilterNode.t [@@js.call "createIIRFilter"]
  val createOscillator: 'tags this -> OscillatorNode.t [@@js.call "createOscillator"]
  val createPanner: 'tags this -> PannerNode.t [@@js.call "createPanner"]
  val createPeriodicWave': 'tags this -> real:([`U1 of float list | `U2 of Float32Array.t_0] [@js.union]) -> imag:([`U1 of float list | `U2 of Float32Array.t_0] [@js.union]) -> ?constraints:PeriodicWaveConstraints.t -> unit -> PeriodicWave.t [@@js.call "createPeriodicWave"]
  
  (** @deprecated  *)
  val createScriptProcessor: 'tags this -> ?bufferSize:float -> ?numberOfInputChannels:float -> ?numberOfOutputChannels:float -> unit -> ScriptProcessorNode.t [@@js.call "createScriptProcessor"]
  val createStereoPanner: 'tags this -> StereoPannerNode.t [@@js.call "createStereoPanner"]
  val createWaveShaper: 'tags this -> WaveShaperNode.t [@@js.call "createWaveShaper"]
  val decodeAudioData: 'tags this -> audioData:ArrayBuffer.t_0 -> ?successCallback:DecodeSuccessCallback.t option -> ?errorCallback:DecodeErrorCallback.t option -> unit -> AudioBuffer.t Promise.t_1 [@@js.call "decodeAudioData"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'BaseAudioContextEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'BaseAudioContextEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** A simple low-order filter, and is created using the AudioContext.createBiquadFilter() method. It is an AudioNode that can represent different kinds of filters, tone control devices, and graphic equalizers. *)
and[@js.scope "BiquadFilterNode"] BiquadFilterNode : sig
  type t = [`AudioNode | `BiquadFilterNode | `EventTarget] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AudioNode | `BiquadFilterNode | `EventTarget]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AudioNode | `BiquadFilterNode | `EventTarget]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `BiquadFilterNode ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_Q: 'tags this -> AudioParam.t [@@js.get "Q"]
  val get_detune: 'tags this -> AudioParam.t [@@js.get "detune"]
  val get_frequency: 'tags this -> AudioParam.t [@@js.get "frequency"]
  val get_gain: 'tags this -> AudioParam.t [@@js.get "gain"]
  val get_type: 'tags this -> BiquadFilterType.t [@@js.get "type"]
  val set_type: 'tags this -> BiquadFilterType.t -> unit [@@js.set "type"]
  val getFrequencyResponse: 'tags this -> frequencyHz:Float32Array.t_0 -> magResponse:Float32Array.t_0 -> phaseResponse:Float32Array.t_0 -> unit [@@js.call "getFrequencyResponse"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: context:BaseAudioContext.t -> ?options:BiquadFilterOptions.t -> unit -> t [@@js.create]
end

(** The ChannelMergerNode interface, often used in conjunction with its opposite, ChannelSplitterNode, reunites different mono inputs into a single output. Each input is used to fill a channel of the output. This is useful for accessing each channels separately, e.g. for performing channel mixing where gain must be separately controlled on each channel. *)
and[@js.scope "ChannelMergerNode"] ChannelMergerNode : sig
  type t = [`AudioNode | `ChannelMergerNode | `EventTarget] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AudioNode | `ChannelMergerNode | `EventTarget]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AudioNode | `ChannelMergerNode | `EventTarget]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ChannelMergerNode ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: context:BaseAudioContext.t -> ?options:ChannelMergerOptions.t -> unit -> t [@@js.create]
end

(** The ChannelSplitterNode interface, often used in conjunction with its opposite, ChannelMergerNode, separates the different channels of an audio source into a set of mono outputs. This is useful for accessing each channel separately, e.g. for performing channel mixing where gain must be separately controlled on each channel. *)
and[@js.scope "ChannelSplitterNode"] ChannelSplitterNode : sig
  type t = [`AudioNode | `ChannelSplitterNode | `EventTarget] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AudioNode | `ChannelSplitterNode | `EventTarget]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AudioNode | `ChannelSplitterNode | `EventTarget]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ChannelSplitterNode ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: context:BaseAudioContext.t -> ?options:ChannelSplitterOptions.t -> unit -> t [@@js.create]
end
and[@js.scope "ConstantSourceNode"] ConstantSourceNode : sig
  type t = [`AudioNode | `AudioScheduledSourceNode | `ConstantSourceNode | `EventTarget] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AudioNode | `AudioScheduledSourceNode | `ConstantSourceNode | `EventTarget]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AudioNode | `AudioScheduledSourceNode | `ConstantSourceNode | `EventTarget]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ConstantSourceNode ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_offset: 'tags this -> AudioParam.t [@@js.get "offset"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'AudioScheduledSourceNodeEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'AudioScheduledSourceNodeEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: context:BaseAudioContext.t -> ?options:ConstantSourceOptions.t -> unit -> t [@@js.create]
end

(** An AudioNode that performs a Linear Convolution on a given AudioBuffer, often used to achieve a reverb effect. A ConvolverNode always has exactly one input and one output. *)
and[@js.scope "ConvolverNode"] ConvolverNode : sig
  type t = [`AudioNode | `ConvolverNode | `EventTarget] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AudioNode | `ConvolverNode | `EventTarget]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AudioNode | `ConvolverNode | `EventTarget]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ConvolverNode ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_buffer: 'tags this -> AudioBuffer.t option [@@js.get "buffer"]
  val set_buffer: 'tags this -> AudioBuffer.t option -> unit [@@js.set "buffer"]
  val get_normalize: 'tags this -> bool [@@js.get "normalize"]
  val set_normalize: 'tags this -> bool -> unit [@@js.set "normalize"]
  val create: ?buffer:AudioBuffer.t -> normalize:bool -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': context:BaseAudioContext.t -> ?options:ConvolverOptions.t -> unit -> t [@@js.create]
end

(** A delay-line; an AudioNode audio-processing module that causes a delay between the arrival of an input data and its propagation to the output. *)
and[@js.scope "DelayNode"] DelayNode : sig
  type t = [`AudioNode | `DelayNode | `EventTarget] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AudioNode | `DelayNode | `EventTarget]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AudioNode | `DelayNode | `EventTarget]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `DelayNode ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_delayTime: 'tags this -> AudioParam.t [@@js.get "delayTime"]
  val create: delayTime:AudioParam.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': context:BaseAudioContext.t -> ?options:DelayOptions.t -> unit -> t [@@js.create]
end

(** Inherits properties from its parent, AudioNode. *)
and[@js.scope "DynamicsCompressorNode"] DynamicsCompressorNode : sig
  type t = [`AudioNode | `DynamicsCompressorNode | `EventTarget] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AudioNode | `DynamicsCompressorNode | `EventTarget]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AudioNode | `DynamicsCompressorNode | `EventTarget]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `DynamicsCompressorNode ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_attack: 'tags this -> AudioParam.t [@@js.get "attack"]
  val get_knee: 'tags this -> AudioParam.t [@@js.get "knee"]
  val get_ratio: 'tags this -> AudioParam.t [@@js.get "ratio"]
  val get_reduction: 'tags this -> float [@@js.get "reduction"]
  val get_release: 'tags this -> AudioParam.t [@@js.get "release"]
  val get_threshold: 'tags this -> AudioParam.t [@@js.get "threshold"]
  val create: attack:AudioParam.t -> knee:AudioParam.t -> ratio:AudioParam.t -> reduction:float -> release:AudioParam.t -> threshold:AudioParam.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': context:BaseAudioContext.t -> ?options:DynamicsCompressorOptions.t -> unit -> t [@@js.create]
end

(** A change in volume. It is an AudioNode audio-processing module that causes a given gain to be applied to the input data before its propagation to the output. A GainNode always has exactly one input and one output, both with the same number of channels. *)
and[@js.scope "GainNode"] GainNode : sig
  type t = [`AudioNode | `EventTarget | `GainNode] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AudioNode | `EventTarget | `GainNode]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AudioNode | `EventTarget | `GainNode]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `GainNode ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_gain: 'tags this -> AudioParam.t [@@js.get "gain"]
  val create: gain:AudioParam.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': context:BaseAudioContext.t -> ?options:GainOptions.t -> unit -> t [@@js.create]
end

(** The IIRFilterNode interface of the Web Audio API is a AudioNode processor which implements a general infinite impulse response (IIR)  filter; this type of filter can be used to implement tone control devices and graphic equalizers as well. It lets the parameters of the filter response be specified, so that it can be tuned as needed. *)
and[@js.scope "IIRFilterNode"] IIRFilterNode : sig
  type t = [`AudioNode | `EventTarget | `IIRFilterNode] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AudioNode | `EventTarget | `IIRFilterNode]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AudioNode | `EventTarget | `IIRFilterNode]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `IIRFilterNode ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val getFrequencyResponse: 'tags this -> frequencyHz:Float32Array.t_0 -> magResponse:Float32Array.t_0 -> phaseResponse:Float32Array.t_0 -> unit [@@js.call "getFrequencyResponse"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: context:BaseAudioContext.t -> options:IIRFilterOptions.t -> t [@@js.create]
end

(** The OscillatorNode interface represents a periodic waveform, such as a sine wave. It is an AudioScheduledSourceNode audio-processing module that causes a specified frequency of a given wave to be created—in effect, a constant tone. *)
and[@js.scope "OscillatorNode"] OscillatorNode : sig
  type t = [`AudioNode | `AudioScheduledSourceNode | `EventTarget | `OscillatorNode] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AudioNode | `AudioScheduledSourceNode | `EventTarget | `OscillatorNode]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AudioNode | `AudioScheduledSourceNode | `EventTarget | `OscillatorNode]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `OscillatorNode ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_detune: 'tags this -> AudioParam.t [@@js.get "detune"]
  val get_frequency: 'tags this -> AudioParam.t [@@js.get "frequency"]
  val get_type: 'tags this -> OscillatorType.t [@@js.get "type"]
  val set_type: 'tags this -> OscillatorType.t -> unit [@@js.set "type"]
  val setPeriodicWave: 'tags this -> periodicWave:PeriodicWave.t -> unit [@@js.call "setPeriodicWave"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'AudioScheduledSourceNodeEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'AudioScheduledSourceNodeEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: context:BaseAudioContext.t -> ?options:OscillatorOptions.t -> unit -> t [@@js.create]
end
and OscillatorOptions : sig
  type t = [`AudioNodeOptions | `OscillatorOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AudioNodeOptions | `OscillatorOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AudioNodeOptions | `OscillatorOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `OscillatorOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_detune: 'tags this -> float option [@@js.get "detune"]
  val set_detune: 'tags this -> float -> unit [@@js.set "detune"]
  val get_frequency: 'tags this -> float option [@@js.get "frequency"]
  val set_frequency: 'tags this -> float -> unit [@@js.set "frequency"]
  val get_periodicWave: 'tags this -> PeriodicWave.t option [@@js.get "periodicWave"]
  val set_periodicWave: 'tags this -> PeriodicWave.t -> unit [@@js.set "periodicWave"]
  val get_type: 'tags this -> OscillatorType.t option [@@js.get "type"]
  val set_type: 'tags this -> OscillatorType.t -> unit [@@js.set "type"]
  val create: ?detune:float -> ?frequency:float -> ?periodicWave:PeriodicWave.t -> ?type_:(OscillatorType.t[@js "type"]) -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** A PannerNode always has exactly one input and one output: the input can be mono or stereo but the output is always stereo (2 channels); you can't have panning effects without at least two audio channels! *)
and[@js.scope "PannerNode"] PannerNode : sig
  type t = [`AudioNode | `EventTarget | `PannerNode] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AudioNode | `EventTarget | `PannerNode]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AudioNode | `EventTarget | `PannerNode]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PannerNode ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_coneInnerAngle: 'tags this -> float [@@js.get "coneInnerAngle"]
  val set_coneInnerAngle: 'tags this -> float -> unit [@@js.set "coneInnerAngle"]
  val get_coneOuterAngle: 'tags this -> float [@@js.get "coneOuterAngle"]
  val set_coneOuterAngle: 'tags this -> float -> unit [@@js.set "coneOuterAngle"]
  val get_coneOuterGain: 'tags this -> float [@@js.get "coneOuterGain"]
  val set_coneOuterGain: 'tags this -> float -> unit [@@js.set "coneOuterGain"]
  val get_distanceModel: 'tags this -> DistanceModelType.t [@@js.get "distanceModel"]
  val set_distanceModel: 'tags this -> DistanceModelType.t -> unit [@@js.set "distanceModel"]
  val get_maxDistance: 'tags this -> float [@@js.get "maxDistance"]
  val set_maxDistance: 'tags this -> float -> unit [@@js.set "maxDistance"]
  val get_orientationX: 'tags this -> AudioParam.t [@@js.get "orientationX"]
  val get_orientationY: 'tags this -> AudioParam.t [@@js.get "orientationY"]
  val get_orientationZ: 'tags this -> AudioParam.t [@@js.get "orientationZ"]
  val get_panningModel: 'tags this -> PanningModelType.t [@@js.get "panningModel"]
  val set_panningModel: 'tags this -> PanningModelType.t -> unit [@@js.set "panningModel"]
  val get_positionX: 'tags this -> AudioParam.t [@@js.get "positionX"]
  val get_positionY: 'tags this -> AudioParam.t [@@js.get "positionY"]
  val get_positionZ: 'tags this -> AudioParam.t [@@js.get "positionZ"]
  val get_refDistance: 'tags this -> float [@@js.get "refDistance"]
  val set_refDistance: 'tags this -> float -> unit [@@js.set "refDistance"]
  val get_rolloffFactor: 'tags this -> float [@@js.get "rolloffFactor"]
  val set_rolloffFactor: 'tags this -> float -> unit [@@js.set "rolloffFactor"]
  
  (** @deprecated  *)
  val setOrientation: 'tags this -> x:float -> y:float -> z:float -> unit [@@js.call "setOrientation"]
  
  (** @deprecated  *)
  val setPosition: 'tags this -> x:float -> y:float -> z:float -> unit [@@js.call "setPosition"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: context:BaseAudioContext.t -> ?options:PannerOptions.t -> unit -> t [@@js.create]
end

(** PeriodicWave has no inputs or outputs; it is used to define custom oscillators when calling OscillatorNode.setPeriodicWave(). The PeriodicWave itself is created/returned by AudioContext.createPeriodicWave(). *)
and[@js.scope "PeriodicWave"] PeriodicWave : sig
  type t = [`PeriodicWave] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`PeriodicWave]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`PeriodicWave]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `PeriodicWave ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: context:BaseAudioContext.t -> ?options:PeriodicWaveOptions.t -> unit -> t [@@js.create]
end

(** Allows the generation, processing, or analyzing of audio using JavaScript. *)
and[@js.scope "ScriptProcessorNode"] ScriptProcessorNode : sig
  type t = [`AudioNode | `EventTarget | `ScriptProcessorNode] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AudioNode | `EventTarget | `ScriptProcessorNode]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AudioNode | `EventTarget | `ScriptProcessorNode]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ScriptProcessorNode ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** @deprecated  *)
  val get_bufferSize: 'tags this -> float [@@js.get "bufferSize"]
  
  (** @deprecated  *)
  val get_onaudioprocess: 'tags this -> (this:t -> ev:AudioProcessingEvent.t -> any) option [@@js.get "onaudioprocess"]
  
  (** @deprecated  *)
  val set_onaudioprocess: 'tags this -> (this:t -> ev:AudioProcessingEvent.t -> any) option -> unit [@@js.set "onaudioprocess"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'ScriptProcessorNodeEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'ScriptProcessorNodeEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** The pan property takes a unitless value between -1 (full left pan) and 1 (full right pan). This interface was introduced as a much simpler way to apply a simple panning effect than having to use a full PannerNode. *)
and[@js.scope "StereoPannerNode"] StereoPannerNode : sig
  type t = [`AudioNode | `EventTarget | `StereoPannerNode] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AudioNode | `EventTarget | `StereoPannerNode]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AudioNode | `EventTarget | `StereoPannerNode]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `StereoPannerNode ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_pan: 'tags this -> AudioParam.t [@@js.get "pan"]
  val create: pan:AudioParam.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': context:BaseAudioContext.t -> ?options:StereoPannerOptions.t -> unit -> t [@@js.create]
end

(** A WaveShaperNode always has exactly one input and one output. *)
and[@js.scope "WaveShaperNode"] WaveShaperNode : sig
  type t = [`AudioNode | `EventTarget | `WaveShaperNode] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AudioNode | `EventTarget | `WaveShaperNode]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AudioNode | `EventTarget | `WaveShaperNode]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `WaveShaperNode ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_curve: 'tags this -> Float32Array.t_0 option [@@js.get "curve"]
  val set_curve: 'tags this -> Float32Array.t_0 option -> unit [@@js.set "curve"]
  val get_oversample: 'tags this -> OverSampleType.t [@@js.get "oversample"]
  val set_oversample: 'tags this -> OverSampleType.t -> unit [@@js.set "oversample"]
  val create: ?curve:Float32Array.t_0 -> oversample:OverSampleType.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': context:BaseAudioContext.t -> ?options:WaveShaperOptions.t -> unit -> t [@@js.create]
end

(** An AudioContext interface representing an audio-processing graph built from linked together AudioNodes. In contrast with a standard AudioContext, an OfflineAudioContext doesn't render the audio to the device hardware; instead, it generates it, as fast as it can, and outputs the result to an AudioBuffer. *)
module[@js.scope "OfflineAudioContext"] OfflineAudioContext : sig
  type t = [`BaseAudioContext | `EventTarget | `OfflineAudioContext] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`BaseAudioContext | `EventTarget | `OfflineAudioContext]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`BaseAudioContext | `EventTarget | `OfflineAudioContext]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `OfflineAudioContext ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_length: 'tags this -> float [@@js.get "length"]
  val get_oncomplete: 'tags this -> (this:t -> ev:OfflineAudioCompletionEvent.t -> any) option [@@js.get "oncomplete"]
  val set_oncomplete: 'tags this -> (this:t -> ev:OfflineAudioCompletionEvent.t -> any) option -> unit [@@js.set "oncomplete"]
  val resume: 'tags this -> unit Promise.t_1 [@@js.call "resume"]
  val startRendering: 'tags this -> AudioBuffer.t Promise.t_1 [@@js.call "startRendering"]
  val suspend: 'tags this -> suspendTime:float -> unit Promise.t_1 [@@js.call "suspend"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'OfflineAudioContextEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'OfflineAudioContextEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: OfflineAudioContextOptions.t -> t [@@js.create]
  val create': numberOfChannels:float -> length:float -> sampleRate:float -> t [@@js.create]
end
module OES_fbo_render_mipmap : sig
  type t = [`OES_fbo_render_mipmap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`OES_fbo_render_mipmap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`OES_fbo_render_mipmap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `OES_fbo_render_mipmap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module NotificationEventMap : sig
  type t = [`NotificationEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`NotificationEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`NotificationEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `NotificationEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_click: 'tags this -> Event.t [@@js.get "click"]
  val set_click: 'tags this -> Event.t -> unit [@@js.set "click"]
  val get_close: 'tags this -> Event.t [@@js.get "close"]
  val set_close: 'tags this -> Event.t -> unit [@@js.set "close"]
  val get_error: 'tags this -> Event.t [@@js.get "error"]
  val set_error: 'tags this -> Event.t -> unit [@@js.set "error"]
  val get_show: 'tags this -> Event.t [@@js.get "show"]
  val set_show: 'tags this -> Event.t -> unit [@@js.set "show"]
  val create: click:Event.t -> close:Event.t -> error:Event.t -> show:Event.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module MutationRecordType : sig
  type t = ([`L_s132_attributes[@js "attributes"] | `L_s189_characterData[@js "characterData"] | `L_s191_childList[@js "childList"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end

(** A MutationRecord represents an individual DOM mutation. It is the object that is passed to MutationObserver's callback. *)
module[@js.scope "MutationRecord"] MutationRecord : sig
  type t = [`MutationRecord] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`MutationRecord]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`MutationRecord]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MutationRecord ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Return the nodes added and removed respectively. *)
  val get_addedNodes: 'tags this -> NodeList.t [@@js.get "addedNodes"]
  
  (** Returns the local name of the changed attribute, and null otherwise. *)
  val get_attributeName: 'tags this -> string option [@@js.get "attributeName"]
  
  (** Returns the namespace of the changed attribute, and null otherwise. *)
  val get_attributeNamespace: 'tags this -> string option [@@js.get "attributeNamespace"]
  
  (** Return the previous and next sibling respectively of the added or removed nodes, and null otherwise. *)
  val get_nextSibling: 'tags this -> Node.t option [@@js.get "nextSibling"]
  
  (** The return value depends on type. For "attributes", it is the value of the changed attribute before the change. For "characterData", it is the data of the changed node before the change. For "childList", it is null. *)
  val get_oldValue: 'tags this -> string option [@@js.get "oldValue"]
  
  (** Return the previous and next sibling respectively of the added or removed nodes, and null otherwise. *)
  val get_previousSibling: 'tags this -> Node.t option [@@js.get "previousSibling"]
  
  (** Return the nodes added and removed respectively. *)
  val get_removedNodes: 'tags this -> NodeList.t [@@js.get "removedNodes"]
  
  (** Returns the node the mutation affected, depending on the type. For "attributes", it is the element whose attribute changed. For "characterData", it is the CharacterData node. For "childList", it is the node whose children changed. *)
  val get_target: 'tags this -> Node.t [@@js.get "target"]
  
  (** Returns "attributes" if it was an attribute mutation. "characterData" if it was a mutation to a CharacterData node. And "childList" if it was a mutation to the tree of nodes. *)
  val get_type: 'tags this -> MutationRecordType.t [@@js.get "type"]
  val create: addedNodes:NodeList.t -> ?attributeName:string -> ?attributeNamespace:string -> ?nextSibling:Node.t -> ?oldValue:string -> ?previousSibling:Node.t -> removedNodes:NodeList.t -> target:Node.t -> type_:(MutationRecordType.t[@js "type"]) -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end
module MutationObserverInit : sig
  type t = [`MutationObserverInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`MutationObserverInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`MutationObserverInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MutationObserverInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Set to a list of attribute local names (without namespace) if not all attribute mutations need to be observed and attributes is true or omitted. *)
  val get_attributeFilter: 'tags this -> string list option [@@js.get "attributeFilter"]
  
  (** Set to a list of attribute local names (without namespace) if not all attribute mutations need to be observed and attributes is true or omitted. *)
  val set_attributeFilter: 'tags this -> string list -> unit [@@js.set "attributeFilter"]
  
  (** Set to true if attributes is true or omitted and target's attribute value before the mutation needs to be recorded. *)
  val get_attributeOldValue: 'tags this -> bool option [@@js.get "attributeOldValue"]
  
  (** Set to true if attributes is true or omitted and target's attribute value before the mutation needs to be recorded. *)
  val set_attributeOldValue: 'tags this -> bool -> unit [@@js.set "attributeOldValue"]
  
  (** Set to true if mutations to target's attributes are to be observed. Can be omitted if attributeOldValue or attributeFilter is specified. *)
  val get_attributes: 'tags this -> bool option [@@js.get "attributes"]
  
  (** Set to true if mutations to target's attributes are to be observed. Can be omitted if attributeOldValue or attributeFilter is specified. *)
  val set_attributes: 'tags this -> bool -> unit [@@js.set "attributes"]
  
  (** Set to true if mutations to target's data are to be observed. Can be omitted if characterDataOldValue is specified. *)
  val get_characterData: 'tags this -> bool option [@@js.get "characterData"]
  
  (** Set to true if mutations to target's data are to be observed. Can be omitted if characterDataOldValue is specified. *)
  val set_characterData: 'tags this -> bool -> unit [@@js.set "characterData"]
  
  (** Set to true if characterData is set to true or omitted and target's data before the mutation needs to be recorded. *)
  val get_characterDataOldValue: 'tags this -> bool option [@@js.get "characterDataOldValue"]
  
  (** Set to true if characterData is set to true or omitted and target's data before the mutation needs to be recorded. *)
  val set_characterDataOldValue: 'tags this -> bool -> unit [@@js.set "characterDataOldValue"]
  
  (** Set to true if mutations to target's children are to be observed. *)
  val get_childList: 'tags this -> bool option [@@js.get "childList"]
  
  (** Set to true if mutations to target's children are to be observed. *)
  val set_childList: 'tags this -> bool -> unit [@@js.set "childList"]
  
  (** Set to true if mutations to not just target, but also target's descendants are to be observed. *)
  val get_subtree: 'tags this -> bool option [@@js.get "subtree"]
  
  (** Set to true if mutations to not just target, but also target's descendants are to be observed. *)
  val set_subtree: 'tags this -> bool -> unit [@@js.set "subtree"]
  val create: ?attributeFilter:string list -> ?attributeOldValue:bool -> ?attributes:bool -> ?characterData:bool -> ?characterDataOldValue:bool -> ?childList:bool -> ?subtree:bool -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module rec MutationCallback : sig
  type t = [`MutationCallback] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`MutationCallback]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`MutationCallback]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MutationCallback ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val apply: 'tags this -> mutations:MutationRecord.t list -> observer:MutationObserver.t -> unit [@@js.apply]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** Provides the ability to watch for changes being made to the DOM tree. It is designed as a replacement for the older Mutation Events feature which was part of the DOM3 Events specification. *)
and[@js.scope "MutationObserver"] MutationObserver : sig
  type t = [`MutationObserver] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`MutationObserver]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`MutationObserver]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MutationObserver ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Stops observer from observing any mutations. Until the observe() method is used again, observer's callback will not be invoked. *)
  val disconnect: 'tags this -> unit [@@js.call "disconnect"]
  
  (**
    Instructs the user agent to observe a given target (a node) and report any mutations based on the criteria given by options (an object).
    
    The options argument allows for setting mutation observation options via object members.
  *)
  val observe: 'tags this -> target:Node.t -> ?options:MutationObserverInit.t -> unit -> unit [@@js.call "observe"]
  
  (** Empties the record queue and returns what was in there. *)
  val takeRecords: 'tags this -> MutationRecord.t list [@@js.call "takeRecords"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: MutationCallback.t -> t [@@js.create]
end
module MessagePortEventMap : sig
  type t = [`MessagePortEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`MessagePortEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`MessagePortEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MessagePortEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_message: 'tags this -> MessageEvent.t_0 [@@js.get "message"]
  val set_message: 'tags this -> MessageEvent.t_0 -> unit [@@js.set "message"]
  val get_messageerror: 'tags this -> MessageEvent.t_0 [@@js.get "messageerror"]
  val set_messageerror: 'tags this -> MessageEvent.t_0 -> unit [@@js.set "messageerror"]
  val create: message:MessageEvent.t_0 -> messageerror:MessageEvent.t_0 -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** This Channel Messaging API interface allows us to create a new message channel and send data through it via its two MessagePort properties. *)
module[@js.scope "MessageChannel"] MessageChannel : sig
  type t = [`MessageChannel] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`MessageChannel]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`MessageChannel]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MessageChannel ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Returns the first MessagePort object. *)
  val get_port1: 'tags this -> MessagePort.t [@@js.get "port1"]
  
  (** Returns the second MessagePort object. *)
  val get_port2: 'tags this -> MessagePort.t [@@js.get "port2"]
  val create: port1:MessagePort.t -> port2:MessagePort.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end
module MediaStreamTrackEventMap : sig
  type t = [`MediaStreamTrackEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`MediaStreamTrackEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`MediaStreamTrackEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MediaStreamTrackEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_ended: 'tags this -> Event.t [@@js.get "ended"]
  val set_ended: 'tags this -> Event.t -> unit [@@js.set "ended"]
  val get_mute: 'tags this -> Event.t [@@js.get "mute"]
  val set_mute: 'tags this -> Event.t -> unit [@@js.set "mute"]
  val get_unmute: 'tags this -> Event.t [@@js.get "unmute"]
  val set_unmute: 'tags this -> Event.t -> unit [@@js.set "unmute"]
  val create: ended:Event.t -> mute:Event.t -> unmute:Event.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module MediaStreamEventMap : sig
  type t = [`MediaStreamEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`MediaStreamEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`MediaStreamEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MediaStreamEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_addtrack: 'tags this -> MediaStreamTrackEvent.t [@@js.get "addtrack"]
  val set_addtrack: 'tags this -> MediaStreamTrackEvent.t -> unit [@@js.set "addtrack"]
  val get_removetrack: 'tags this -> MediaStreamTrackEvent.t [@@js.get "removetrack"]
  val set_removetrack: 'tags this -> MediaStreamTrackEvent.t -> unit [@@js.set "removetrack"]
  val create: addtrack:MediaStreamTrackEvent.t -> removetrack:MediaStreamTrackEvent.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module MediaSourceEventMap : sig
  type t = [`MediaSourceEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`MediaSourceEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`MediaSourceEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MediaSourceEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_sourceclose: 'tags this -> Event.t [@@js.get "sourceclose"]
  val set_sourceclose: 'tags this -> Event.t -> unit [@@js.set "sourceclose"]
  val get_sourceended: 'tags this -> Event.t [@@js.get "sourceended"]
  val set_sourceended: 'tags this -> Event.t -> unit [@@js.set "sourceended"]
  val get_sourceopen: 'tags this -> Event.t [@@js.get "sourceopen"]
  val set_sourceopen: 'tags this -> Event.t -> unit [@@js.set "sourceopen"]
  val create: sourceclose:Event.t -> sourceended:Event.t -> sourceopen:Event.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module MediaRecorderEventMap : sig
  type t = [`MediaRecorderEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`MediaRecorderEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`MediaRecorderEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MediaRecorderEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_dataavailable: 'tags this -> BlobEvent.t [@@js.get "dataavailable"]
  val set_dataavailable: 'tags this -> BlobEvent.t -> unit [@@js.set "dataavailable"]
  val get_error: 'tags this -> MediaRecorderErrorEvent.t [@@js.get "error"]
  val set_error: 'tags this -> MediaRecorderErrorEvent.t -> unit [@@js.set "error"]
  val get_pause: 'tags this -> Event.t [@@js.get "pause"]
  val set_pause: 'tags this -> Event.t -> unit [@@js.set "pause"]
  val get_resume: 'tags this -> Event.t [@@js.get "resume"]
  val set_resume: 'tags this -> Event.t -> unit [@@js.set "resume"]
  val get_start: 'tags this -> Event.t [@@js.get "start"]
  val set_start: 'tags this -> Event.t -> unit [@@js.set "start"]
  val get_stop: 'tags this -> Event.t [@@js.get "stop"]
  val set_stop: 'tags this -> Event.t -> unit [@@js.set "stop"]
  val create: dataavailable:BlobEvent.t -> error:MediaRecorderErrorEvent.t -> pause:Event.t -> resume:Event.t -> start:Event.t -> stop:Event.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module RecordingState : sig
  type t = ([`L_s421_inactive[@js "inactive"] | `L_s593_paused[@js "paused"] | `L_s653_recording[@js "recording"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module MediaRecorderOptions : sig
  type t = [`MediaRecorderOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`MediaRecorderOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`MediaRecorderOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MediaRecorderOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_audioBitsPerSecond: 'tags this -> float option [@@js.get "audioBitsPerSecond"]
  val set_audioBitsPerSecond: 'tags this -> float -> unit [@@js.set "audioBitsPerSecond"]
  val get_bitsPerSecond: 'tags this -> float option [@@js.get "bitsPerSecond"]
  val set_bitsPerSecond: 'tags this -> float -> unit [@@js.set "bitsPerSecond"]
  val get_mimeType: 'tags this -> string option [@@js.get "mimeType"]
  val set_mimeType: 'tags this -> string -> unit [@@js.set "mimeType"]
  val get_videoBitsPerSecond: 'tags this -> float option [@@js.get "videoBitsPerSecond"]
  val set_videoBitsPerSecond: 'tags this -> float -> unit [@@js.set "videoBitsPerSecond"]
  val create: ?audioBitsPerSecond:float -> ?bitsPerSecond:float -> ?mimeType:string -> ?videoBitsPerSecond:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module[@js.scope "MediaRecorder"] MediaRecorder : sig
  type t = [`EventTarget | `MediaRecorder] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventTarget | `MediaRecorder]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventTarget | `MediaRecorder]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MediaRecorder ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_audioBitsPerSecond: 'tags this -> float [@@js.get "audioBitsPerSecond"]
  val get_mimeType: 'tags this -> string [@@js.get "mimeType"]
  val get_ondataavailable: 'tags this -> (this:t -> ev:BlobEvent.t -> any) option [@@js.get "ondataavailable"]
  val set_ondataavailable: 'tags this -> (this:t -> ev:BlobEvent.t -> any) option -> unit [@@js.set "ondataavailable"]
  val get_onerror: 'tags this -> (this:t -> ev:MediaRecorderErrorEvent.t -> any) option [@@js.get "onerror"]
  val set_onerror: 'tags this -> (this:t -> ev:MediaRecorderErrorEvent.t -> any) option -> unit [@@js.set "onerror"]
  val get_onpause: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onpause"]
  val set_onpause: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onpause"]
  val get_onresume: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onresume"]
  val set_onresume: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onresume"]
  val get_onstart: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onstart"]
  val set_onstart: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onstart"]
  val get_onstop: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onstop"]
  val set_onstop: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onstop"]
  val get_state: 'tags this -> RecordingState.t [@@js.get "state"]
  val get_stream: 'tags this -> MediaStream.t [@@js.get "stream"]
  val get_videoBitsPerSecond: 'tags this -> float [@@js.get "videoBitsPerSecond"]
  val pause: 'tags this -> unit [@@js.call "pause"]
  val requestData: 'tags this -> unit [@@js.call "requestData"]
  val resume: 'tags this -> unit [@@js.call "resume"]
  val start: 'tags this -> ?timeslice:float -> unit -> unit [@@js.call "start"]
  val stop: 'tags this -> unit [@@js.call "stop"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'MediaRecorderEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'MediaRecorderEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: stream:MediaStream.t -> ?options:MediaRecorderOptions.t -> unit -> t [@@js.create]
  val isTypeSupported: string -> bool [@@js.global "isTypeSupported"]
end
module MediaQueryListEventMap : sig
  type t = [`MediaQueryListEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`MediaQueryListEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`MediaQueryListEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MediaQueryListEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_change: 'tags this -> MediaQueryListEvent.t [@@js.get "change"]
  val set_change: 'tags this -> MediaQueryListEvent.t -> unit [@@js.set "change"]
  val create: change:MediaQueryListEvent.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module MediaKeySessionEventMap : sig
  type t = [`MediaKeySessionEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`MediaKeySessionEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`MediaKeySessionEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MediaKeySessionEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_keystatuseschange: 'tags this -> Event.t [@@js.get "keystatuseschange"]
  val set_keystatuseschange: 'tags this -> Event.t -> unit [@@js.set "keystatuseschange"]
  val get_message: 'tags this -> MediaKeyMessageEvent.t [@@js.get "message"]
  val set_message: 'tags this -> MediaKeyMessageEvent.t -> unit [@@js.set "message"]
  val create: keystatuseschange:Event.t -> message:MediaKeyMessageEvent.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module MediaDevicesEventMap : sig
  type t = [`MediaDevicesEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`MediaDevicesEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`MediaDevicesEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MediaDevicesEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_devicechange: 'tags this -> Event.t [@@js.get "devicechange"]
  val set_devicechange: 'tags this -> Event.t -> unit [@@js.set "devicechange"]
  val create: devicechange:Event.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module MathMLElementEventMap : sig
  type t = [`DocumentAndElementEventHandlersEventMap | `ElementEventMap | `GlobalEventHandlersEventMap | `MathMLElementEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`DocumentAndElementEventHandlersEventMap | `ElementEventMap | `GlobalEventHandlersEventMap | `MathMLElementEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`DocumentAndElementEventHandlersEventMap | `ElementEventMap | `GlobalEventHandlersEventMap | `MathMLElementEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MathMLElementEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module[@js.scope "MathMLElement"] MathMLElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `MathMLElement | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `MathMLElement | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `MathMLElement | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MathMLElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'MathMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'MathMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module LockMode : sig
  type t = ([`L_s302_exclusive[@js "exclusive"] | `L_s718_shared[@js "shared"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module LockOptions : sig
  type t = [`LockOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`LockOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`LockOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `LockOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_ifAvailable: 'tags this -> bool option [@@js.get "ifAvailable"]
  val set_ifAvailable: 'tags this -> bool -> unit [@@js.set "ifAvailable"]
  val get_mode: 'tags this -> LockMode.t option [@@js.get "mode"]
  val set_mode: 'tags this -> LockMode.t -> unit [@@js.set "mode"]
  val get_signal: 'tags this -> AbortSignal.t option [@@js.get "signal"]
  val set_signal: 'tags this -> AbortSignal.t -> unit [@@js.set "signal"]
  val get_steal: 'tags this -> bool option [@@js.get "steal"]
  val set_steal: 'tags this -> bool -> unit [@@js.set "steal"]
  val create: ?ifAvailable:bool -> ?mode:LockMode.t -> ?signal:AbortSignal.t -> ?steal:bool -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module LockInfo : sig
  type t = [`LockInfo] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`LockInfo]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`LockInfo]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `LockInfo ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_clientId: 'tags this -> string option [@@js.get "clientId"]
  val set_clientId: 'tags this -> string -> unit [@@js.set "clientId"]
  val get_mode: 'tags this -> LockMode.t option [@@js.get "mode"]
  val set_mode: 'tags this -> LockMode.t -> unit [@@js.set "mode"]
  val get_name: 'tags this -> string option [@@js.get "name"]
  val set_name: 'tags this -> string -> unit [@@js.set "name"]
  val create: ?clientId:string -> ?mode:LockMode.t -> ?name:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module LockManagerSnapshot : sig
  type t = [`LockManagerSnapshot] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`LockManagerSnapshot]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`LockManagerSnapshot]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `LockManagerSnapshot ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_held: 'tags this -> LockInfo.t list option [@@js.get "held"]
  val set_held: 'tags this -> LockInfo.t list -> unit [@@js.set "held"]
  val get_pending: 'tags this -> LockInfo.t list option [@@js.get "pending"]
  val set_pending: 'tags this -> LockInfo.t list -> unit [@@js.set "pending"]
  val create: ?held:LockInfo.t list -> ?pending:LockInfo.t list -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** Available only in secure contexts. *)
module[@js.scope "Lock"] Lock : sig
  type t = [`Lock] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Lock]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Lock]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `Lock ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_mode: 'tags this -> LockMode.t [@@js.get "mode"]
  val get_name: 'tags this -> string [@@js.get "name"]
  val create: mode:LockMode.t -> name:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end
module LockGrantedCallback : sig
  type t = [`LockGrantedCallback] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`LockGrantedCallback]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`LockGrantedCallback]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `LockGrantedCallback ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val apply: 'tags this -> lock:Lock.t option -> any [@@js.apply]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** Available only in secure contexts. *)
module[@js.scope "LockManager"] LockManager : sig
  type t = [`LockManager] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`LockManager]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`LockManager]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `LockManager ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val query: 'tags this -> LockManagerSnapshot.t Promise.t_1 [@@js.call "query"]
  val request: 'tags this -> name:string -> callback:LockGrantedCallback.t -> any Promise.t_1 [@@js.call "request"]
  val request': 'tags this -> name:string -> options:LockOptions.t -> callback:LockGrantedCallback.t -> any Promise.t_1 [@@js.call "request"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module ComputedKeyframe : sig
  type t = [`ComputedKeyframe] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ComputedKeyframe]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ComputedKeyframe]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ComputedKeyframe ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_composite: 'tags this -> CompositeOperationOrAuto.t [@@js.get "composite"]
  val set_composite: 'tags this -> CompositeOperationOrAuto.t -> unit [@@js.set "composite"]
  val get_computedOffset: 'tags this -> float [@@js.get "computedOffset"]
  val set_computedOffset: 'tags this -> float -> unit [@@js.set "computedOffset"]
  val get_easing: 'tags this -> string [@@js.get "easing"]
  val set_easing: 'tags this -> string -> unit [@@js.set "easing"]
  val get_offset: 'tags this -> float option [@@js.get "offset"]
  val set_offset: 'tags this -> float option -> unit [@@js.set "offset"]
  val get: 'tags this -> string -> ([`Number of float | `String of string | `Null | `Undefined] [@js.union on_field "dummy"]) Primitive.t [@@js.index_get]
  val set: 'tags this -> string -> ([`Null | `Undefined of undefined | `U1 of string | `U2 of float] [@js.union]) -> unit [@@js.index_set]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module[@js.scope "KeyframeEffect"] KeyframeEffect : sig
  type t = [`AnimationEffect | `KeyframeEffect] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AnimationEffect | `KeyframeEffect]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AnimationEffect | `KeyframeEffect]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `KeyframeEffect ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_composite: 'tags this -> CompositeOperation.t [@@js.get "composite"]
  val set_composite: 'tags this -> CompositeOperation.t -> unit [@@js.set "composite"]
  val get_iterationComposite: 'tags this -> IterationCompositeOperation.t [@@js.get "iterationComposite"]
  val set_iterationComposite: 'tags this -> IterationCompositeOperation.t -> unit [@@js.set "iterationComposite"]
  val get_pseudoElement: 'tags this -> string option [@@js.get "pseudoElement"]
  val set_pseudoElement: 'tags this -> string option -> unit [@@js.set "pseudoElement"]
  val get_target: 'tags this -> Element.t option [@@js.get "target"]
  val set_target: 'tags this -> Element.t option -> unit [@@js.set "target"]
  val getKeyframes: 'tags this -> ComputedKeyframe.t list [@@js.call "getKeyframes"]
  val setKeyframes: 'tags this -> keyframes:([`Null | `U1 of Keyframe.t list | `U2 of PropertyIndexedKeyframes.t] [@js.union]) -> unit [@@js.call "setKeyframes"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: target:Element.t option -> keyframes:([`Null | `U1 of Keyframe.t list | `U2 of PropertyIndexedKeyframes.t] [@js.union]) -> ?options:([`U1 of float | `U2 of KeyframeEffectOptions.t] [@js.union]) -> unit -> t [@@js.create]
  val create': t -> t [@@js.create]
end
module IntersectionObserverInit : sig
  type t = [`IntersectionObserverInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`IntersectionObserverInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`IntersectionObserverInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `IntersectionObserverInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_root: 'tags this -> (Document.t, Element.t) union2 option option [@@js.get "root"]
  val set_root: 'tags this -> ([`Null | `U1 of Element.t | `U2 of Document.t] [@js.union]) -> unit [@@js.set "root"]
  val get_rootMargin: 'tags this -> string option [@@js.get "rootMargin"]
  val set_rootMargin: 'tags this -> string -> unit [@@js.set "rootMargin"]
  val get_threshold: 'tags this -> ([`Number of float | `Other of float list] [@js.union on_field "dummy"]) Primitive.t option [@@js.get "threshold"]
  val set_threshold: 'tags this -> ([`U1 of float | `U2 of float list] [@js.union]) -> unit [@@js.set "threshold"]
  val create: ?root:(Document.t, Element.t) union2 -> ?rootMargin:string -> ?threshold:([`Number of float | `Other of float list] [@js.union on_field "dummy"]) Primitive.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module IntersectionObserverEntryInit : sig
  type t = [`IntersectionObserverEntryInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`IntersectionObserverEntryInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`IntersectionObserverEntryInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `IntersectionObserverEntryInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_boundingClientRect: 'tags this -> DOMRectInit.t [@@js.get "boundingClientRect"]
  val set_boundingClientRect: 'tags this -> DOMRectInit.t -> unit [@@js.set "boundingClientRect"]
  val get_intersectionRatio: 'tags this -> float [@@js.get "intersectionRatio"]
  val set_intersectionRatio: 'tags this -> float -> unit [@@js.set "intersectionRatio"]
  val get_intersectionRect: 'tags this -> DOMRectInit.t [@@js.get "intersectionRect"]
  val set_intersectionRect: 'tags this -> DOMRectInit.t -> unit [@@js.set "intersectionRect"]
  val get_isIntersecting: 'tags this -> bool [@@js.get "isIntersecting"]
  val set_isIntersecting: 'tags this -> bool -> unit [@@js.set "isIntersecting"]
  val get_rootBounds: 'tags this -> DOMRectInit.t option [@@js.get "rootBounds"]
  val set_rootBounds: 'tags this -> DOMRectInit.t option -> unit [@@js.set "rootBounds"]
  val get_target: 'tags this -> Element.t [@@js.get "target"]
  val set_target: 'tags this -> Element.t -> unit [@@js.set "target"]
  val get_time: 'tags this -> DOMHighResTimeStamp.t [@@js.get "time"]
  val set_time: 'tags this -> DOMHighResTimeStamp.t -> unit [@@js.set "time"]
  val create: boundingClientRect:DOMRectInit.t -> intersectionRatio:float -> intersectionRect:DOMRectInit.t -> isIntersecting:bool -> ?rootBounds:DOMRectInit.t -> target:Element.t -> time:DOMHighResTimeStamp.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** This Intersection Observer API interface describes the intersection between the target element and its root container at a specific moment of transition. *)
module[@js.scope "IntersectionObserverEntry"] IntersectionObserverEntry : sig
  type t = [`IntersectionObserverEntry] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`IntersectionObserverEntry]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`IntersectionObserverEntry]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `IntersectionObserverEntry ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_boundingClientRect: 'tags this -> DOMRectReadOnly.t [@@js.get "boundingClientRect"]
  val get_intersectionRatio: 'tags this -> float [@@js.get "intersectionRatio"]
  val get_intersectionRect: 'tags this -> DOMRectReadOnly.t [@@js.get "intersectionRect"]
  val get_isIntersecting: 'tags this -> bool [@@js.get "isIntersecting"]
  val get_rootBounds: 'tags this -> DOMRectReadOnly.t option [@@js.get "rootBounds"]
  val get_target: 'tags this -> Element.t [@@js.get "target"]
  val get_time: 'tags this -> DOMHighResTimeStamp.t [@@js.get "time"]
  val create: boundingClientRect:DOMRectReadOnly.t -> intersectionRatio:float -> intersectionRect:DOMRectReadOnly.t -> isIntersecting:bool -> ?rootBounds:DOMRectReadOnly.t -> target:Element.t -> time:DOMHighResTimeStamp.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': IntersectionObserverEntryInit.t -> t [@@js.create]
end

(** provides a way to asynchronously observe changes in the intersection of a target element with an ancestor element or with a top-level document's viewport. *)
module[@js.scope "IntersectionObserver"] rec IntersectionObserver : sig
  type t = [`IntersectionObserver] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`IntersectionObserver]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`IntersectionObserver]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `IntersectionObserver ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_root: 'tags this -> (Document.t, Element.t) union2 option [@@js.get "root"]
  val get_rootMargin: 'tags this -> string [@@js.get "rootMargin"]
  val get_thresholds: 'tags this -> float list [@@js.get "thresholds"]
  val disconnect: 'tags this -> unit [@@js.call "disconnect"]
  val observe: 'tags this -> target:Element.t -> unit [@@js.call "observe"]
  val takeRecords: 'tags this -> IntersectionObserverEntry.t list [@@js.call "takeRecords"]
  val unobserve: 'tags this -> target:Element.t -> unit [@@js.call "unobserve"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: callback:IntersectionObserverCallback.t -> ?options:IntersectionObserverInit.t -> unit -> t [@@js.create]
end
and IntersectionObserverCallback : sig
  type t = [`IntersectionObserverCallback] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`IntersectionObserverCallback]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`IntersectionObserverCallback]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `IntersectionObserverCallback ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val apply: 'tags this -> entries:IntersectionObserverEntry.t list -> observer:IntersectionObserver.t -> unit [@@js.apply]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module[@js.scope "InputDeviceInfo"] InputDeviceInfo : sig
  type t = [`InputDeviceInfo | `MediaDeviceInfo] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`InputDeviceInfo | `MediaDeviceInfo]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`InputDeviceInfo | `MediaDeviceInfo]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `InputDeviceInfo ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(**
  The type of `import.meta`.
  
  If you need to declare that a given property exists on `import.meta`,
  this type may be augmented via interface merging.
*)
module ImportMeta : sig
  type t = [`ImportMeta] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ImportMeta]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ImportMeta]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ImportMeta ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_url: 'tags this -> string [@@js.get "url"]
  val set_url: 'tags this -> string -> unit [@@js.set "url"]
  val create: url:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module[@js.scope "Image"] Image : sig
  val create: ?width:float -> ?height:float -> unit -> HTMLImageElement.t [@@js.create]
end
module IDBTransactionEventMap : sig
  type t = [`IDBTransactionEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`IDBTransactionEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`IDBTransactionEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `IDBTransactionEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_abort: 'tags this -> Event.t [@@js.get "abort"]
  val set_abort: 'tags this -> Event.t -> unit [@@js.set "abort"]
  val get_complete: 'tags this -> Event.t [@@js.get "complete"]
  val set_complete: 'tags this -> Event.t -> unit [@@js.set "complete"]
  val get_error: 'tags this -> Event.t [@@js.get "error"]
  val set_error: 'tags this -> Event.t -> unit [@@js.set "error"]
  val create: abort:Event.t -> complete:Event.t -> error:Event.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module IDBRequestEventMap : sig
  type t = [`IDBRequestEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`IDBRequestEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`IDBRequestEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `IDBRequestEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_error: 'tags this -> Event.t [@@js.get "error"]
  val set_error: 'tags this -> Event.t -> unit [@@js.set "error"]
  val get_success: 'tags this -> Event.t [@@js.get "success"]
  val set_success: 'tags this -> Event.t -> unit [@@js.set "success"]
  val create: error:Event.t -> success:Event.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module IDBOpenDBRequestEventMap : sig
  type t = [`IDBOpenDBRequestEventMap | `IDBRequestEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`IDBOpenDBRequestEventMap | `IDBRequestEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`IDBOpenDBRequestEventMap | `IDBRequestEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `IDBOpenDBRequestEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_blocked: 'tags this -> Event.t [@@js.get "blocked"]
  val set_blocked: 'tags this -> Event.t -> unit [@@js.set "blocked"]
  val get_upgradeneeded: 'tags this -> IDBVersionChangeEvent.t [@@js.get "upgradeneeded"]
  val set_upgradeneeded: 'tags this -> IDBVersionChangeEvent.t -> unit [@@js.set "upgradeneeded"]
  val create: blocked:Event.t -> upgradeneeded:IDBVersionChangeEvent.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module IDBDatabaseEventMap : sig
  type t = [`IDBDatabaseEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`IDBDatabaseEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`IDBDatabaseEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `IDBDatabaseEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_abort: 'tags this -> Event.t [@@js.get "abort"]
  val set_abort: 'tags this -> Event.t -> unit [@@js.set "abort"]
  val get_close: 'tags this -> Event.t [@@js.get "close"]
  val set_close: 'tags this -> Event.t -> unit [@@js.set "close"]
  val get_error: 'tags this -> Event.t [@@js.get "error"]
  val set_error: 'tags this -> Event.t -> unit [@@js.set "error"]
  val get_versionchange: 'tags this -> IDBVersionChangeEvent.t [@@js.get "versionchange"]
  val set_versionchange: 'tags this -> IDBVersionChangeEvent.t -> unit [@@js.set "versionchange"]
  val create: abort:Event.t -> close:Event.t -> error:Event.t -> versionchange:IDBVersionChangeEvent.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module HmacKeyAlgorithm : sig
  type t = [`HmacKeyAlgorithm | `KeyAlgorithm] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`HmacKeyAlgorithm | `KeyAlgorithm]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`HmacKeyAlgorithm | `KeyAlgorithm]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HmacKeyAlgorithm ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_hash: 'tags this -> KeyAlgorithm.t [@@js.get "hash"]
  val set_hash: 'tags this -> KeyAlgorithm.t -> unit [@@js.set "hash"]
  val get_length: 'tags this -> float [@@js.get "length"]
  val set_length: 'tags this -> float -> unit [@@js.set "length"]
  val create: hash:KeyAlgorithm.t -> length:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module HTMLElementEventMap : sig
  type t = [`DocumentAndElementEventHandlersEventMap | `ElementEventMap | `GlobalEventHandlersEventMap | `HTMLElementEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`DocumentAndElementEventHandlersEventMap | `ElementEventMap | `GlobalEventHandlersEventMap | `HTMLElementEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`DocumentAndElementEventHandlersEventMap | `ElementEventMap | `GlobalEventHandlersEventMap | `HTMLElementEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLElementEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module HTMLMediaElementEventMap : sig
  type t = [`DocumentAndElementEventHandlersEventMap | `ElementEventMap | `GlobalEventHandlersEventMap | `HTMLElementEventMap | `HTMLMediaElementEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`DocumentAndElementEventHandlersEventMap | `ElementEventMap | `GlobalEventHandlersEventMap | `HTMLElementEventMap | `HTMLMediaElementEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`DocumentAndElementEventHandlersEventMap | `ElementEventMap | `GlobalEventHandlersEventMap | `HTMLElementEventMap | `HTMLMediaElementEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLMediaElementEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_encrypted: 'tags this -> MediaEncryptedEvent.t [@@js.get "encrypted"]
  val set_encrypted: 'tags this -> MediaEncryptedEvent.t -> unit [@@js.set "encrypted"]
  val get_waitingforkey: 'tags this -> Event.t [@@js.get "waitingforkey"]
  val set_waitingforkey: 'tags this -> Event.t -> unit [@@js.set "waitingforkey"]
  val create: encrypted:MediaEncryptedEvent.t -> waitingforkey:Event.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module HTMLVideoElementEventMap : sig
  type t = [`DocumentAndElementEventHandlersEventMap | `ElementEventMap | `GlobalEventHandlersEventMap | `HTMLElementEventMap | `HTMLMediaElementEventMap | `HTMLVideoElementEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`DocumentAndElementEventHandlersEventMap | `ElementEventMap | `GlobalEventHandlersEventMap | `HTMLElementEventMap | `HTMLMediaElementEventMap | `HTMLVideoElementEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`DocumentAndElementEventHandlersEventMap | `ElementEventMap | `GlobalEventHandlersEventMap | `HTMLElementEventMap | `HTMLMediaElementEventMap | `HTMLVideoElementEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLVideoElementEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_enterpictureinpicture: 'tags this -> Event.t [@@js.get "enterpictureinpicture"]
  val set_enterpictureinpicture: 'tags this -> Event.t -> unit [@@js.set "enterpictureinpicture"]
  val get_leavepictureinpicture: 'tags this -> Event.t [@@js.get "leavepictureinpicture"]
  val set_leavepictureinpicture: 'tags this -> Event.t -> unit [@@js.set "leavepictureinpicture"]
  val create: enterpictureinpicture:Event.t -> leavepictureinpicture:Event.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** An invalid HTML element and derives from the HTMLElement interface, but without implementing any additional properties or methods. *)
module[@js.scope "HTMLUnknownElement"] HTMLUnknownElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLUnknownElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLUnknownElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLUnknownElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLUnknownElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Provides special properties and methods (beyond the regular HTMLElement interface it also has available to it by inheritance) for manipulating the layout and presentation of table cells, either header or data cells, in an HTML document. *)
module[@js.scope "HTMLTableCellElement"] HTMLTableCellElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLTableCellElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLTableCellElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLTableCellElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLTableCellElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Sets or retrieves abbreviated text for the object. *)
  val get_abbr: 'tags this -> string [@@js.get "abbr"]
  
  (** Sets or retrieves abbreviated text for the object. *)
  val set_abbr: 'tags this -> string -> unit [@@js.set "abbr"]
  
  (**
    Sets or retrieves how the object is aligned with adjacent text.
    @deprecated 
  *)
  val get_align: 'tags this -> string [@@js.get "align"]
  
  (**
    Sets or retrieves how the object is aligned with adjacent text.
    @deprecated 
  *)
  val set_align: 'tags this -> string -> unit [@@js.set "align"]
  
  (**
    Sets or retrieves a comma-delimited list of conceptual categories associated with the object.
    @deprecated 
  *)
  val get_axis: 'tags this -> string [@@js.get "axis"]
  
  (**
    Sets or retrieves a comma-delimited list of conceptual categories associated with the object.
    @deprecated 
  *)
  val set_axis: 'tags this -> string -> unit [@@js.set "axis"]
  
  (** @deprecated  *)
  val get_bgColor: 'tags this -> string [@@js.get "bgColor"]
  
  (** @deprecated  *)
  val set_bgColor: 'tags this -> string -> unit [@@js.set "bgColor"]
  
  (** Retrieves the position of the object in the cells collection of a row. *)
  val get_cellIndex: 'tags this -> float [@@js.get "cellIndex"]
  
  (** @deprecated  *)
  val get_ch: 'tags this -> string [@@js.get "ch"]
  
  (** @deprecated  *)
  val set_ch: 'tags this -> string -> unit [@@js.set "ch"]
  
  (** @deprecated  *)
  val get_chOff: 'tags this -> string [@@js.get "chOff"]
  
  (** @deprecated  *)
  val set_chOff: 'tags this -> string -> unit [@@js.set "chOff"]
  
  (** Sets or retrieves the number columns in the table that the object should span. *)
  val get_colSpan: 'tags this -> float [@@js.get "colSpan"]
  
  (** Sets or retrieves the number columns in the table that the object should span. *)
  val set_colSpan: 'tags this -> float -> unit [@@js.set "colSpan"]
  
  (** Sets or retrieves a list of header cells that provide information for the object. *)
  val get_headers: 'tags this -> string [@@js.get "headers"]
  
  (** Sets or retrieves a list of header cells that provide information for the object. *)
  val set_headers: 'tags this -> string -> unit [@@js.set "headers"]
  
  (**
    Sets or retrieves the height of the object.
    @deprecated 
  *)
  val get_height: 'tags this -> string [@@js.get "height"]
  
  (**
    Sets or retrieves the height of the object.
    @deprecated 
  *)
  val set_height: 'tags this -> string -> unit [@@js.set "height"]
  
  (**
    Sets or retrieves whether the browser automatically performs wordwrap.
    @deprecated 
  *)
  val get_noWrap: 'tags this -> bool [@@js.get "noWrap"]
  
  (**
    Sets or retrieves whether the browser automatically performs wordwrap.
    @deprecated 
  *)
  val set_noWrap: 'tags this -> bool -> unit [@@js.set "noWrap"]
  
  (** Sets or retrieves how many rows in a table the cell should span. *)
  val get_rowSpan: 'tags this -> float [@@js.get "rowSpan"]
  
  (** Sets or retrieves how many rows in a table the cell should span. *)
  val set_rowSpan: 'tags this -> float -> unit [@@js.set "rowSpan"]
  
  (** Sets or retrieves the group of cells in a table to which the object's information applies. *)
  val get_scope: 'tags this -> string [@@js.get "scope"]
  
  (** Sets or retrieves the group of cells in a table to which the object's information applies. *)
  val set_scope: 'tags this -> string -> unit [@@js.set "scope"]
  
  (** @deprecated  *)
  val get_vAlign: 'tags this -> string [@@js.get "vAlign"]
  
  (** @deprecated  *)
  val set_vAlign: 'tags this -> string -> unit [@@js.set "vAlign"]
  
  (**
    Sets or retrieves the width of the object.
    @deprecated 
  *)
  val get_width: 'tags this -> string [@@js.get "width"]
  
  (**
    Sets or retrieves the width of the object.
    @deprecated 
  *)
  val set_width: 'tags this -> string -> unit [@@js.set "width"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** @deprecated prefer HTMLTableCellElement *)
module HTMLTableHeaderCellElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLTableCellElement | `HTMLTableHeaderCellElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLTableCellElement | `HTMLTableHeaderCellElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLTableCellElement | `HTMLTableHeaderCellElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLTableHeaderCellElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** @deprecated prefer HTMLTableCellElement *)
module HTMLTableDataCellElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLTableCellElement | `HTMLTableDataCellElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLTableCellElement | `HTMLTableDataCellElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLTableCellElement | `HTMLTableDataCellElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLTableDataCellElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module HTMLFrameSetElementEventMap : sig
  type t = [`DocumentAndElementEventHandlersEventMap | `ElementEventMap | `GlobalEventHandlersEventMap | `HTMLElementEventMap | `HTMLFrameSetElementEventMap | `WindowEventHandlersEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`DocumentAndElementEventHandlersEventMap | `ElementEventMap | `GlobalEventHandlersEventMap | `HTMLElementEventMap | `HTMLFrameSetElementEventMap | `WindowEventHandlersEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`DocumentAndElementEventHandlersEventMap | `ElementEventMap | `GlobalEventHandlersEventMap | `HTMLElementEventMap | `HTMLFrameSetElementEventMap | `WindowEventHandlersEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLFrameSetElementEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** Exposes specific properties and methods (beyond those of the HTMLElement interface it also has available to it by inheritance) for manipulating a block of preformatted text (<pre>). *)
module[@js.scope "HTMLPreElement"] HTMLPreElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLPreElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLPreElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLPreElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLPreElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    Sets or gets a value that you can use to implement your own width functionality for the object.
    @deprecated 
  *)
  val get_width: 'tags this -> float [@@js.get "width"]
  
  (**
    Sets or gets a value that you can use to implement your own width functionality for the object.
    @deprecated 
  *)
  val set_width: 'tags this -> float -> unit [@@js.set "width"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module HTMLElementDeprecatedTagNameMap : sig
  type t = [`HTMLElementDeprecatedTagNameMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`HTMLElementDeprecatedTagNameMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`HTMLElementDeprecatedTagNameMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLElementDeprecatedTagNameMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_listing: 'tags this -> HTMLPreElement.t [@@js.get "listing"]
  val set_listing: 'tags this -> HTMLPreElement.t -> unit [@@js.set "listing"]
  val get_xmp: 'tags this -> HTMLPreElement.t [@@js.get "xmp"]
  val set_xmp: 'tags this -> HTMLPreElement.t -> unit [@@js.set "xmp"]
  val create: listing:HTMLPreElement.t -> xmp:HTMLPreElement.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** @deprecated use Document *)
module[@js.scope "HTMLDocument"] HTMLDocument : sig
  type t = [`Document | `DocumentAndElementEventHandlers | `DocumentOrShadowRoot | `EventTarget | `FontFaceSource | `GlobalEventHandlers | `HTMLDocument | `Node | `NonElementParentNode | `ParentNode | `XPathEvaluatorBase] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Document | `DocumentAndElementEventHandlers | `DocumentOrShadowRoot | `EventTarget | `FontFaceSource | `GlobalEventHandlers | `HTMLDocument | `Node | `NonElementParentNode | `ParentNode | `XPathEvaluatorBase]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Document | `DocumentAndElementEventHandlers | `DocumentOrShadowRoot | `EventTarget | `FontFaceSource | `GlobalEventHandlers | `HTMLDocument | `Node | `NonElementParentNode | `ParentNode | `XPathEvaluatorBase]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLDocument ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'DocumentEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'DocumentEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module HTMLBodyElementEventMap : sig
  type t = [`DocumentAndElementEventHandlersEventMap | `ElementEventMap | `GlobalEventHandlersEventMap | `HTMLBodyElementEventMap | `HTMLElementEventMap | `WindowEventHandlersEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`DocumentAndElementEventHandlersEventMap | `ElementEventMap | `GlobalEventHandlersEventMap | `HTMLBodyElementEventMap | `HTMLElementEventMap | `WindowEventHandlersEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`DocumentAndElementEventHandlersEventMap | `ElementEventMap | `GlobalEventHandlersEventMap | `HTMLBodyElementEventMap | `HTMLElementEventMap | `WindowEventHandlersEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLBodyElementEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_orientationchange: 'tags this -> Event.t [@@js.get "orientationchange"]
  val set_orientationchange: 'tags this -> Event.t -> unit [@@js.set "orientationchange"]
  val create: orientationchange:Event.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module FontFaceSetEventMap : sig
  type t = [`FontFaceSetEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`FontFaceSetEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`FontFaceSetEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `FontFaceSetEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_loading: 'tags this -> Event.t [@@js.get "loading"]
  val set_loading: 'tags this -> Event.t -> unit [@@js.set "loading"]
  val get_loadingdone: 'tags this -> Event.t [@@js.get "loadingdone"]
  val set_loadingdone: 'tags this -> Event.t -> unit [@@js.set "loadingdone"]
  val get_loadingerror: 'tags this -> Event.t [@@js.get "loadingerror"]
  val set_loadingerror: 'tags this -> Event.t -> unit [@@js.set "loadingerror"]
  val create: loading:Event.t -> loadingdone:Event.t -> loadingerror:Event.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module FileCallback : sig
  type t = [`FileCallback] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`FileCallback]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`FileCallback]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `FileCallback ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val apply: 'tags this -> file:File.t -> unit [@@js.apply]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module[@js.scope "FileSystemFileEntry"] FileSystemFileEntry : sig
  type t = [`FileSystemEntry | `FileSystemFileEntry] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`FileSystemEntry | `FileSystemFileEntry]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`FileSystemEntry | `FileSystemFileEntry]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `FileSystemFileEntry ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val file: 'tags this -> successCallback:FileCallback.t -> ?errorCallback:ErrorCallback.t -> unit -> unit [@@js.call "file"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Lets web applications asynchronously read the contents of files (or raw data buffers) stored on the user's computer, using File or Blob objects to specify the file or data to read. *)
module[@js.scope "FileReader"] FileReader : sig
  type t = [`EventTarget | `FileReader] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventTarget | `FileReader]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventTarget | `FileReader]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `FileReader ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_error: 'tags this -> DOMException.t option [@@js.get "error"]
  val get_onabort: 'tags this -> (this:t -> ev:t ProgressEvent.t -> any) option [@@js.get "onabort"]
  val set_onabort: 'tags this -> (this:t -> ev:t ProgressEvent.t -> any) option -> unit [@@js.set "onabort"]
  val get_onerror: 'tags this -> (this:t -> ev:t ProgressEvent.t -> any) option [@@js.get "onerror"]
  val set_onerror: 'tags this -> (this:t -> ev:t ProgressEvent.t -> any) option -> unit [@@js.set "onerror"]
  val get_onload: 'tags this -> (this:t -> ev:t ProgressEvent.t -> any) option [@@js.get "onload"]
  val set_onload: 'tags this -> (this:t -> ev:t ProgressEvent.t -> any) option -> unit [@@js.set "onload"]
  val get_onloadend: 'tags this -> (this:t -> ev:t ProgressEvent.t -> any) option [@@js.get "onloadend"]
  val set_onloadend: 'tags this -> (this:t -> ev:t ProgressEvent.t -> any) option -> unit [@@js.set "onloadend"]
  val get_onloadstart: 'tags this -> (this:t -> ev:t ProgressEvent.t -> any) option [@@js.get "onloadstart"]
  val set_onloadstart: 'tags this -> (this:t -> ev:t ProgressEvent.t -> any) option -> unit [@@js.set "onloadstart"]
  val get_onprogress: 'tags this -> (this:t -> ev:t ProgressEvent.t -> any) option [@@js.get "onprogress"]
  val set_onprogress: 'tags this -> (this:t -> ev:t ProgressEvent.t -> any) option -> unit [@@js.set "onprogress"]
  val get_readyState: 'tags this -> float [@@js.get "readyState"]
  val get_result: 'tags this -> ([`String of string | `Null | `Other of ArrayBuffer.t_0] [@js.union on_field "dummy"]) Primitive.t [@@js.get "result"]
  val abort: 'tags this -> unit [@@js.call "abort"]
  val readAsArrayBuffer: 'tags this -> blob:Blob.t -> unit [@@js.call "readAsArrayBuffer"]
  val readAsBinaryString: 'tags this -> blob:Blob.t -> unit [@@js.call "readAsBinaryString"]
  val readAsDataURL: 'tags this -> blob:Blob.t -> unit [@@js.call "readAsDataURL"]
  val readAsText: 'tags this -> blob:Blob.t -> ?encoding:string -> unit -> unit [@@js.call "readAsText"]
  val get_DONE: 'tags this -> float [@@js.get "DONE"]
  val get_EMPTY: 'tags this -> float [@@js.get "EMPTY"]
  val get_LOADING: 'tags this -> float [@@js.get "LOADING"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'FileReaderEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'FileReaderEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
  val done_: unit -> float [@@js.get "DONE"]
  val empty: unit -> float [@@js.get "EMPTY"]
  val loading: unit -> float [@@js.get "LOADING"]
end
module FileReaderEventMap : sig
  type t = [`FileReaderEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`FileReaderEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`FileReaderEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `FileReaderEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_abort: 'tags this -> FileReader.t ProgressEvent.t [@@js.get "abort"]
  val set_abort: 'tags this -> FileReader.t ProgressEvent.t -> unit [@@js.set "abort"]
  val get_error: 'tags this -> FileReader.t ProgressEvent.t [@@js.get "error"]
  val set_error: 'tags this -> FileReader.t ProgressEvent.t -> unit [@@js.set "error"]
  val get_load: 'tags this -> FileReader.t ProgressEvent.t [@@js.get "load"]
  val set_load: 'tags this -> FileReader.t ProgressEvent.t -> unit [@@js.set "load"]
  val get_loadend: 'tags this -> FileReader.t ProgressEvent.t [@@js.get "loadend"]
  val set_loadend: 'tags this -> FileReader.t ProgressEvent.t -> unit [@@js.set "loadend"]
  val get_loadstart: 'tags this -> FileReader.t ProgressEvent.t [@@js.get "loadstart"]
  val set_loadstart: 'tags this -> FileReader.t ProgressEvent.t -> unit [@@js.set "loadstart"]
  val get_progress: 'tags this -> FileReader.t ProgressEvent.t [@@js.get "progress"]
  val set_progress: 'tags this -> FileReader.t ProgressEvent.t -> unit [@@js.set "progress"]
  val create: abort:FileReader.t ProgressEvent.t -> error:FileReader.t ProgressEvent.t -> load:FileReader.t ProgressEvent.t -> loadend:FileReader.t ProgressEvent.t -> loadstart:FileReader.t ProgressEvent.t -> progress:FileReader.t ProgressEvent.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module EventSourceEventMap : sig
  type t = [`EventSourceEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventSourceEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventSourceEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `EventSourceEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_error: 'tags this -> Event.t [@@js.get "error"]
  val set_error: 'tags this -> Event.t -> unit [@@js.set "error"]
  val get_message: 'tags this -> MessageEvent.t_0 [@@js.get "message"]
  val set_message: 'tags this -> MessageEvent.t_0 -> unit [@@js.set "message"]
  val get_open: 'tags this -> Event.t [@@js.get "open"]
  val set_open: 'tags this -> Event.t -> unit [@@js.set "open"]
  val create: error:Event.t -> message:MessageEvent.t_0 -> open_:(Event.t[@js "open"]) -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module EventSourceInit : sig
  type t = [`EventSourceInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventSourceInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventSourceInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `EventSourceInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_withCredentials: 'tags this -> bool option [@@js.get "withCredentials"]
  val set_withCredentials: 'tags this -> bool -> unit [@@js.set "withCredentials"]
  val create: ?withCredentials:bool -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module[@js.scope "EventSource"] EventSource : sig
  type t = [`EventSource | `EventTarget] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EventSource | `EventTarget]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EventSource | `EventTarget]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `EventSource ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_onerror: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onerror"]
  val set_onerror: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onerror"]
  val get_onmessage: 'tags this -> (this:t -> ev:MessageEvent.t_0 -> any) option [@@js.get "onmessage"]
  val set_onmessage: 'tags this -> (this:t -> ev:MessageEvent.t_0 -> any) option -> unit [@@js.set "onmessage"]
  val get_onopen: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onopen"]
  val set_onopen: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onopen"]
  
  (** Returns the state of this EventSource object's connection. It can have the values described below. *)
  val get_readyState: 'tags this -> float [@@js.get "readyState"]
  
  (** Returns the URL providing the event stream. *)
  val get_url: 'tags this -> string [@@js.get "url"]
  
  (** Returns true if the credentials mode for connection requests to the URL providing the event stream is set to "include", and false otherwise. *)
  val get_withCredentials: 'tags this -> bool [@@js.get "withCredentials"]
  
  (** Aborts any instances of the fetch algorithm started for this EventSource object, and sets the readyState attribute to CLOSED. *)
  val close: 'tags this -> unit [@@js.call "close"]
  val get_CLOSED: 'tags this -> float [@@js.get "CLOSED"]
  val get_CONNECTING: 'tags this -> float [@@js.get "CONNECTING"]
  val get_OPEN: 'tags this -> float [@@js.get "OPEN"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'EventSourceEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:(this:t -> event:MessageEvent.t_0 -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener'': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'EventSourceEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:(this:t -> event:MessageEvent.t_0 -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener'': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: url:([`U1 of string | `U2 of URL.t] [@js.union]) -> ?eventSourceInitDict:EventSourceInit.t -> unit -> t [@@js.create]
  val closed: unit -> float [@@js.get "CLOSED"]
  val connecting: unit -> float [@@js.get "CONNECTING"]
  val open_: unit -> float [@@js.get "OPEN"]
end

(** Provides access to the properties of <view> elements, as well as methods to manipulate them. *)
module[@js.scope "SVGViewElement"] SVGViewElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFitToViewBox | `SVGViewElement | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFitToViewBox | `SVGViewElement | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFitToViewBox | `SVGViewElement | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGViewElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Corresponds to the <title> element. *)
module[@js.scope "SVGTitleElement"] SVGTitleElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGTitleElement | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGTitleElement | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGTitleElement | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGTitleElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Corresponds to the <textPath> element. *)
module[@js.scope "SVGTextPathElement"] SVGTextPathElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGGraphicsElement | `SVGTests | `SVGTextContentElement | `SVGTextPathElement | `SVGURIReference | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGGraphicsElement | `SVGTests | `SVGTextContentElement | `SVGTextPathElement | `SVGURIReference | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGGraphicsElement | `SVGTests | `SVGTextContentElement | `SVGTextPathElement | `SVGURIReference | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGTextPathElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_method: 'tags this -> SVGAnimatedEnumeration.t [@@js.get "method"]
  val get_spacing: 'tags this -> SVGAnimatedEnumeration.t [@@js.get "spacing"]
  val get_startOffset: 'tags this -> SVGAnimatedLength.t [@@js.get "startOffset"]
  val get_TEXTPATH_METHODTYPE_ALIGN: 'tags this -> float [@@js.get "TEXTPATH_METHODTYPE_ALIGN"]
  val get_TEXTPATH_METHODTYPE_STRETCH: 'tags this -> float [@@js.get "TEXTPATH_METHODTYPE_STRETCH"]
  val get_TEXTPATH_METHODTYPE_UNKNOWN: 'tags this -> float [@@js.get "TEXTPATH_METHODTYPE_UNKNOWN"]
  val get_TEXTPATH_SPACINGTYPE_AUTO: 'tags this -> float [@@js.get "TEXTPATH_SPACINGTYPE_AUTO"]
  val get_TEXTPATH_SPACINGTYPE_EXACT: 'tags this -> float [@@js.get "TEXTPATH_SPACINGTYPE_EXACT"]
  val get_TEXTPATH_SPACINGTYPE_UNKNOWN: 'tags this -> float [@@js.get "TEXTPATH_SPACINGTYPE_UNKNOWN"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
  val textpath_methodtype_align: unit -> float [@@js.get "TEXTPATH_METHODTYPE_ALIGN"]
  val textpath_methodtype_stretch: unit -> float [@@js.get "TEXTPATH_METHODTYPE_STRETCH"]
  val textpath_methodtype_unknown: unit -> float [@@js.get "TEXTPATH_METHODTYPE_UNKNOWN"]
  val textpath_spacingtype_auto: unit -> float [@@js.get "TEXTPATH_SPACINGTYPE_AUTO"]
  val textpath_spacingtype_exact: unit -> float [@@js.get "TEXTPATH_SPACINGTYPE_EXACT"]
  val textpath_spacingtype_unknown: unit -> float [@@js.get "TEXTPATH_SPACINGTYPE_UNKNOWN"]
end

(** A <tspan> element. *)
module[@js.scope "SVGTSpanElement"] SVGTSpanElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGGraphicsElement | `SVGTSpanElement | `SVGTests | `SVGTextContentElement | `SVGTextPositioningElement | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGGraphicsElement | `SVGTSpanElement | `SVGTests | `SVGTextContentElement | `SVGTextPositioningElement | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGGraphicsElement | `SVGTSpanElement | `SVGTests | `SVGTextContentElement | `SVGTextPositioningElement | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGTSpanElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Corresponds to the <symbol> element. *)
module[@js.scope "SVGSymbolElement"] SVGSymbolElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFitToViewBox | `SVGSymbolElement | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFitToViewBox | `SVGSymbolElement | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFitToViewBox | `SVGSymbolElement | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGSymbolElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Corresponds to the <switch> element. *)
module[@js.scope "SVGSwitchElement"] SVGSwitchElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGGraphicsElement | `SVGSwitchElement | `SVGTests | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGGraphicsElement | `SVGSwitchElement | `SVGTests | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGGraphicsElement | `SVGSwitchElement | `SVGTests | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGSwitchElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Corresponds to the SVG <style> element. *)
module[@js.scope "SVGStyleElement"] SVGStyleElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `LinkStyle | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGStyleElement | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `LinkStyle | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGStyleElement | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `LinkStyle | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGStyleElement | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGStyleElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_disabled: 'tags this -> bool [@@js.get "disabled"]
  val set_disabled: 'tags this -> bool -> unit [@@js.set "disabled"]
  val get_media: 'tags this -> string [@@js.get "media"]
  val set_media: 'tags this -> string -> unit [@@js.set "media"]
  val get_title: 'tags this -> string [@@js.get "title"]
  val set_title: 'tags this -> string -> unit [@@js.set "title"]
  val get_type: 'tags this -> string [@@js.get "type"]
  val set_type: 'tags this -> string -> unit [@@js.set "type"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Corresponds to the <stop> element. *)
module[@js.scope "SVGStopElement"] SVGStopElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGStopElement | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGStopElement | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGStopElement | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGStopElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_offset: 'tags this -> SVGAnimatedNumber.t [@@js.get "offset"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module[@js.scope "SVGAnimationElement"] SVGAnimationElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGAnimationElement | `SVGElement | `SVGTests | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGAnimationElement | `SVGElement | `SVGTests | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGAnimationElement | `SVGElement | `SVGTests | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGAnimationElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_targetElement: 'tags this -> SVGElement.t option [@@js.get "targetElement"]
  val beginElement: 'tags this -> unit [@@js.call "beginElement"]
  val beginElementAt: 'tags this -> offset:float -> unit [@@js.call "beginElementAt"]
  val endElement: 'tags this -> unit [@@js.call "endElement"]
  val endElementAt: 'tags this -> offset:float -> unit [@@js.call "endElementAt"]
  val getCurrentTime: 'tags this -> float [@@js.call "getCurrentTime"]
  val getSimpleDuration: 'tags this -> float [@@js.call "getSimpleDuration"]
  val getStartTime: 'tags this -> float [@@js.call "getStartTime"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module[@js.scope "SVGSetElement"] SVGSetElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGAnimationElement | `SVGElement | `SVGSetElement | `SVGTests | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGAnimationElement | `SVGElement | `SVGSetElement | `SVGTests | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGAnimationElement | `SVGElement | `SVGSetElement | `SVGTests | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGSetElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** The SVGGradient interface is a base interface used by SVGLinearGradientElement and SVGRadialGradientElement. *)
module[@js.scope "SVGGradientElement"] SVGGradientElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGGradientElement | `SVGURIReference | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGGradientElement | `SVGURIReference | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGGradientElement | `SVGURIReference | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGGradientElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_gradientTransform: 'tags this -> SVGAnimatedTransformList.t [@@js.get "gradientTransform"]
  val get_gradientUnits: 'tags this -> SVGAnimatedEnumeration.t [@@js.get "gradientUnits"]
  val get_spreadMethod: 'tags this -> SVGAnimatedEnumeration.t [@@js.get "spreadMethod"]
  val get_SVG_SPREADMETHOD_PAD: 'tags this -> float [@@js.get "SVG_SPREADMETHOD_PAD"]
  val get_SVG_SPREADMETHOD_REFLECT: 'tags this -> float [@@js.get "SVG_SPREADMETHOD_REFLECT"]
  val get_SVG_SPREADMETHOD_REPEAT: 'tags this -> float [@@js.get "SVG_SPREADMETHOD_REPEAT"]
  val get_SVG_SPREADMETHOD_UNKNOWN: 'tags this -> float [@@js.get "SVG_SPREADMETHOD_UNKNOWN"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
  val svg_spreadmethod_pad: unit -> float [@@js.get "SVG_SPREADMETHOD_PAD"]
  val svg_spreadmethod_reflect: unit -> float [@@js.get "SVG_SPREADMETHOD_REFLECT"]
  val svg_spreadmethod_repeat: unit -> float [@@js.get "SVG_SPREADMETHOD_REPEAT"]
  val svg_spreadmethod_unknown: unit -> float [@@js.get "SVG_SPREADMETHOD_UNKNOWN"]
end

(** Corresponds to the <RadialGradient> element. *)
module[@js.scope "SVGRadialGradientElement"] SVGRadialGradientElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGGradientElement | `SVGRadialGradientElement | `SVGURIReference | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGGradientElement | `SVGRadialGradientElement | `SVGURIReference | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGGradientElement | `SVGRadialGradientElement | `SVGURIReference | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGRadialGradientElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_cx: 'tags this -> SVGAnimatedLength.t [@@js.get "cx"]
  val get_cy: 'tags this -> SVGAnimatedLength.t [@@js.get "cy"]
  val get_fr: 'tags this -> SVGAnimatedLength.t [@@js.get "fr"]
  val get_fx: 'tags this -> SVGAnimatedLength.t [@@js.get "fx"]
  val get_fy: 'tags this -> SVGAnimatedLength.t [@@js.get "fy"]
  val get_r: 'tags this -> SVGAnimatedLength.t [@@js.get "r"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Corresponds to the <pattern> element. *)
module[@js.scope "SVGPatternElement"] SVGPatternElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFitToViewBox | `SVGPatternElement | `SVGURIReference | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFitToViewBox | `SVGPatternElement | `SVGURIReference | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFitToViewBox | `SVGPatternElement | `SVGURIReference | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGPatternElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_height: 'tags this -> SVGAnimatedLength.t [@@js.get "height"]
  val get_patternContentUnits: 'tags this -> SVGAnimatedEnumeration.t [@@js.get "patternContentUnits"]
  val get_patternTransform: 'tags this -> SVGAnimatedTransformList.t [@@js.get "patternTransform"]
  val get_patternUnits: 'tags this -> SVGAnimatedEnumeration.t [@@js.get "patternUnits"]
  val get_width: 'tags this -> SVGAnimatedLength.t [@@js.get "width"]
  val get_x: 'tags this -> SVGAnimatedLength.t [@@js.get "x"]
  val get_y: 'tags this -> SVGAnimatedLength.t [@@js.get "y"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Corresponds to the <metadata> element. *)
module[@js.scope "SVGMetadataElement"] SVGMetadataElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGMetadataElement | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGMetadataElement | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGMetadataElement | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGMetadataElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Provides access to the properties of <mask> elements, as well as methods to manipulate them. *)
module[@js.scope "SVGMaskElement"] SVGMaskElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGMaskElement | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGMaskElement | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGMaskElement | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGMaskElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_height: 'tags this -> SVGAnimatedLength.t [@@js.get "height"]
  val get_maskContentUnits: 'tags this -> SVGAnimatedEnumeration.t [@@js.get "maskContentUnits"]
  val get_maskUnits: 'tags this -> SVGAnimatedEnumeration.t [@@js.get "maskUnits"]
  val get_width: 'tags this -> SVGAnimatedLength.t [@@js.get "width"]
  val get_x: 'tags this -> SVGAnimatedLength.t [@@js.get "x"]
  val get_y: 'tags this -> SVGAnimatedLength.t [@@js.get "y"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Used for attributes of basic type <angle> which can be animated. *)
module[@js.scope "SVGAnimatedAngle"] SVGAnimatedAngle : sig
  type t = [`SVGAnimatedAngle] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`SVGAnimatedAngle]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`SVGAnimatedAngle]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGAnimatedAngle ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_animVal: 'tags this -> SVGAngle.t [@@js.get "animVal"]
  val get_baseVal: 'tags this -> SVGAngle.t [@@js.get "baseVal"]
  val create: animVal:SVGAngle.t -> baseVal:SVGAngle.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end
module[@js.scope "SVGMarkerElement"] SVGMarkerElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFitToViewBox | `SVGMarkerElement | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFitToViewBox | `SVGMarkerElement | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFitToViewBox | `SVGMarkerElement | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGMarkerElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_markerHeight: 'tags this -> SVGAnimatedLength.t [@@js.get "markerHeight"]
  val get_markerUnits: 'tags this -> SVGAnimatedEnumeration.t [@@js.get "markerUnits"]
  val get_markerWidth: 'tags this -> SVGAnimatedLength.t [@@js.get "markerWidth"]
  val get_orientAngle: 'tags this -> SVGAnimatedAngle.t [@@js.get "orientAngle"]
  val get_orientType: 'tags this -> SVGAnimatedEnumeration.t [@@js.get "orientType"]
  val get_refX: 'tags this -> SVGAnimatedLength.t [@@js.get "refX"]
  val get_refY: 'tags this -> SVGAnimatedLength.t [@@js.get "refY"]
  val setOrientToAngle: 'tags this -> angle:SVGAngle.t -> unit [@@js.call "setOrientToAngle"]
  val setOrientToAuto: 'tags this -> unit [@@js.call "setOrientToAuto"]
  val get_SVG_MARKERUNITS_STROKEWIDTH: 'tags this -> float [@@js.get "SVG_MARKERUNITS_STROKEWIDTH"]
  val get_SVG_MARKERUNITS_UNKNOWN: 'tags this -> float [@@js.get "SVG_MARKERUNITS_UNKNOWN"]
  val get_SVG_MARKERUNITS_USERSPACEONUSE: 'tags this -> float [@@js.get "SVG_MARKERUNITS_USERSPACEONUSE"]
  val get_SVG_MARKER_ORIENT_ANGLE: 'tags this -> float [@@js.get "SVG_MARKER_ORIENT_ANGLE"]
  val get_SVG_MARKER_ORIENT_AUTO: 'tags this -> float [@@js.get "SVG_MARKER_ORIENT_AUTO"]
  val get_SVG_MARKER_ORIENT_UNKNOWN: 'tags this -> float [@@js.get "SVG_MARKER_ORIENT_UNKNOWN"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
  val svg_markerunits_strokewidth: unit -> float [@@js.get "SVG_MARKERUNITS_STROKEWIDTH"]
  val svg_markerunits_unknown: unit -> float [@@js.get "SVG_MARKERUNITS_UNKNOWN"]
  val svg_markerunits_userspaceonuse: unit -> float [@@js.get "SVG_MARKERUNITS_USERSPACEONUSE"]
  val svg_marker_orient_angle: unit -> float [@@js.get "SVG_MARKER_ORIENT_ANGLE"]
  val svg_marker_orient_auto: unit -> float [@@js.get "SVG_MARKER_ORIENT_AUTO"]
  val svg_marker_orient_unknown: unit -> float [@@js.get "SVG_MARKER_ORIENT_UNKNOWN"]
end
module[@js.scope "SVGMPathElement"] SVGMPathElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGMPathElement | `SVGURIReference | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGMPathElement | `SVGURIReference | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGMPathElement | `SVGURIReference | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGMPathElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Corresponds to the <linearGradient> element. *)
module[@js.scope "SVGLinearGradientElement"] SVGLinearGradientElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGGradientElement | `SVGLinearGradientElement | `SVGURIReference | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGGradientElement | `SVGLinearGradientElement | `SVGURIReference | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGGradientElement | `SVGLinearGradientElement | `SVGURIReference | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGLinearGradientElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_x1: 'tags this -> SVGAnimatedLength.t [@@js.get "x1"]
  val get_x2: 'tags this -> SVGAnimatedLength.t [@@js.get "x2"]
  val get_y1: 'tags this -> SVGAnimatedLength.t [@@js.get "y1"]
  val get_y2: 'tags this -> SVGAnimatedLength.t [@@js.get "y2"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Corresponds to the <g> element. *)
module[@js.scope "SVGGElement"] SVGGElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGGElement | `SVGGraphicsElement | `SVGTests | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGGElement | `SVGGraphicsElement | `SVGTests | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGGElement | `SVGGraphicsElement | `SVGTests | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGGElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Provides access to the properties of <foreignObject> elements, as well as methods to manipulate them. *)
module[@js.scope "SVGForeignObjectElement"] SVGForeignObjectElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGForeignObjectElement | `SVGGraphicsElement | `SVGTests | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGForeignObjectElement | `SVGGraphicsElement | `SVGTests | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGForeignObjectElement | `SVGGraphicsElement | `SVGTests | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGForeignObjectElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_height: 'tags this -> SVGAnimatedLength.t [@@js.get "height"]
  val get_width: 'tags this -> SVGAnimatedLength.t [@@js.get "width"]
  val get_x: 'tags this -> SVGAnimatedLength.t [@@js.get "x"]
  val get_y: 'tags this -> SVGAnimatedLength.t [@@js.get "y"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Provides access to the properties of <filter> elements, as well as methods to manipulate them. *)
module[@js.scope "SVGFilterElement"] SVGFilterElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFilterElement | `SVGURIReference | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFilterElement | `SVGURIReference | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFilterElement | `SVGURIReference | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGFilterElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_filterUnits: 'tags this -> SVGAnimatedEnumeration.t [@@js.get "filterUnits"]
  val get_height: 'tags this -> SVGAnimatedLength.t [@@js.get "height"]
  val get_primitiveUnits: 'tags this -> SVGAnimatedEnumeration.t [@@js.get "primitiveUnits"]
  val get_width: 'tags this -> SVGAnimatedLength.t [@@js.get "width"]
  val get_x: 'tags this -> SVGAnimatedLength.t [@@js.get "x"]
  val get_y: 'tags this -> SVGAnimatedLength.t [@@js.get "y"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Used for attributes of basic type <integer> which can be animated. *)
module[@js.scope "SVGAnimatedInteger"] SVGAnimatedInteger : sig
  type t = [`SVGAnimatedInteger] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`SVGAnimatedInteger]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`SVGAnimatedInteger]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGAnimatedInteger ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_animVal: 'tags this -> float [@@js.get "animVal"]
  val get_baseVal: 'tags this -> float [@@js.get "baseVal"]
  val set_baseVal: 'tags this -> float -> unit [@@js.set "baseVal"]
  val create: animVal:float -> baseVal:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end
module SVGFilterPrimitiveStandardAttributes : sig
  type t = [`SVGFilterPrimitiveStandardAttributes] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`SVGFilterPrimitiveStandardAttributes]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`SVGFilterPrimitiveStandardAttributes]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGFilterPrimitiveStandardAttributes ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_height: 'tags this -> SVGAnimatedLength.t [@@js.get "height"]
  val get_result: 'tags this -> SVGAnimatedString.t [@@js.get "result"]
  val get_width: 'tags this -> SVGAnimatedLength.t [@@js.get "width"]
  val get_x: 'tags this -> SVGAnimatedLength.t [@@js.get "x"]
  val get_y: 'tags this -> SVGAnimatedLength.t [@@js.get "y"]
  val create: height:SVGAnimatedLength.t -> result:SVGAnimatedString.t -> width:SVGAnimatedLength.t -> x:SVGAnimatedLength.t -> y:SVGAnimatedLength.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** Corresponds to the <feTurbulence> element. *)
module[@js.scope "SVGFETurbulenceElement"] SVGFETurbulenceElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFETurbulenceElement | `SVGFilterPrimitiveStandardAttributes | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFETurbulenceElement | `SVGFilterPrimitiveStandardAttributes | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFETurbulenceElement | `SVGFilterPrimitiveStandardAttributes | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGFETurbulenceElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_baseFrequencyX: 'tags this -> SVGAnimatedNumber.t [@@js.get "baseFrequencyX"]
  val get_baseFrequencyY: 'tags this -> SVGAnimatedNumber.t [@@js.get "baseFrequencyY"]
  val get_numOctaves: 'tags this -> SVGAnimatedInteger.t [@@js.get "numOctaves"]
  val get_seed: 'tags this -> SVGAnimatedNumber.t [@@js.get "seed"]
  val get_stitchTiles: 'tags this -> SVGAnimatedEnumeration.t [@@js.get "stitchTiles"]
  val get_type: 'tags this -> SVGAnimatedEnumeration.t [@@js.get "type"]
  val get_SVG_STITCHTYPE_NOSTITCH: 'tags this -> float [@@js.get "SVG_STITCHTYPE_NOSTITCH"]
  val get_SVG_STITCHTYPE_STITCH: 'tags this -> float [@@js.get "SVG_STITCHTYPE_STITCH"]
  val get_SVG_STITCHTYPE_UNKNOWN: 'tags this -> float [@@js.get "SVG_STITCHTYPE_UNKNOWN"]
  val get_SVG_TURBULENCE_TYPE_FRACTALNOISE: 'tags this -> float [@@js.get "SVG_TURBULENCE_TYPE_FRACTALNOISE"]
  val get_SVG_TURBULENCE_TYPE_TURBULENCE: 'tags this -> float [@@js.get "SVG_TURBULENCE_TYPE_TURBULENCE"]
  val get_SVG_TURBULENCE_TYPE_UNKNOWN: 'tags this -> float [@@js.get "SVG_TURBULENCE_TYPE_UNKNOWN"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
  val svg_stitchtype_nostitch: unit -> float [@@js.get "SVG_STITCHTYPE_NOSTITCH"]
  val svg_stitchtype_stitch: unit -> float [@@js.get "SVG_STITCHTYPE_STITCH"]
  val svg_stitchtype_unknown: unit -> float [@@js.get "SVG_STITCHTYPE_UNKNOWN"]
  val svg_turbulence_type_fractalnoise: unit -> float [@@js.get "SVG_TURBULENCE_TYPE_FRACTALNOISE"]
  val svg_turbulence_type_turbulence: unit -> float [@@js.get "SVG_TURBULENCE_TYPE_TURBULENCE"]
  val svg_turbulence_type_unknown: unit -> float [@@js.get "SVG_TURBULENCE_TYPE_UNKNOWN"]
end

(** Corresponds to the <feTile> element. *)
module[@js.scope "SVGFETileElement"] SVGFETileElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFETileElement | `SVGFilterPrimitiveStandardAttributes | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFETileElement | `SVGFilterPrimitiveStandardAttributes | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFETileElement | `SVGFilterPrimitiveStandardAttributes | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGFETileElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_in1: 'tags this -> SVGAnimatedString.t [@@js.get "in1"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Corresponds to the <feSpotLight> element. *)
module[@js.scope "SVGFESpotLightElement"] SVGFESpotLightElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFESpotLightElement | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFESpotLightElement | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFESpotLightElement | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGFESpotLightElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_limitingConeAngle: 'tags this -> SVGAnimatedNumber.t [@@js.get "limitingConeAngle"]
  val get_pointsAtX: 'tags this -> SVGAnimatedNumber.t [@@js.get "pointsAtX"]
  val get_pointsAtY: 'tags this -> SVGAnimatedNumber.t [@@js.get "pointsAtY"]
  val get_pointsAtZ: 'tags this -> SVGAnimatedNumber.t [@@js.get "pointsAtZ"]
  val get_specularExponent: 'tags this -> SVGAnimatedNumber.t [@@js.get "specularExponent"]
  val get_x: 'tags this -> SVGAnimatedNumber.t [@@js.get "x"]
  val get_y: 'tags this -> SVGAnimatedNumber.t [@@js.get "y"]
  val get_z: 'tags this -> SVGAnimatedNumber.t [@@js.get "z"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Corresponds to the <feSpecularLighting> element. *)
module[@js.scope "SVGFESpecularLightingElement"] SVGFESpecularLightingElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFESpecularLightingElement | `SVGFilterPrimitiveStandardAttributes | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFESpecularLightingElement | `SVGFilterPrimitiveStandardAttributes | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFESpecularLightingElement | `SVGFilterPrimitiveStandardAttributes | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGFESpecularLightingElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_in1: 'tags this -> SVGAnimatedString.t [@@js.get "in1"]
  val get_kernelUnitLengthX: 'tags this -> SVGAnimatedNumber.t [@@js.get "kernelUnitLengthX"]
  val get_kernelUnitLengthY: 'tags this -> SVGAnimatedNumber.t [@@js.get "kernelUnitLengthY"]
  val get_specularConstant: 'tags this -> SVGAnimatedNumber.t [@@js.get "specularConstant"]
  val get_specularExponent: 'tags this -> SVGAnimatedNumber.t [@@js.get "specularExponent"]
  val get_surfaceScale: 'tags this -> SVGAnimatedNumber.t [@@js.get "surfaceScale"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Corresponds to the <fePointLight> element. *)
module[@js.scope "SVGFEPointLightElement"] SVGFEPointLightElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFEPointLightElement | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFEPointLightElement | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFEPointLightElement | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGFEPointLightElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_x: 'tags this -> SVGAnimatedNumber.t [@@js.get "x"]
  val get_y: 'tags this -> SVGAnimatedNumber.t [@@js.get "y"]
  val get_z: 'tags this -> SVGAnimatedNumber.t [@@js.get "z"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Corresponds to the <feOffset> element. *)
module[@js.scope "SVGFEOffsetElement"] SVGFEOffsetElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFEOffsetElement | `SVGFilterPrimitiveStandardAttributes | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFEOffsetElement | `SVGFilterPrimitiveStandardAttributes | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFEOffsetElement | `SVGFilterPrimitiveStandardAttributes | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGFEOffsetElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_dx: 'tags this -> SVGAnimatedNumber.t [@@js.get "dx"]
  val get_dy: 'tags this -> SVGAnimatedNumber.t [@@js.get "dy"]
  val get_in1: 'tags this -> SVGAnimatedString.t [@@js.get "in1"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Corresponds to the <feMorphology> element. *)
module[@js.scope "SVGFEMorphologyElement"] SVGFEMorphologyElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFEMorphologyElement | `SVGFilterPrimitiveStandardAttributes | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFEMorphologyElement | `SVGFilterPrimitiveStandardAttributes | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFEMorphologyElement | `SVGFilterPrimitiveStandardAttributes | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGFEMorphologyElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_in1: 'tags this -> SVGAnimatedString.t [@@js.get "in1"]
  val get_operator: 'tags this -> SVGAnimatedEnumeration.t [@@js.get "operator"]
  val get_radiusX: 'tags this -> SVGAnimatedNumber.t [@@js.get "radiusX"]
  val get_radiusY: 'tags this -> SVGAnimatedNumber.t [@@js.get "radiusY"]
  val get_SVG_MORPHOLOGY_OPERATOR_DILATE: 'tags this -> float [@@js.get "SVG_MORPHOLOGY_OPERATOR_DILATE"]
  val get_SVG_MORPHOLOGY_OPERATOR_ERODE: 'tags this -> float [@@js.get "SVG_MORPHOLOGY_OPERATOR_ERODE"]
  val get_SVG_MORPHOLOGY_OPERATOR_UNKNOWN: 'tags this -> float [@@js.get "SVG_MORPHOLOGY_OPERATOR_UNKNOWN"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
  val svg_morphology_operator_dilate: unit -> float [@@js.get "SVG_MORPHOLOGY_OPERATOR_DILATE"]
  val svg_morphology_operator_erode: unit -> float [@@js.get "SVG_MORPHOLOGY_OPERATOR_ERODE"]
  val svg_morphology_operator_unknown: unit -> float [@@js.get "SVG_MORPHOLOGY_OPERATOR_UNKNOWN"]
end

(** Corresponds to the <feMergeNode> element. *)
module[@js.scope "SVGFEMergeNodeElement"] SVGFEMergeNodeElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFEMergeNodeElement | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFEMergeNodeElement | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFEMergeNodeElement | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGFEMergeNodeElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_in1: 'tags this -> SVGAnimatedString.t [@@js.get "in1"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Corresponds to the <feMerge> element. *)
module[@js.scope "SVGFEMergeElement"] SVGFEMergeElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFEMergeElement | `SVGFilterPrimitiveStandardAttributes | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFEMergeElement | `SVGFilterPrimitiveStandardAttributes | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFEMergeElement | `SVGFilterPrimitiveStandardAttributes | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGFEMergeElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Corresponds to the <feImage> element. *)
module[@js.scope "SVGFEImageElement"] SVGFEImageElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFEImageElement | `SVGFilterPrimitiveStandardAttributes | `SVGURIReference | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFEImageElement | `SVGFilterPrimitiveStandardAttributes | `SVGURIReference | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFEImageElement | `SVGFilterPrimitiveStandardAttributes | `SVGURIReference | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGFEImageElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_preserveAspectRatio: 'tags this -> SVGAnimatedPreserveAspectRatio.t [@@js.get "preserveAspectRatio"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Corresponds to the <feGaussianBlur> element. *)
module[@js.scope "SVGFEGaussianBlurElement"] SVGFEGaussianBlurElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFEGaussianBlurElement | `SVGFilterPrimitiveStandardAttributes | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFEGaussianBlurElement | `SVGFilterPrimitiveStandardAttributes | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFEGaussianBlurElement | `SVGFilterPrimitiveStandardAttributes | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGFEGaussianBlurElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_in1: 'tags this -> SVGAnimatedString.t [@@js.get "in1"]
  val get_stdDeviationX: 'tags this -> SVGAnimatedNumber.t [@@js.get "stdDeviationX"]
  val get_stdDeviationY: 'tags this -> SVGAnimatedNumber.t [@@js.get "stdDeviationY"]
  val setStdDeviation: 'tags this -> stdDeviationX:float -> stdDeviationY:float -> unit [@@js.call "setStdDeviation"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** A base interface used by the component transfer function interfaces. *)
module[@js.scope "SVGComponentTransferFunctionElement"] SVGComponentTransferFunctionElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGComponentTransferFunctionElement | `SVGElement | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGComponentTransferFunctionElement | `SVGElement | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGComponentTransferFunctionElement | `SVGElement | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGComponentTransferFunctionElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_amplitude: 'tags this -> SVGAnimatedNumber.t [@@js.get "amplitude"]
  val get_exponent: 'tags this -> SVGAnimatedNumber.t [@@js.get "exponent"]
  val get_intercept: 'tags this -> SVGAnimatedNumber.t [@@js.get "intercept"]
  val get_offset: 'tags this -> SVGAnimatedNumber.t [@@js.get "offset"]
  val get_slope: 'tags this -> SVGAnimatedNumber.t [@@js.get "slope"]
  val get_tableValues: 'tags this -> SVGAnimatedNumberList.t [@@js.get "tableValues"]
  val get_type: 'tags this -> SVGAnimatedEnumeration.t [@@js.get "type"]
  val get_SVG_FECOMPONENTTRANSFER_TYPE_DISCRETE: 'tags this -> float [@@js.get "SVG_FECOMPONENTTRANSFER_TYPE_DISCRETE"]
  val get_SVG_FECOMPONENTTRANSFER_TYPE_GAMMA: 'tags this -> float [@@js.get "SVG_FECOMPONENTTRANSFER_TYPE_GAMMA"]
  val get_SVG_FECOMPONENTTRANSFER_TYPE_IDENTITY: 'tags this -> float [@@js.get "SVG_FECOMPONENTTRANSFER_TYPE_IDENTITY"]
  val get_SVG_FECOMPONENTTRANSFER_TYPE_LINEAR: 'tags this -> float [@@js.get "SVG_FECOMPONENTTRANSFER_TYPE_LINEAR"]
  val get_SVG_FECOMPONENTTRANSFER_TYPE_TABLE: 'tags this -> float [@@js.get "SVG_FECOMPONENTTRANSFER_TYPE_TABLE"]
  val get_SVG_FECOMPONENTTRANSFER_TYPE_UNKNOWN: 'tags this -> float [@@js.get "SVG_FECOMPONENTTRANSFER_TYPE_UNKNOWN"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
  val svg_fecomponenttransfer_type_discrete: unit -> float [@@js.get "SVG_FECOMPONENTTRANSFER_TYPE_DISCRETE"]
  val svg_fecomponenttransfer_type_gamma: unit -> float [@@js.get "SVG_FECOMPONENTTRANSFER_TYPE_GAMMA"]
  val svg_fecomponenttransfer_type_identity: unit -> float [@@js.get "SVG_FECOMPONENTTRANSFER_TYPE_IDENTITY"]
  val svg_fecomponenttransfer_type_linear: unit -> float [@@js.get "SVG_FECOMPONENTTRANSFER_TYPE_LINEAR"]
  val svg_fecomponenttransfer_type_table: unit -> float [@@js.get "SVG_FECOMPONENTTRANSFER_TYPE_TABLE"]
  val svg_fecomponenttransfer_type_unknown: unit -> float [@@js.get "SVG_FECOMPONENTTRANSFER_TYPE_UNKNOWN"]
end

(** Corresponds to the <feFuncR> element. *)
module[@js.scope "SVGFEFuncRElement"] SVGFEFuncRElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGComponentTransferFunctionElement | `SVGElement | `SVGFEFuncRElement | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGComponentTransferFunctionElement | `SVGElement | `SVGFEFuncRElement | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGComponentTransferFunctionElement | `SVGElement | `SVGFEFuncRElement | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGFEFuncRElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Corresponds to the <feFuncG> element. *)
module[@js.scope "SVGFEFuncGElement"] SVGFEFuncGElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGComponentTransferFunctionElement | `SVGElement | `SVGFEFuncGElement | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGComponentTransferFunctionElement | `SVGElement | `SVGFEFuncGElement | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGComponentTransferFunctionElement | `SVGElement | `SVGFEFuncGElement | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGFEFuncGElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Corresponds to the <feFuncB> element. *)
module[@js.scope "SVGFEFuncBElement"] SVGFEFuncBElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGComponentTransferFunctionElement | `SVGElement | `SVGFEFuncBElement | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGComponentTransferFunctionElement | `SVGElement | `SVGFEFuncBElement | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGComponentTransferFunctionElement | `SVGElement | `SVGFEFuncBElement | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGFEFuncBElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Corresponds to the <feFuncA> element. *)
module[@js.scope "SVGFEFuncAElement"] SVGFEFuncAElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGComponentTransferFunctionElement | `SVGElement | `SVGFEFuncAElement | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGComponentTransferFunctionElement | `SVGElement | `SVGFEFuncAElement | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGComponentTransferFunctionElement | `SVGElement | `SVGFEFuncAElement | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGFEFuncAElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Corresponds to the <feFlood> element. *)
module[@js.scope "SVGFEFloodElement"] SVGFEFloodElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFEFloodElement | `SVGFilterPrimitiveStandardAttributes | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFEFloodElement | `SVGFilterPrimitiveStandardAttributes | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFEFloodElement | `SVGFilterPrimitiveStandardAttributes | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGFEFloodElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module[@js.scope "SVGFEDropShadowElement"] SVGFEDropShadowElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFEDropShadowElement | `SVGFilterPrimitiveStandardAttributes | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFEDropShadowElement | `SVGFilterPrimitiveStandardAttributes | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFEDropShadowElement | `SVGFilterPrimitiveStandardAttributes | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGFEDropShadowElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_dx: 'tags this -> SVGAnimatedNumber.t [@@js.get "dx"]
  val get_dy: 'tags this -> SVGAnimatedNumber.t [@@js.get "dy"]
  val get_in1: 'tags this -> SVGAnimatedString.t [@@js.get "in1"]
  val get_stdDeviationX: 'tags this -> SVGAnimatedNumber.t [@@js.get "stdDeviationX"]
  val get_stdDeviationY: 'tags this -> SVGAnimatedNumber.t [@@js.get "stdDeviationY"]
  val setStdDeviation: 'tags this -> stdDeviationX:float -> stdDeviationY:float -> unit [@@js.call "setStdDeviation"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Corresponds to the <feDistantLight> element. *)
module[@js.scope "SVGFEDistantLightElement"] SVGFEDistantLightElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFEDistantLightElement | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFEDistantLightElement | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFEDistantLightElement | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGFEDistantLightElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_azimuth: 'tags this -> SVGAnimatedNumber.t [@@js.get "azimuth"]
  val get_elevation: 'tags this -> SVGAnimatedNumber.t [@@js.get "elevation"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Corresponds to the <feDisplacementMap> element. *)
module[@js.scope "SVGFEDisplacementMapElement"] SVGFEDisplacementMapElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFEDisplacementMapElement | `SVGFilterPrimitiveStandardAttributes | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFEDisplacementMapElement | `SVGFilterPrimitiveStandardAttributes | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFEDisplacementMapElement | `SVGFilterPrimitiveStandardAttributes | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGFEDisplacementMapElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_in1: 'tags this -> SVGAnimatedString.t [@@js.get "in1"]
  val get_in2: 'tags this -> SVGAnimatedString.t [@@js.get "in2"]
  val get_scale: 'tags this -> SVGAnimatedNumber.t [@@js.get "scale"]
  val get_xChannelSelector: 'tags this -> SVGAnimatedEnumeration.t [@@js.get "xChannelSelector"]
  val get_yChannelSelector: 'tags this -> SVGAnimatedEnumeration.t [@@js.get "yChannelSelector"]
  val get_SVG_CHANNEL_A: 'tags this -> float [@@js.get "SVG_CHANNEL_A"]
  val get_SVG_CHANNEL_B: 'tags this -> float [@@js.get "SVG_CHANNEL_B"]
  val get_SVG_CHANNEL_G: 'tags this -> float [@@js.get "SVG_CHANNEL_G"]
  val get_SVG_CHANNEL_R: 'tags this -> float [@@js.get "SVG_CHANNEL_R"]
  val get_SVG_CHANNEL_UNKNOWN: 'tags this -> float [@@js.get "SVG_CHANNEL_UNKNOWN"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
  val svg_channel_a: unit -> float [@@js.get "SVG_CHANNEL_A"]
  val svg_channel_b: unit -> float [@@js.get "SVG_CHANNEL_B"]
  val svg_channel_g: unit -> float [@@js.get "SVG_CHANNEL_G"]
  val svg_channel_r: unit -> float [@@js.get "SVG_CHANNEL_R"]
  val svg_channel_unknown: unit -> float [@@js.get "SVG_CHANNEL_UNKNOWN"]
end

(** Corresponds to the <feDiffuseLighting> element. *)
module[@js.scope "SVGFEDiffuseLightingElement"] SVGFEDiffuseLightingElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFEDiffuseLightingElement | `SVGFilterPrimitiveStandardAttributes | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFEDiffuseLightingElement | `SVGFilterPrimitiveStandardAttributes | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFEDiffuseLightingElement | `SVGFilterPrimitiveStandardAttributes | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGFEDiffuseLightingElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_diffuseConstant: 'tags this -> SVGAnimatedNumber.t [@@js.get "diffuseConstant"]
  val get_in1: 'tags this -> SVGAnimatedString.t [@@js.get "in1"]
  val get_kernelUnitLengthX: 'tags this -> SVGAnimatedNumber.t [@@js.get "kernelUnitLengthX"]
  val get_kernelUnitLengthY: 'tags this -> SVGAnimatedNumber.t [@@js.get "kernelUnitLengthY"]
  val get_surfaceScale: 'tags this -> SVGAnimatedNumber.t [@@js.get "surfaceScale"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Used for attributes of type boolean which can be animated. *)
module[@js.scope "SVGAnimatedBoolean"] SVGAnimatedBoolean : sig
  type t = [`SVGAnimatedBoolean] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`SVGAnimatedBoolean]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`SVGAnimatedBoolean]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGAnimatedBoolean ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_animVal: 'tags this -> bool [@@js.get "animVal"]
  val get_baseVal: 'tags this -> bool [@@js.get "baseVal"]
  val set_baseVal: 'tags this -> bool -> unit [@@js.set "baseVal"]
  val create: animVal:bool -> baseVal:bool -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end

(** Corresponds to the <feConvolveMatrix> element. *)
module[@js.scope "SVGFEConvolveMatrixElement"] SVGFEConvolveMatrixElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFEConvolveMatrixElement | `SVGFilterPrimitiveStandardAttributes | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFEConvolveMatrixElement | `SVGFilterPrimitiveStandardAttributes | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFEConvolveMatrixElement | `SVGFilterPrimitiveStandardAttributes | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGFEConvolveMatrixElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_bias: 'tags this -> SVGAnimatedNumber.t [@@js.get "bias"]
  val get_divisor: 'tags this -> SVGAnimatedNumber.t [@@js.get "divisor"]
  val get_edgeMode: 'tags this -> SVGAnimatedEnumeration.t [@@js.get "edgeMode"]
  val get_in1: 'tags this -> SVGAnimatedString.t [@@js.get "in1"]
  val get_kernelMatrix: 'tags this -> SVGAnimatedNumberList.t [@@js.get "kernelMatrix"]
  val get_kernelUnitLengthX: 'tags this -> SVGAnimatedNumber.t [@@js.get "kernelUnitLengthX"]
  val get_kernelUnitLengthY: 'tags this -> SVGAnimatedNumber.t [@@js.get "kernelUnitLengthY"]
  val get_orderX: 'tags this -> SVGAnimatedInteger.t [@@js.get "orderX"]
  val get_orderY: 'tags this -> SVGAnimatedInteger.t [@@js.get "orderY"]
  val get_preserveAlpha: 'tags this -> SVGAnimatedBoolean.t [@@js.get "preserveAlpha"]
  val get_targetX: 'tags this -> SVGAnimatedInteger.t [@@js.get "targetX"]
  val get_targetY: 'tags this -> SVGAnimatedInteger.t [@@js.get "targetY"]
  val get_SVG_EDGEMODE_DUPLICATE: 'tags this -> float [@@js.get "SVG_EDGEMODE_DUPLICATE"]
  val get_SVG_EDGEMODE_NONE: 'tags this -> float [@@js.get "SVG_EDGEMODE_NONE"]
  val get_SVG_EDGEMODE_UNKNOWN: 'tags this -> float [@@js.get "SVG_EDGEMODE_UNKNOWN"]
  val get_SVG_EDGEMODE_WRAP: 'tags this -> float [@@js.get "SVG_EDGEMODE_WRAP"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
  val svg_edgemode_duplicate: unit -> float [@@js.get "SVG_EDGEMODE_DUPLICATE"]
  val svg_edgemode_none: unit -> float [@@js.get "SVG_EDGEMODE_NONE"]
  val svg_edgemode_unknown: unit -> float [@@js.get "SVG_EDGEMODE_UNKNOWN"]
  val svg_edgemode_wrap: unit -> float [@@js.get "SVG_EDGEMODE_WRAP"]
end

(** Corresponds to the <feComposite> element. *)
module[@js.scope "SVGFECompositeElement"] SVGFECompositeElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFECompositeElement | `SVGFilterPrimitiveStandardAttributes | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFECompositeElement | `SVGFilterPrimitiveStandardAttributes | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFECompositeElement | `SVGFilterPrimitiveStandardAttributes | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGFECompositeElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_in1: 'tags this -> SVGAnimatedString.t [@@js.get "in1"]
  val get_in2: 'tags this -> SVGAnimatedString.t [@@js.get "in2"]
  val get_k1: 'tags this -> SVGAnimatedNumber.t [@@js.get "k1"]
  val get_k2: 'tags this -> SVGAnimatedNumber.t [@@js.get "k2"]
  val get_k3: 'tags this -> SVGAnimatedNumber.t [@@js.get "k3"]
  val get_k4: 'tags this -> SVGAnimatedNumber.t [@@js.get "k4"]
  val get_operator: 'tags this -> SVGAnimatedEnumeration.t [@@js.get "operator"]
  val get_SVG_FECOMPOSITE_OPERATOR_ARITHMETIC: 'tags this -> float [@@js.get "SVG_FECOMPOSITE_OPERATOR_ARITHMETIC"]
  val get_SVG_FECOMPOSITE_OPERATOR_ATOP: 'tags this -> float [@@js.get "SVG_FECOMPOSITE_OPERATOR_ATOP"]
  val get_SVG_FECOMPOSITE_OPERATOR_IN: 'tags this -> float [@@js.get "SVG_FECOMPOSITE_OPERATOR_IN"]
  val get_SVG_FECOMPOSITE_OPERATOR_OUT: 'tags this -> float [@@js.get "SVG_FECOMPOSITE_OPERATOR_OUT"]
  val get_SVG_FECOMPOSITE_OPERATOR_OVER: 'tags this -> float [@@js.get "SVG_FECOMPOSITE_OPERATOR_OVER"]
  val get_SVG_FECOMPOSITE_OPERATOR_UNKNOWN: 'tags this -> float [@@js.get "SVG_FECOMPOSITE_OPERATOR_UNKNOWN"]
  val get_SVG_FECOMPOSITE_OPERATOR_XOR: 'tags this -> float [@@js.get "SVG_FECOMPOSITE_OPERATOR_XOR"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
  val svg_fecomposite_operator_arithmetic: unit -> float [@@js.get "SVG_FECOMPOSITE_OPERATOR_ARITHMETIC"]
  val svg_fecomposite_operator_atop: unit -> float [@@js.get "SVG_FECOMPOSITE_OPERATOR_ATOP"]
  val svg_fecomposite_operator_in: unit -> float [@@js.get "SVG_FECOMPOSITE_OPERATOR_IN"]
  val svg_fecomposite_operator_out: unit -> float [@@js.get "SVG_FECOMPOSITE_OPERATOR_OUT"]
  val svg_fecomposite_operator_over: unit -> float [@@js.get "SVG_FECOMPOSITE_OPERATOR_OVER"]
  val svg_fecomposite_operator_unknown: unit -> float [@@js.get "SVG_FECOMPOSITE_OPERATOR_UNKNOWN"]
  val svg_fecomposite_operator_xor: unit -> float [@@js.get "SVG_FECOMPOSITE_OPERATOR_XOR"]
end

(** Corresponds to the <feComponentTransfer> element. *)
module[@js.scope "SVGFEComponentTransferElement"] SVGFEComponentTransferElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFEComponentTransferElement | `SVGFilterPrimitiveStandardAttributes | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFEComponentTransferElement | `SVGFilterPrimitiveStandardAttributes | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFEComponentTransferElement | `SVGFilterPrimitiveStandardAttributes | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGFEComponentTransferElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_in1: 'tags this -> SVGAnimatedString.t [@@js.get "in1"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Corresponds to the <feColorMatrix> element. *)
module[@js.scope "SVGFEColorMatrixElement"] SVGFEColorMatrixElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFEColorMatrixElement | `SVGFilterPrimitiveStandardAttributes | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFEColorMatrixElement | `SVGFilterPrimitiveStandardAttributes | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFEColorMatrixElement | `SVGFilterPrimitiveStandardAttributes | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGFEColorMatrixElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_in1: 'tags this -> SVGAnimatedString.t [@@js.get "in1"]
  val get_type: 'tags this -> SVGAnimatedEnumeration.t [@@js.get "type"]
  val get_values: 'tags this -> SVGAnimatedNumberList.t [@@js.get "values"]
  val get_SVG_FECOLORMATRIX_TYPE_HUEROTATE: 'tags this -> float [@@js.get "SVG_FECOLORMATRIX_TYPE_HUEROTATE"]
  val get_SVG_FECOLORMATRIX_TYPE_LUMINANCETOALPHA: 'tags this -> float [@@js.get "SVG_FECOLORMATRIX_TYPE_LUMINANCETOALPHA"]
  val get_SVG_FECOLORMATRIX_TYPE_MATRIX: 'tags this -> float [@@js.get "SVG_FECOLORMATRIX_TYPE_MATRIX"]
  val get_SVG_FECOLORMATRIX_TYPE_SATURATE: 'tags this -> float [@@js.get "SVG_FECOLORMATRIX_TYPE_SATURATE"]
  val get_SVG_FECOLORMATRIX_TYPE_UNKNOWN: 'tags this -> float [@@js.get "SVG_FECOLORMATRIX_TYPE_UNKNOWN"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
  val svg_fecolormatrix_type_huerotate: unit -> float [@@js.get "SVG_FECOLORMATRIX_TYPE_HUEROTATE"]
  val svg_fecolormatrix_type_luminancetoalpha: unit -> float [@@js.get "SVG_FECOLORMATRIX_TYPE_LUMINANCETOALPHA"]
  val svg_fecolormatrix_type_matrix: unit -> float [@@js.get "SVG_FECOLORMATRIX_TYPE_MATRIX"]
  val svg_fecolormatrix_type_saturate: unit -> float [@@js.get "SVG_FECOLORMATRIX_TYPE_SATURATE"]
  val svg_fecolormatrix_type_unknown: unit -> float [@@js.get "SVG_FECOLORMATRIX_TYPE_UNKNOWN"]
end

(** Corresponds to the <feBlend> element. *)
module[@js.scope "SVGFEBlendElement"] SVGFEBlendElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFEBlendElement | `SVGFilterPrimitiveStandardAttributes | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFEBlendElement | `SVGFilterPrimitiveStandardAttributes | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGElement | `SVGFEBlendElement | `SVGFilterPrimitiveStandardAttributes | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGFEBlendElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_in1: 'tags this -> SVGAnimatedString.t [@@js.get "in1"]
  val get_in2: 'tags this -> SVGAnimatedString.t [@@js.get "in2"]
  val get_mode: 'tags this -> SVGAnimatedEnumeration.t [@@js.get "mode"]
  val get_SVG_FEBLEND_MODE_COLOR: 'tags this -> float [@@js.get "SVG_FEBLEND_MODE_COLOR"]
  val get_SVG_FEBLEND_MODE_COLOR_BURN: 'tags this -> float [@@js.get "SVG_FEBLEND_MODE_COLOR_BURN"]
  val get_SVG_FEBLEND_MODE_COLOR_DODGE: 'tags this -> float [@@js.get "SVG_FEBLEND_MODE_COLOR_DODGE"]
  val get_SVG_FEBLEND_MODE_DARKEN: 'tags this -> float [@@js.get "SVG_FEBLEND_MODE_DARKEN"]
  val get_SVG_FEBLEND_MODE_DIFFERENCE: 'tags this -> float [@@js.get "SVG_FEBLEND_MODE_DIFFERENCE"]
  val get_SVG_FEBLEND_MODE_EXCLUSION: 'tags this -> float [@@js.get "SVG_FEBLEND_MODE_EXCLUSION"]
  val get_SVG_FEBLEND_MODE_HARD_LIGHT: 'tags this -> float [@@js.get "SVG_FEBLEND_MODE_HARD_LIGHT"]
  val get_SVG_FEBLEND_MODE_HUE: 'tags this -> float [@@js.get "SVG_FEBLEND_MODE_HUE"]
  val get_SVG_FEBLEND_MODE_LIGHTEN: 'tags this -> float [@@js.get "SVG_FEBLEND_MODE_LIGHTEN"]
  val get_SVG_FEBLEND_MODE_LUMINOSITY: 'tags this -> float [@@js.get "SVG_FEBLEND_MODE_LUMINOSITY"]
  val get_SVG_FEBLEND_MODE_MULTIPLY: 'tags this -> float [@@js.get "SVG_FEBLEND_MODE_MULTIPLY"]
  val get_SVG_FEBLEND_MODE_NORMAL: 'tags this -> float [@@js.get "SVG_FEBLEND_MODE_NORMAL"]
  val get_SVG_FEBLEND_MODE_OVERLAY: 'tags this -> float [@@js.get "SVG_FEBLEND_MODE_OVERLAY"]
  val get_SVG_FEBLEND_MODE_SATURATION: 'tags this -> float [@@js.get "SVG_FEBLEND_MODE_SATURATION"]
  val get_SVG_FEBLEND_MODE_SCREEN: 'tags this -> float [@@js.get "SVG_FEBLEND_MODE_SCREEN"]
  val get_SVG_FEBLEND_MODE_SOFT_LIGHT: 'tags this -> float [@@js.get "SVG_FEBLEND_MODE_SOFT_LIGHT"]
  val get_SVG_FEBLEND_MODE_UNKNOWN: 'tags this -> float [@@js.get "SVG_FEBLEND_MODE_UNKNOWN"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
  val svg_feblend_mode_color: unit -> float [@@js.get "SVG_FEBLEND_MODE_COLOR"]
  val svg_feblend_mode_color_burn: unit -> float [@@js.get "SVG_FEBLEND_MODE_COLOR_BURN"]
  val svg_feblend_mode_color_dodge: unit -> float [@@js.get "SVG_FEBLEND_MODE_COLOR_DODGE"]
  val svg_feblend_mode_darken: unit -> float [@@js.get "SVG_FEBLEND_MODE_DARKEN"]
  val svg_feblend_mode_difference: unit -> float [@@js.get "SVG_FEBLEND_MODE_DIFFERENCE"]
  val svg_feblend_mode_exclusion: unit -> float [@@js.get "SVG_FEBLEND_MODE_EXCLUSION"]
  val svg_feblend_mode_hard_light: unit -> float [@@js.get "SVG_FEBLEND_MODE_HARD_LIGHT"]
  val svg_feblend_mode_hue: unit -> float [@@js.get "SVG_FEBLEND_MODE_HUE"]
  val svg_feblend_mode_lighten: unit -> float [@@js.get "SVG_FEBLEND_MODE_LIGHTEN"]
  val svg_feblend_mode_luminosity: unit -> float [@@js.get "SVG_FEBLEND_MODE_LUMINOSITY"]
  val svg_feblend_mode_multiply: unit -> float [@@js.get "SVG_FEBLEND_MODE_MULTIPLY"]
  val svg_feblend_mode_normal: unit -> float [@@js.get "SVG_FEBLEND_MODE_NORMAL"]
  val svg_feblend_mode_overlay: unit -> float [@@js.get "SVG_FEBLEND_MODE_OVERLAY"]
  val svg_feblend_mode_saturation: unit -> float [@@js.get "SVG_FEBLEND_MODE_SATURATION"]
  val svg_feblend_mode_screen: unit -> float [@@js.get "SVG_FEBLEND_MODE_SCREEN"]
  val svg_feblend_mode_soft_light: unit -> float [@@js.get "SVG_FEBLEND_MODE_SOFT_LIGHT"]
  val svg_feblend_mode_unknown: unit -> float [@@js.get "SVG_FEBLEND_MODE_UNKNOWN"]
end

(** Corresponds to the <desc> element. *)
module[@js.scope "SVGDescElement"] SVGDescElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGDescElement | `SVGElement | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGDescElement | `SVGElement | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGDescElement | `SVGElement | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGDescElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Corresponds to the <defs> element. *)
module[@js.scope "SVGDefsElement"] SVGDefsElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGDefsElement | `SVGElement | `SVGGraphicsElement | `SVGTests | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGDefsElement | `SVGElement | `SVGGraphicsElement | `SVGTests | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGDefsElement | `SVGElement | `SVGGraphicsElement | `SVGTests | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGDefsElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Provides access to the properties of <clipPath> elements, as well as methods to manipulate them. *)
module[@js.scope "SVGClipPathElement"] SVGClipPathElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGClipPathElement | `SVGElement | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGClipPathElement | `SVGElement | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGClipPathElement | `SVGElement | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGClipPathElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_clipPathUnits: 'tags this -> SVGAnimatedEnumeration.t [@@js.get "clipPathUnits"]
  val get_transform: 'tags this -> SVGAnimatedTransformList.t [@@js.get "transform"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module[@js.scope "SVGAnimateTransformElement"] SVGAnimateTransformElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGAnimateTransformElement | `SVGAnimationElement | `SVGElement | `SVGTests | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGAnimateTransformElement | `SVGAnimationElement | `SVGElement | `SVGTests | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGAnimateTransformElement | `SVGAnimationElement | `SVGElement | `SVGTests | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGAnimateTransformElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module[@js.scope "SVGAnimateMotionElement"] SVGAnimateMotionElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGAnimateMotionElement | `SVGAnimationElement | `SVGElement | `SVGTests | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGAnimateMotionElement | `SVGAnimationElement | `SVGElement | `SVGTests | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGAnimateMotionElement | `SVGAnimationElement | `SVGElement | `SVGTests | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGAnimateMotionElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module[@js.scope "SVGAnimateElement"] SVGAnimateElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGAnimateElement | `SVGAnimationElement | `SVGElement | `SVGTests | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGAnimateElement | `SVGAnimationElement | `SVGElement | `SVGTests | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGAnimateElement | `SVGAnimationElement | `SVGElement | `SVGTests | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGAnimateElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Provides access to the properties of <a> element, as well as methods to manipulate them. *)
module[@js.scope "SVGAElement"] SVGAElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGAElement | `SVGElement | `SVGGraphicsElement | `SVGTests | `SVGURIReference | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGAElement | `SVGElement | `SVGGraphicsElement | `SVGTests | `SVGURIReference | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `EventTarget | `GlobalEventHandlers | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `SVGAElement | `SVGElement | `SVGGraphicsElement | `SVGTests | `SVGURIReference | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGAElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_rel: 'tags this -> string [@@js.get "rel"]
  val set_rel: 'tags this -> string -> unit [@@js.set "rel"]
  val get_relList: 'tags this -> DOMTokenList.t [@@js.get "relList"]
  val get_target: 'tags this -> SVGAnimatedString.t [@@js.get "target"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'SVGElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module SVGElementTagNameMap : sig
  type t = [`SVGElementTagNameMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`SVGElementTagNameMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`SVGElementTagNameMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `SVGElementTagNameMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_a: 'tags this -> SVGAElement.t [@@js.get "a"]
  val set_a: 'tags this -> SVGAElement.t -> unit [@@js.set "a"]
  val get_animate: 'tags this -> SVGAnimateElement.t [@@js.get "animate"]
  val set_animate: 'tags this -> SVGAnimateElement.t -> unit [@@js.set "animate"]
  val get_animateMotion: 'tags this -> SVGAnimateMotionElement.t [@@js.get "animateMotion"]
  val set_animateMotion: 'tags this -> SVGAnimateMotionElement.t -> unit [@@js.set "animateMotion"]
  val get_animateTransform: 'tags this -> SVGAnimateTransformElement.t [@@js.get "animateTransform"]
  val set_animateTransform: 'tags this -> SVGAnimateTransformElement.t -> unit [@@js.set "animateTransform"]
  val get_circle: 'tags this -> SVGCircleElement.t [@@js.get "circle"]
  val set_circle: 'tags this -> SVGCircleElement.t -> unit [@@js.set "circle"]
  val get_clipPath: 'tags this -> SVGClipPathElement.t [@@js.get "clipPath"]
  val set_clipPath: 'tags this -> SVGClipPathElement.t -> unit [@@js.set "clipPath"]
  val get_defs: 'tags this -> SVGDefsElement.t [@@js.get "defs"]
  val set_defs: 'tags this -> SVGDefsElement.t -> unit [@@js.set "defs"]
  val get_desc: 'tags this -> SVGDescElement.t [@@js.get "desc"]
  val set_desc: 'tags this -> SVGDescElement.t -> unit [@@js.set "desc"]
  val get_ellipse: 'tags this -> SVGEllipseElement.t [@@js.get "ellipse"]
  val set_ellipse: 'tags this -> SVGEllipseElement.t -> unit [@@js.set "ellipse"]
  val get_feBlend: 'tags this -> SVGFEBlendElement.t [@@js.get "feBlend"]
  val set_feBlend: 'tags this -> SVGFEBlendElement.t -> unit [@@js.set "feBlend"]
  val get_feColorMatrix: 'tags this -> SVGFEColorMatrixElement.t [@@js.get "feColorMatrix"]
  val set_feColorMatrix: 'tags this -> SVGFEColorMatrixElement.t -> unit [@@js.set "feColorMatrix"]
  val get_feComponentTransfer: 'tags this -> SVGFEComponentTransferElement.t [@@js.get "feComponentTransfer"]
  val set_feComponentTransfer: 'tags this -> SVGFEComponentTransferElement.t -> unit [@@js.set "feComponentTransfer"]
  val get_feComposite: 'tags this -> SVGFECompositeElement.t [@@js.get "feComposite"]
  val set_feComposite: 'tags this -> SVGFECompositeElement.t -> unit [@@js.set "feComposite"]
  val get_feConvolveMatrix: 'tags this -> SVGFEConvolveMatrixElement.t [@@js.get "feConvolveMatrix"]
  val set_feConvolveMatrix: 'tags this -> SVGFEConvolveMatrixElement.t -> unit [@@js.set "feConvolveMatrix"]
  val get_feDiffuseLighting: 'tags this -> SVGFEDiffuseLightingElement.t [@@js.get "feDiffuseLighting"]
  val set_feDiffuseLighting: 'tags this -> SVGFEDiffuseLightingElement.t -> unit [@@js.set "feDiffuseLighting"]
  val get_feDisplacementMap: 'tags this -> SVGFEDisplacementMapElement.t [@@js.get "feDisplacementMap"]
  val set_feDisplacementMap: 'tags this -> SVGFEDisplacementMapElement.t -> unit [@@js.set "feDisplacementMap"]
  val get_feDistantLight: 'tags this -> SVGFEDistantLightElement.t [@@js.get "feDistantLight"]
  val set_feDistantLight: 'tags this -> SVGFEDistantLightElement.t -> unit [@@js.set "feDistantLight"]
  val get_feDropShadow: 'tags this -> SVGFEDropShadowElement.t [@@js.get "feDropShadow"]
  val set_feDropShadow: 'tags this -> SVGFEDropShadowElement.t -> unit [@@js.set "feDropShadow"]
  val get_feFlood: 'tags this -> SVGFEFloodElement.t [@@js.get "feFlood"]
  val set_feFlood: 'tags this -> SVGFEFloodElement.t -> unit [@@js.set "feFlood"]
  val get_feFuncA: 'tags this -> SVGFEFuncAElement.t [@@js.get "feFuncA"]
  val set_feFuncA: 'tags this -> SVGFEFuncAElement.t -> unit [@@js.set "feFuncA"]
  val get_feFuncB: 'tags this -> SVGFEFuncBElement.t [@@js.get "feFuncB"]
  val set_feFuncB: 'tags this -> SVGFEFuncBElement.t -> unit [@@js.set "feFuncB"]
  val get_feFuncG: 'tags this -> SVGFEFuncGElement.t [@@js.get "feFuncG"]
  val set_feFuncG: 'tags this -> SVGFEFuncGElement.t -> unit [@@js.set "feFuncG"]
  val get_feFuncR: 'tags this -> SVGFEFuncRElement.t [@@js.get "feFuncR"]
  val set_feFuncR: 'tags this -> SVGFEFuncRElement.t -> unit [@@js.set "feFuncR"]
  val get_feGaussianBlur: 'tags this -> SVGFEGaussianBlurElement.t [@@js.get "feGaussianBlur"]
  val set_feGaussianBlur: 'tags this -> SVGFEGaussianBlurElement.t -> unit [@@js.set "feGaussianBlur"]
  val get_feImage: 'tags this -> SVGFEImageElement.t [@@js.get "feImage"]
  val set_feImage: 'tags this -> SVGFEImageElement.t -> unit [@@js.set "feImage"]
  val get_feMerge: 'tags this -> SVGFEMergeElement.t [@@js.get "feMerge"]
  val set_feMerge: 'tags this -> SVGFEMergeElement.t -> unit [@@js.set "feMerge"]
  val get_feMergeNode: 'tags this -> SVGFEMergeNodeElement.t [@@js.get "feMergeNode"]
  val set_feMergeNode: 'tags this -> SVGFEMergeNodeElement.t -> unit [@@js.set "feMergeNode"]
  val get_feMorphology: 'tags this -> SVGFEMorphologyElement.t [@@js.get "feMorphology"]
  val set_feMorphology: 'tags this -> SVGFEMorphologyElement.t -> unit [@@js.set "feMorphology"]
  val get_feOffset: 'tags this -> SVGFEOffsetElement.t [@@js.get "feOffset"]
  val set_feOffset: 'tags this -> SVGFEOffsetElement.t -> unit [@@js.set "feOffset"]
  val get_fePointLight: 'tags this -> SVGFEPointLightElement.t [@@js.get "fePointLight"]
  val set_fePointLight: 'tags this -> SVGFEPointLightElement.t -> unit [@@js.set "fePointLight"]
  val get_feSpecularLighting: 'tags this -> SVGFESpecularLightingElement.t [@@js.get "feSpecularLighting"]
  val set_feSpecularLighting: 'tags this -> SVGFESpecularLightingElement.t -> unit [@@js.set "feSpecularLighting"]
  val get_feSpotLight: 'tags this -> SVGFESpotLightElement.t [@@js.get "feSpotLight"]
  val set_feSpotLight: 'tags this -> SVGFESpotLightElement.t -> unit [@@js.set "feSpotLight"]
  val get_feTile: 'tags this -> SVGFETileElement.t [@@js.get "feTile"]
  val set_feTile: 'tags this -> SVGFETileElement.t -> unit [@@js.set "feTile"]
  val get_feTurbulence: 'tags this -> SVGFETurbulenceElement.t [@@js.get "feTurbulence"]
  val set_feTurbulence: 'tags this -> SVGFETurbulenceElement.t -> unit [@@js.set "feTurbulence"]
  val get_filter: 'tags this -> SVGFilterElement.t [@@js.get "filter"]
  val set_filter: 'tags this -> SVGFilterElement.t -> unit [@@js.set "filter"]
  val get_foreignObject: 'tags this -> SVGForeignObjectElement.t [@@js.get "foreignObject"]
  val set_foreignObject: 'tags this -> SVGForeignObjectElement.t -> unit [@@js.set "foreignObject"]
  val get_g: 'tags this -> SVGGElement.t [@@js.get "g"]
  val set_g: 'tags this -> SVGGElement.t -> unit [@@js.set "g"]
  val get_image: 'tags this -> SVGImageElement.t [@@js.get "image"]
  val set_image: 'tags this -> SVGImageElement.t -> unit [@@js.set "image"]
  val get_line: 'tags this -> SVGLineElement.t [@@js.get "line"]
  val set_line: 'tags this -> SVGLineElement.t -> unit [@@js.set "line"]
  val get_linearGradient: 'tags this -> SVGLinearGradientElement.t [@@js.get "linearGradient"]
  val set_linearGradient: 'tags this -> SVGLinearGradientElement.t -> unit [@@js.set "linearGradient"]
  val get_marker: 'tags this -> SVGMarkerElement.t [@@js.get "marker"]
  val set_marker: 'tags this -> SVGMarkerElement.t -> unit [@@js.set "marker"]
  val get_mask: 'tags this -> SVGMaskElement.t [@@js.get "mask"]
  val set_mask: 'tags this -> SVGMaskElement.t -> unit [@@js.set "mask"]
  val get_metadata: 'tags this -> SVGMetadataElement.t [@@js.get "metadata"]
  val set_metadata: 'tags this -> SVGMetadataElement.t -> unit [@@js.set "metadata"]
  val get_mpath: 'tags this -> SVGMPathElement.t [@@js.get "mpath"]
  val set_mpath: 'tags this -> SVGMPathElement.t -> unit [@@js.set "mpath"]
  val get_path: 'tags this -> SVGPathElement.t [@@js.get "path"]
  val set_path: 'tags this -> SVGPathElement.t -> unit [@@js.set "path"]
  val get_pattern: 'tags this -> SVGPatternElement.t [@@js.get "pattern"]
  val set_pattern: 'tags this -> SVGPatternElement.t -> unit [@@js.set "pattern"]
  val get_polygon: 'tags this -> SVGPolygonElement.t [@@js.get "polygon"]
  val set_polygon: 'tags this -> SVGPolygonElement.t -> unit [@@js.set "polygon"]
  val get_polyline: 'tags this -> SVGPolylineElement.t [@@js.get "polyline"]
  val set_polyline: 'tags this -> SVGPolylineElement.t -> unit [@@js.set "polyline"]
  val get_radialGradient: 'tags this -> SVGRadialGradientElement.t [@@js.get "radialGradient"]
  val set_radialGradient: 'tags this -> SVGRadialGradientElement.t -> unit [@@js.set "radialGradient"]
  val get_rect: 'tags this -> SVGRectElement.t [@@js.get "rect"]
  val set_rect: 'tags this -> SVGRectElement.t -> unit [@@js.set "rect"]
  val get_script: 'tags this -> SVGScriptElement.t [@@js.get "script"]
  val set_script: 'tags this -> SVGScriptElement.t -> unit [@@js.set "script"]
  val get_set: 'tags this -> SVGSetElement.t [@@js.get "set"]
  val set_set: 'tags this -> SVGSetElement.t -> unit [@@js.set "set"]
  val get_stop: 'tags this -> SVGStopElement.t [@@js.get "stop"]
  val set_stop: 'tags this -> SVGStopElement.t -> unit [@@js.set "stop"]
  val get_style: 'tags this -> SVGStyleElement.t [@@js.get "style"]
  val set_style: 'tags this -> SVGStyleElement.t -> unit [@@js.set "style"]
  val get_svg: 'tags this -> SVGSVGElement.t [@@js.get "svg"]
  val set_svg: 'tags this -> SVGSVGElement.t -> unit [@@js.set "svg"]
  val get_switch: 'tags this -> SVGSwitchElement.t [@@js.get "switch"]
  val set_switch: 'tags this -> SVGSwitchElement.t -> unit [@@js.set "switch"]
  val get_symbol: 'tags this -> SVGSymbolElement.t [@@js.get "symbol"]
  val set_symbol: 'tags this -> SVGSymbolElement.t -> unit [@@js.set "symbol"]
  val get_text: 'tags this -> SVGTextElement.t [@@js.get "text"]
  val set_text: 'tags this -> SVGTextElement.t -> unit [@@js.set "text"]
  val get_textPath: 'tags this -> SVGTextPathElement.t [@@js.get "textPath"]
  val set_textPath: 'tags this -> SVGTextPathElement.t -> unit [@@js.set "textPath"]
  val get_title: 'tags this -> SVGTitleElement.t [@@js.get "title"]
  val set_title: 'tags this -> SVGTitleElement.t -> unit [@@js.set "title"]
  val get_tspan: 'tags this -> SVGTSpanElement.t [@@js.get "tspan"]
  val set_tspan: 'tags this -> SVGTSpanElement.t -> unit [@@js.set "tspan"]
  val get_use: 'tags this -> SVGUseElement.t [@@js.get "use"]
  val set_use: 'tags this -> SVGUseElement.t -> unit [@@js.set "use"]
  val get_view: 'tags this -> SVGViewElement.t [@@js.get "view"]
  val set_view: 'tags this -> SVGViewElement.t -> unit [@@js.set "view"]
  val create: a:SVGAElement.t -> animate:SVGAnimateElement.t -> animateMotion:SVGAnimateMotionElement.t -> animateTransform:SVGAnimateTransformElement.t -> circle:SVGCircleElement.t -> clipPath:SVGClipPathElement.t -> defs:SVGDefsElement.t -> desc:SVGDescElement.t -> ellipse:SVGEllipseElement.t -> feBlend:SVGFEBlendElement.t -> feColorMatrix:SVGFEColorMatrixElement.t -> feComponentTransfer:SVGFEComponentTransferElement.t -> feComposite:SVGFECompositeElement.t -> feConvolveMatrix:SVGFEConvolveMatrixElement.t -> feDiffuseLighting:SVGFEDiffuseLightingElement.t -> feDisplacementMap:SVGFEDisplacementMapElement.t -> feDistantLight:SVGFEDistantLightElement.t -> feDropShadow:SVGFEDropShadowElement.t -> feFlood:SVGFEFloodElement.t -> feFuncA:SVGFEFuncAElement.t -> feFuncB:SVGFEFuncBElement.t -> feFuncG:SVGFEFuncGElement.t -> feFuncR:SVGFEFuncRElement.t -> feGaussianBlur:SVGFEGaussianBlurElement.t -> feImage:SVGFEImageElement.t -> feMerge:SVGFEMergeElement.t -> feMergeNode:SVGFEMergeNodeElement.t -> feMorphology:SVGFEMorphologyElement.t -> feOffset:SVGFEOffsetElement.t -> fePointLight:SVGFEPointLightElement.t -> feSpecularLighting:SVGFESpecularLightingElement.t -> feSpotLight:SVGFESpotLightElement.t -> feTile:SVGFETileElement.t -> feTurbulence:SVGFETurbulenceElement.t -> filter:SVGFilterElement.t -> foreignObject:SVGForeignObjectElement.t -> g:SVGGElement.t -> image:SVGImageElement.t -> line:SVGLineElement.t -> linearGradient:SVGLinearGradientElement.t -> marker:SVGMarkerElement.t -> mask:SVGMaskElement.t -> metadata:SVGMetadataElement.t -> mpath:SVGMPathElement.t -> path:SVGPathElement.t -> pattern:SVGPatternElement.t -> polygon:SVGPolygonElement.t -> polyline:SVGPolylineElement.t -> radialGradient:SVGRadialGradientElement.t -> rect:SVGRectElement.t -> script:SVGScriptElement.t -> set_:(SVGSetElement.t[@js "set"]) -> stop:SVGStopElement.t -> style:SVGStyleElement.t -> svg:SVGSVGElement.t -> switch:SVGSwitchElement.t -> symbol:SVGSymbolElement.t -> text:SVGTextElement.t -> textPath:SVGTextPathElement.t -> title:SVGTitleElement.t -> tspan:SVGTSpanElement.t -> use:SVGUseElement.t -> view:SVGViewElement.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** Provides special properties (beyond those defined on the regular HTMLElement interface it also has available to it by inheritance) for manipulating unordered list elements. *)
module[@js.scope "HTMLUListElement"] HTMLUListElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLUListElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLUListElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLUListElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLUListElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** @deprecated  *)
  val get_compact: 'tags this -> bool [@@js.get "compact"]
  
  (** @deprecated  *)
  val set_compact: 'tags this -> bool -> unit [@@js.set "compact"]
  
  (** @deprecated  *)
  val get_type: 'tags this -> string [@@js.get "type"]
  
  (** @deprecated  *)
  val set_type: 'tags this -> string -> unit [@@js.set "type"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** The HTMLTrackElement *)
module[@js.scope "HTMLTrackElement"] HTMLTrackElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLTrackElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLTrackElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLTrackElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLTrackElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_default: 'tags this -> bool [@@js.get "default"]
  val set_default: 'tags this -> bool -> unit [@@js.set "default"]
  val get_kind: 'tags this -> string [@@js.get "kind"]
  val set_kind: 'tags this -> string -> unit [@@js.set "kind"]
  val get_label: 'tags this -> string [@@js.get "label"]
  val set_label: 'tags this -> string -> unit [@@js.set "label"]
  val get_readyState: 'tags this -> float [@@js.get "readyState"]
  val get_src: 'tags this -> string [@@js.get "src"]
  val set_src: 'tags this -> string -> unit [@@js.set "src"]
  val get_srclang: 'tags this -> string [@@js.get "srclang"]
  val set_srclang: 'tags this -> string -> unit [@@js.set "srclang"]
  
  (** Returns the TextTrack object corresponding to the text track of the track element. *)
  val get_track: 'tags this -> TextTrack.t [@@js.get "track"]
  val get_ERROR: 'tags this -> float [@@js.get "ERROR"]
  val get_LOADED: 'tags this -> float [@@js.get "LOADED"]
  val get_LOADING: 'tags this -> float [@@js.get "LOADING"]
  val get_NONE: 'tags this -> float [@@js.get "NONE"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
  val error: unit -> float [@@js.get "ERROR"]
  val loaded: unit -> float [@@js.get "LOADED"]
  val loading: unit -> float [@@js.get "LOADING"]
  val none: unit -> float [@@js.get "NONE"]
end

(** Contains the title for a document. This element inherits all of the properties and methods of the HTMLElement interface. *)
module[@js.scope "HTMLTitleElement"] HTMLTitleElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLTitleElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLTitleElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLTitleElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLTitleElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Retrieves or sets the text of the object as a string. *)
  val get_text: 'tags this -> string [@@js.get "text"]
  
  (** Retrieves or sets the text of the object as a string. *)
  val set_text: 'tags this -> string -> unit [@@js.set "text"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Provides special properties (beyond the regular HTMLElement interface it also has available to it by inheritance) for manipulating <time> elements. *)
module[@js.scope "HTMLTimeElement"] HTMLTimeElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLTimeElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLTimeElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLTimeElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLTimeElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_dateTime: 'tags this -> string [@@js.get "dateTime"]
  val set_dateTime: 'tags this -> string -> unit [@@js.set "dateTime"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module SelectionMode : sig
  type t = ([`L_s290_end[@js "end"] | `L_s631_preserve[@js "preserve"] | `L_s709_select[@js "select"] | `L_s754_start[@js "start"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end

(** The validity states that an element can be in, with respect to constraint validation. Together, they help explain why an element's value fails to validate, if it's not valid. *)
module[@js.scope "ValidityState"] ValidityState : sig
  type t = [`ValidityState] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ValidityState]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ValidityState]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ValidityState ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_badInput: 'tags this -> bool [@@js.get "badInput"]
  val get_customError: 'tags this -> bool [@@js.get "customError"]
  val get_patternMismatch: 'tags this -> bool [@@js.get "patternMismatch"]
  val get_rangeOverflow: 'tags this -> bool [@@js.get "rangeOverflow"]
  val get_rangeUnderflow: 'tags this -> bool [@@js.get "rangeUnderflow"]
  val get_stepMismatch: 'tags this -> bool [@@js.get "stepMismatch"]
  val get_tooLong: 'tags this -> bool [@@js.get "tooLong"]
  val get_tooShort: 'tags this -> bool [@@js.get "tooShort"]
  val get_typeMismatch: 'tags this -> bool [@@js.get "typeMismatch"]
  val get_valid: 'tags this -> bool [@@js.get "valid"]
  val get_valueMissing: 'tags this -> bool [@@js.get "valueMissing"]
  val create: badInput:bool -> customError:bool -> patternMismatch:bool -> rangeOverflow:bool -> rangeUnderflow:bool -> stepMismatch:bool -> tooLong:bool -> tooShort:bool -> typeMismatch:bool -> valid:bool -> valueMissing:bool -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end

(** Gives access to properties specific to <label> elements. It inherits methods and properties from the base HTMLElement interface. *)
module[@js.scope "HTMLLabelElement"] HTMLLabelElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLLabelElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLLabelElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLLabelElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLLabelElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Returns the form control that is associated with this element. *)
  val get_control: 'tags this -> HTMLElement.t option [@@js.get "control"]
  
  (** Retrieves a reference to the form that the object is embedded in. *)
  val get_form: 'tags this -> HTMLFormElement.t option [@@js.get "form"]
  
  (** Sets or retrieves the object to which the given label object is assigned. *)
  val get_htmlFor: 'tags this -> string [@@js.get "htmlFor"]
  
  (** Sets or retrieves the object to which the given label object is assigned. *)
  val set_htmlFor: 'tags this -> string -> unit [@@js.set "htmlFor"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Provides special properties and methods for manipulating the layout and presentation of <textarea> elements. *)
module[@js.scope "HTMLTextAreaElement"] HTMLTextAreaElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLTextAreaElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLTextAreaElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLTextAreaElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLTextAreaElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_autocomplete: 'tags this -> string [@@js.get "autocomplete"]
  val set_autocomplete: 'tags this -> string -> unit [@@js.set "autocomplete"]
  
  (** Sets or retrieves the width of the object. *)
  val get_cols: 'tags this -> float [@@js.get "cols"]
  
  (** Sets or retrieves the width of the object. *)
  val set_cols: 'tags this -> float -> unit [@@js.set "cols"]
  
  (** Sets or retrieves the initial contents of the object. *)
  val get_defaultValue: 'tags this -> string [@@js.get "defaultValue"]
  
  (** Sets or retrieves the initial contents of the object. *)
  val set_defaultValue: 'tags this -> string -> unit [@@js.set "defaultValue"]
  val get_dirName: 'tags this -> string [@@js.get "dirName"]
  val set_dirName: 'tags this -> string -> unit [@@js.set "dirName"]
  val get_disabled: 'tags this -> bool [@@js.get "disabled"]
  val set_disabled: 'tags this -> bool -> unit [@@js.set "disabled"]
  
  (** Retrieves a reference to the form that the object is embedded in. *)
  val get_form: 'tags this -> HTMLFormElement.t option [@@js.get "form"]
  val get_labels: 'tags this -> HTMLLabelElement.t NodeListOf.t [@@js.get "labels"]
  
  (** Sets or retrieves the maximum number of characters that the user can enter in a text control. *)
  val get_maxLength: 'tags this -> float [@@js.get "maxLength"]
  
  (** Sets or retrieves the maximum number of characters that the user can enter in a text control. *)
  val set_maxLength: 'tags this -> float -> unit [@@js.set "maxLength"]
  val get_minLength: 'tags this -> float [@@js.get "minLength"]
  val set_minLength: 'tags this -> float -> unit [@@js.set "minLength"]
  
  (** Sets or retrieves the name of the object. *)
  val get_name: 'tags this -> string [@@js.get "name"]
  
  (** Sets or retrieves the name of the object. *)
  val set_name: 'tags this -> string -> unit [@@js.set "name"]
  
  (** Gets or sets a text string that is displayed in an input field as a hint or prompt to users as the format or type of information they need to enter.The text appears in an input field until the user puts focus on the field. *)
  val get_placeholder: 'tags this -> string [@@js.get "placeholder"]
  
  (** Gets or sets a text string that is displayed in an input field as a hint or prompt to users as the format or type of information they need to enter.The text appears in an input field until the user puts focus on the field. *)
  val set_placeholder: 'tags this -> string -> unit [@@js.set "placeholder"]
  
  (** Sets or retrieves the value indicated whether the content of the object is read-only. *)
  val get_readOnly: 'tags this -> bool [@@js.get "readOnly"]
  
  (** Sets or retrieves the value indicated whether the content of the object is read-only. *)
  val set_readOnly: 'tags this -> bool -> unit [@@js.set "readOnly"]
  
  (** When present, marks an element that can't be submitted without a value. *)
  val get_required: 'tags this -> bool [@@js.get "required"]
  
  (** When present, marks an element that can't be submitted without a value. *)
  val set_required: 'tags this -> bool -> unit [@@js.set "required"]
  
  (** Sets or retrieves the number of horizontal rows contained in the object. *)
  val get_rows: 'tags this -> float [@@js.get "rows"]
  
  (** Sets or retrieves the number of horizontal rows contained in the object. *)
  val set_rows: 'tags this -> float -> unit [@@js.set "rows"]
  val get_selectionDirection: 'tags this -> ([`L_s145_backward[@js "backward"] | `L_s358_forward[@js "forward"] | `L_s548_none[@js "none"]] [@js.enum]) [@@js.get "selectionDirection"]
  val set_selectionDirection: 'tags this -> ([`U1 of ([`L_s358_forward[@js "forward"]] [@js.enum]) | `U2 of ([`L_s145_backward[@js "backward"]] [@js.enum]) | `U3 of ([`L_s548_none[@js "none"]] [@js.enum])] [@js.union]) -> unit [@@js.set "selectionDirection"]
  
  (** Gets or sets the end position or offset of a text selection. *)
  val get_selectionEnd: 'tags this -> float [@@js.get "selectionEnd"]
  
  (** Gets or sets the end position or offset of a text selection. *)
  val set_selectionEnd: 'tags this -> float -> unit [@@js.set "selectionEnd"]
  
  (** Gets or sets the starting position or offset of a text selection. *)
  val get_selectionStart: 'tags this -> float [@@js.get "selectionStart"]
  
  (** Gets or sets the starting position or offset of a text selection. *)
  val set_selectionStart: 'tags this -> float -> unit [@@js.set "selectionStart"]
  val get_textLength: 'tags this -> float [@@js.get "textLength"]
  
  (** Retrieves the type of control. *)
  val get_type: 'tags this -> string [@@js.get "type"]
  
  (** Returns the error message that would be displayed if the user submits the form, or an empty string if no error message. It also triggers the standard error message, such as "this is a required field". The result is that the user sees validation messages without actually submitting. *)
  val get_validationMessage: 'tags this -> string [@@js.get "validationMessage"]
  
  (** Returns a  ValidityState object that represents the validity states of an element. *)
  val get_validity: 'tags this -> ValidityState.t [@@js.get "validity"]
  
  (** Retrieves or sets the text in the entry field of the textArea element. *)
  val get_value: 'tags this -> string [@@js.get "value"]
  
  (** Retrieves or sets the text in the entry field of the textArea element. *)
  val set_value: 'tags this -> string -> unit [@@js.set "value"]
  
  (** Returns whether an element will successfully validate based on forms validation rules and constraints. *)
  val get_willValidate: 'tags this -> bool [@@js.get "willValidate"]
  
  (** Sets or retrieves how to handle wordwrapping in the object. *)
  val get_wrap: 'tags this -> string [@@js.get "wrap"]
  
  (** Sets or retrieves how to handle wordwrapping in the object. *)
  val set_wrap: 'tags this -> string -> unit [@@js.set "wrap"]
  
  (** Returns whether a form will validate when it is submitted, without having to submit it. *)
  val checkValidity: 'tags this -> bool [@@js.call "checkValidity"]
  val reportValidity: 'tags this -> bool [@@js.call "reportValidity"]
  
  (** Highlights the input area of a form element. *)
  val select: 'tags this -> unit [@@js.call "select"]
  
  (**
    Sets a custom error message that is displayed when a form is submitted.
    @param error Sets a custom error message that is displayed when a form is submitted.
  *)
  val setCustomValidity: 'tags this -> error:string -> unit [@@js.call "setCustomValidity"]
  val setRangeText: 'tags this -> replacement:string -> unit [@@js.call "setRangeText"]
  val setRangeText': 'tags this -> replacement:string -> start:float -> end_:float -> ?selectionMode:SelectionMode.t -> unit -> unit [@@js.call "setRangeText"]
  
  (**
    Sets the start and end positions of a selection in a text field.
    @param start The offset into the text field for the start of the selection.
    @param end The offset into the text field for the end of the selection.
    @param direction The direction in which the selection is performed.
  *)
  val setSelectionRange: 'tags this -> start:float option -> end_:float option -> ?direction:([`U1 of ([`L_s358_forward[@js "forward"]] [@js.enum]) | `U2 of ([`L_s145_backward[@js "backward"]] [@js.enum]) | `U3 of ([`L_s548_none[@js "none"]] [@js.enum])] [@js.union]) -> unit -> unit [@@js.call "setSelectionRange"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Enables access to the contents of an HTML <template> element. *)
module[@js.scope "HTMLTemplateElement"] HTMLTemplateElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLTemplateElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLTemplateElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLTemplateElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLTemplateElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Returns the template contents (a DocumentFragment). *)
  val get_content: 'tags this -> DocumentFragment.t [@@js.get "content"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Provides special properties and methods (beyond the HTMLElement interface it also has available to it by inheritance) for manipulating the layout and presentation of rows in an HTML table. *)
module[@js.scope "HTMLTableRowElement"] HTMLTableRowElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLTableRowElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLTableRowElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLTableRowElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLTableRowElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    Sets or retrieves how the object is aligned with adjacent text.
    @deprecated 
  *)
  val get_align: 'tags this -> string [@@js.get "align"]
  
  (**
    Sets or retrieves how the object is aligned with adjacent text.
    @deprecated 
  *)
  val set_align: 'tags this -> string -> unit [@@js.set "align"]
  
  (** @deprecated  *)
  val get_bgColor: 'tags this -> string [@@js.get "bgColor"]
  
  (** @deprecated  *)
  val set_bgColor: 'tags this -> string -> unit [@@js.set "bgColor"]
  
  (** Retrieves a collection of all cells in the table row. *)
  val get_cells: 'tags this -> HTMLTableCellElement.t HTMLCollectionOf.t [@@js.get "cells"]
  
  (** @deprecated  *)
  val get_ch: 'tags this -> string [@@js.get "ch"]
  
  (** @deprecated  *)
  val set_ch: 'tags this -> string -> unit [@@js.set "ch"]
  
  (** @deprecated  *)
  val get_chOff: 'tags this -> string [@@js.get "chOff"]
  
  (** @deprecated  *)
  val set_chOff: 'tags this -> string -> unit [@@js.set "chOff"]
  
  (** Retrieves the position of the object in the rows collection for the table. *)
  val get_rowIndex: 'tags this -> float [@@js.get "rowIndex"]
  
  (** Retrieves the position of the object in the collection. *)
  val get_sectionRowIndex: 'tags this -> float [@@js.get "sectionRowIndex"]
  
  (** @deprecated  *)
  val get_vAlign: 'tags this -> string [@@js.get "vAlign"]
  
  (** @deprecated  *)
  val set_vAlign: 'tags this -> string -> unit [@@js.set "vAlign"]
  
  (**
    Removes the specified cell from the table row, as well as from the cells collection.
    @param index Number that specifies the zero-based position of the cell to remove from the table row. If no value is provided, the last cell in the cells collection is deleted.
  *)
  val deleteCell: 'tags this -> index:float -> unit [@@js.call "deleteCell"]
  
  (**
    Creates a new cell in the table row, and adds the cell to the cells collection.
    @param index Number that specifies where to insert the cell in the tr. The default value is -1, which appends the new cell to the end of the cells collection.
  *)
  val insertCell: 'tags this -> ?index:float -> unit -> HTMLTableCellElement.t [@@js.call "insertCell"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Provides special properties and methods (beyond the HTMLElement interface it also has available to it by inheritance) for manipulating the layout and presentation of sections, that is headers, footers and bodies, in an HTML table. *)
module[@js.scope "HTMLTableSectionElement"] HTMLTableSectionElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLTableSectionElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLTableSectionElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLTableSectionElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLTableSectionElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    Sets or retrieves a value that indicates the table alignment.
    @deprecated 
  *)
  val get_align: 'tags this -> string [@@js.get "align"]
  
  (**
    Sets or retrieves a value that indicates the table alignment.
    @deprecated 
  *)
  val set_align: 'tags this -> string -> unit [@@js.set "align"]
  
  (** @deprecated  *)
  val get_ch: 'tags this -> string [@@js.get "ch"]
  
  (** @deprecated  *)
  val set_ch: 'tags this -> string -> unit [@@js.set "ch"]
  
  (** @deprecated  *)
  val get_chOff: 'tags this -> string [@@js.get "chOff"]
  
  (** @deprecated  *)
  val set_chOff: 'tags this -> string -> unit [@@js.set "chOff"]
  
  (** Sets or retrieves the number of horizontal rows contained in the object. *)
  val get_rows: 'tags this -> HTMLTableRowElement.t HTMLCollectionOf.t [@@js.get "rows"]
  
  (** @deprecated  *)
  val get_vAlign: 'tags this -> string [@@js.get "vAlign"]
  
  (** @deprecated  *)
  val set_vAlign: 'tags this -> string -> unit [@@js.set "vAlign"]
  
  (**
    Removes the specified row (tr) from the element and from the rows collection.
    @param index Number that specifies the zero-based position in the rows collection of the row to remove.
  *)
  val deleteRow: 'tags this -> index:float -> unit [@@js.call "deleteRow"]
  
  (**
    Creates a new row (tr) in the table, and adds the row to the rows collection.
    @param index Number that specifies where to insert the row in the rows collection. The default value is -1, which appends the new row to the end of the rows collection.
  *)
  val insertRow: 'tags this -> ?index:float -> unit -> HTMLTableRowElement.t [@@js.call "insertRow"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Special properties (beyond the regular HTMLElement interface it also has available to it by inheritance) for manipulating table caption elements. *)
module[@js.scope "HTMLTableCaptionElement"] HTMLTableCaptionElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLTableCaptionElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLTableCaptionElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLTableCaptionElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLTableCaptionElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    Sets or retrieves the alignment of the caption or legend.
    @deprecated 
  *)
  val get_align: 'tags this -> string [@@js.get "align"]
  
  (**
    Sets or retrieves the alignment of the caption or legend.
    @deprecated 
  *)
  val set_align: 'tags this -> string -> unit [@@js.set "align"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Provides special properties and methods (beyond the regular HTMLElement object interface it also has available to it by inheritance) for manipulating the layout and presentation of tables in an HTML document. *)
module[@js.scope "HTMLTableElement"] HTMLTableElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLTableElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLTableElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLTableElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLTableElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    Sets or retrieves a value that indicates the table alignment.
    @deprecated 
  *)
  val get_align: 'tags this -> string [@@js.get "align"]
  
  (**
    Sets or retrieves a value that indicates the table alignment.
    @deprecated 
  *)
  val set_align: 'tags this -> string -> unit [@@js.set "align"]
  
  (** @deprecated  *)
  val get_bgColor: 'tags this -> string [@@js.get "bgColor"]
  
  (** @deprecated  *)
  val set_bgColor: 'tags this -> string -> unit [@@js.set "bgColor"]
  
  (**
    Sets or retrieves the width of the border to draw around the object.
    @deprecated 
  *)
  val get_border: 'tags this -> string [@@js.get "border"]
  
  (**
    Sets or retrieves the width of the border to draw around the object.
    @deprecated 
  *)
  val set_border: 'tags this -> string -> unit [@@js.set "border"]
  
  (** Retrieves the caption object of a table. *)
  val get_caption: 'tags this -> HTMLTableCaptionElement.t option [@@js.get "caption"]
  
  (** Retrieves the caption object of a table. *)
  val set_caption: 'tags this -> HTMLTableCaptionElement.t option -> unit [@@js.set "caption"]
  
  (**
    Sets or retrieves the amount of space between the border of the cell and the content of the cell.
    @deprecated 
  *)
  val get_cellPadding: 'tags this -> string [@@js.get "cellPadding"]
  
  (**
    Sets or retrieves the amount of space between the border of the cell and the content of the cell.
    @deprecated 
  *)
  val set_cellPadding: 'tags this -> string -> unit [@@js.set "cellPadding"]
  
  (**
    Sets or retrieves the amount of space between cells in a table.
    @deprecated 
  *)
  val get_cellSpacing: 'tags this -> string [@@js.get "cellSpacing"]
  
  (**
    Sets or retrieves the amount of space between cells in a table.
    @deprecated 
  *)
  val set_cellSpacing: 'tags this -> string -> unit [@@js.set "cellSpacing"]
  
  (**
    Sets or retrieves the way the border frame around the table is displayed.
    @deprecated 
  *)
  val get_frame: 'tags this -> string [@@js.get "frame"]
  
  (**
    Sets or retrieves the way the border frame around the table is displayed.
    @deprecated 
  *)
  val set_frame: 'tags this -> string -> unit [@@js.set "frame"]
  
  (** Sets or retrieves the number of horizontal rows contained in the object. *)
  val get_rows: 'tags this -> HTMLTableRowElement.t HTMLCollectionOf.t [@@js.get "rows"]
  
  (**
    Sets or retrieves which dividing lines (inner borders) are displayed.
    @deprecated 
  *)
  val get_rules: 'tags this -> string [@@js.get "rules"]
  
  (**
    Sets or retrieves which dividing lines (inner borders) are displayed.
    @deprecated 
  *)
  val set_rules: 'tags this -> string -> unit [@@js.set "rules"]
  
  (**
    Sets or retrieves a description and/or structure of the object.
    @deprecated 
  *)
  val get_summary: 'tags this -> string [@@js.get "summary"]
  
  (**
    Sets or retrieves a description and/or structure of the object.
    @deprecated 
  *)
  val set_summary: 'tags this -> string -> unit [@@js.set "summary"]
  
  (** Retrieves a collection of all tBody objects in the table. Objects in this collection are in source order. *)
  val get_tBodies: 'tags this -> HTMLTableSectionElement.t HTMLCollectionOf.t [@@js.get "tBodies"]
  
  (** Retrieves the tFoot object of the table. *)
  val get_tFoot: 'tags this -> HTMLTableSectionElement.t option [@@js.get "tFoot"]
  
  (** Retrieves the tFoot object of the table. *)
  val set_tFoot: 'tags this -> HTMLTableSectionElement.t option -> unit [@@js.set "tFoot"]
  
  (** Retrieves the tHead object of the table. *)
  val get_tHead: 'tags this -> HTMLTableSectionElement.t option [@@js.get "tHead"]
  
  (** Retrieves the tHead object of the table. *)
  val set_tHead: 'tags this -> HTMLTableSectionElement.t option -> unit [@@js.set "tHead"]
  
  (**
    Sets or retrieves the width of the object.
    @deprecated 
  *)
  val get_width: 'tags this -> string [@@js.get "width"]
  
  (**
    Sets or retrieves the width of the object.
    @deprecated 
  *)
  val set_width: 'tags this -> string -> unit [@@js.set "width"]
  
  (** Creates an empty caption element in the table. *)
  val createCaption: 'tags this -> HTMLTableCaptionElement.t [@@js.call "createCaption"]
  
  (** Creates an empty tBody element in the table. *)
  val createTBody: 'tags this -> HTMLTableSectionElement.t [@@js.call "createTBody"]
  
  (** Creates an empty tFoot element in the table. *)
  val createTFoot: 'tags this -> HTMLTableSectionElement.t [@@js.call "createTFoot"]
  
  (** Returns the tHead element object if successful, or null otherwise. *)
  val createTHead: 'tags this -> HTMLTableSectionElement.t [@@js.call "createTHead"]
  
  (** Deletes the caption element and its contents from the table. *)
  val deleteCaption: 'tags this -> unit [@@js.call "deleteCaption"]
  
  (**
    Removes the specified row (tr) from the element and from the rows collection.
    @param index Number that specifies the zero-based position in the rows collection of the row to remove.
  *)
  val deleteRow: 'tags this -> index:float -> unit [@@js.call "deleteRow"]
  
  (** Deletes the tFoot element and its contents from the table. *)
  val deleteTFoot: 'tags this -> unit [@@js.call "deleteTFoot"]
  
  (** Deletes the tHead element and its contents from the table. *)
  val deleteTHead: 'tags this -> unit [@@js.call "deleteTHead"]
  
  (**
    Creates a new row (tr) in the table, and adds the row to the rows collection.
    @param index Number that specifies where to insert the row in the rows collection. The default value is -1, which appends the new row to the end of the rows collection.
  *)
  val insertRow: 'tags this -> ?index:float -> unit -> HTMLTableRowElement.t [@@js.call "insertRow"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Provides special properties (beyond the HTMLElement interface it also has available to it inheritance) for manipulating single or grouped table column elements. *)
module[@js.scope "HTMLTableColElement"] HTMLTableColElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLTableColElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLTableColElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLTableColElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLTableColElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    Sets or retrieves the alignment of the object relative to the display or table.
    @deprecated 
  *)
  val get_align: 'tags this -> string [@@js.get "align"]
  
  (**
    Sets or retrieves the alignment of the object relative to the display or table.
    @deprecated 
  *)
  val set_align: 'tags this -> string -> unit [@@js.set "align"]
  
  (** @deprecated  *)
  val get_ch: 'tags this -> string [@@js.get "ch"]
  
  (** @deprecated  *)
  val set_ch: 'tags this -> string -> unit [@@js.set "ch"]
  
  (** @deprecated  *)
  val get_chOff: 'tags this -> string [@@js.get "chOff"]
  
  (** @deprecated  *)
  val set_chOff: 'tags this -> string -> unit [@@js.set "chOff"]
  
  (** Sets or retrieves the number of columns in the group. *)
  val get_span: 'tags this -> float [@@js.get "span"]
  
  (** Sets or retrieves the number of columns in the group. *)
  val set_span: 'tags this -> float -> unit [@@js.set "span"]
  
  (** @deprecated  *)
  val get_vAlign: 'tags this -> string [@@js.get "vAlign"]
  
  (** @deprecated  *)
  val set_vAlign: 'tags this -> string -> unit [@@js.set "vAlign"]
  
  (**
    Sets or retrieves the width of the object.
    @deprecated 
  *)
  val get_width: 'tags this -> string [@@js.get "width"]
  
  (**
    Sets or retrieves the width of the object.
    @deprecated 
  *)
  val set_width: 'tags this -> string -> unit [@@js.set "width"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** A <style> element. It inherits properties and methods from its parent, HTMLElement, and from LinkStyle. *)
module[@js.scope "HTMLStyleElement"] HTMLStyleElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLStyleElement | `InnerHTML | `LinkStyle | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLStyleElement | `InnerHTML | `LinkStyle | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLStyleElement | `InnerHTML | `LinkStyle | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLStyleElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Sets or retrieves the media type. *)
  val get_media: 'tags this -> string [@@js.get "media"]
  
  (** Sets or retrieves the media type. *)
  val set_media: 'tags this -> string -> unit [@@js.set "media"]
  
  (**
    Retrieves the CSS language in which the style sheet is written.
    @deprecated 
  *)
  val get_type: 'tags this -> string [@@js.get "type"]
  
  (**
    Retrieves the CSS language in which the style sheet is written.
    @deprecated 
  *)
  val set_type: 'tags this -> string -> unit [@@js.set "type"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** A <span> element and derives from the HTMLElement interface, but without implementing any additional properties or methods. *)
module[@js.scope "HTMLSpanElement"] HTMLSpanElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLSpanElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLSpanElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLSpanElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLSpanElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Provides special properties (beyond the regular HTMLElement object interface it also has available to it by inheritance) for manipulating <source> elements. *)
module[@js.scope "HTMLSourceElement"] HTMLSourceElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLSourceElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLSourceElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLSourceElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLSourceElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_height: 'tags this -> float [@@js.get "height"]
  val set_height: 'tags this -> float -> unit [@@js.set "height"]
  
  (** Gets or sets the intended media type of the media source. *)
  val get_media: 'tags this -> string [@@js.get "media"]
  
  (** Gets or sets the intended media type of the media source. *)
  val set_media: 'tags this -> string -> unit [@@js.set "media"]
  val get_sizes: 'tags this -> string [@@js.get "sizes"]
  val set_sizes: 'tags this -> string -> unit [@@js.set "sizes"]
  
  (** The address or URL of the a media resource that is to be considered. *)
  val get_src: 'tags this -> string [@@js.get "src"]
  
  (** The address or URL of the a media resource that is to be considered. *)
  val set_src: 'tags this -> string -> unit [@@js.set "src"]
  val get_srcset: 'tags this -> string [@@js.get "srcset"]
  val set_srcset: 'tags this -> string -> unit [@@js.set "srcset"]
  
  (** Gets or sets the MIME type of a media resource. *)
  val get_type: 'tags this -> string [@@js.get "type"]
  
  (** Gets or sets the MIME type of a media resource. *)
  val set_type: 'tags this -> string -> unit [@@js.set "type"]
  val get_width: 'tags this -> float [@@js.get "width"]
  val set_width: 'tags this -> float -> unit [@@js.set "width"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Provides special properties and methods (beyond the regular HTMLElement object interface they also have available to them by inheritance) for manipulating the layout and presentation of <optgroup> elements. *)
module[@js.scope "HTMLOptGroupElement"] HTMLOptGroupElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOptGroupElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOptGroupElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOptGroupElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLOptGroupElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_disabled: 'tags this -> bool [@@js.get "disabled"]
  val set_disabled: 'tags this -> bool -> unit [@@js.set "disabled"]
  
  (** Sets or retrieves a value that you can use to implement your own label functionality for the object. *)
  val get_label: 'tags this -> string [@@js.get "label"]
  
  (** Sets or retrieves a value that you can use to implement your own label functionality for the object. *)
  val set_label: 'tags this -> string -> unit [@@js.set "label"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** HTMLOptionsCollection is an interface representing a collection of HTML option elements (in document order) and offers methods and properties for traversing the list as well as optionally altering its items. This type is returned solely by the "options" property of select. *)
module[@js.scope "HTMLOptionsCollection"] HTMLOptionsCollection : sig
  type t = [`HTMLCollectionBase | `HTMLCollectionOf of HTMLOptionElement.t | `HTMLOptionsCollection | HTMLOptionElement.t ArrayLike.tags_1 | HTMLOptionElement.t IterableIterator.tags_1] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`HTMLCollectionBase | `HTMLCollectionOf of HTMLOptionElement.t | `HTMLOptionsCollection | HTMLOptionElement.t ArrayLike.tags_1 | HTMLOptionElement.t IterableIterator.tags_1]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`HTMLCollectionBase | `HTMLCollectionOf of HTMLOptionElement.t | `HTMLOptionsCollection | HTMLOptionElement.t ArrayLike.tags_1 | HTMLOptionElement.t IterableIterator.tags_1]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLOptionsCollection ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    Returns the number of elements in the collection.
    
    When set to a smaller number, truncates the number of option elements in the corresponding container.
    
    When set to a greater number, adds new blank option elements to that container.
  *)
  val get_length: 'tags this -> float [@@js.get "length"]
  
  (**
    Returns the number of elements in the collection.
    
    When set to a smaller number, truncates the number of option elements in the corresponding container.
    
    When set to a greater number, adds new blank option elements to that container.
  *)
  val set_length: 'tags this -> float -> unit [@@js.set "length"]
  
  (**
    Returns the index of the first selected item, if any, or −1 if there is no selected item.
    
    Can be set, to change the selection.
  *)
  val get_selectedIndex: 'tags this -> float [@@js.get "selectedIndex"]
  
  (**
    Returns the index of the first selected item, if any, or −1 if there is no selected item.
    
    Can be set, to change the selection.
  *)
  val set_selectedIndex: 'tags this -> float -> unit [@@js.set "selectedIndex"]
  
  (**
    Inserts element before the node given by before.
    
    The before argument can be a number, in which case element is inserted before the item with that number, or an element from the collection, in which case element is inserted before that element.
    
    If before is omitted, null, or a number out of range, then element will be added at the end of the list.
    
    This method will throw a "HierarchyRequestError" DOMException if element is an ancestor of the element into which it is to be inserted.
  *)
  val add: 'tags this -> element:([`U1 of HTMLOptionElement.t | `U2 of HTMLOptGroupElement.t] [@js.union]) -> ?before:([`Null | `U1 of HTMLElement.t | `U2 of float] [@js.union]) -> unit -> unit [@@js.call "add"]
  
  (** Removes the item with index index from the collection. *)
  val remove: 'tags this -> index:float -> unit [@@js.call "remove"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** A <select> HTML Element. These elements also share all of the properties and methods of other HTML elements via the HTMLElement interface. *)
module[@js.scope "HTMLSelectElement"] HTMLSelectElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLSelectElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable | (HTMLOptGroupElement.t, HTMLOptionElement.t) union2 ArrayLike.tags_1 | HTMLOptionElement.t IterableIterator.tags_1] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLSelectElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable | (HTMLOptGroupElement.t, HTMLOptionElement.t) union2 ArrayLike.tags_1 | HTMLOptionElement.t IterableIterator.tags_1]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLSelectElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable | (HTMLOptGroupElement.t, HTMLOptionElement.t) union2 ArrayLike.tags_1 | HTMLOptionElement.t IterableIterator.tags_1]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLSelectElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  (* [Symbol.iterator]: unit -> HTMLOptionElement.t IterableIterator.t_1 *)
  val get_autocomplete: 'tags this -> string [@@js.get "autocomplete"]
  val set_autocomplete: 'tags this -> string -> unit [@@js.set "autocomplete"]
  val get_disabled: 'tags this -> bool [@@js.get "disabled"]
  val set_disabled: 'tags this -> bool -> unit [@@js.set "disabled"]
  
  (** Retrieves a reference to the form that the object is embedded in. *)
  val get_form: 'tags this -> HTMLFormElement.t option [@@js.get "form"]
  val get_labels: 'tags this -> HTMLLabelElement.t NodeListOf.t [@@js.get "labels"]
  
  (** Sets or retrieves the number of objects in a collection. *)
  val get_length: 'tags this -> float [@@js.get "length"]
  
  (** Sets or retrieves the number of objects in a collection. *)
  val set_length: 'tags this -> float -> unit [@@js.set "length"]
  
  (** Sets or retrieves the Boolean value indicating whether multiple items can be selected from a list. *)
  val get_multiple: 'tags this -> bool [@@js.get "multiple"]
  
  (** Sets or retrieves the Boolean value indicating whether multiple items can be selected from a list. *)
  val set_multiple: 'tags this -> bool -> unit [@@js.set "multiple"]
  
  (** Sets or retrieves the name of the object. *)
  val get_name: 'tags this -> string [@@js.get "name"]
  
  (** Sets or retrieves the name of the object. *)
  val set_name: 'tags this -> string -> unit [@@js.set "name"]
  
  (** Returns an HTMLOptionsCollection of the list of options. *)
  val get_options: 'tags this -> HTMLOptionsCollection.t [@@js.get "options"]
  
  (** When present, marks an element that can't be submitted without a value. *)
  val get_required: 'tags this -> bool [@@js.get "required"]
  
  (** When present, marks an element that can't be submitted without a value. *)
  val set_required: 'tags this -> bool -> unit [@@js.set "required"]
  
  (** Sets or retrieves the index of the selected option in a select object. *)
  val get_selectedIndex: 'tags this -> float [@@js.get "selectedIndex"]
  
  (** Sets or retrieves the index of the selected option in a select object. *)
  val set_selectedIndex: 'tags this -> float -> unit [@@js.set "selectedIndex"]
  val get_selectedOptions: 'tags this -> HTMLOptionElement.t HTMLCollectionOf.t [@@js.get "selectedOptions"]
  
  (** Sets or retrieves the number of rows in the list box. *)
  val get_size: 'tags this -> float [@@js.get "size"]
  
  (** Sets or retrieves the number of rows in the list box. *)
  val set_size: 'tags this -> float -> unit [@@js.set "size"]
  
  (** Retrieves the type of select control based on the value of the MULTIPLE attribute. *)
  val get_type: 'tags this -> string [@@js.get "type"]
  
  (** Returns the error message that would be displayed if the user submits the form, or an empty string if no error message. It also triggers the standard error message, such as "this is a required field". The result is that the user sees validation messages without actually submitting. *)
  val get_validationMessage: 'tags this -> string [@@js.get "validationMessage"]
  
  (** Returns a  ValidityState object that represents the validity states of an element. *)
  val get_validity: 'tags this -> ValidityState.t [@@js.get "validity"]
  
  (** Sets or retrieves the value which is returned to the server when the form control is submitted. *)
  val get_value: 'tags this -> string [@@js.get "value"]
  
  (** Sets or retrieves the value which is returned to the server when the form control is submitted. *)
  val set_value: 'tags this -> string -> unit [@@js.set "value"]
  
  (** Returns whether an element will successfully validate based on forms validation rules and constraints. *)
  val get_willValidate: 'tags this -> bool [@@js.get "willValidate"]
  
  (**
    Adds an element to the areas, controlRange, or options collection.
    @param element Variant of type Number that specifies the index position in the collection where the element is placed. If no value is given, the method places the element at the end of the collection.
    @param before Variant of type Object that specifies an element to insert before, or null to append the object to the collection.
  *)
  val add: 'tags this -> element:([`U1 of HTMLOptionElement.t | `U2 of HTMLOptGroupElement.t] [@js.union]) -> ?before:([`Null | `U1 of HTMLElement.t | `U2 of float] [@js.union]) -> unit -> unit [@@js.call "add"]
  
  (** Returns whether a form will validate when it is submitted, without having to submit it. *)
  val checkValidity: 'tags this -> bool [@@js.call "checkValidity"]
  
  (**
    Retrieves a select object or an object from an options collection.
    @param name Variant of type Number or String that specifies the object or collection to retrieve. If this parameter is an integer, it is the zero-based index of the object. If this parameter is a string, all objects with matching name or id properties are retrieved, and a collection is returned if more than one match is made.
    @param index Variant of type Number that specifies the zero-based index of the object to retrieve when a collection is returned.
  *)
  val item: 'tags this -> index:float -> HTMLOptionElement.t option [@@js.call "item"]
  
  (**
    Retrieves a select object or an object from an options collection.
    @param namedItem A String that specifies the name or id property of the object to retrieve. A collection is returned if more than one match is made.
  *)
  val namedItem: 'tags this -> name:string -> HTMLOptionElement.t option [@@js.call "namedItem"]
  
  (**
    Removes an element from the collection.
    @param index Number that specifies the zero-based index of the element to remove from the collection.
  *)
  val remove: 'tags this -> unit [@@js.call "remove"]
  
  (** Removes node. *)
  val remove': 'tags this -> index:float -> unit [@@js.call "remove"]
  val reportValidity: 'tags this -> bool [@@js.call "reportValidity"]
  
  (**
    Sets a custom error message that is displayed when a form is submitted.
    @param error Sets a custom error message that is displayed when a form is submitted.
  *)
  val setCustomValidity: 'tags this -> error:string -> unit [@@js.call "setCustomValidity"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val get: 'tags this -> float -> (HTMLOptGroupElement.t, HTMLOptionElement.t) union2 [@@js.index_get]
  val set: 'tags this -> float -> ([`U1 of HTMLOptionElement.t | `U2 of HTMLOptGroupElement.t] [@js.union]) -> unit [@@js.index_set]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Provides special properties and methods (beyond the regular HTMLElement interface it also has available to it by inheritance) for manipulating quoting elements, like <blockquote> and <q>, but not the <cite> element. *)
module[@js.scope "HTMLQuoteElement"] HTMLQuoteElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLQuoteElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLQuoteElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLQuoteElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLQuoteElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Sets or retrieves reference information about the object. *)
  val get_cite: 'tags this -> string [@@js.get "cite"]
  
  (** Sets or retrieves reference information about the object. *)
  val set_cite: 'tags this -> string -> unit [@@js.set "cite"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Provides special properties and methods (beyond the regular HTMLElement interface it also has available to it by inheritance) for manipulating the layout and presentation of <progress> elements. *)
module[@js.scope "HTMLProgressElement"] HTMLProgressElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLProgressElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLProgressElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLProgressElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLProgressElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_labels: 'tags this -> HTMLLabelElement.t NodeListOf.t [@@js.get "labels"]
  
  (** Defines the maximum, or "done" value for a progress element. *)
  val get_max: 'tags this -> float [@@js.get "max"]
  
  (** Defines the maximum, or "done" value for a progress element. *)
  val set_max: 'tags this -> float -> unit [@@js.set "max"]
  
  (** Returns the quotient of value/max when the value attribute is set (determinate progress bar), or -1 when the value attribute is missing (indeterminate progress bar). *)
  val get_position: 'tags this -> float [@@js.get "position"]
  
  (** Sets or gets the current value of a progress element. The value must be a non-negative number between 0 and the max value. *)
  val get_value: 'tags this -> float [@@js.get "value"]
  
  (** Sets or gets the current value of a progress element. The value must be a non-negative number between 0 and the max value. *)
  val set_value: 'tags this -> float -> unit [@@js.set "value"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** A <picture> HTML element. It doesn't implement specific properties or methods. *)
module[@js.scope "HTMLPictureElement"] HTMLPictureElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLPictureElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLPictureElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLPictureElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLPictureElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Provides special properties (beyond those of the regular HTMLElement object interface it inherits) for manipulating <param> elements, representing a pair of a key and a value that acts as a parameter for an <object> element. *)
module[@js.scope "HTMLParamElement"] HTMLParamElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLParamElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLParamElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLParamElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLParamElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Sets or retrieves the name of an input parameter for an element. *)
  val get_name: 'tags this -> string [@@js.get "name"]
  
  (** Sets or retrieves the name of an input parameter for an element. *)
  val set_name: 'tags this -> string -> unit [@@js.set "name"]
  
  (**
    Sets or retrieves the content type of the resource designated by the value attribute.
    @deprecated 
  *)
  val get_type: 'tags this -> string [@@js.get "type"]
  
  (**
    Sets or retrieves the content type of the resource designated by the value attribute.
    @deprecated 
  *)
  val set_type: 'tags this -> string -> unit [@@js.set "type"]
  
  (** Sets or retrieves the value of an input parameter for an element. *)
  val get_value: 'tags this -> string [@@js.get "value"]
  
  (** Sets or retrieves the value of an input parameter for an element. *)
  val set_value: 'tags this -> string -> unit [@@js.set "value"]
  
  (**
    Sets or retrieves the data type of the value attribute.
    @deprecated 
  *)
  val get_valueType: 'tags this -> string [@@js.get "valueType"]
  
  (**
    Sets or retrieves the data type of the value attribute.
    @deprecated 
  *)
  val set_valueType: 'tags this -> string -> unit [@@js.set "valueType"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Provides special properties (beyond those of the regular HTMLElement object interface it inherits) for manipulating <p> elements. *)
module[@js.scope "HTMLParagraphElement"] HTMLParagraphElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLParagraphElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLParagraphElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLParagraphElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLParagraphElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    Sets or retrieves how the object is aligned with adjacent text.
    @deprecated 
  *)
  val get_align: 'tags this -> string [@@js.get "align"]
  
  (**
    Sets or retrieves how the object is aligned with adjacent text.
    @deprecated 
  *)
  val set_align: 'tags this -> string -> unit [@@js.set "align"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Provides properties and methods (beyond those inherited from HTMLElement) for manipulating the layout and presentation of <output> elements. *)
module[@js.scope "HTMLOutputElement"] HTMLOutputElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLOutputElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLOutputElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOrSVGElement | `HTMLOutputElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLOutputElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_defaultValue: 'tags this -> string [@@js.get "defaultValue"]
  val set_defaultValue: 'tags this -> string -> unit [@@js.set "defaultValue"]
  val get_form: 'tags this -> HTMLFormElement.t option [@@js.get "form"]
  val get_htmlFor: 'tags this -> DOMTokenList.t [@@js.get "htmlFor"]
  val get_labels: 'tags this -> HTMLLabelElement.t NodeListOf.t [@@js.get "labels"]
  val get_name: 'tags this -> string [@@js.get "name"]
  val set_name: 'tags this -> string -> unit [@@js.set "name"]
  
  (** Returns the string "output". *)
  val get_type: 'tags this -> string [@@js.get "type"]
  val get_validationMessage: 'tags this -> string [@@js.get "validationMessage"]
  val get_validity: 'tags this -> ValidityState.t [@@js.get "validity"]
  
  (**
    Returns the element's current value.
    
    Can be set, to change the value.
  *)
  val get_value: 'tags this -> string [@@js.get "value"]
  
  (**
    Returns the element's current value.
    
    Can be set, to change the value.
  *)
  val set_value: 'tags this -> string -> unit [@@js.set "value"]
  val get_willValidate: 'tags this -> bool [@@js.get "willValidate"]
  val checkValidity: 'tags this -> bool [@@js.call "checkValidity"]
  val reportValidity: 'tags this -> bool [@@js.call "reportValidity"]
  val setCustomValidity: 'tags this -> error:string -> unit [@@js.call "setCustomValidity"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Provides special properties and methods (beyond those on the HTMLElement interface it also has available to it by inheritance) for manipulating the layout and presentation of <object> element, representing external resources. *)
module[@js.scope "HTMLObjectElement"] HTMLObjectElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLObjectElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLObjectElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLObjectElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLObjectElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** @deprecated  *)
  val get_align: 'tags this -> string [@@js.get "align"]
  
  (** @deprecated  *)
  val set_align: 'tags this -> string -> unit [@@js.set "align"]
  
  (**
    Sets or retrieves a character string that can be used to implement your own archive functionality for the object.
    @deprecated 
  *)
  val get_archive: 'tags this -> string [@@js.get "archive"]
  
  (**
    Sets or retrieves a character string that can be used to implement your own archive functionality for the object.
    @deprecated 
  *)
  val set_archive: 'tags this -> string -> unit [@@js.set "archive"]
  
  (** @deprecated  *)
  val get_border: 'tags this -> string [@@js.get "border"]
  
  (** @deprecated  *)
  val set_border: 'tags this -> string -> unit [@@js.set "border"]
  
  (**
    Sets or retrieves the URL of the file containing the compiled Java class.
    @deprecated 
  *)
  val get_code: 'tags this -> string [@@js.get "code"]
  
  (**
    Sets or retrieves the URL of the file containing the compiled Java class.
    @deprecated 
  *)
  val set_code: 'tags this -> string -> unit [@@js.set "code"]
  
  (**
    Sets or retrieves the URL of the component.
    @deprecated 
  *)
  val get_codeBase: 'tags this -> string [@@js.get "codeBase"]
  
  (**
    Sets or retrieves the URL of the component.
    @deprecated 
  *)
  val set_codeBase: 'tags this -> string -> unit [@@js.set "codeBase"]
  
  (**
    Sets or retrieves the Internet media type for the code associated with the object.
    @deprecated 
  *)
  val get_codeType: 'tags this -> string [@@js.get "codeType"]
  
  (**
    Sets or retrieves the Internet media type for the code associated with the object.
    @deprecated 
  *)
  val set_codeType: 'tags this -> string -> unit [@@js.set "codeType"]
  
  (** Retrieves the document object of the page or frame. *)
  val get_contentDocument: 'tags this -> Document.t option [@@js.get "contentDocument"]
  val get_contentWindow: 'tags this -> WindowProxy.t option [@@js.get "contentWindow"]
  
  (** Sets or retrieves the URL that references the data of the object. *)
  val get_data: 'tags this -> string [@@js.get "data"]
  
  (** Sets or retrieves the URL that references the data of the object. *)
  val set_data: 'tags this -> string -> unit [@@js.set "data"]
  
  (** @deprecated  *)
  val get_declare: 'tags this -> bool [@@js.get "declare"]
  
  (** @deprecated  *)
  val set_declare: 'tags this -> bool -> unit [@@js.set "declare"]
  
  (** Retrieves a reference to the form that the object is embedded in. *)
  val get_form: 'tags this -> HTMLFormElement.t option [@@js.get "form"]
  
  (** Sets or retrieves the height of the object. *)
  val get_height: 'tags this -> string [@@js.get "height"]
  
  (** Sets or retrieves the height of the object. *)
  val set_height: 'tags this -> string -> unit [@@js.set "height"]
  
  (** @deprecated  *)
  val get_hspace: 'tags this -> float [@@js.get "hspace"]
  
  (** @deprecated  *)
  val set_hspace: 'tags this -> float -> unit [@@js.set "hspace"]
  
  (** Sets or retrieves the name of the object. *)
  val get_name: 'tags this -> string [@@js.get "name"]
  
  (** Sets or retrieves the name of the object. *)
  val set_name: 'tags this -> string -> unit [@@js.set "name"]
  
  (**
    Sets or retrieves a message to be displayed while an object is loading.
    @deprecated 
  *)
  val get_standby: 'tags this -> string [@@js.get "standby"]
  
  (**
    Sets or retrieves a message to be displayed while an object is loading.
    @deprecated 
  *)
  val set_standby: 'tags this -> string -> unit [@@js.set "standby"]
  
  (** Sets or retrieves the MIME type of the object. *)
  val get_type: 'tags this -> string [@@js.get "type"]
  
  (** Sets or retrieves the MIME type of the object. *)
  val set_type: 'tags this -> string -> unit [@@js.set "type"]
  
  (** Sets or retrieves the URL, often with a bookmark extension (#name), to use as a client-side image map. *)
  val get_useMap: 'tags this -> string [@@js.get "useMap"]
  
  (** Sets or retrieves the URL, often with a bookmark extension (#name), to use as a client-side image map. *)
  val set_useMap: 'tags this -> string -> unit [@@js.set "useMap"]
  
  (** Returns the error message that would be displayed if the user submits the form, or an empty string if no error message. It also triggers the standard error message, such as "this is a required field". The result is that the user sees validation messages without actually submitting. *)
  val get_validationMessage: 'tags this -> string [@@js.get "validationMessage"]
  
  (** Returns a  ValidityState object that represents the validity states of an element. *)
  val get_validity: 'tags this -> ValidityState.t [@@js.get "validity"]
  
  (** @deprecated  *)
  val get_vspace: 'tags this -> float [@@js.get "vspace"]
  
  (** @deprecated  *)
  val set_vspace: 'tags this -> float -> unit [@@js.set "vspace"]
  
  (** Sets or retrieves the width of the object. *)
  val get_width: 'tags this -> string [@@js.get "width"]
  
  (** Sets or retrieves the width of the object. *)
  val set_width: 'tags this -> string -> unit [@@js.set "width"]
  
  (** Returns whether an element will successfully validate based on forms validation rules and constraints. *)
  val get_willValidate: 'tags this -> bool [@@js.get "willValidate"]
  
  (** Returns whether a form will validate when it is submitted, without having to submit it. *)
  val checkValidity: 'tags this -> bool [@@js.call "checkValidity"]
  val getSVGDocument: 'tags this -> Document.t option [@@js.call "getSVGDocument"]
  val reportValidity: 'tags this -> bool [@@js.call "reportValidity"]
  
  (**
    Sets a custom error message that is displayed when a form is submitted.
    @param error Sets a custom error message that is displayed when a form is submitted.
  *)
  val setCustomValidity: 'tags this -> error:string -> unit [@@js.call "setCustomValidity"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Provides special properties (beyond those defined on the regular HTMLElement interface it also has available to it by inheritance) for manipulating ordered list elements. *)
module[@js.scope "HTMLOListElement"] HTMLOListElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOListElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOListElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLOListElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLOListElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** @deprecated  *)
  val get_compact: 'tags this -> bool [@@js.get "compact"]
  
  (** @deprecated  *)
  val set_compact: 'tags this -> bool -> unit [@@js.set "compact"]
  val get_reversed: 'tags this -> bool [@@js.get "reversed"]
  val set_reversed: 'tags this -> bool -> unit [@@js.set "reversed"]
  
  (** The starting number. *)
  val get_start: 'tags this -> float [@@js.get "start"]
  
  (** The starting number. *)
  val set_start: 'tags this -> float -> unit [@@js.set "start"]
  val get_type: 'tags this -> string [@@js.get "type"]
  val set_type: 'tags this -> string -> unit [@@js.set "type"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Provides special properties (beyond the regular methods and properties available through the HTMLElement interface they also have available to them by inheritance) for manipulating modification elements, that is <del> and <ins>. *)
module[@js.scope "HTMLModElement"] HTMLModElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLModElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLModElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLModElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLModElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Sets or retrieves reference information about the object. *)
  val get_cite: 'tags this -> string [@@js.get "cite"]
  
  (** Sets or retrieves reference information about the object. *)
  val set_cite: 'tags this -> string -> unit [@@js.set "cite"]
  
  (** Sets or retrieves the date and time of a modification to the object. *)
  val get_dateTime: 'tags this -> string [@@js.get "dateTime"]
  
  (** Sets or retrieves the date and time of a modification to the object. *)
  val set_dateTime: 'tags this -> string -> unit [@@js.set "dateTime"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** The HTML <meter> elements expose the HTMLMeterElement interface, which provides special properties and methods (beyond the HTMLElement object interface they also have available to them by inheritance) for manipulating the layout and presentation of <meter> elements. *)
module[@js.scope "HTMLMeterElement"] HTMLMeterElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLMeterElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLMeterElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLMeterElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLMeterElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_high: 'tags this -> float [@@js.get "high"]
  val set_high: 'tags this -> float -> unit [@@js.set "high"]
  val get_labels: 'tags this -> HTMLLabelElement.t NodeListOf.t [@@js.get "labels"]
  val get_low: 'tags this -> float [@@js.get "low"]
  val set_low: 'tags this -> float -> unit [@@js.set "low"]
  val get_max: 'tags this -> float [@@js.get "max"]
  val set_max: 'tags this -> float -> unit [@@js.set "max"]
  val get_min: 'tags this -> float [@@js.get "min"]
  val set_min: 'tags this -> float -> unit [@@js.set "min"]
  val get_optimum: 'tags this -> float [@@js.get "optimum"]
  val set_optimum: 'tags this -> float -> unit [@@js.set "optimum"]
  val get_value: 'tags this -> float [@@js.get "value"]
  val set_value: 'tags this -> float -> unit [@@js.set "value"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Contains descriptive metadata about a document. It inherits all of the properties and methods described in the HTMLElement interface. *)
module[@js.scope "HTMLMetaElement"] HTMLMetaElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLMetaElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLMetaElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLMetaElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLMetaElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Gets or sets meta-information to associate with httpEquiv or name. *)
  val get_content: 'tags this -> string [@@js.get "content"]
  
  (** Gets or sets meta-information to associate with httpEquiv or name. *)
  val set_content: 'tags this -> string -> unit [@@js.set "content"]
  
  (** Gets or sets information used to bind the value of a content attribute of a meta element to an HTTP response header. *)
  val get_httpEquiv: 'tags this -> string [@@js.get "httpEquiv"]
  
  (** Gets or sets information used to bind the value of a content attribute of a meta element to an HTTP response header. *)
  val set_httpEquiv: 'tags this -> string -> unit [@@js.set "httpEquiv"]
  val get_media: 'tags this -> string [@@js.get "media"]
  val set_media: 'tags this -> string -> unit [@@js.set "media"]
  
  (** Sets or retrieves the value specified in the content attribute of the meta object. *)
  val get_name: 'tags this -> string [@@js.get "name"]
  
  (** Sets or retrieves the value specified in the content attribute of the meta object. *)
  val set_name: 'tags this -> string -> unit [@@js.set "name"]
  
  (**
    Sets or retrieves a scheme to be used in interpreting the value of a property specified for the object.
    @deprecated 
  *)
  val get_scheme: 'tags this -> string [@@js.get "scheme"]
  
  (**
    Sets or retrieves a scheme to be used in interpreting the value of a property specified for the object.
    @deprecated 
  *)
  val set_scheme: 'tags this -> string -> unit [@@js.set "scheme"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module[@js.scope "HTMLMenuElement"] HTMLMenuElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLMenuElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLMenuElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLMenuElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLMenuElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** @deprecated  *)
  val get_compact: 'tags this -> bool [@@js.get "compact"]
  
  (** @deprecated  *)
  val set_compact: 'tags this -> bool -> unit [@@js.set "compact"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Provides methods to manipulate <marquee> elements. *)
module[@js.scope "HTMLMarqueeElement"] HTMLMarqueeElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLMarqueeElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLMarqueeElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLMarqueeElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLMarqueeElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** @deprecated  *)
  val get_behavior: 'tags this -> string [@@js.get "behavior"]
  
  (** @deprecated  *)
  val set_behavior: 'tags this -> string -> unit [@@js.set "behavior"]
  
  (** @deprecated  *)
  val get_bgColor: 'tags this -> string [@@js.get "bgColor"]
  
  (** @deprecated  *)
  val set_bgColor: 'tags this -> string -> unit [@@js.set "bgColor"]
  
  (** @deprecated  *)
  val get_direction: 'tags this -> string [@@js.get "direction"]
  
  (** @deprecated  *)
  val set_direction: 'tags this -> string -> unit [@@js.set "direction"]
  
  (** @deprecated  *)
  val get_height: 'tags this -> string [@@js.get "height"]
  
  (** @deprecated  *)
  val set_height: 'tags this -> string -> unit [@@js.set "height"]
  
  (** @deprecated  *)
  val get_hspace: 'tags this -> float [@@js.get "hspace"]
  
  (** @deprecated  *)
  val set_hspace: 'tags this -> float -> unit [@@js.set "hspace"]
  
  (** @deprecated  *)
  val get_loop: 'tags this -> float [@@js.get "loop"]
  
  (** @deprecated  *)
  val set_loop: 'tags this -> float -> unit [@@js.set "loop"]
  
  (** @deprecated  *)
  val get_scrollAmount: 'tags this -> float [@@js.get "scrollAmount"]
  
  (** @deprecated  *)
  val set_scrollAmount: 'tags this -> float -> unit [@@js.set "scrollAmount"]
  
  (** @deprecated  *)
  val get_scrollDelay: 'tags this -> float [@@js.get "scrollDelay"]
  
  (** @deprecated  *)
  val set_scrollDelay: 'tags this -> float -> unit [@@js.set "scrollDelay"]
  
  (** @deprecated  *)
  val get_trueSpeed: 'tags this -> bool [@@js.get "trueSpeed"]
  
  (** @deprecated  *)
  val set_trueSpeed: 'tags this -> bool -> unit [@@js.set "trueSpeed"]
  
  (** @deprecated  *)
  val get_vspace: 'tags this -> float [@@js.get "vspace"]
  
  (** @deprecated  *)
  val set_vspace: 'tags this -> float -> unit [@@js.set "vspace"]
  
  (** @deprecated  *)
  val get_width: 'tags this -> string [@@js.get "width"]
  
  (** @deprecated  *)
  val set_width: 'tags this -> string -> unit [@@js.set "width"]
  
  (** @deprecated  *)
  val start: 'tags this -> unit [@@js.call "start"]
  
  (** @deprecated  *)
  val stop: 'tags this -> unit [@@js.call "stop"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Provides special properties and methods (beyond those of the regular object HTMLElement interface it also has available to it by inheritance) for manipulating the layout and presentation of map elements. *)
module[@js.scope "HTMLMapElement"] HTMLMapElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLMapElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLMapElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLMapElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLMapElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Retrieves a collection of the area objects defined for the given map object. *)
  val get_areas: 'tags this -> HTMLCollection.t [@@js.get "areas"]
  
  (** Sets or retrieves the name of the object. *)
  val get_name: 'tags this -> string [@@js.get "name"]
  
  (** Sets or retrieves the name of the object. *)
  val set_name: 'tags this -> string -> unit [@@js.set "name"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Reference information for external resources and the relationship of those resources to a document and vice-versa. This object inherits all of the properties and methods of the HTMLElement interface. *)
module[@js.scope "HTMLLinkElement"] HTMLLinkElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLLinkElement | `HTMLOrSVGElement | `InnerHTML | `LinkStyle | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLLinkElement | `HTMLOrSVGElement | `InnerHTML | `LinkStyle | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLLinkElement | `HTMLOrSVGElement | `InnerHTML | `LinkStyle | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLLinkElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_as: 'tags this -> string [@@js.get "as"]
  val set_as: 'tags this -> string -> unit [@@js.set "as"]
  
  (**
    Sets or retrieves the character set used to encode the object.
    @deprecated 
  *)
  val get_charset: 'tags this -> string [@@js.get "charset"]
  
  (**
    Sets or retrieves the character set used to encode the object.
    @deprecated 
  *)
  val set_charset: 'tags this -> string -> unit [@@js.set "charset"]
  val get_crossOrigin: 'tags this -> string option [@@js.get "crossOrigin"]
  val set_crossOrigin: 'tags this -> string option -> unit [@@js.set "crossOrigin"]
  val get_disabled: 'tags this -> bool [@@js.get "disabled"]
  val set_disabled: 'tags this -> bool -> unit [@@js.set "disabled"]
  
  (** Sets or retrieves a destination URL or an anchor point. *)
  val get_href: 'tags this -> string [@@js.get "href"]
  
  (** Sets or retrieves a destination URL or an anchor point. *)
  val set_href: 'tags this -> string -> unit [@@js.set "href"]
  
  (** Sets or retrieves the language code of the object. *)
  val get_hreflang: 'tags this -> string [@@js.get "hreflang"]
  
  (** Sets or retrieves the language code of the object. *)
  val set_hreflang: 'tags this -> string -> unit [@@js.set "hreflang"]
  val get_imageSizes: 'tags this -> string [@@js.get "imageSizes"]
  val set_imageSizes: 'tags this -> string -> unit [@@js.set "imageSizes"]
  val get_imageSrcset: 'tags this -> string [@@js.get "imageSrcset"]
  val set_imageSrcset: 'tags this -> string -> unit [@@js.set "imageSrcset"]
  val get_integrity: 'tags this -> string [@@js.get "integrity"]
  val set_integrity: 'tags this -> string -> unit [@@js.set "integrity"]
  
  (** Sets or retrieves the media type. *)
  val get_media: 'tags this -> string [@@js.get "media"]
  
  (** Sets or retrieves the media type. *)
  val set_media: 'tags this -> string -> unit [@@js.set "media"]
  val get_referrerPolicy: 'tags this -> string [@@js.get "referrerPolicy"]
  val set_referrerPolicy: 'tags this -> string -> unit [@@js.set "referrerPolicy"]
  
  (** Sets or retrieves the relationship between the object and the destination of the link. *)
  val get_rel: 'tags this -> string [@@js.get "rel"]
  
  (** Sets or retrieves the relationship between the object and the destination of the link. *)
  val set_rel: 'tags this -> string -> unit [@@js.set "rel"]
  val get_relList: 'tags this -> DOMTokenList.t [@@js.get "relList"]
  
  (**
    Sets or retrieves the relationship between the object and the destination of the link.
    @deprecated 
  *)
  val get_rev: 'tags this -> string [@@js.get "rev"]
  
  (**
    Sets or retrieves the relationship between the object and the destination of the link.
    @deprecated 
  *)
  val set_rev: 'tags this -> string -> unit [@@js.set "rev"]
  val get_sizes: 'tags this -> DOMTokenList.t [@@js.get "sizes"]
  
  (**
    Sets or retrieves the window or frame at which to target content.
    @deprecated 
  *)
  val get_target: 'tags this -> string [@@js.get "target"]
  
  (**
    Sets or retrieves the window or frame at which to target content.
    @deprecated 
  *)
  val set_target: 'tags this -> string -> unit [@@js.set "target"]
  
  (** Sets or retrieves the MIME type of the object. *)
  val get_type: 'tags this -> string [@@js.get "type"]
  
  (** Sets or retrieves the MIME type of the object. *)
  val set_type: 'tags this -> string -> unit [@@js.set "type"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** The HTMLLegendElement is an interface allowing to access properties of the <legend> elements. It inherits properties and methods from the HTMLElement interface. *)
module[@js.scope "HTMLLegendElement"] HTMLLegendElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLLegendElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLLegendElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLLegendElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLLegendElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** @deprecated  *)
  val get_align: 'tags this -> string [@@js.get "align"]
  
  (** @deprecated  *)
  val set_align: 'tags this -> string -> unit [@@js.set "align"]
  
  (** Retrieves a reference to the form that the object is embedded in. *)
  val get_form: 'tags this -> HTMLFormElement.t option [@@js.get "form"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Exposes specific properties and methods (beyond those defined by regular HTMLElement interface it also has available to it by inheritance) for manipulating list elements. *)
module[@js.scope "HTMLLIElement"] HTMLLIElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLLIElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLLIElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLLIElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLLIElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** @deprecated  *)
  val get_type: 'tags this -> string [@@js.get "type"]
  
  (** @deprecated  *)
  val set_type: 'tags this -> string -> unit [@@js.set "type"]
  
  (** Sets or retrieves the value of a list item. *)
  val get_value: 'tags this -> float [@@js.get "value"]
  
  (** Sets or retrieves the value of a list item. *)
  val set_value: 'tags this -> float -> unit [@@js.set "value"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Provides special properties and methods for manipulating the options, layout, and presentation of <input> elements. *)
module[@js.scope "HTMLInputElement"] HTMLInputElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLInputElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLInputElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLInputElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLInputElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Sets or retrieves a comma-separated list of content types. *)
  val get_accept: 'tags this -> string [@@js.get "accept"]
  
  (** Sets or retrieves a comma-separated list of content types. *)
  val set_accept: 'tags this -> string -> unit [@@js.set "accept"]
  
  (**
    Sets or retrieves how the object is aligned with adjacent text.
    @deprecated 
  *)
  val get_align: 'tags this -> string [@@js.get "align"]
  
  (**
    Sets or retrieves how the object is aligned with adjacent text.
    @deprecated 
  *)
  val set_align: 'tags this -> string -> unit [@@js.set "align"]
  
  (** Sets or retrieves a text alternative to the graphic. *)
  val get_alt: 'tags this -> string [@@js.get "alt"]
  
  (** Sets or retrieves a text alternative to the graphic. *)
  val set_alt: 'tags this -> string -> unit [@@js.set "alt"]
  
  (** Specifies whether autocomplete is applied to an editable text field. *)
  val get_autocomplete: 'tags this -> string [@@js.get "autocomplete"]
  
  (** Specifies whether autocomplete is applied to an editable text field. *)
  val set_autocomplete: 'tags this -> string -> unit [@@js.set "autocomplete"]
  val get_capture: 'tags this -> string [@@js.get "capture"]
  val set_capture: 'tags this -> string -> unit [@@js.set "capture"]
  
  (** Sets or retrieves the state of the check box or radio button. *)
  val get_checked: 'tags this -> bool [@@js.get "checked"]
  
  (** Sets or retrieves the state of the check box or radio button. *)
  val set_checked: 'tags this -> bool -> unit [@@js.set "checked"]
  
  (** Sets or retrieves the state of the check box or radio button. *)
  val get_defaultChecked: 'tags this -> bool [@@js.get "defaultChecked"]
  
  (** Sets or retrieves the state of the check box or radio button. *)
  val set_defaultChecked: 'tags this -> bool -> unit [@@js.set "defaultChecked"]
  
  (** Sets or retrieves the initial contents of the object. *)
  val get_defaultValue: 'tags this -> string [@@js.get "defaultValue"]
  
  (** Sets or retrieves the initial contents of the object. *)
  val set_defaultValue: 'tags this -> string -> unit [@@js.set "defaultValue"]
  val get_dirName: 'tags this -> string [@@js.get "dirName"]
  val set_dirName: 'tags this -> string -> unit [@@js.set "dirName"]
  val get_disabled: 'tags this -> bool [@@js.get "disabled"]
  val set_disabled: 'tags this -> bool -> unit [@@js.set "disabled"]
  
  (** Returns a FileList object on a file type input object. *)
  val get_files: 'tags this -> FileList.t option [@@js.get "files"]
  
  (** Returns a FileList object on a file type input object. *)
  val set_files: 'tags this -> FileList.t option -> unit [@@js.set "files"]
  
  (** Retrieves a reference to the form that the object is embedded in. *)
  val get_form: 'tags this -> HTMLFormElement.t option [@@js.get "form"]
  
  (** Overrides the action attribute (where the data on a form is sent) on the parent form element. *)
  val get_formAction: 'tags this -> string [@@js.get "formAction"]
  
  (** Overrides the action attribute (where the data on a form is sent) on the parent form element. *)
  val set_formAction: 'tags this -> string -> unit [@@js.set "formAction"]
  
  (** Used to override the encoding (formEnctype attribute) specified on the form element. *)
  val get_formEnctype: 'tags this -> string [@@js.get "formEnctype"]
  
  (** Used to override the encoding (formEnctype attribute) specified on the form element. *)
  val set_formEnctype: 'tags this -> string -> unit [@@js.set "formEnctype"]
  
  (** Overrides the submit method attribute previously specified on a form element. *)
  val get_formMethod: 'tags this -> string [@@js.get "formMethod"]
  
  (** Overrides the submit method attribute previously specified on a form element. *)
  val set_formMethod: 'tags this -> string -> unit [@@js.set "formMethod"]
  
  (** Overrides any validation or required attributes on a form or form elements to allow it to be submitted without validation. This can be used to create a "save draft"-type submit option. *)
  val get_formNoValidate: 'tags this -> bool [@@js.get "formNoValidate"]
  
  (** Overrides any validation or required attributes on a form or form elements to allow it to be submitted without validation. This can be used to create a "save draft"-type submit option. *)
  val set_formNoValidate: 'tags this -> bool -> unit [@@js.set "formNoValidate"]
  
  (** Overrides the target attribute on a form element. *)
  val get_formTarget: 'tags this -> string [@@js.get "formTarget"]
  
  (** Overrides the target attribute on a form element. *)
  val set_formTarget: 'tags this -> string -> unit [@@js.set "formTarget"]
  
  (** Sets or retrieves the height of the object. *)
  val get_height: 'tags this -> float [@@js.get "height"]
  
  (** Sets or retrieves the height of the object. *)
  val set_height: 'tags this -> float -> unit [@@js.set "height"]
  
  (** When set, overrides the rendering of checkbox controls so that the current value is not visible. *)
  val get_indeterminate: 'tags this -> bool [@@js.get "indeterminate"]
  
  (** When set, overrides the rendering of checkbox controls so that the current value is not visible. *)
  val set_indeterminate: 'tags this -> bool -> unit [@@js.set "indeterminate"]
  val get_labels: 'tags this -> HTMLLabelElement.t NodeListOf.t option [@@js.get "labels"]
  
  (** Specifies the ID of a pre-defined datalist of options for an input element. *)
  val get_list: 'tags this -> HTMLElement.t option [@@js.get "list"]
  
  (** Defines the maximum acceptable value for an input element with type="number".When used with the min and step attributes, lets you control the range and increment (such as only even numbers) that the user can enter into an input field. *)
  val get_max: 'tags this -> string [@@js.get "max"]
  
  (** Defines the maximum acceptable value for an input element with type="number".When used with the min and step attributes, lets you control the range and increment (such as only even numbers) that the user can enter into an input field. *)
  val set_max: 'tags this -> string -> unit [@@js.set "max"]
  
  (** Sets or retrieves the maximum number of characters that the user can enter in a text control. *)
  val get_maxLength: 'tags this -> float [@@js.get "maxLength"]
  
  (** Sets or retrieves the maximum number of characters that the user can enter in a text control. *)
  val set_maxLength: 'tags this -> float -> unit [@@js.set "maxLength"]
  
  (** Defines the minimum acceptable value for an input element with type="number". When used with the max and step attributes, lets you control the range and increment (such as even numbers only) that the user can enter into an input field. *)
  val get_min: 'tags this -> string [@@js.get "min"]
  
  (** Defines the minimum acceptable value for an input element with type="number". When used with the max and step attributes, lets you control the range and increment (such as even numbers only) that the user can enter into an input field. *)
  val set_min: 'tags this -> string -> unit [@@js.set "min"]
  val get_minLength: 'tags this -> float [@@js.get "minLength"]
  val set_minLength: 'tags this -> float -> unit [@@js.set "minLength"]
  
  (** Sets or retrieves the Boolean value indicating whether multiple items can be selected from a list. *)
  val get_multiple: 'tags this -> bool [@@js.get "multiple"]
  
  (** Sets or retrieves the Boolean value indicating whether multiple items can be selected from a list. *)
  val set_multiple: 'tags this -> bool -> unit [@@js.set "multiple"]
  
  (** Sets or retrieves the name of the object. *)
  val get_name: 'tags this -> string [@@js.get "name"]
  
  (** Sets or retrieves the name of the object. *)
  val set_name: 'tags this -> string -> unit [@@js.set "name"]
  
  (** Gets or sets a string containing a regular expression that the user's input must match. *)
  val get_pattern: 'tags this -> string [@@js.get "pattern"]
  
  (** Gets or sets a string containing a regular expression that the user's input must match. *)
  val set_pattern: 'tags this -> string -> unit [@@js.set "pattern"]
  
  (** Gets or sets a text string that is displayed in an input field as a hint or prompt to users as the format or type of information they need to enter.The text appears in an input field until the user puts focus on the field. *)
  val get_placeholder: 'tags this -> string [@@js.get "placeholder"]
  
  (** Gets or sets a text string that is displayed in an input field as a hint or prompt to users as the format or type of information they need to enter.The text appears in an input field until the user puts focus on the field. *)
  val set_placeholder: 'tags this -> string -> unit [@@js.set "placeholder"]
  val get_readOnly: 'tags this -> bool [@@js.get "readOnly"]
  val set_readOnly: 'tags this -> bool -> unit [@@js.set "readOnly"]
  
  (** When present, marks an element that can't be submitted without a value. *)
  val get_required: 'tags this -> bool [@@js.get "required"]
  
  (** When present, marks an element that can't be submitted without a value. *)
  val set_required: 'tags this -> bool -> unit [@@js.set "required"]
  val get_selectionDirection: 'tags this -> ([`L_s145_backward[@js "backward"] | `L_s358_forward[@js "forward"] | `L_s548_none[@js "none"]] [@js.enum]) option [@@js.get "selectionDirection"]
  val set_selectionDirection: 'tags this -> ([`Null | `U1 of ([`L_s358_forward[@js "forward"]] [@js.enum]) | `U2 of ([`L_s145_backward[@js "backward"]] [@js.enum]) | `U3 of ([`L_s548_none[@js "none"]] [@js.enum])] [@js.union]) -> unit [@@js.set "selectionDirection"]
  
  (** Gets or sets the end position or offset of a text selection. *)
  val get_selectionEnd: 'tags this -> float option [@@js.get "selectionEnd"]
  
  (** Gets or sets the end position or offset of a text selection. *)
  val set_selectionEnd: 'tags this -> float option -> unit [@@js.set "selectionEnd"]
  
  (** Gets or sets the starting position or offset of a text selection. *)
  val get_selectionStart: 'tags this -> float option [@@js.get "selectionStart"]
  
  (** Gets or sets the starting position or offset of a text selection. *)
  val set_selectionStart: 'tags this -> float option -> unit [@@js.set "selectionStart"]
  val get_size: 'tags this -> float [@@js.get "size"]
  val set_size: 'tags this -> float -> unit [@@js.set "size"]
  
  (** The address or URL of the a media resource that is to be considered. *)
  val get_src: 'tags this -> string [@@js.get "src"]
  
  (** The address or URL of the a media resource that is to be considered. *)
  val set_src: 'tags this -> string -> unit [@@js.set "src"]
  
  (** Defines an increment or jump between values that you want to allow the user to enter. When used with the max and min attributes, lets you control the range and increment (for example, allow only even numbers) that the user can enter into an input field. *)
  val get_step: 'tags this -> string [@@js.get "step"]
  
  (** Defines an increment or jump between values that you want to allow the user to enter. When used with the max and min attributes, lets you control the range and increment (for example, allow only even numbers) that the user can enter into an input field. *)
  val set_step: 'tags this -> string -> unit [@@js.set "step"]
  
  (** Returns the content type of the object. *)
  val get_type: 'tags this -> string [@@js.get "type"]
  
  (** Returns the content type of the object. *)
  val set_type: 'tags this -> string -> unit [@@js.set "type"]
  
  (**
    Sets or retrieves the URL, often with a bookmark extension (#name), to use as a client-side image map.
    @deprecated 
  *)
  val get_useMap: 'tags this -> string [@@js.get "useMap"]
  
  (**
    Sets or retrieves the URL, often with a bookmark extension (#name), to use as a client-side image map.
    @deprecated 
  *)
  val set_useMap: 'tags this -> string -> unit [@@js.set "useMap"]
  
  (** Returns the error message that would be displayed if the user submits the form, or an empty string if no error message. It also triggers the standard error message, such as "this is a required field". The result is that the user sees validation messages without actually submitting. *)
  val get_validationMessage: 'tags this -> string [@@js.get "validationMessage"]
  
  (** Returns a  ValidityState object that represents the validity states of an element. *)
  val get_validity: 'tags this -> ValidityState.t [@@js.get "validity"]
  
  (** Returns the value of the data at the cursor's current position. *)
  val get_value: 'tags this -> string [@@js.get "value"]
  
  (** Returns the value of the data at the cursor's current position. *)
  val set_value: 'tags this -> string -> unit [@@js.set "value"]
  
  (** Returns a Date object representing the form control's value, if applicable; otherwise, returns null. Can be set, to change the value. Throws an "InvalidStateError" DOMException if the control isn't date- or time-based. *)
  val get_valueAsDate: 'tags this -> Date.t_0 option [@@js.get "valueAsDate"]
  
  (** Returns a Date object representing the form control's value, if applicable; otherwise, returns null. Can be set, to change the value. Throws an "InvalidStateError" DOMException if the control isn't date- or time-based. *)
  val set_valueAsDate: 'tags this -> Date.t_0 option -> unit [@@js.set "valueAsDate"]
  
  (** Returns the input field value as a number. *)
  val get_valueAsNumber: 'tags this -> float [@@js.get "valueAsNumber"]
  
  (** Returns the input field value as a number. *)
  val set_valueAsNumber: 'tags this -> float -> unit [@@js.set "valueAsNumber"]
  val get_webkitEntries: 'tags this -> FileSystemEntry.t list [@@js.get "webkitEntries"]
  val get_webkitdirectory: 'tags this -> bool [@@js.get "webkitdirectory"]
  val set_webkitdirectory: 'tags this -> bool -> unit [@@js.set "webkitdirectory"]
  
  (** Sets or retrieves the width of the object. *)
  val get_width: 'tags this -> float [@@js.get "width"]
  
  (** Sets or retrieves the width of the object. *)
  val set_width: 'tags this -> float -> unit [@@js.set "width"]
  
  (** Returns whether an element will successfully validate based on forms validation rules and constraints. *)
  val get_willValidate: 'tags this -> bool [@@js.get "willValidate"]
  
  (** Returns whether a form will validate when it is submitted, without having to submit it. *)
  val checkValidity: 'tags this -> bool [@@js.call "checkValidity"]
  val reportValidity: 'tags this -> bool [@@js.call "reportValidity"]
  
  (** Makes the selection equal to the current object. *)
  val select: 'tags this -> unit [@@js.call "select"]
  
  (**
    Sets a custom error message that is displayed when a form is submitted.
    @param error Sets a custom error message that is displayed when a form is submitted.
  *)
  val setCustomValidity: 'tags this -> error:string -> unit [@@js.call "setCustomValidity"]
  val setRangeText: 'tags this -> replacement:string -> unit [@@js.call "setRangeText"]
  val setRangeText': 'tags this -> replacement:string -> start:float -> end_:float -> ?selectionMode:SelectionMode.t -> unit -> unit [@@js.call "setRangeText"]
  
  (**
    Sets the start and end positions of a selection in a text field.
    @param start The offset into the text field for the start of the selection.
    @param end The offset into the text field for the end of the selection.
    @param direction The direction in which the selection is performed.
  *)
  val setSelectionRange: 'tags this -> start:float option -> end_:float option -> ?direction:([`U1 of ([`L_s358_forward[@js "forward"]] [@js.enum]) | `U2 of ([`L_s145_backward[@js "backward"]] [@js.enum]) | `U3 of ([`L_s548_none[@js "none"]] [@js.enum])] [@js.union]) -> unit -> unit [@@js.call "setSelectionRange"]
  
  (**
    Decrements a range input control's value by the value given by the Step attribute. If the optional parameter is used, it will decrement the input control's step value multiplied by the parameter's value.
    @param n Value to decrement the value by.
  *)
  val stepDown: 'tags this -> ?n:float -> unit -> unit [@@js.call "stepDown"]
  
  (**
    Increments a range input control's value by the value given by the Step attribute. If the optional parameter is used, will increment the input control's value by that value.
    @param n Value to increment the value by.
  *)
  val stepUp: 'tags this -> ?n:float -> unit -> unit [@@js.call "stepUp"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Provides special properties and methods (beyond those of the HTMLElement interface it also has available to it by inheritance) for manipulating the layout and presentation of inline frame elements. *)
module[@js.scope "HTMLIFrameElement"] HTMLIFrameElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLIFrameElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLIFrameElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLIFrameElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLIFrameElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    Sets or retrieves how the object is aligned with adjacent text.
    @deprecated 
  *)
  val get_align: 'tags this -> string [@@js.get "align"]
  
  (**
    Sets or retrieves how the object is aligned with adjacent text.
    @deprecated 
  *)
  val set_align: 'tags this -> string -> unit [@@js.set "align"]
  val get_allow: 'tags this -> string [@@js.get "allow"]
  val set_allow: 'tags this -> string -> unit [@@js.set "allow"]
  val get_allowFullscreen: 'tags this -> bool [@@js.get "allowFullscreen"]
  val set_allowFullscreen: 'tags this -> bool -> unit [@@js.set "allowFullscreen"]
  
  (** Retrieves the document object of the page or frame. *)
  val get_contentDocument: 'tags this -> Document.t option [@@js.get "contentDocument"]
  
  (** Retrieves the object of the specified. *)
  val get_contentWindow: 'tags this -> WindowProxy.t option [@@js.get "contentWindow"]
  
  (**
    Sets or retrieves whether to display a border for the frame.
    @deprecated 
  *)
  val get_frameBorder: 'tags this -> string [@@js.get "frameBorder"]
  
  (**
    Sets or retrieves whether to display a border for the frame.
    @deprecated 
  *)
  val set_frameBorder: 'tags this -> string -> unit [@@js.set "frameBorder"]
  
  (** Sets or retrieves the height of the object. *)
  val get_height: 'tags this -> string [@@js.get "height"]
  
  (** Sets or retrieves the height of the object. *)
  val set_height: 'tags this -> string -> unit [@@js.set "height"]
  
  (**
    Sets or retrieves a URI to a long description of the object.
    @deprecated 
  *)
  val get_longDesc: 'tags this -> string [@@js.get "longDesc"]
  
  (**
    Sets or retrieves a URI to a long description of the object.
    @deprecated 
  *)
  val set_longDesc: 'tags this -> string -> unit [@@js.set "longDesc"]
  
  (**
    Sets or retrieves the top and bottom margin heights before displaying the text in a frame.
    @deprecated 
  *)
  val get_marginHeight: 'tags this -> string [@@js.get "marginHeight"]
  
  (**
    Sets or retrieves the top and bottom margin heights before displaying the text in a frame.
    @deprecated 
  *)
  val set_marginHeight: 'tags this -> string -> unit [@@js.set "marginHeight"]
  
  (**
    Sets or retrieves the left and right margin widths before displaying the text in a frame.
    @deprecated 
  *)
  val get_marginWidth: 'tags this -> string [@@js.get "marginWidth"]
  
  (**
    Sets or retrieves the left and right margin widths before displaying the text in a frame.
    @deprecated 
  *)
  val set_marginWidth: 'tags this -> string -> unit [@@js.set "marginWidth"]
  
  (** Sets or retrieves the frame name. *)
  val get_name: 'tags this -> string [@@js.get "name"]
  
  (** Sets or retrieves the frame name. *)
  val set_name: 'tags this -> string -> unit [@@js.set "name"]
  val get_referrerPolicy: 'tags this -> ReferrerPolicy.t [@@js.get "referrerPolicy"]
  val set_referrerPolicy: 'tags this -> ReferrerPolicy.t -> unit [@@js.set "referrerPolicy"]
  val get_sandbox: 'tags this -> DOMTokenList.t [@@js.get "sandbox"]
  
  (**
    Sets or retrieves whether the frame can be scrolled.
    @deprecated 
  *)
  val get_scrolling: 'tags this -> string [@@js.get "scrolling"]
  
  (**
    Sets or retrieves whether the frame can be scrolled.
    @deprecated 
  *)
  val set_scrolling: 'tags this -> string -> unit [@@js.set "scrolling"]
  
  (** Sets or retrieves a URL to be loaded by the object. *)
  val get_src: 'tags this -> string [@@js.get "src"]
  
  (** Sets or retrieves a URL to be loaded by the object. *)
  val set_src: 'tags this -> string -> unit [@@js.set "src"]
  
  (** Sets or retrives the content of the page that is to contain. *)
  val get_srcdoc: 'tags this -> string [@@js.get "srcdoc"]
  
  (** Sets or retrives the content of the page that is to contain. *)
  val set_srcdoc: 'tags this -> string -> unit [@@js.set "srcdoc"]
  
  (** Sets or retrieves the width of the object. *)
  val get_width: 'tags this -> string [@@js.get "width"]
  
  (** Sets or retrieves the width of the object. *)
  val set_width: 'tags this -> string -> unit [@@js.set "width"]
  val getSVGDocument: 'tags this -> Document.t option [@@js.call "getSVGDocument"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Serves as the root node for a given HTML document. This object inherits the properties and methods described in the HTMLElement interface. *)
module[@js.scope "HTMLHtmlElement"] HTMLHtmlElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLHtmlElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLHtmlElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLHtmlElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLHtmlElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    Sets or retrieves the DTD version that governs the current document.
    @deprecated 
  *)
  val get_version: 'tags this -> string [@@js.get "version"]
  
  (**
    Sets or retrieves the DTD version that governs the current document.
    @deprecated 
  *)
  val set_version: 'tags this -> string -> unit [@@js.set "version"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** The different heading elements. It inherits methods and properties from the HTMLElement interface. *)
module[@js.scope "HTMLHeadingElement"] HTMLHeadingElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLHeadingElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLHeadingElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLHeadingElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLHeadingElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    Sets or retrieves a value that indicates the table alignment.
    @deprecated 
  *)
  val get_align: 'tags this -> string [@@js.get "align"]
  
  (**
    Sets or retrieves a value that indicates the table alignment.
    @deprecated 
  *)
  val set_align: 'tags this -> string -> unit [@@js.set "align"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Provides special properties (beyond those of the HTMLElement interface it also has available to it by inheritance) for manipulating <hr> elements. *)
module[@js.scope "HTMLHRElement"] HTMLHRElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLHRElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLHRElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLHRElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLHRElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    Sets or retrieves how the object is aligned with adjacent text.
    @deprecated 
  *)
  val get_align: 'tags this -> string [@@js.get "align"]
  
  (**
    Sets or retrieves how the object is aligned with adjacent text.
    @deprecated 
  *)
  val set_align: 'tags this -> string -> unit [@@js.set "align"]
  
  (** @deprecated  *)
  val get_color: 'tags this -> string [@@js.get "color"]
  
  (** @deprecated  *)
  val set_color: 'tags this -> string -> unit [@@js.set "color"]
  
  (**
    Sets or retrieves whether the horizontal rule is drawn with 3-D shading.
    @deprecated 
  *)
  val get_noShade: 'tags this -> bool [@@js.get "noShade"]
  
  (**
    Sets or retrieves whether the horizontal rule is drawn with 3-D shading.
    @deprecated 
  *)
  val set_noShade: 'tags this -> bool -> unit [@@js.set "noShade"]
  
  (** @deprecated  *)
  val get_size: 'tags this -> string [@@js.get "size"]
  
  (** @deprecated  *)
  val set_size: 'tags this -> string -> unit [@@js.set "size"]
  
  (**
    Sets or retrieves the width of the object.
    @deprecated 
  *)
  val get_width: 'tags this -> string [@@js.get "width"]
  
  (**
    Sets or retrieves the width of the object.
    @deprecated 
  *)
  val set_width: 'tags this -> string -> unit [@@js.set "width"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Provides special properties (beyond those of the regular HTMLElement interface they also inherit) for manipulating <frameset> elements. *)
module[@js.scope "HTMLFrameSetElement"] HTMLFrameSetElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLFrameSetElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable | `WindowEventHandlers] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLFrameSetElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable | `WindowEventHandlers]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLFrameSetElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable | `WindowEventHandlers]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLFrameSetElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    Sets or retrieves the frame widths of the object.
    @deprecated 
  *)
  val get_cols: 'tags this -> string [@@js.get "cols"]
  
  (**
    Sets or retrieves the frame widths of the object.
    @deprecated 
  *)
  val set_cols: 'tags this -> string -> unit [@@js.set "cols"]
  
  (**
    Sets or retrieves the frame heights of the object.
    @deprecated 
  *)
  val get_rows: 'tags this -> string [@@js.get "rows"]
  
  (**
    Sets or retrieves the frame heights of the object.
    @deprecated 
  *)
  val set_rows: 'tags this -> string -> unit [@@js.set "rows"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLFrameSetElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLFrameSetElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** @deprecated  *)
module[@js.scope "HTMLFrameElement"] HTMLFrameElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLFrameElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLFrameElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLFrameElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLFrameElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    Retrieves the document object of the page or frame.
    @deprecated 
  *)
  val get_contentDocument: 'tags this -> Document.t option [@@js.get "contentDocument"]
  
  (**
    Retrieves the object of the specified.
    @deprecated 
  *)
  val get_contentWindow: 'tags this -> WindowProxy.t option [@@js.get "contentWindow"]
  
  (**
    Sets or retrieves whether to display a border for the frame.
    @deprecated 
  *)
  val get_frameBorder: 'tags this -> string [@@js.get "frameBorder"]
  
  (**
    Sets or retrieves whether to display a border for the frame.
    @deprecated 
  *)
  val set_frameBorder: 'tags this -> string -> unit [@@js.set "frameBorder"]
  
  (**
    Sets or retrieves a URI to a long description of the object.
    @deprecated 
  *)
  val get_longDesc: 'tags this -> string [@@js.get "longDesc"]
  
  (**
    Sets or retrieves a URI to a long description of the object.
    @deprecated 
  *)
  val set_longDesc: 'tags this -> string -> unit [@@js.set "longDesc"]
  
  (**
    Sets or retrieves the top and bottom margin heights before displaying the text in a frame.
    @deprecated 
  *)
  val get_marginHeight: 'tags this -> string [@@js.get "marginHeight"]
  
  (**
    Sets or retrieves the top and bottom margin heights before displaying the text in a frame.
    @deprecated 
  *)
  val set_marginHeight: 'tags this -> string -> unit [@@js.set "marginHeight"]
  
  (**
    Sets or retrieves the left and right margin widths before displaying the text in a frame.
    @deprecated 
  *)
  val get_marginWidth: 'tags this -> string [@@js.get "marginWidth"]
  
  (**
    Sets or retrieves the left and right margin widths before displaying the text in a frame.
    @deprecated 
  *)
  val set_marginWidth: 'tags this -> string -> unit [@@js.set "marginWidth"]
  
  (**
    Sets or retrieves the frame name.
    @deprecated 
  *)
  val get_name: 'tags this -> string [@@js.get "name"]
  
  (**
    Sets or retrieves the frame name.
    @deprecated 
  *)
  val set_name: 'tags this -> string -> unit [@@js.set "name"]
  
  (**
    Sets or retrieves whether the user can resize the frame.
    @deprecated 
  *)
  val get_noResize: 'tags this -> bool [@@js.get "noResize"]
  
  (**
    Sets or retrieves whether the user can resize the frame.
    @deprecated 
  *)
  val set_noResize: 'tags this -> bool -> unit [@@js.set "noResize"]
  
  (**
    Sets or retrieves whether the frame can be scrolled.
    @deprecated 
  *)
  val get_scrolling: 'tags this -> string [@@js.get "scrolling"]
  
  (**
    Sets or retrieves whether the frame can be scrolled.
    @deprecated 
  *)
  val set_scrolling: 'tags this -> string -> unit [@@js.set "scrolling"]
  
  (**
    Sets or retrieves a URL to be loaded by the object.
    @deprecated 
  *)
  val get_src: 'tags this -> string [@@js.get "src"]
  
  (**
    Sets or retrieves a URL to be loaded by the object.
    @deprecated 
  *)
  val set_src: 'tags this -> string -> unit [@@js.set "src"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Implements the document object model (DOM) representation of the font element. The HTML Font Element <font> defines the font size, font face and color of text. *)
module[@js.scope "HTMLFontElement"] HTMLFontElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLFontElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLFontElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLFontElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLFontElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** @deprecated  *)
  val get_color: 'tags this -> string [@@js.get "color"]
  
  (** @deprecated  *)
  val set_color: 'tags this -> string -> unit [@@js.set "color"]
  
  (**
    Sets or retrieves the current typeface family.
    @deprecated 
  *)
  val get_face: 'tags this -> string [@@js.get "face"]
  
  (**
    Sets or retrieves the current typeface family.
    @deprecated 
  *)
  val set_face: 'tags this -> string -> unit [@@js.set "face"]
  
  (** @deprecated  *)
  val get_size: 'tags this -> string [@@js.get "size"]
  
  (** @deprecated  *)
  val set_size: 'tags this -> string -> unit [@@js.set "size"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Provides special properties and methods (beyond the regular HTMLElement interface it also has available to it by inheritance) for manipulating the layout and presentation of <fieldset> elements. *)
module[@js.scope "HTMLFieldSetElement"] HTMLFieldSetElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLFieldSetElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLFieldSetElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLElement | `HTMLFieldSetElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLFieldSetElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_disabled: 'tags this -> bool [@@js.get "disabled"]
  val set_disabled: 'tags this -> bool -> unit [@@js.set "disabled"]
  
  (** Returns an HTMLCollection of the form controls in the element. *)
  val get_elements: 'tags this -> HTMLCollection.t [@@js.get "elements"]
  
  (** Retrieves a reference to the form that the object is embedded in. *)
  val get_form: 'tags this -> HTMLFormElement.t option [@@js.get "form"]
  val get_name: 'tags this -> string [@@js.get "name"]
  val set_name: 'tags this -> string -> unit [@@js.set "name"]
  
  (** Returns the string "fieldset". *)
  val get_type: 'tags this -> string [@@js.get "type"]
  
  (** Returns the error message that would be displayed if the user submits the form, or an empty string if no error message. It also triggers the standard error message, such as "this is a required field". The result is that the user sees validation messages without actually submitting. *)
  val get_validationMessage: 'tags this -> string [@@js.get "validationMessage"]
  
  (** Returns a  ValidityState object that represents the validity states of an element. *)
  val get_validity: 'tags this -> ValidityState.t [@@js.get "validity"]
  
  (** Returns whether an element will successfully validate based on forms validation rules and constraints. *)
  val get_willValidate: 'tags this -> bool [@@js.get "willValidate"]
  
  (** Returns whether a form will validate when it is submitted, without having to submit it. *)
  val checkValidity: 'tags this -> bool [@@js.call "checkValidity"]
  val reportValidity: 'tags this -> bool [@@js.call "reportValidity"]
  
  (**
    Sets a custom error message that is displayed when a form is submitted.
    @param error Sets a custom error message that is displayed when a form is submitted.
  *)
  val setCustomValidity: 'tags this -> error:string -> unit [@@js.call "setCustomValidity"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Provides special properties (beyond the regular HTMLElement interface it also has available to it by inheritance) for manipulating <div> elements. *)
module[@js.scope "HTMLDivElement"] HTMLDivElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLDivElement | `HTMLElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLDivElement | `HTMLElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLDivElement | `HTMLElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLDivElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    Sets or retrieves how the object is aligned with adjacent text.
    @deprecated 
  *)
  val get_align: 'tags this -> string [@@js.get "align"]
  
  (**
    Sets or retrieves how the object is aligned with adjacent text.
    @deprecated 
  *)
  val set_align: 'tags this -> string -> unit [@@js.set "align"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** @deprecated  *)
module[@js.scope "HTMLDirectoryElement"] HTMLDirectoryElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLDirectoryElement | `HTMLElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLDirectoryElement | `HTMLElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLDirectoryElement | `HTMLElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLDirectoryElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** @deprecated  *)
  val get_compact: 'tags this -> bool [@@js.get "compact"]
  
  (** @deprecated  *)
  val set_compact: 'tags this -> bool -> unit [@@js.set "compact"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** @deprecated this is not available in most browsers *)
module HTMLDialogElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLDialogElement | `HTMLElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLDialogElement | `HTMLElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLDialogElement | `HTMLElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLDialogElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module[@js.scope "HTMLDetailsElement"] HTMLDetailsElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLDetailsElement | `HTMLElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLDetailsElement | `HTMLElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLDetailsElement | `HTMLElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLDetailsElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_open: 'tags this -> bool [@@js.get "open"]
  val set_open: 'tags this -> bool -> unit [@@js.set "open"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Provides special properties (beyond the HTMLElement object interface it also has available to it by inheritance) to manipulate <datalist> elements and their content. *)
module[@js.scope "HTMLDataListElement"] HTMLDataListElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLDataListElement | `HTMLElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLDataListElement | `HTMLElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLDataListElement | `HTMLElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLDataListElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Returns an HTMLCollection of the option elements of the datalist element. *)
  val get_options: 'tags this -> HTMLOptionElement.t HTMLCollectionOf.t [@@js.get "options"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Provides special properties (beyond the regular HTMLElement interface it also has available to it by inheritance) for manipulating <data> elements. *)
module[@js.scope "HTMLDataElement"] HTMLDataElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLDataElement | `HTMLElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLDataElement | `HTMLElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLDataElement | `HTMLElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLDataElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_value: 'tags this -> string [@@js.get "value"]
  val set_value: 'tags this -> string -> unit [@@js.set "value"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Provides special properties (beyond those of the regular HTMLElement interface it also has available to it by inheritance) for manipulating definition list (<dl>) elements. *)
module[@js.scope "HTMLDListElement"] HTMLDListElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLDListElement | `HTMLElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLDListElement | `HTMLElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLDListElement | `HTMLElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLDListElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** @deprecated  *)
  val get_compact: 'tags this -> bool [@@js.get "compact"]
  
  (** @deprecated  *)
  val set_compact: 'tags this -> bool -> unit [@@js.set "compact"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Provides properties and methods (beyond the regular HTMLElement interface it also has available to it by inheritance) for manipulating <button> elements. *)
module[@js.scope "HTMLButtonElement"] HTMLButtonElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLButtonElement | `HTMLElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLButtonElement | `HTMLElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLButtonElement | `HTMLElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLButtonElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_disabled: 'tags this -> bool [@@js.get "disabled"]
  val set_disabled: 'tags this -> bool -> unit [@@js.set "disabled"]
  
  (** Retrieves a reference to the form that the object is embedded in. *)
  val get_form: 'tags this -> HTMLFormElement.t option [@@js.get "form"]
  
  (** Overrides the action attribute (where the data on a form is sent) on the parent form element. *)
  val get_formAction: 'tags this -> string [@@js.get "formAction"]
  
  (** Overrides the action attribute (where the data on a form is sent) on the parent form element. *)
  val set_formAction: 'tags this -> string -> unit [@@js.set "formAction"]
  
  (** Used to override the encoding (formEnctype attribute) specified on the form element. *)
  val get_formEnctype: 'tags this -> string [@@js.get "formEnctype"]
  
  (** Used to override the encoding (formEnctype attribute) specified on the form element. *)
  val set_formEnctype: 'tags this -> string -> unit [@@js.set "formEnctype"]
  
  (** Overrides the submit method attribute previously specified on a form element. *)
  val get_formMethod: 'tags this -> string [@@js.get "formMethod"]
  
  (** Overrides the submit method attribute previously specified on a form element. *)
  val set_formMethod: 'tags this -> string -> unit [@@js.set "formMethod"]
  
  (** Overrides any validation or required attributes on a form or form elements to allow it to be submitted without validation. This can be used to create a "save draft"-type submit option. *)
  val get_formNoValidate: 'tags this -> bool [@@js.get "formNoValidate"]
  
  (** Overrides any validation or required attributes on a form or form elements to allow it to be submitted without validation. This can be used to create a "save draft"-type submit option. *)
  val set_formNoValidate: 'tags this -> bool -> unit [@@js.set "formNoValidate"]
  
  (** Overrides the target attribute on a form element. *)
  val get_formTarget: 'tags this -> string [@@js.get "formTarget"]
  
  (** Overrides the target attribute on a form element. *)
  val set_formTarget: 'tags this -> string -> unit [@@js.set "formTarget"]
  val get_labels: 'tags this -> HTMLLabelElement.t NodeListOf.t [@@js.get "labels"]
  
  (** Sets or retrieves the name of the object. *)
  val get_name: 'tags this -> string [@@js.get "name"]
  
  (** Sets or retrieves the name of the object. *)
  val set_name: 'tags this -> string -> unit [@@js.set "name"]
  
  (** Gets the classification and default behavior of the button. *)
  val get_type: 'tags this -> string [@@js.get "type"]
  
  (** Gets the classification and default behavior of the button. *)
  val set_type: 'tags this -> string -> unit [@@js.set "type"]
  
  (** Returns the error message that would be displayed if the user submits the form, or an empty string if no error message. It also triggers the standard error message, such as "this is a required field". The result is that the user sees validation messages without actually submitting. *)
  val get_validationMessage: 'tags this -> string [@@js.get "validationMessage"]
  
  (** Returns a  ValidityState object that represents the validity states of an element. *)
  val get_validity: 'tags this -> ValidityState.t [@@js.get "validity"]
  
  (** Sets or retrieves the default or selected value of the control. *)
  val get_value: 'tags this -> string [@@js.get "value"]
  
  (** Sets or retrieves the default or selected value of the control. *)
  val set_value: 'tags this -> string -> unit [@@js.set "value"]
  
  (** Returns whether an element will successfully validate based on forms validation rules and constraints. *)
  val get_willValidate: 'tags this -> bool [@@js.get "willValidate"]
  
  (** Returns whether a form will validate when it is submitted, without having to submit it. *)
  val checkValidity: 'tags this -> bool [@@js.call "checkValidity"]
  val reportValidity: 'tags this -> bool [@@js.call "reportValidity"]
  
  (**
    Sets a custom error message that is displayed when a form is submitted.
    @param error Sets a custom error message that is displayed when a form is submitted.
  *)
  val setCustomValidity: 'tags this -> error:string -> unit [@@js.call "setCustomValidity"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Provides special properties (beyond those inherited from the regular HTMLElement interface) for manipulating <body> elements. *)
module[@js.scope "HTMLBodyElement"] HTMLBodyElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLBodyElement | `HTMLElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable | `WindowEventHandlers] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLBodyElement | `HTMLElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable | `WindowEventHandlers]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLBodyElement | `HTMLElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable | `WindowEventHandlers]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLBodyElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** @deprecated  *)
  val get_aLink: 'tags this -> string [@@js.get "aLink"]
  
  (** @deprecated  *)
  val set_aLink: 'tags this -> string -> unit [@@js.set "aLink"]
  
  (** @deprecated  *)
  val get_background: 'tags this -> string [@@js.get "background"]
  
  (** @deprecated  *)
  val set_background: 'tags this -> string -> unit [@@js.set "background"]
  
  (** @deprecated  *)
  val get_bgColor: 'tags this -> string [@@js.get "bgColor"]
  
  (** @deprecated  *)
  val set_bgColor: 'tags this -> string -> unit [@@js.set "bgColor"]
  
  (** @deprecated  *)
  val get_link: 'tags this -> string [@@js.get "link"]
  
  (** @deprecated  *)
  val set_link: 'tags this -> string -> unit [@@js.set "link"]
  
  (** @deprecated  *)
  val get_onorientationchange: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onorientationchange"]
  
  (** @deprecated  *)
  val set_onorientationchange: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onorientationchange"]
  
  (** @deprecated  *)
  val get_text: 'tags this -> string [@@js.get "text"]
  
  (** @deprecated  *)
  val set_text: 'tags this -> string -> unit [@@js.set "text"]
  
  (** @deprecated  *)
  val get_vLink: 'tags this -> string [@@js.get "vLink"]
  
  (** @deprecated  *)
  val set_vLink: 'tags this -> string -> unit [@@js.set "vLink"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLBodyElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLBodyElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Contains the base URI for a document. This object inherits all of the properties and methods as described in the HTMLElement interface. *)
module[@js.scope "HTMLBaseElement"] HTMLBaseElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLBaseElement | `HTMLElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLBaseElement | `HTMLElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLBaseElement | `HTMLElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLBaseElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Gets or sets the baseline URL on which relative links are based. *)
  val get_href: 'tags this -> string [@@js.get "href"]
  
  (** Gets or sets the baseline URL on which relative links are based. *)
  val set_href: 'tags this -> string -> unit [@@js.set "href"]
  
  (** Sets or retrieves the window or frame at which to target content. *)
  val get_target: 'tags this -> string [@@js.get "target"]
  
  (** Sets or retrieves the window or frame at which to target content. *)
  val set_target: 'tags this -> string -> unit [@@js.set "target"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** A HTML line break element (<br>). It inherits from HTMLElement. *)
module[@js.scope "HTMLBRElement"] HTMLBRElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLBRElement | `HTMLElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLBRElement | `HTMLElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLBRElement | `HTMLElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLBRElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    Sets or retrieves the side on which floating objects are not to be positioned when any IHTMLBlockElement is inserted into the document.
    @deprecated 
  *)
  val get_clear: 'tags this -> string [@@js.get "clear"]
  
  (**
    Sets or retrieves the side on which floating objects are not to be positioned when any IHTMLBlockElement is inserted into the document.
    @deprecated 
  *)
  val set_clear: 'tags this -> string -> unit [@@js.set "clear"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Provides access to the properties of <audio> elements, as well as methods to manipulate them. It derives from the HTMLMediaElement interface. *)
module[@js.scope "HTMLAudioElement"] HTMLAudioElement : sig
  type t = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLAudioElement | `HTMLElement | `HTMLMediaElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLAudioElement | `HTMLElement | `HTMLMediaElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ARIAMixin | `Animatable | `ChildNode | `DocumentAndElementEventHandlers | `Element | `ElementCSSInlineStyle | `ElementContentEditable | `EventTarget | `GlobalEventHandlers | `HTMLAudioElement | `HTMLElement | `HTMLMediaElement | `HTMLOrSVGElement | `InnerHTML | `Node | `NonDocumentTypeChildNode | `ParentNode | `Slottable]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLAudioElement ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLMediaElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'HTMLMediaElementEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (**
    
    
    Removes the event listener in target's event listener list with the same type, callback, and options.
  *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module HTMLElementTagNameMap : sig
  type t = [`HTMLElementTagNameMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`HTMLElementTagNameMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`HTMLElementTagNameMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `HTMLElementTagNameMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_a: 'tags this -> HTMLAnchorElement.t [@@js.get "a"]
  val set_a: 'tags this -> HTMLAnchorElement.t -> unit [@@js.set "a"]
  val get_abbr: 'tags this -> HTMLElement.t [@@js.get "abbr"]
  val set_abbr: 'tags this -> HTMLElement.t -> unit [@@js.set "abbr"]
  val get_address: 'tags this -> HTMLElement.t [@@js.get "address"]
  val set_address: 'tags this -> HTMLElement.t -> unit [@@js.set "address"]
  val get_area: 'tags this -> HTMLAreaElement.t [@@js.get "area"]
  val set_area: 'tags this -> HTMLAreaElement.t -> unit [@@js.set "area"]
  val get_article: 'tags this -> HTMLElement.t [@@js.get "article"]
  val set_article: 'tags this -> HTMLElement.t -> unit [@@js.set "article"]
  val get_aside: 'tags this -> HTMLElement.t [@@js.get "aside"]
  val set_aside: 'tags this -> HTMLElement.t -> unit [@@js.set "aside"]
  val get_audio: 'tags this -> HTMLAudioElement.t [@@js.get "audio"]
  val set_audio: 'tags this -> HTMLAudioElement.t -> unit [@@js.set "audio"]
  val get_b: 'tags this -> HTMLElement.t [@@js.get "b"]
  val set_b: 'tags this -> HTMLElement.t -> unit [@@js.set "b"]
  val get_base: 'tags this -> HTMLBaseElement.t [@@js.get "base"]
  val set_base: 'tags this -> HTMLBaseElement.t -> unit [@@js.set "base"]
  val get_bdi: 'tags this -> HTMLElement.t [@@js.get "bdi"]
  val set_bdi: 'tags this -> HTMLElement.t -> unit [@@js.set "bdi"]
  val get_bdo: 'tags this -> HTMLElement.t [@@js.get "bdo"]
  val set_bdo: 'tags this -> HTMLElement.t -> unit [@@js.set "bdo"]
  val get_blockquote: 'tags this -> HTMLQuoteElement.t [@@js.get "blockquote"]
  val set_blockquote: 'tags this -> HTMLQuoteElement.t -> unit [@@js.set "blockquote"]
  val get_body: 'tags this -> HTMLBodyElement.t [@@js.get "body"]
  val set_body: 'tags this -> HTMLBodyElement.t -> unit [@@js.set "body"]
  val get_br: 'tags this -> HTMLBRElement.t [@@js.get "br"]
  val set_br: 'tags this -> HTMLBRElement.t -> unit [@@js.set "br"]
  val get_button: 'tags this -> HTMLButtonElement.t [@@js.get "button"]
  val set_button: 'tags this -> HTMLButtonElement.t -> unit [@@js.set "button"]
  val get_canvas: 'tags this -> HTMLCanvasElement.t [@@js.get "canvas"]
  val set_canvas: 'tags this -> HTMLCanvasElement.t -> unit [@@js.set "canvas"]
  val get_caption: 'tags this -> HTMLTableCaptionElement.t [@@js.get "caption"]
  val set_caption: 'tags this -> HTMLTableCaptionElement.t -> unit [@@js.set "caption"]
  val get_cite: 'tags this -> HTMLElement.t [@@js.get "cite"]
  val set_cite: 'tags this -> HTMLElement.t -> unit [@@js.set "cite"]
  val get_code: 'tags this -> HTMLElement.t [@@js.get "code"]
  val set_code: 'tags this -> HTMLElement.t -> unit [@@js.set "code"]
  val get_col: 'tags this -> HTMLTableColElement.t [@@js.get "col"]
  val set_col: 'tags this -> HTMLTableColElement.t -> unit [@@js.set "col"]
  val get_colgroup: 'tags this -> HTMLTableColElement.t [@@js.get "colgroup"]
  val set_colgroup: 'tags this -> HTMLTableColElement.t -> unit [@@js.set "colgroup"]
  val get_data: 'tags this -> HTMLDataElement.t [@@js.get "data"]
  val set_data: 'tags this -> HTMLDataElement.t -> unit [@@js.set "data"]
  val get_datalist: 'tags this -> HTMLDataListElement.t [@@js.get "datalist"]
  val set_datalist: 'tags this -> HTMLDataListElement.t -> unit [@@js.set "datalist"]
  val get_dd: 'tags this -> HTMLElement.t [@@js.get "dd"]
  val set_dd: 'tags this -> HTMLElement.t -> unit [@@js.set "dd"]
  val get_del: 'tags this -> HTMLModElement.t [@@js.get "del"]
  val set_del: 'tags this -> HTMLModElement.t -> unit [@@js.set "del"]
  val get_details: 'tags this -> HTMLDetailsElement.t [@@js.get "details"]
  val set_details: 'tags this -> HTMLDetailsElement.t -> unit [@@js.set "details"]
  val get_dfn: 'tags this -> HTMLElement.t [@@js.get "dfn"]
  val set_dfn: 'tags this -> HTMLElement.t -> unit [@@js.set "dfn"]
  val get_dialog: 'tags this -> HTMLDialogElement.t [@@js.get "dialog"]
  val set_dialog: 'tags this -> HTMLDialogElement.t -> unit [@@js.set "dialog"]
  val get_dir: 'tags this -> HTMLDirectoryElement.t [@@js.get "dir"]
  val set_dir: 'tags this -> HTMLDirectoryElement.t -> unit [@@js.set "dir"]
  val get_div: 'tags this -> HTMLDivElement.t [@@js.get "div"]
  val set_div: 'tags this -> HTMLDivElement.t -> unit [@@js.set "div"]
  val get_dl: 'tags this -> HTMLDListElement.t [@@js.get "dl"]
  val set_dl: 'tags this -> HTMLDListElement.t -> unit [@@js.set "dl"]
  val get_dt: 'tags this -> HTMLElement.t [@@js.get "dt"]
  val set_dt: 'tags this -> HTMLElement.t -> unit [@@js.set "dt"]
  val get_em: 'tags this -> HTMLElement.t [@@js.get "em"]
  val set_em: 'tags this -> HTMLElement.t -> unit [@@js.set "em"]
  val get_embed: 'tags this -> HTMLEmbedElement.t [@@js.get "embed"]
  val set_embed: 'tags this -> HTMLEmbedElement.t -> unit [@@js.set "embed"]
  val get_fieldset: 'tags this -> HTMLFieldSetElement.t [@@js.get "fieldset"]
  val set_fieldset: 'tags this -> HTMLFieldSetElement.t -> unit [@@js.set "fieldset"]
  val get_figcaption: 'tags this -> HTMLElement.t [@@js.get "figcaption"]
  val set_figcaption: 'tags this -> HTMLElement.t -> unit [@@js.set "figcaption"]
  val get_figure: 'tags this -> HTMLElement.t [@@js.get "figure"]
  val set_figure: 'tags this -> HTMLElement.t -> unit [@@js.set "figure"]
  val get_font: 'tags this -> HTMLFontElement.t [@@js.get "font"]
  val set_font: 'tags this -> HTMLFontElement.t -> unit [@@js.set "font"]
  val get_footer: 'tags this -> HTMLElement.t [@@js.get "footer"]
  val set_footer: 'tags this -> HTMLElement.t -> unit [@@js.set "footer"]
  val get_form: 'tags this -> HTMLFormElement.t [@@js.get "form"]
  val set_form: 'tags this -> HTMLFormElement.t -> unit [@@js.set "form"]
  val get_frame: 'tags this -> HTMLFrameElement.t [@@js.get "frame"]
  val set_frame: 'tags this -> HTMLFrameElement.t -> unit [@@js.set "frame"]
  val get_frameset: 'tags this -> HTMLFrameSetElement.t [@@js.get "frameset"]
  val set_frameset: 'tags this -> HTMLFrameSetElement.t -> unit [@@js.set "frameset"]
  val get_h1: 'tags this -> HTMLHeadingElement.t [@@js.get "h1"]
  val set_h1: 'tags this -> HTMLHeadingElement.t -> unit [@@js.set "h1"]
  val get_h2: 'tags this -> HTMLHeadingElement.t [@@js.get "h2"]
  val set_h2: 'tags this -> HTMLHeadingElement.t -> unit [@@js.set "h2"]
  val get_h3: 'tags this -> HTMLHeadingElement.t [@@js.get "h3"]
  val set_h3: 'tags this -> HTMLHeadingElement.t -> unit [@@js.set "h3"]
  val get_h4: 'tags this -> HTMLHeadingElement.t [@@js.get "h4"]
  val set_h4: 'tags this -> HTMLHeadingElement.t -> unit [@@js.set "h4"]
  val get_h5: 'tags this -> HTMLHeadingElement.t [@@js.get "h5"]
  val set_h5: 'tags this -> HTMLHeadingElement.t -> unit [@@js.set "h5"]
  val get_h6: 'tags this -> HTMLHeadingElement.t [@@js.get "h6"]
  val set_h6: 'tags this -> HTMLHeadingElement.t -> unit [@@js.set "h6"]
  val get_head: 'tags this -> HTMLHeadElement.t [@@js.get "head"]
  val set_head: 'tags this -> HTMLHeadElement.t -> unit [@@js.set "head"]
  val get_header: 'tags this -> HTMLElement.t [@@js.get "header"]
  val set_header: 'tags this -> HTMLElement.t -> unit [@@js.set "header"]
  val get_hgroup: 'tags this -> HTMLElement.t [@@js.get "hgroup"]
  val set_hgroup: 'tags this -> HTMLElement.t -> unit [@@js.set "hgroup"]
  val get_hr: 'tags this -> HTMLHRElement.t [@@js.get "hr"]
  val set_hr: 'tags this -> HTMLHRElement.t -> unit [@@js.set "hr"]
  val get_html: 'tags this -> HTMLHtmlElement.t [@@js.get "html"]
  val set_html: 'tags this -> HTMLHtmlElement.t -> unit [@@js.set "html"]
  val get_i: 'tags this -> HTMLElement.t [@@js.get "i"]
  val set_i: 'tags this -> HTMLElement.t -> unit [@@js.set "i"]
  val get_iframe: 'tags this -> HTMLIFrameElement.t [@@js.get "iframe"]
  val set_iframe: 'tags this -> HTMLIFrameElement.t -> unit [@@js.set "iframe"]
  val get_img: 'tags this -> HTMLImageElement.t [@@js.get "img"]
  val set_img: 'tags this -> HTMLImageElement.t -> unit [@@js.set "img"]
  val get_input: 'tags this -> HTMLInputElement.t [@@js.get "input"]
  val set_input: 'tags this -> HTMLInputElement.t -> unit [@@js.set "input"]
  val get_ins: 'tags this -> HTMLModElement.t [@@js.get "ins"]
  val set_ins: 'tags this -> HTMLModElement.t -> unit [@@js.set "ins"]
  val get_kbd: 'tags this -> HTMLElement.t [@@js.get "kbd"]
  val set_kbd: 'tags this -> HTMLElement.t -> unit [@@js.set "kbd"]
  val get_label: 'tags this -> HTMLLabelElement.t [@@js.get "label"]
  val set_label: 'tags this -> HTMLLabelElement.t -> unit [@@js.set "label"]
  val get_legend: 'tags this -> HTMLLegendElement.t [@@js.get "legend"]
  val set_legend: 'tags this -> HTMLLegendElement.t -> unit [@@js.set "legend"]
  val get_li: 'tags this -> HTMLLIElement.t [@@js.get "li"]
  val set_li: 'tags this -> HTMLLIElement.t -> unit [@@js.set "li"]
  val get_link: 'tags this -> HTMLLinkElement.t [@@js.get "link"]
  val set_link: 'tags this -> HTMLLinkElement.t -> unit [@@js.set "link"]
  val get_main: 'tags this -> HTMLElement.t [@@js.get "main"]
  val set_main: 'tags this -> HTMLElement.t -> unit [@@js.set "main"]
  val get_map: 'tags this -> HTMLMapElement.t [@@js.get "map"]
  val set_map: 'tags this -> HTMLMapElement.t -> unit [@@js.set "map"]
  val get_mark: 'tags this -> HTMLElement.t [@@js.get "mark"]
  val set_mark: 'tags this -> HTMLElement.t -> unit [@@js.set "mark"]
  val get_marquee: 'tags this -> HTMLMarqueeElement.t [@@js.get "marquee"]
  val set_marquee: 'tags this -> HTMLMarqueeElement.t -> unit [@@js.set "marquee"]
  val get_menu: 'tags this -> HTMLMenuElement.t [@@js.get "menu"]
  val set_menu: 'tags this -> HTMLMenuElement.t -> unit [@@js.set "menu"]
  val get_meta: 'tags this -> HTMLMetaElement.t [@@js.get "meta"]
  val set_meta: 'tags this -> HTMLMetaElement.t -> unit [@@js.set "meta"]
  val get_meter: 'tags this -> HTMLMeterElement.t [@@js.get "meter"]
  val set_meter: 'tags this -> HTMLMeterElement.t -> unit [@@js.set "meter"]
  val get_nav: 'tags this -> HTMLElement.t [@@js.get "nav"]
  val set_nav: 'tags this -> HTMLElement.t -> unit [@@js.set "nav"]
  val get_noscript: 'tags this -> HTMLElement.t [@@js.get "noscript"]
  val set_noscript: 'tags this -> HTMLElement.t -> unit [@@js.set "noscript"]
  val get_object: 'tags this -> HTMLObjectElement.t [@@js.get "object"]
  val set_object: 'tags this -> HTMLObjectElement.t -> unit [@@js.set "object"]
  val get_ol: 'tags this -> HTMLOListElement.t [@@js.get "ol"]
  val set_ol: 'tags this -> HTMLOListElement.t -> unit [@@js.set "ol"]
  val get_optgroup: 'tags this -> HTMLOptGroupElement.t [@@js.get "optgroup"]
  val set_optgroup: 'tags this -> HTMLOptGroupElement.t -> unit [@@js.set "optgroup"]
  val get_option: 'tags this -> HTMLOptionElement.t [@@js.get "option"]
  val set_option: 'tags this -> HTMLOptionElement.t -> unit [@@js.set "option"]
  val get_output: 'tags this -> HTMLOutputElement.t [@@js.get "output"]
  val set_output: 'tags this -> HTMLOutputElement.t -> unit [@@js.set "output"]
  val get_p: 'tags this -> HTMLParagraphElement.t [@@js.get "p"]
  val set_p: 'tags this -> HTMLParagraphElement.t -> unit [@@js.set "p"]
  val get_param: 'tags this -> HTMLParamElement.t [@@js.get "param"]
  val set_param: 'tags this -> HTMLParamElement.t -> unit [@@js.set "param"]
  val get_picture: 'tags this -> HTMLPictureElement.t [@@js.get "picture"]
  val set_picture: 'tags this -> HTMLPictureElement.t -> unit [@@js.set "picture"]
  val get_pre: 'tags this -> HTMLPreElement.t [@@js.get "pre"]
  val set_pre: 'tags this -> HTMLPreElement.t -> unit [@@js.set "pre"]
  val get_progress: 'tags this -> HTMLProgressElement.t [@@js.get "progress"]
  val set_progress: 'tags this -> HTMLProgressElement.t -> unit [@@js.set "progress"]
  val get_q: 'tags this -> HTMLQuoteElement.t [@@js.get "q"]
  val set_q: 'tags this -> HTMLQuoteElement.t -> unit [@@js.set "q"]
  val get_rp: 'tags this -> HTMLElement.t [@@js.get "rp"]
  val set_rp: 'tags this -> HTMLElement.t -> unit [@@js.set "rp"]
  val get_rt: 'tags this -> HTMLElement.t [@@js.get "rt"]
  val set_rt: 'tags this -> HTMLElement.t -> unit [@@js.set "rt"]
  val get_ruby: 'tags this -> HTMLElement.t [@@js.get "ruby"]
  val set_ruby: 'tags this -> HTMLElement.t -> unit [@@js.set "ruby"]
  val get_s: 'tags this -> HTMLElement.t [@@js.get "s"]
  val set_s: 'tags this -> HTMLElement.t -> unit [@@js.set "s"]
  val get_samp: 'tags this -> HTMLElement.t [@@js.get "samp"]
  val set_samp: 'tags this -> HTMLElement.t -> unit [@@js.set "samp"]
  val get_script: 'tags this -> HTMLScriptElement.t [@@js.get "script"]
  val set_script: 'tags this -> HTMLScriptElement.t -> unit [@@js.set "script"]
  val get_section: 'tags this -> HTMLElement.t [@@js.get "section"]
  val set_section: 'tags this -> HTMLElement.t -> unit [@@js.set "section"]
  val get_select: 'tags this -> HTMLSelectElement.t [@@js.get "select"]
  val set_select: 'tags this -> HTMLSelectElement.t -> unit [@@js.set "select"]
  val get_slot: 'tags this -> HTMLSlotElement.t [@@js.get "slot"]
  val set_slot: 'tags this -> HTMLSlotElement.t -> unit [@@js.set "slot"]
  val get_small: 'tags this -> HTMLElement.t [@@js.get "small"]
  val set_small: 'tags this -> HTMLElement.t -> unit [@@js.set "small"]
  val get_source: 'tags this -> HTMLSourceElement.t [@@js.get "source"]
  val set_source: 'tags this -> HTMLSourceElement.t -> unit [@@js.set "source"]
  val get_span: 'tags this -> HTMLSpanElement.t [@@js.get "span"]
  val set_span: 'tags this -> HTMLSpanElement.t -> unit [@@js.set "span"]
  val get_strong: 'tags this -> HTMLElement.t [@@js.get "strong"]
  val set_strong: 'tags this -> HTMLElement.t -> unit [@@js.set "strong"]
  val get_style: 'tags this -> HTMLStyleElement.t [@@js.get "style"]
  val set_style: 'tags this -> HTMLStyleElement.t -> unit [@@js.set "style"]
  val get_sub: 'tags this -> HTMLElement.t [@@js.get "sub"]
  val set_sub: 'tags this -> HTMLElement.t -> unit [@@js.set "sub"]
  val get_summary: 'tags this -> HTMLElement.t [@@js.get "summary"]
  val set_summary: 'tags this -> HTMLElement.t -> unit [@@js.set "summary"]
  val get_sup: 'tags this -> HTMLElement.t [@@js.get "sup"]
  val set_sup: 'tags this -> HTMLElement.t -> unit [@@js.set "sup"]
  val get_table: 'tags this -> HTMLTableElement.t [@@js.get "table"]
  val set_table: 'tags this -> HTMLTableElement.t -> unit [@@js.set "table"]
  val get_tbody: 'tags this -> HTMLTableSectionElement.t [@@js.get "tbody"]
  val set_tbody: 'tags this -> HTMLTableSectionElement.t -> unit [@@js.set "tbody"]
  val get_td: 'tags this -> HTMLTableCellElement.t [@@js.get "td"]
  val set_td: 'tags this -> HTMLTableCellElement.t -> unit [@@js.set "td"]
  val get_template: 'tags this -> HTMLTemplateElement.t [@@js.get "template"]
  val set_template: 'tags this -> HTMLTemplateElement.t -> unit [@@js.set "template"]
  val get_textarea: 'tags this -> HTMLTextAreaElement.t [@@js.get "textarea"]
  val set_textarea: 'tags this -> HTMLTextAreaElement.t -> unit [@@js.set "textarea"]
  val get_tfoot: 'tags this -> HTMLTableSectionElement.t [@@js.get "tfoot"]
  val set_tfoot: 'tags this -> HTMLTableSectionElement.t -> unit [@@js.set "tfoot"]
  val get_th: 'tags this -> HTMLTableCellElement.t [@@js.get "th"]
  val set_th: 'tags this -> HTMLTableCellElement.t -> unit [@@js.set "th"]
  val get_thead: 'tags this -> HTMLTableSectionElement.t [@@js.get "thead"]
  val set_thead: 'tags this -> HTMLTableSectionElement.t -> unit [@@js.set "thead"]
  val get_time: 'tags this -> HTMLTimeElement.t [@@js.get "time"]
  val set_time: 'tags this -> HTMLTimeElement.t -> unit [@@js.set "time"]
  val get_title: 'tags this -> HTMLTitleElement.t [@@js.get "title"]
  val set_title: 'tags this -> HTMLTitleElement.t -> unit [@@js.set "title"]
  val get_tr: 'tags this -> HTMLTableRowElement.t [@@js.get "tr"]
  val set_tr: 'tags this -> HTMLTableRowElement.t -> unit [@@js.set "tr"]
  val get_track: 'tags this -> HTMLTrackElement.t [@@js.get "track"]
  val set_track: 'tags this -> HTMLTrackElement.t -> unit [@@js.set "track"]
  val get_u: 'tags this -> HTMLElement.t [@@js.get "u"]
  val set_u: 'tags this -> HTMLElement.t -> unit [@@js.set "u"]
  val get_ul: 'tags this -> HTMLUListElement.t [@@js.get "ul"]
  val set_ul: 'tags this -> HTMLUListElement.t -> unit [@@js.set "ul"]
  val get_var: 'tags this -> HTMLElement.t [@@js.get "var"]
  val set_var: 'tags this -> HTMLElement.t -> unit [@@js.set "var"]
  val get_video: 'tags this -> HTMLVideoElement.t [@@js.get "video"]
  val set_video: 'tags this -> HTMLVideoElement.t -> unit [@@js.set "video"]
  val get_wbr: 'tags this -> HTMLElement.t [@@js.get "wbr"]
  val set_wbr: 'tags this -> HTMLElement.t -> unit [@@js.set "wbr"]
  val create: a:HTMLAnchorElement.t -> abbr:HTMLElement.t -> address:HTMLElement.t -> area:HTMLAreaElement.t -> article:HTMLElement.t -> aside:HTMLElement.t -> audio:HTMLAudioElement.t -> b:HTMLElement.t -> base:HTMLBaseElement.t -> bdi:HTMLElement.t -> bdo:HTMLElement.t -> blockquote:HTMLQuoteElement.t -> body:HTMLBodyElement.t -> br:HTMLBRElement.t -> button:HTMLButtonElement.t -> canvas:HTMLCanvasElement.t -> caption:HTMLTableCaptionElement.t -> cite:HTMLElement.t -> code:HTMLElement.t -> col:HTMLTableColElement.t -> colgroup:HTMLTableColElement.t -> data:HTMLDataElement.t -> datalist:HTMLDataListElement.t -> dd:HTMLElement.t -> del:HTMLModElement.t -> details:HTMLDetailsElement.t -> dfn:HTMLElement.t -> dialog:HTMLDialogElement.t -> dir:HTMLDirectoryElement.t -> div:HTMLDivElement.t -> dl:HTMLDListElement.t -> dt:HTMLElement.t -> em:HTMLElement.t -> embed:HTMLEmbedElement.t -> fieldset:HTMLFieldSetElement.t -> figcaption:HTMLElement.t -> figure:HTMLElement.t -> font:HTMLFontElement.t -> footer:HTMLElement.t -> form:HTMLFormElement.t -> frame:HTMLFrameElement.t -> frameset:HTMLFrameSetElement.t -> h1:HTMLHeadingElement.t -> h2:HTMLHeadingElement.t -> h3:HTMLHeadingElement.t -> h4:HTMLHeadingElement.t -> h5:HTMLHeadingElement.t -> h6:HTMLHeadingElement.t -> head:HTMLHeadElement.t -> header:HTMLElement.t -> hgroup:HTMLElement.t -> hr:HTMLHRElement.t -> html:HTMLHtmlElement.t -> i:HTMLElement.t -> iframe:HTMLIFrameElement.t -> img:HTMLImageElement.t -> input:HTMLInputElement.t -> ins:HTMLModElement.t -> kbd:HTMLElement.t -> label:HTMLLabelElement.t -> legend:HTMLLegendElement.t -> li:HTMLLIElement.t -> link:HTMLLinkElement.t -> main:HTMLElement.t -> map:HTMLMapElement.t -> mark:HTMLElement.t -> marquee:HTMLMarqueeElement.t -> menu:HTMLMenuElement.t -> meta:HTMLMetaElement.t -> meter:HTMLMeterElement.t -> nav:HTMLElement.t -> noscript:HTMLElement.t -> object_:(HTMLObjectElement.t[@js "object"]) -> ol:HTMLOListElement.t -> optgroup:HTMLOptGroupElement.t -> option:HTMLOptionElement.t -> output:HTMLOutputElement.t -> p:HTMLParagraphElement.t -> param:HTMLParamElement.t -> picture:HTMLPictureElement.t -> pre:HTMLPreElement.t -> progress:HTMLProgressElement.t -> q:HTMLQuoteElement.t -> rp:HTMLElement.t -> rt:HTMLElement.t -> ruby:HTMLElement.t -> s:HTMLElement.t -> samp:HTMLElement.t -> script:HTMLScriptElement.t -> section:HTMLElement.t -> select:HTMLSelectElement.t -> slot:HTMLSlotElement.t -> small:HTMLElement.t -> source:HTMLSourceElement.t -> span:HTMLSpanElement.t -> strong:HTMLElement.t -> style:HTMLStyleElement.t -> sub:HTMLElement.t -> summary:HTMLElement.t -> sup:HTMLElement.t -> table:HTMLTableElement.t -> tbody:HTMLTableSectionElement.t -> td:HTMLTableCellElement.t -> template:HTMLTemplateElement.t -> textarea:HTMLTextAreaElement.t -> tfoot:HTMLTableSectionElement.t -> th:HTMLTableCellElement.t -> thead:HTMLTableSectionElement.t -> time:HTMLTimeElement.t -> title:HTMLTitleElement.t -> tr:HTMLTableRowElement.t -> track:HTMLTrackElement.t -> u:HTMLElement.t -> ul:HTMLUListElement.t -> var:HTMLElement.t -> video:HTMLVideoElement.t -> wbr:HTMLElement.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** @deprecated Directly use HTMLElementTagNameMap or SVGElementTagNameMap as appropriate, instead. *)
module ElementTagNameMap : sig
  type t = (HTMLElementTagNameMap.t, (SVGElementTagNameMap.t, (([`L_s113_animate[@js "animate"] | `L_s114_animateMotion[@js "animateMotion"] | `L_s115_animateTransform[@js "animateTransform"] | `L_s192_circle[@js "circle"] | `L_s197_clipPath[@js "clipPath"] | `L_s242_defs[@js "defs"] | `L_s247_desc[@js "desc"] | `L_s284_ellipse[@js "ellipse"] | `L_s315_feBlend[@js "feBlend"] | `L_s316_feColorMatrix[@js "feColorMatrix"] | `L_s317_feComponentTransfer[@js "feComponentTransfer"] | `L_s318_feComposite[@js "feComposite"] | `L_s319_feConvolveMatrix[@js "feConvolveMatrix"] | `L_s320_feDiffuseLighting[@js "feDiffuseLighting"] | `L_s321_feDisplacementMap[@js "feDisplacementMap"] | `L_s322_feDistantLight[@js "feDistantLight"] | `L_s323_feDropShadow[@js "feDropShadow"] | `L_s324_feFlood[@js "feFlood"] | `L_s325_feFuncA[@js "feFuncA"] | `L_s326_feFuncB[@js "feFuncB"] | `L_s327_feFuncG[@js "feFuncG"] | `L_s328_feFuncR[@js "feFuncR"] | `L_s329_feGaussianBlur[@js "feGaussianBlur"] | `L_s330_feImage[@js "feImage"] | `L_s331_feMerge[@js "feMerge"] | `L_s332_feMergeNode[@js "feMergeNode"] | `L_s333_feMorphology[@js "feMorphology"] | `L_s334_feOffset[@js "feOffset"] | `L_s335_fePointLight[@js "fePointLight"] | `L_s336_feSpecularLighting[@js "feSpecularLighting"] | `L_s337_feSpotLight[@js "feSpotLight"] | `L_s338_feTile[@js "feTile"] | `L_s339_feTurbulence[@js "feTurbulence"] | `L_s344_filter[@js "filter"] | `L_s355_foreignObject[@js "foreignObject"] | `L_s366_g[@js "g"] | `L_s416_image[@js "image"] | `L_s464_line[@js "line"] | `L_s468_linearGradient[@js "linearGradient"] | `L_s498_marker[@js "marker"] | `L_s500_mask[@js "mask"] | `L_s512_metadata[@js "metadata"] | `L_s527_mpath[@js "mpath"] | `L_s590_path[@js "path"] | `L_s591_pattern[@js "pattern"] | `L_s619_polygon[@js "polygon"] | `L_s620_polyline[@js "polyline"] | `L_s645_radialGradient[@js "radialGradient"] | `L_s654_rect[@js "rect"] | `L_s698_script[@js "script"] | `L_s717_set[@js "set"] | `L_s757_stop[@js "stop"] | `L_s764_style[@js "style"] | `L_s775_svg[@js "svg"] | `L_s776_switch[@js "switch"] | `L_s777_symbol[@js "symbol"] | `L_s787_text[@js "text"] | `L_s791_textPath[@js "textPath"] | `L_s799_title[@js "title"] | `L_s819_tspan[@js "tspan"] | `L_s844_use[@js "use"] | `L_s854_view[@js "view"] | `L_s91_a[@js "a"]] [@js.enum]), ([`L_s100_address[@js "address"] | `L_s126_area[@js "area"] | `L_s128_article[@js "article"] | `L_s129_aside[@js "aside"] | `L_s133_audio[@js "audio"] | `L_s143_b[@js "b"] | `L_s149_base[@js "base"] | `L_s151_bdi[@js "bdi"] | `L_s152_bdo[@js "bdo"] | `L_s163_blockquote[@js "blockquote"] | `L_s166_body[@js "body"] | `L_s171_br[@js "br"] | `L_s175_button[@js "button"] | `L_s181_canvas[@js "canvas"] | `L_s182_caption[@js "caption"] | `L_s193_cite[@js "cite"] | `L_s202_code[@js "code"] | `L_s204_col[@js "col"] | `L_s205_colgroup[@js "colgroup"] | `L_s232_data[@js "data"] | `L_s236_datalist[@js "datalist"] | `L_s238_dd[@js "dd"] | `L_s243_del[@js "del"] | `L_s253_details[@js "details"] | `L_s258_dfn[@js "dfn"] | `L_s259_dialog[@js "dialog"] | `L_s261_dir[@js "dir"] | `L_s270_div[@js "div"] | `L_s271_dl[@js "dl"] | `L_s281_dt[@js "dt"] | `L_s285_em[@js "em"] | `L_s286_embed[@js "embed"] | `L_s340_fieldset[@js "fieldset"] | `L_s341_figcaption[@js "figcaption"] | `L_s342_figure[@js "figure"] | `L_s352_font[@js "font"] | `L_s353_footer[@js "footer"] | `L_s356_form[@js "form"] | `L_s360_frame[@js "frame"] | `L_s361_frameset[@js "frameset"] | `L_s375_h1[@js "h1"] | `L_s376_h2[@js "h2"] | `L_s377_h3[@js "h3"] | `L_s378_h4[@js "h4"] | `L_s379_h5[@js "h5"] | `L_s380_h6[@js "h6"] | `L_s390_head[@js "head"] | `L_s391_header[@js "header"] | `L_s392_hgroup[@js "hgroup"] | `L_s401_hr[@js "hr"] | `L_s402_html[@js "html"] | `L_s406_i[@js "i"] | `L_s415_iframe[@js "iframe"] | `L_s418_img[@js "img"] | `L_s429_input[@js "input"] | `L_s430_ins[@js "ins"] | `L_s443_kbd[@js "kbd"] | `L_s448_label[@js "label"] | `L_s457_legend[@js "legend"] | `L_s458_li[@js "li"] | `L_s469_link[@js "link"] | `L_s491_main[@js "main"] | `L_s496_map[@js "map"] | `L_s497_mark[@js "mark"] | `L_s499_marquee[@js "marquee"] | `L_s508_menu[@js "menu"] | `L_s511_meta[@js "meta"] | `L_s513_meter[@js "meter"] | `L_s533_nav[@js "nav"] | `L_s551_noscript[@js "noscript"] | `L_s555_object[@js "object"] | `L_s558_ol[@js "ol"] | `L_s565_optgroup[@js "optgroup"] | `L_s568_option[@js "option"] | `L_s575_output[@js "output"] | `L_s579_p[@js "p"] | `L_s585_param[@js "param"] | `L_s602_picture[@js "picture"] | `L_s627_pre[@js "pre"] | `L_s639_progress[@js "progress"] | `L_s644_q[@js "q"] | `L_s684_rp[@js "rp"] | `L_s685_rt[@js "rt"] | `L_s689_ruby[@js "ruby"] | `L_s691_s[@js "s"] | `L_s693_samp[@js "samp"] | `L_s698_script[@js "script"] | `L_s701_section[@js "section"] | `L_s709_select[@js "select"] | `L_s727_slot[@js "slot"] | `L_s729_small[@js "small"] | `L_s737_source[@js "source"] | `L_s745_span[@js "span"] | `L_s763_strong[@js "strong"] | `L_s764_style[@js "style"] | `L_s766_sub[@js "sub"] | `L_s771_summary[@js "summary"] | `L_s772_sup[@js "sup"] | `L_s781_table[@js "table"] | `L_s782_tbody[@js "tbody"] | `L_s784_td[@js "td"] | `L_s785_template[@js "template"] | `L_s792_textarea[@js "textarea"] | `L_s793_tfoot[@js "tfoot"] | `L_s794_th[@js "th"] | `L_s795_thead[@js "thead"] | `L_s796_time[@js "time"] | `L_s799_title[@js "title"] | `L_s810_tr[@js "tr"] | `L_s811_track[@js "track"] | `L_s820_u[@js "u"] | `L_s822_ul[@js "ul"] | `L_s847_var[@js "var"] | `L_s852_video[@js "video"] | `L_s862_wbr[@js "wbr"] | `L_s91_a[@js "a"] | `L_s93_abbr[@js "abbr"]] [@js.enum])) Exclude.t_2) Pick.t_2) intersection2
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module EcKeyAlgorithm : sig
  type t = [`EcKeyAlgorithm | `KeyAlgorithm] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EcKeyAlgorithm | `KeyAlgorithm]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EcKeyAlgorithm | `KeyAlgorithm]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `EcKeyAlgorithm ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_namedCurve: 'tags this -> NamedCurve.t [@@js.get "namedCurve"]
  val set_namedCurve: 'tags this -> NamedCurve.t -> unit [@@js.set "namedCurve"]
  val create: namedCurve:NamedCurve.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module EXT_texture_compression_rgtc : sig
  type t = [`EXT_texture_compression_rgtc] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`EXT_texture_compression_rgtc]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`EXT_texture_compression_rgtc]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `EXT_texture_compression_rgtc ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_COMPRESSED_RED_GREEN_RGTC2_EXT: 'tags this -> GLenum.t [@@js.get "COMPRESSED_RED_GREEN_RGTC2_EXT"]
  val get_COMPRESSED_RED_RGTC1_EXT: 'tags this -> GLenum.t [@@js.get "COMPRESSED_RED_RGTC1_EXT"]
  val get_COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT: 'tags this -> GLenum.t [@@js.get "COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT"]
  val get_COMPRESSED_SIGNED_RED_RGTC1_EXT: 'tags this -> GLenum.t [@@js.get "COMPRESSED_SIGNED_RED_RGTC1_EXT"]
  val create: compressed_red_green_rgtc2_ext:(GLenum.t[@js "COMPRESSED_RED_GREEN_RGTC2_EXT"]) -> compressed_red_rgtc1_ext:(GLenum.t[@js "COMPRESSED_RED_RGTC1_EXT"]) -> compressed_signed_red_green_rgtc2_ext:(GLenum.t[@js "COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT"]) -> compressed_signed_red_rgtc1_ext:(GLenum.t[@js "COMPRESSED_SIGNED_RED_RGTC1_EXT"]) -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module DocumentEventMap : sig
  type t = [`DocumentAndElementEventHandlersEventMap | `DocumentEventMap | `GlobalEventHandlersEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`DocumentAndElementEventHandlersEventMap | `DocumentEventMap | `GlobalEventHandlersEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`DocumentAndElementEventHandlersEventMap | `DocumentEventMap | `GlobalEventHandlersEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `DocumentEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_fullscreenchange: 'tags this -> Event.t [@@js.get "fullscreenchange"]
  val set_fullscreenchange: 'tags this -> Event.t -> unit [@@js.set "fullscreenchange"]
  val get_fullscreenerror: 'tags this -> Event.t [@@js.get "fullscreenerror"]
  val set_fullscreenerror: 'tags this -> Event.t -> unit [@@js.set "fullscreenerror"]
  val get_pointerlockchange: 'tags this -> Event.t [@@js.get "pointerlockchange"]
  val set_pointerlockchange: 'tags this -> Event.t -> unit [@@js.set "pointerlockchange"]
  val get_pointerlockerror: 'tags this -> Event.t [@@js.get "pointerlockerror"]
  val set_pointerlockerror: 'tags this -> Event.t -> unit [@@js.set "pointerlockerror"]
  val get_readystatechange: 'tags this -> Event.t [@@js.get "readystatechange"]
  val set_readystatechange: 'tags this -> Event.t -> unit [@@js.set "readystatechange"]
  val get_visibilitychange: 'tags this -> Event.t [@@js.get "visibilitychange"]
  val set_visibilitychange: 'tags this -> Event.t -> unit [@@js.set "visibilitychange"]
  val create: fullscreenchange:Event.t -> fullscreenerror:Event.t -> pointerlockchange:Event.t -> pointerlockerror:Event.t -> readystatechange:Event.t -> visibilitychange:Event.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module DisplayCaptureSurfaceType : sig
  type t = ([`L_s123_application[@js "application"] | `L_s172_browser[@js "browser"] | `L_s518_monitor[@js "monitor"] | `L_s872_window[@js "window"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module DOMQuadInit : sig
  type t = [`DOMQuadInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`DOMQuadInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`DOMQuadInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `DOMQuadInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_p1: 'tags this -> DOMPointInit.t option [@@js.get "p1"]
  val set_p1: 'tags this -> DOMPointInit.t -> unit [@@js.set "p1"]
  val get_p2: 'tags this -> DOMPointInit.t option [@@js.get "p2"]
  val set_p2: 'tags this -> DOMPointInit.t -> unit [@@js.set "p2"]
  val get_p3: 'tags this -> DOMPointInit.t option [@@js.get "p3"]
  val set_p3: 'tags this -> DOMPointInit.t -> unit [@@js.set "p3"]
  val get_p4: 'tags this -> DOMPointInit.t option [@@js.get "p4"]
  val set_p4: 'tags this -> DOMPointInit.t -> unit [@@js.set "p4"]
  val create: ?p1:DOMPointInit.t -> ?p2:DOMPointInit.t -> ?p3:DOMPointInit.t -> ?p4:DOMPointInit.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module[@js.scope "DOMQuad"] DOMQuad : sig
  type t = [`DOMQuad] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`DOMQuad]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`DOMQuad]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `DOMQuad ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_p1: 'tags this -> DOMPoint.t [@@js.get "p1"]
  val get_p2: 'tags this -> DOMPoint.t [@@js.get "p2"]
  val get_p3: 'tags this -> DOMPoint.t [@@js.get "p3"]
  val get_p4: 'tags this -> DOMPoint.t [@@js.get "p4"]
  val getBounds: 'tags this -> DOMRect.t [@@js.call "getBounds"]
  val toJSON: 'tags this -> any [@@js.call "toJSON"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: ?p1:DOMPointInit.t -> ?p2:DOMPointInit.t -> ?p3:DOMPointInit.t -> ?p4:DOMPointInit.t -> unit -> t [@@js.create]
  val fromQuad: ?other:DOMQuadInit.t -> unit -> t [@@js.global "fromQuad"]
  val fromRect: ?other:DOMRectInit.t -> unit -> t [@@js.global "fromRect"]
end
module DOMParserSupportedType : sig
  type t = ([`L_s124_application_xhtml_xml[@js "application/xhtml+xml"] | `L_s125_application_xml[@js "application/xml"] | `L_s417_image_svg_xml[@js "image/svg+xml"] | `L_s789_text_html[@js "text/html"] | `L_s790_text_xml[@js "text/xml"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end

(** Provides the ability to parse XML or HTML source code from a string into a DOM Document. *)
module[@js.scope "DOMParser"] DOMParser : sig
  type t = [`DOMParser] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`DOMParser]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`DOMParser]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `DOMParser ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    Parses string using either the HTML or XML parser, according to type, and returns the resulting Document. type can be "text/html" (which will invoke the HTML parser), or any of "text/xml", "application/xml", "application/xhtml+xml", or "image/svg+xml" (which will invoke the XML parser).
    
    For the XML parser, if string cannot be parsed, then the returned Document will contain elements describing the resulting error.
    
    Note that script elements are not evaluated during parsing, and the resulting document's encoding will always be UTF-8.
    
    Values other than the above for type will cause a TypeError exception to be thrown.
  *)
  val parseFromString: 'tags this -> string:string -> type_:DOMParserSupportedType.t -> Document.t [@@js.call "parseFromString"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module QueuingStrategyInit : sig
  type t = [`QueuingStrategyInit] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`QueuingStrategyInit]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`QueuingStrategyInit]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `QueuingStrategyInit ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    Creates a new ByteLengthQueuingStrategy with the provided high water mark.
    
    Note that the provided high water mark will not be validated ahead of time. Instead, if it is negative, NaN, or not a number, the resulting ByteLengthQueuingStrategy will cause the corresponding stream constructor to throw.
  *)
  val get_highWaterMark: 'tags this -> float [@@js.get "highWaterMark"]
  
  (**
    Creates a new ByteLengthQueuingStrategy with the provided high water mark.
    
    Note that the provided high water mark will not be validated ahead of time. Instead, if it is negative, NaN, or not a number, the resulting ByteLengthQueuingStrategy will cause the corresponding stream constructor to throw.
  *)
  val set_highWaterMark: 'tags this -> float -> unit [@@js.set "highWaterMark"]
  val create: highWaterMark:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** This Streams API interface provides a built-in byte length queuing strategy that can be used when constructing streams. *)
module[@js.scope "CountQueuingStrategy"] CountQueuingStrategy : sig
  type t = [`CountQueuingStrategy | `QueuingStrategy of any] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`CountQueuingStrategy | `QueuingStrategy of any]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`CountQueuingStrategy | `QueuingStrategy of any]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `CountQueuingStrategy ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_highWaterMark: 'tags this -> float [@@js.get "highWaterMark"]
  val get_size: 'tags this -> QueuingStrategySize.t_0 [@@js.get "size"]
  val create: highWaterMark:float -> size:QueuingStrategySize.t_0 -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': QueuingStrategyInit.t -> t [@@js.create]
end
module Console : sig
  type t = [`Console] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Console]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Console]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `Console ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (**
    `console.assert()` writes a message if `value` is \[falsy\](https://developer.mozilla.org/en-US/docs/Glossary/Falsy) or omitted. It only
    writes a message and does not otherwise affect execution. The output always
    starts with `"Assertion failed"`. If provided, `message` is formatted using `util.format()`.
    
    If `value` is \[truthy\](https://developer.mozilla.org/en-US/docs/Glossary/Truthy), nothing happens.
    
    ```js
    console.assert(true, 'does nothing');
    
    console.assert(false, 'Whoops %s work', 'didn\'t');
    // Assertion failed: Whoops didn't work
    
    console.assert();
    // Assertion failed
    ```
  *)
  val assert_: 'tags this -> ?condition:bool -> data:(any list [@js.variadic]) -> unit -> unit [@@js.call "assert"]
  
  (**
    When `stdout` is a TTY, calling `console.clear()` will attempt to clear the
    TTY. When `stdout` is not a TTY, this method does nothing.
    
    The specific operation of `console.clear()` can vary across operating systems
    and terminal types. For most Linux operating systems, `console.clear()`operates similarly to the `clear` shell command. On Windows, `console.clear()`will clear only the output in the
    current terminal viewport for the Node.js
    binary.
  *)
  val clear: 'tags this -> unit [@@js.call "clear"]
  
  (**
    Maintains an internal counter specific to `label` and outputs to `stdout` the
    number of times `console.count()` has been called with the given `label`.
    
    ```js
    > console.count()
    default: 1
    undefined
    > console.count('default')
    default: 2
    undefined
    > console.count('abc')
    abc: 1
    undefined
    > console.count('xyz')
    xyz: 1
    undefined
    > console.count('abc')
    abc: 2
    undefined
    > console.count()
    default: 3
    undefined
    >
    ```
  *)
  val count: 'tags this -> ?label:string -> unit -> unit [@@js.call "count"]
  
  (**
    Resets the internal counter specific to `label`.
    
    ```js
    > console.count('abc');
    abc: 1
    undefined
    > console.countReset('abc');
    undefined
    > console.count('abc');
    abc: 1
    undefined
    >
    ```
  *)
  val countReset: 'tags this -> ?label:string -> unit -> unit [@@js.call "countReset"]
  
  (**
    The `console.debug()` function is an alias for 
    \{\@link 
    log
    \}
    .
  *)
  val debug: 'tags this -> data:(any list [@js.variadic]) -> unit [@@js.call "debug"]
  
  (**
    Uses `util.inspect()` on `obj` and prints the resulting string to `stdout`.
    This function bypasses any custom `inspect()` function defined on `obj`.
  *)
  val dir: 'tags this -> ?item:any -> ?options:any -> unit -> unit [@@js.call "dir"]
  
  (**
    This method calls `console.log()` passing it the arguments received.
    This method does not produce any XML formatting.
  *)
  val dirxml: 'tags this -> data:(any list [@js.variadic]) -> unit [@@js.call "dirxml"]
  
  (**
    Prints to `stderr` with newline. Multiple arguments can be passed, with the
    first used as the primary message and all additional used as substitution
    values similar to \[`printf(3)`\](http://man7.org/linux/man-pages/man3/printf.3.html) (the arguments are all passed to `util.format()`).
    
    ```js
    const code = 5;
    console.error('error #%d', code);
    // Prints: error #5, to stderr
    console.error('error', code);
    // Prints: error 5, to stderr
    ```
    
    If formatting elements (e.g. `%d`) are not found in the first string then `util.inspect()` is called on each argument and the resulting string
    values are concatenated. See `util.format()` for more information.
  *)
  val error: 'tags this -> data:(any list [@js.variadic]) -> unit [@@js.call "error"]
  
  (**
    Increases indentation of subsequent lines by spaces for `groupIndentation`length.
    
    If one or more `label`s are provided, those are printed first without the
    additional indentation.
  *)
  val group: 'tags this -> data:(any list [@js.variadic]) -> unit [@@js.call "group"]
  
  (**
    An alias for 
    \{\@link 
    group
    \}
    .
  *)
  val groupCollapsed: 'tags this -> data:(any list [@js.variadic]) -> unit [@@js.call "groupCollapsed"]
  
  (** Decreases indentation of subsequent lines by spaces for `groupIndentation`length. *)
  val groupEnd: 'tags this -> unit [@@js.call "groupEnd"]
  
  (**
    The `console.info()` function is an alias for 
    \{\@link 
    log
    \}
    .
  *)
  val info: 'tags this -> data:(any list [@js.variadic]) -> unit [@@js.call "info"]
  
  (**
    Prints to `stdout` with newline. Multiple arguments can be passed, with the
    first used as the primary message and all additional used as substitution
    values similar to \[`printf(3)`\](http://man7.org/linux/man-pages/man3/printf.3.html) (the arguments are all passed to `util.format()`).
    
    ```js
    const count = 5;
    console.log('count: %d', count);
    // Prints: count: 5, to stdout
    console.log('count:', count);
    // Prints: count: 5, to stdout
    ```
    
    See `util.format()` for more information.
  *)
  val log: 'tags this -> data:(any list [@js.variadic]) -> unit [@@js.call "log"]
  
  (**
    Try to construct a table with the columns of the properties of `tabularData`(or use `properties`) and rows of `tabularData` and log it. Falls back to just
    logging the argument if it can’t be parsed as tabular.
    
    ```js
    // These can't be parsed as tabular data
    console.table(Symbol());
    // Symbol()
    
    console.table(undefined);
    // undefined
    
    console.table(\[\{ a: 1, b: 'Y' \}, \{ a: 'Z', b: 2 \}\]);
    // ┌─────────┬─────┬─────┐
    // │ (index) │  a  │  b  │
    // ├─────────┼─────┼─────┤
    // │    0    │  1  │ 'Y' │
    // │    1    │ 'Z' │  2  │
    // └─────────┴─────┴─────┘
    
    console.table(\[\{ a: 1, b: 'Y' \}, \{ a: 'Z', b: 2 \}\], \['a'\]);
    // ┌─────────┬─────┐
    // │ (index) │  a  │
    // ├─────────┼─────┤
    // │    0    │  1  │
    // │    1    │ 'Z' │
    // └─────────┴─────┘
    ```
  *)
  val table: 'tags this -> ?tabularData:any -> ?properties:string list -> unit -> unit [@@js.call "table"]
  
  (**
    Starts a timer that can be used to compute the duration of an operation. Timers
    are identified by a unique `label`. Use the same `label` when calling 
    \{\@link 
    timeEnd
    \}
     to stop the timer and output the elapsed time in
    suitable time units to `stdout`. For example, if the elapsed
    time is 3869ms, `console.timeEnd()` displays "3.869s".
  *)
  val time: 'tags this -> ?label:string -> unit -> unit [@@js.call "time"]
  
  (**
    Stops a timer that was previously started by calling 
    \{\@link 
    time
    \}
     and
    prints the result to `stdout`:
    
    ```js
    console.time('100-elements');
    for (let i = 0; i < 100; i++) \{\}
    console.timeEnd('100-elements');
    // prints 100-elements: 225.438ms
    ```
  *)
  val timeEnd: 'tags this -> ?label:string -> unit -> unit [@@js.call "timeEnd"]
  
  (**
    For a timer that was previously started by calling 
    \{\@link 
    time
    \}
    , prints
    the elapsed time and other `data` arguments to `stdout`:
    
    ```js
    console.time('process');
    const value = expensiveProcess1(); // Returns 42
    console.timeLog('process', value);
    // Prints "process: 365.227ms 42".
    doExpensiveProcess2(value);
    console.timeEnd('process');
    ```
  *)
  val timeLog: 'tags this -> ?label:string -> data:(any list [@js.variadic]) -> unit -> unit [@@js.call "timeLog"]
  
  (**
    This method does not display anything unless used in the inspector.
     Adds an event with the label `label` to the Timeline panel of the inspector.
  *)
  val timeStamp: 'tags this -> ?label:string -> unit -> unit [@@js.call "timeStamp"]
  
  (**
    Prints to `stderr` the string `'Trace: '`, followed by the `util.format()` formatted message and stack trace to the current position in the code.
    
    ```js
    console.trace('Show me');
    // Prints: (stack trace will vary based on where trace is called)
    //  Trace: Show me
    //    at repl:2:9
    //    at REPLServer.defaultEval (repl.js:248:27)
    //    at bound (domain.js:287:14)
    //    at REPLServer.runBound \[as eval\] (domain.js:300:12)
    //    at REPLServer.<anonymous> (repl.js:412:12)
    //    at emitOne (events.js:82:20)
    //    at REPLServer.emit (events.js:169:7)
    //    at REPLServer.Interface._onLine (readline.js:210:10)
    //    at REPLServer.Interface._line (readline.js:549:8)
    //    at REPLServer.Interface._ttyWrite (readline.js:826:14)
    ```
  *)
  val trace: 'tags this -> data:(any list [@js.variadic]) -> unit [@@js.call "trace"]
  
  (**
    The `console.warn()` function is an alias for 
    \{\@link 
    error
    \}
    .
  *)
  val warn: 'tags this -> data:(any list [@js.variadic]) -> unit [@@js.call "warn"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module ClipboardItemData : sig
  type t = ClipboardItemDataType.t Promise.t_1
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end

(** @deprecated  *)
module ClientRect : sig
  type t = [`ClientRect | `DOMRect | `DOMRectReadOnly] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ClientRect | `DOMRect | `DOMRectReadOnly]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ClientRect | `DOMRect | `DOMRectReadOnly]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ClientRect ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module ClientTypes : sig
  type t = ([`L_s106_all[@js "all"] | `L_s719_sharedworker[@js "sharedworker"] | `L_s872_window[@js "window"] | `L_s873_worker[@js "worker"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module ClientQueryOptions : sig
  type t = [`ClientQueryOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ClientQueryOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ClientQueryOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ClientQueryOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_includeUncontrolled: 'tags this -> bool option [@@js.get "includeUncontrolled"]
  val set_includeUncontrolled: 'tags this -> bool -> unit [@@js.set "includeUncontrolled"]
  val get_type: 'tags this -> ClientTypes.t option [@@js.get "type"]
  val set_type: 'tags this -> ClientTypes.t -> unit [@@js.set "type"]
  val create: ?includeUncontrolled:bool -> ?type_:(ClientTypes.t[@js "type"]) -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module CanvasTextRendering : sig
  type t = ([`L_s141_auto[@js "auto"] | `L_s371_geometricPrecision[@js "geometricPrecision"] | `L_s566_optimizeLegibility[@js "optimizeLegibility"] | `L_s567_optimizeSpeed[@js "optimizeSpeed"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module CanvasFontVariantCaps : sig
  type t = ([`L_s107_all_petite_caps[@js "all-petite-caps"] | `L_s108_all_small_caps[@js "all-small-caps"] | `L_s550_normal[@js "normal"] | `L_s601_petite_caps[@js "petite-caps"] | `L_s730_small_caps[@js "small-caps"] | `L_s800_titling_caps[@js "titling-caps"] | `L_s826_unicase[@js "unicase"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module CanvasFontStretch : sig
  type t = ([`L_s214_condensed[@js "condensed"] | `L_s304_expanded[@js "expanded"] | `L_s309_extra_condensed[@js "extra-condensed"] | `L_s310_extra_expanded[@js "extra-expanded"] | `L_s550_normal[@js "normal"] | `L_s712_semi_condensed[@js "semi-condensed"] | `L_s713_semi_expanded[@js "semi-expanded"] | `L_s823_ultra_condensed[@js "ultra-condensed"] | `L_s824_ultra_expanded[@js "ultra-expanded"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module CanvasFontKerning : sig
  type t = ([`L_s141_auto[@js "auto"] | `L_s548_none[@js "none"] | `L_s550_normal[@js "normal"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module[@js.scope "CanvasCaptureMediaStreamTrack"] CanvasCaptureMediaStreamTrack : sig
  type t = [`CanvasCaptureMediaStreamTrack | `EventTarget | `MediaStreamTrack] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`CanvasCaptureMediaStreamTrack | `EventTarget | `MediaStreamTrack]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`CanvasCaptureMediaStreamTrack | `EventTarget | `MediaStreamTrack]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `CanvasCaptureMediaStreamTrack ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_canvas: 'tags this -> HTMLCanvasElement.t [@@js.get "canvas"]
  val requestFrame: 'tags this -> unit [@@js.call "requestFrame"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'MediaStreamTrackEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'MediaStreamTrackEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module[@js.scope "CSSTransition"] CSSTransition : sig
  type t = [`Animation | `CSSTransition | `EventTarget] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Animation | `CSSTransition | `EventTarget]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Animation | `CSSTransition | `EventTarget]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `CSSTransition ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_transitionProperty: 'tags this -> string [@@js.get "transitionProperty"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'AnimationEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'AnimationEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Any CSS at-rule that contains other rules nested within it. *)
module[@js.scope "CSSGroupingRule"] CSSGroupingRule : sig
  type t = [`CSSGroupingRule | `CSSRule] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`CSSGroupingRule | `CSSRule]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`CSSGroupingRule | `CSSRule]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `CSSGroupingRule ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_cssRules: 'tags this -> CSSRuleList.t [@@js.get "cssRules"]
  val deleteRule: 'tags this -> index:float -> unit [@@js.call "deleteRule"]
  val insertRule: 'tags this -> rule:string -> ?index:float -> unit -> float [@@js.call "insertRule"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** A single condition CSS at-rule, which consists of a condition and a statement block. It is a child of CSSGroupingRule. *)
module[@js.scope "CSSConditionRule"] CSSConditionRule : sig
  type t = [`CSSConditionRule | `CSSGroupingRule | `CSSRule] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`CSSConditionRule | `CSSGroupingRule | `CSSRule]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`CSSConditionRule | `CSSGroupingRule | `CSSRule]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `CSSConditionRule ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_conditionText: 'tags this -> string [@@js.get "conditionText"]
  val set_conditionText: 'tags this -> string -> unit [@@js.set "conditionText"]
  val create: conditionText:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end

(** An object representing a single CSS \@supports at-rule. It implements the CSSConditionRule interface, and therefore the CSSRule and CSSGroupingRule interfaces with a type value of 12 (CSSRule.SUPPORTS_RULE). *)
module[@js.scope "CSSSupportsRule"] CSSSupportsRule : sig
  type t = [`CSSConditionRule | `CSSGroupingRule | `CSSRule | `CSSSupportsRule] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`CSSConditionRule | `CSSGroupingRule | `CSSRule | `CSSSupportsRule]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`CSSConditionRule | `CSSGroupingRule | `CSSRule | `CSSSupportsRule]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `CSSSupportsRule ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** CSSStyleRule represents a single CSS style rule. It implements the CSSRule interface with a type value of 1 (CSSRule.STYLE_RULE). *)
module[@js.scope "CSSStyleRule"] CSSStyleRule : sig
  type t = [`CSSRule | `CSSStyleRule] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`CSSRule | `CSSStyleRule]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`CSSRule | `CSSStyleRule]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `CSSStyleRule ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_selectorText: 'tags this -> string [@@js.get "selectorText"]
  val set_selectorText: 'tags this -> string -> unit [@@js.set "selectorText"]
  val get_style: 'tags this -> CSSStyleDeclaration.t [@@js.get "style"]
  val create: selectorText:string -> style:CSSStyleDeclaration.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end

(** CSSPageRule is an interface representing a single CSS \@page rule. It implements the CSSRule interface with a type value of 6 (CSSRule.PAGE_RULE). *)
module[@js.scope "CSSPageRule"] CSSPageRule : sig
  type t = [`CSSGroupingRule | `CSSPageRule | `CSSRule] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`CSSGroupingRule | `CSSPageRule | `CSSRule]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`CSSGroupingRule | `CSSPageRule | `CSSRule]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `CSSPageRule ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_selectorText: 'tags this -> string [@@js.get "selectorText"]
  val set_selectorText: 'tags this -> string -> unit [@@js.set "selectorText"]
  val get_style: 'tags this -> CSSStyleDeclaration.t [@@js.get "style"]
  val create: selectorText:string -> style:CSSStyleDeclaration.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end

(** An object representing a single CSS \@namespace at-rule. It implements the CSSRule interface, with a type value of 10 (CSSRule.NAMESPACE_RULE). *)
module[@js.scope "CSSNamespaceRule"] CSSNamespaceRule : sig
  type t = [`CSSNamespaceRule | `CSSRule] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`CSSNamespaceRule | `CSSRule]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`CSSNamespaceRule | `CSSRule]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `CSSNamespaceRule ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_namespaceURI: 'tags this -> string [@@js.get "namespaceURI"]
  val get_prefix: 'tags this -> string [@@js.get "prefix"]
  val create: namespaceURI:string -> prefix:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end

(** A single CSS \@media rule. It implements the CSSConditionRule interface, and therefore the CSSGroupingRule and the CSSRule interface with a type value of 4 (CSSRule.MEDIA_RULE). *)
module[@js.scope "CSSMediaRule"] CSSMediaRule : sig
  type t = [`CSSConditionRule | `CSSGroupingRule | `CSSMediaRule | `CSSRule] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`CSSConditionRule | `CSSGroupingRule | `CSSMediaRule | `CSSRule]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`CSSConditionRule | `CSSGroupingRule | `CSSMediaRule | `CSSRule]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `CSSMediaRule ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_media: 'tags this -> MediaList.t [@@js.get "media"]
  val create: media:MediaList.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end

(** An object representing a set of style for a given keyframe. It corresponds to the contains of a single keyframe of a \@keyframes at-rule. It implements the CSSRule interface with a type value of 8 (CSSRule.KEYFRAME_RULE). *)
module[@js.scope "CSSKeyframeRule"] CSSKeyframeRule : sig
  type t = [`CSSKeyframeRule | `CSSRule] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`CSSKeyframeRule | `CSSRule]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`CSSKeyframeRule | `CSSRule]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `CSSKeyframeRule ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_keyText: 'tags this -> string [@@js.get "keyText"]
  val set_keyText: 'tags this -> string -> unit [@@js.set "keyText"]
  val get_style: 'tags this -> CSSStyleDeclaration.t [@@js.get "style"]
  val create: keyText:string -> style:CSSStyleDeclaration.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end

(** An object representing a complete set of keyframes for a CSS animation. It corresponds to the contains of a whole \@keyframes at-rule. It implements the CSSRule interface with a type value of 7 (CSSRule.KEYFRAMES_RULE). *)
module[@js.scope "CSSKeyframesRule"] CSSKeyframesRule : sig
  type t = [`CSSKeyframesRule | `CSSRule] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`CSSKeyframesRule | `CSSRule]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`CSSKeyframesRule | `CSSRule]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `CSSKeyframesRule ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_cssRules: 'tags this -> CSSRuleList.t [@@js.get "cssRules"]
  val get_name: 'tags this -> string [@@js.get "name"]
  val set_name: 'tags this -> string -> unit [@@js.set "name"]
  val appendRule: 'tags this -> rule:string -> unit [@@js.call "appendRule"]
  val deleteRule: 'tags this -> select:string -> unit [@@js.call "deleteRule"]
  val findRule: 'tags this -> select:string -> CSSKeyframeRule.t option [@@js.call "findRule"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module[@js.scope "CSSImportRule"] CSSImportRule : sig
  type t = [`CSSImportRule | `CSSRule] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`CSSImportRule | `CSSRule]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`CSSImportRule | `CSSRule]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `CSSImportRule ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_href: 'tags this -> string [@@js.get "href"]
  val get_media: 'tags this -> MediaList.t [@@js.get "media"]
  val get_styleSheet: 'tags this -> CSSStyleSheet.t [@@js.get "styleSheet"]
  val create: href:string -> media:MediaList.t -> styleSheet:CSSStyleSheet.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end
module[@js.scope "CSSFontFaceRule"] CSSFontFaceRule : sig
  type t = [`CSSFontFaceRule | `CSSRule] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`CSSFontFaceRule | `CSSRule]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`CSSFontFaceRule | `CSSRule]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `CSSFontFaceRule ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_style: 'tags this -> CSSStyleDeclaration.t [@@js.get "style"]
  val create: style:CSSStyleDeclaration.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end
module[@js.scope "CSSCounterStyleRule"] CSSCounterStyleRule : sig
  type t = [`CSSCounterStyleRule | `CSSRule] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`CSSCounterStyleRule | `CSSRule]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`CSSCounterStyleRule | `CSSRule]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `CSSCounterStyleRule ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_additiveSymbols: 'tags this -> string [@@js.get "additiveSymbols"]
  val set_additiveSymbols: 'tags this -> string -> unit [@@js.set "additiveSymbols"]
  val get_fallback: 'tags this -> string [@@js.get "fallback"]
  val set_fallback: 'tags this -> string -> unit [@@js.set "fallback"]
  val get_name: 'tags this -> string [@@js.get "name"]
  val set_name: 'tags this -> string -> unit [@@js.set "name"]
  val get_negative: 'tags this -> string [@@js.get "negative"]
  val set_negative: 'tags this -> string -> unit [@@js.set "negative"]
  val get_pad: 'tags this -> string [@@js.get "pad"]
  val set_pad: 'tags this -> string -> unit [@@js.set "pad"]
  val get_prefix: 'tags this -> string [@@js.get "prefix"]
  val set_prefix: 'tags this -> string -> unit [@@js.set "prefix"]
  val get_range: 'tags this -> string [@@js.get "range"]
  val set_range: 'tags this -> string -> unit [@@js.set "range"]
  val get_speakAs: 'tags this -> string [@@js.get "speakAs"]
  val set_speakAs: 'tags this -> string -> unit [@@js.set "speakAs"]
  val get_suffix: 'tags this -> string [@@js.get "suffix"]
  val set_suffix: 'tags this -> string -> unit [@@js.set "suffix"]
  val get_symbols: 'tags this -> string [@@js.get "symbols"]
  val set_symbols: 'tags this -> string -> unit [@@js.set "symbols"]
  val get_system: 'tags this -> string [@@js.get "system"]
  val set_system: 'tags this -> string -> unit [@@js.set "system"]
  val create: additiveSymbols:string -> fallback:string -> name:string -> negative:string -> pad:string -> prefix:string -> range:string -> speakAs:string -> suffix:string -> symbols:string -> system:string -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end
module[@js.scope "CSSAnimation"] CSSAnimation : sig
  type t = [`Animation | `CSSAnimation | `EventTarget] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`Animation | `CSSAnimation | `EventTarget]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`Animation | `CSSAnimation | `EventTarget]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `CSSAnimation ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_animationName: 'tags this -> string [@@js.get "animationName"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'AnimationEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'AnimationEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Holds useful CSS-related methods. No object with this interface are implemented: it contains only static methods and therefore is a utilitarian interface. *)
module[@js.scope "CSS"] CSS : sig
  val escape: string -> string [@@js.global "escape"]
  val supports: property:string -> value:string -> bool [@@js.global "supports"]
  val supports': string -> bool [@@js.global "supports"]
end

(** This Streams API interface provides a built-in byte length queuing strategy that can be used when constructing streams. *)
module[@js.scope "ByteLengthQueuingStrategy"] ByteLengthQueuingStrategy : sig
  type t = [`ByteLengthQueuingStrategy | `QueuingStrategy of ArrayBufferView.t_0] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`ByteLengthQueuingStrategy | `QueuingStrategy of ArrayBufferView.t_0]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`ByteLengthQueuingStrategy | `QueuingStrategy of ArrayBufferView.t_0]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `ByteLengthQueuingStrategy ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_highWaterMark: 'tags this -> float [@@js.get "highWaterMark"]
  val get_size: 'tags this -> ArrayBufferView.t_0 QueuingStrategySize.t [@@js.get "size"]
  val create: highWaterMark:float -> size:ArrayBufferView.t_0 QueuingStrategySize.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': QueuingStrategyInit.t -> t [@@js.create]
end
module BroadcastChannelEventMap : sig
  type t = [`BroadcastChannelEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`BroadcastChannelEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`BroadcastChannelEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `BroadcastChannelEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_message: 'tags this -> MessageEvent.t_0 [@@js.get "message"]
  val set_message: 'tags this -> MessageEvent.t_0 -> unit [@@js.set "message"]
  val get_messageerror: 'tags this -> MessageEvent.t_0 [@@js.get "messageerror"]
  val set_messageerror: 'tags this -> MessageEvent.t_0 -> unit [@@js.set "messageerror"]
  val create: message:MessageEvent.t_0 -> messageerror:MessageEvent.t_0 -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module[@js.scope "BroadcastChannel"] BroadcastChannel : sig
  type t = [`BroadcastChannel | `EventTarget] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`BroadcastChannel | `EventTarget]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`BroadcastChannel | `EventTarget]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `BroadcastChannel ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Returns the channel name (as passed to the constructor). *)
  val get_name: 'tags this -> string [@@js.get "name"]
  val get_onmessage: 'tags this -> (this:t -> ev:MessageEvent.t_0 -> any) option [@@js.get "onmessage"]
  val set_onmessage: 'tags this -> (this:t -> ev:MessageEvent.t_0 -> any) option -> unit [@@js.set "onmessage"]
  val get_onmessageerror: 'tags this -> (this:t -> ev:MessageEvent.t_0 -> any) option [@@js.get "onmessageerror"]
  val set_onmessageerror: 'tags this -> (this:t -> ev:MessageEvent.t_0 -> any) option -> unit [@@js.set "onmessageerror"]
  
  (** Closes the BroadcastChannel object, opening it up to garbage collection. *)
  val close: 'tags this -> unit [@@js.call "close"]
  
  (** Sends the given message to other BroadcastChannel objects set up for this channel. Messages can be structured objects, e.g. nested objects and arrays. *)
  val postMessage: 'tags this -> message:any -> unit [@@js.call "postMessage"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'BroadcastChannelEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'BroadcastChannelEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: string -> t [@@js.create]
end

(** Available only in secure contexts. *)
module[@js.scope "AuthenticatorAttestationResponse"] AuthenticatorAttestationResponse : sig
  type t = [`AuthenticatorAttestationResponse | `AuthenticatorResponse] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AuthenticatorAttestationResponse | `AuthenticatorResponse]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AuthenticatorAttestationResponse | `AuthenticatorResponse]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `AuthenticatorAttestationResponse ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_attestationObject: 'tags this -> ArrayBuffer.t_0 [@@js.get "attestationObject"]
  val create: attestationObject:ArrayBuffer.t_0 -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end

(** Available only in secure contexts. *)
module[@js.scope "AuthenticatorAssertionResponse"] AuthenticatorAssertionResponse : sig
  type t = [`AuthenticatorAssertionResponse | `AuthenticatorResponse] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AuthenticatorAssertionResponse | `AuthenticatorResponse]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AuthenticatorAssertionResponse | `AuthenticatorResponse]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `AuthenticatorAssertionResponse ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_authenticatorData: 'tags this -> ArrayBuffer.t_0 [@@js.get "authenticatorData"]
  val get_signature: 'tags this -> ArrayBuffer.t_0 [@@js.get "signature"]
  val get_userHandle: 'tags this -> ArrayBuffer.t_0 option [@@js.get "userHandle"]
  val create: authenticatorData:ArrayBuffer.t_0 -> signature:ArrayBuffer.t_0 -> ?userHandle:ArrayBuffer.t_0 -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': unit -> t [@@js.create]
end
module AudioWorkletNodeEventMap : sig
  type t = [`AudioWorkletNodeEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AudioWorkletNodeEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AudioWorkletNodeEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `AudioWorkletNodeEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_processorerror: 'tags this -> Event.t [@@js.get "processorerror"]
  val set_processorerror: 'tags this -> Event.t -> unit [@@js.set "processorerror"]
  val create: processorerror:Event.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module AudioWorkletNodeOptions : sig
  type t = [`AudioNodeOptions | `AudioWorkletNodeOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AudioNodeOptions | `AudioWorkletNodeOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AudioNodeOptions | `AudioWorkletNodeOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `AudioWorkletNodeOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_numberOfInputs: 'tags this -> float option [@@js.get "numberOfInputs"]
  val set_numberOfInputs: 'tags this -> float -> unit [@@js.set "numberOfInputs"]
  val get_numberOfOutputs: 'tags this -> float option [@@js.get "numberOfOutputs"]
  val set_numberOfOutputs: 'tags this -> float -> unit [@@js.set "numberOfOutputs"]
  val get_outputChannelCount: 'tags this -> float list option [@@js.get "outputChannelCount"]
  val set_outputChannelCount: 'tags this -> float list -> unit [@@js.set "outputChannelCount"]
  val get_parameterData: 'tags this -> (string, float) Record.t_2 option [@@js.get "parameterData"]
  val set_parameterData: 'tags this -> (string, float) Record.t_2 -> unit [@@js.set "parameterData"]
  val get_processorOptions: 'tags this -> any option [@@js.get "processorOptions"]
  val set_processorOptions: 'tags this -> any -> unit [@@js.set "processorOptions"]
  val create: ?numberOfInputs:float -> ?numberOfOutputs:float -> ?outputChannelCount:float list -> ?parameterData:(string, float) Record.t_2 -> ?processorOptions:any -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module[@js.scope "AudioParamMap"] AudioParamMap : sig
  type t = [`AudioParamMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AudioParamMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AudioParamMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `AudioParamMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val forEach: 'tags this -> callbackfn:(value:AudioParam.t -> key:string -> parent:t -> unit) -> ?thisArg:any -> unit -> unit [@@js.call "forEach"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end

(** Available only in secure contexts. *)
module[@js.scope "AudioWorkletNode"] AudioWorkletNode : sig
  type t = [`AudioNode | `AudioWorkletNode | `EventTarget] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AudioNode | `AudioWorkletNode | `EventTarget]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AudioNode | `AudioWorkletNode | `EventTarget]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `AudioWorkletNode ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_onprocessorerror: 'tags this -> (this:t -> ev:Event.t -> any) option [@@js.get "onprocessorerror"]
  val set_onprocessorerror: 'tags this -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onprocessorerror"]
  val get_parameters: 'tags this -> AudioParamMap.t [@@js.get "parameters"]
  val get_port: 'tags this -> MessagePort.t [@@js.get "port"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'AudioWorkletNodeEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'AudioWorkletNodeEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: context:BaseAudioContext.t -> name:string -> ?options:AudioWorkletNodeOptions.t -> unit -> t [@@js.create]
end
module AudioScheduledSourceNodeEventMap : sig
  type t = [`AudioScheduledSourceNodeEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AudioScheduledSourceNodeEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AudioScheduledSourceNodeEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `AudioScheduledSourceNodeEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_ended: 'tags this -> Event.t [@@js.get "ended"]
  val set_ended: 'tags this -> Event.t -> unit [@@js.set "ended"]
  val create: ended:Event.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module MediaStreamAudioSourceOptions : sig
  type t = [`MediaStreamAudioSourceOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`MediaStreamAudioSourceOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`MediaStreamAudioSourceOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MediaStreamAudioSourceOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_mediaStream: 'tags this -> MediaStream.t [@@js.get "mediaStream"]
  val set_mediaStream: 'tags this -> MediaStream.t -> unit [@@js.set "mediaStream"]
  val create: mediaStream:MediaStream.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module MediaElementAudioSourceOptions : sig
  type t = [`MediaElementAudioSourceOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`MediaElementAudioSourceOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`MediaElementAudioSourceOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MediaElementAudioSourceOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_mediaElement: 'tags this -> HTMLMediaElement.t [@@js.get "mediaElement"]
  val set_mediaElement: 'tags this -> HTMLMediaElement.t -> unit [@@js.set "mediaElement"]
  val create: mediaElement:HTMLMediaElement.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module AudioTimestamp : sig
  type t = [`AudioTimestamp] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AudioTimestamp]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AudioTimestamp]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `AudioTimestamp ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_contextTime: 'tags this -> float option [@@js.get "contextTime"]
  val set_contextTime: 'tags this -> float -> unit [@@js.set "contextTime"]
  val get_performanceTime: 'tags this -> DOMHighResTimeStamp.t option [@@js.get "performanceTime"]
  val set_performanceTime: 'tags this -> DOMHighResTimeStamp.t -> unit [@@js.set "performanceTime"]
  val create: ?contextTime:float -> ?performanceTime:DOMHighResTimeStamp.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module AudioContextLatencyCategory : sig
  type t = ([`L_s147_balanced[@js "balanced"] | `L_s433_interactive[@js "interactive"] | `L_s607_playback[@js "playback"]] [@js.enum])
  type t_0 = t
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module AudioContextOptions : sig
  type t = [`AudioContextOptions] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AudioContextOptions]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AudioContextOptions]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `AudioContextOptions ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_latencyHint: 'tags this -> ([`Number of float | `Other of AudioContextLatencyCategory.t] [@js.union on_field "dummy"]) Primitive.t option [@@js.get "latencyHint"]
  val set_latencyHint: 'tags this -> ([`U1 of AudioContextLatencyCategory.t | `U2 of float] [@js.union]) -> unit [@@js.set "latencyHint"]
  val get_sampleRate: 'tags this -> float option [@@js.get "sampleRate"]
  val set_sampleRate: 'tags this -> float -> unit [@@js.set "sampleRate"]
  val create: ?latencyHint:([`Number of float | `Other of AudioContextLatencyCategory.t] [@js.union on_field "dummy"]) Primitive.t -> ?sampleRate:float -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** An audio-processing graph built from audio modules linked together, each represented by an AudioNode. *)
module[@js.scope "AudioContext"] rec AudioContext : sig
  type t = [`AudioContext | `BaseAudioContext | `EventTarget] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AudioContext | `BaseAudioContext | `EventTarget]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AudioContext | `BaseAudioContext | `EventTarget]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `AudioContext ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_baseLatency: 'tags this -> float [@@js.get "baseLatency"]
  val close: 'tags this -> unit Promise.t_1 [@@js.call "close"]
  val createMediaElementSource: 'tags this -> mediaElement:HTMLMediaElement.t -> MediaElementAudioSourceNode.t [@@js.call "createMediaElementSource"]
  val createMediaStreamDestination: 'tags this -> MediaStreamAudioDestinationNode.t [@@js.call "createMediaStreamDestination"]
  val createMediaStreamSource: 'tags this -> mediaStream:MediaStream.t -> MediaStreamAudioSourceNode.t [@@js.call "createMediaStreamSource"]
  val getOutputTimestamp: 'tags this -> AudioTimestamp.t [@@js.call "getOutputTimestamp"]
  val resume: 'tags this -> unit Promise.t_1 [@@js.call "resume"]
  val suspend: 'tags this -> unit Promise.t_1 [@@js.call "suspend"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'BaseAudioContextEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: 'tags this -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'BaseAudioContextEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener': 'tags this -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: ?contextOptions:AudioContextOptions.t -> unit -> t [@@js.create]
end

(** A MediaElementSourceNode has no inputs and exactly one output, and is created using the AudioContext.createMediaElementSource method. The amount of channels in the output equals the number of channels of the audio referenced by the HTMLMediaElement used in the creation of the node, or is 1 if the HTMLMediaElement has no audio. *)
and[@js.scope "MediaElementAudioSourceNode"] MediaElementAudioSourceNode : sig
  type t = [`AudioNode | `EventTarget | `MediaElementAudioSourceNode] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AudioNode | `EventTarget | `MediaElementAudioSourceNode]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AudioNode | `EventTarget | `MediaElementAudioSourceNode]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MediaElementAudioSourceNode ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_mediaElement: 'tags this -> HTMLMediaElement.t [@@js.get "mediaElement"]
  val create: mediaElement:HTMLMediaElement.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': context:AudioContext.t -> options:MediaElementAudioSourceOptions.t -> t [@@js.create]
end
and[@js.scope "MediaStreamAudioDestinationNode"] MediaStreamAudioDestinationNode : sig
  type t = [`AudioNode | `EventTarget | `MediaStreamAudioDestinationNode] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AudioNode | `EventTarget | `MediaStreamAudioDestinationNode]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AudioNode | `EventTarget | `MediaStreamAudioDestinationNode]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MediaStreamAudioDestinationNode ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_stream: 'tags this -> MediaStream.t [@@js.get "stream"]
  val create: stream:MediaStream.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': context:AudioContext.t -> ?options:AudioNodeOptions.t -> unit -> t [@@js.create]
end

(** A type of AudioNode which operates as an audio source whose media is received from a MediaStream obtained using the WebRTC or Media Capture and Streams APIs. *)
and[@js.scope "MediaStreamAudioSourceNode"] MediaStreamAudioSourceNode : sig
  type t = [`AudioNode | `EventTarget | `MediaStreamAudioSourceNode] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AudioNode | `EventTarget | `MediaStreamAudioSourceNode]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AudioNode | `EventTarget | `MediaStreamAudioSourceNode]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `MediaStreamAudioSourceNode ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_mediaStream: 'tags this -> MediaStream.t [@@js.get "mediaStream"]
  val create: mediaStream:MediaStream.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create': context:AudioContext.t -> options:MediaStreamAudioSourceOptions.t -> t [@@js.create]
end
module[@js.scope "Audio"] Audio : sig
  val create: ?src:string -> unit -> HTMLAudioElement.t [@@js.create]
end
module AnimationEventMap : sig
  type t = [`AnimationEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AnimationEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AnimationEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `AnimationEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_cancel: 'tags this -> AnimationPlaybackEvent.t [@@js.get "cancel"]
  val set_cancel: 'tags this -> AnimationPlaybackEvent.t -> unit [@@js.set "cancel"]
  val get_finish: 'tags this -> AnimationPlaybackEvent.t [@@js.get "finish"]
  val set_finish: 'tags this -> AnimationPlaybackEvent.t -> unit [@@js.set "finish"]
  val get_remove: 'tags this -> Event.t [@@js.get "remove"]
  val set_remove: 'tags this -> Event.t -> unit [@@js.set "remove"]
  val create: cancel:AnimationPlaybackEvent.t -> finish:AnimationPlaybackEvent.t -> remove:Event.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end
module AbortSignalEventMap : sig
  type t = [`AbortSignalEventMap] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AbortSignalEventMap]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AbortSignalEventMap]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `AbortSignalEventMap ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_abort: 'tags this -> Event.t [@@js.get "abort"]
  val set_abort: 'tags this -> Event.t -> unit [@@js.set "abort"]
  val create: abort:Event.t -> unit -> t [@@js.builder]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
end

(** A controller object that allows you to abort one or more DOM requests as and when desired. *)
module[@js.scope "AbortController"] AbortController : sig
  type t = [`AbortController] intf [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  type t_0 = t
  [@@@js.stop]
  type tags = [`AbortController]
  type tags_0 = tags
  [@@@js.start]
  [@@@js.implem 
    type tags = [`AbortController]
    type tags_0 = tags
  ]
  type 'tags this = 'tags intf constraint 'tags = [> `AbortController ]
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  
  (** Returns the AbortSignal object associated with this object. *)
  val get_signal: 'tags this -> AbortSignal.t [@@js.get "signal"]
  
  (** Invoking this method will set this object's AbortSignal's aborted flag and signal to any observers that the associated activity is to be aborted. *)
  val abort: 'tags this -> ?reason:any -> unit -> unit [@@js.call "abort"]
  val cast_from: 'tags this -> t [@@js.custom let cast_from = Obj.magic]
  val prototype: unit -> t [@@js.get "prototype"]
  val create: unit -> t [@@js.create]
end
module CustomEventInit_Make (T : Ojs.T) : sig
  type 'T parent = 'T CustomEventInit.t
  type t = T.t parent
  val t_of_js: Ojs.t -> t
  val t_to_js: t -> Ojs.t
  
  val get_detail: t -> T.t option [@@js.get "detail"]
  val set_detail: t -> T.t -> unit [@@js.set "detail"]
end
module MessageEventInit_Make (T : Ojs.T) : sig
  type 'T parent = 'T MessageEventInit.t
  type t = T.t parent
  val t_of_js: Ojs.t -> t
  val t_to_js: t -> Ojs.t
  
  val get_data: t -> T.t option [@@js.get "data"]
  val set_data: t -> T.t -> unit [@@js.set "data"]
  val get_lastEventId: t -> string option [@@js.get "lastEventId"]
  val set_lastEventId: t -> string -> unit [@@js.set "lastEventId"]
  val get_origin: t -> string option [@@js.get "origin"]
  val set_origin: t -> string -> unit [@@js.set "origin"]
  val get_ports: t -> MessagePort.t list option [@@js.get "ports"]
  val set_ports: t -> MessagePort.t list -> unit [@@js.set "ports"]
  val get_source: t -> MessageEventSource.t option option [@@js.get "source"]
  val set_source: t -> MessageEventSource.t option -> unit [@@js.set "source"]
end
module QueuingStrategy_Make (T : Ojs.T) : sig
  type 'T parent = 'T QueuingStrategy.t
  type t = T.t parent
  val t_of_js: Ojs.t -> t
  val t_to_js: t -> Ojs.t
  
  val get_highWaterMark: t -> float option [@@js.get "highWaterMark"]
  val set_highWaterMark: t -> float -> unit [@@js.set "highWaterMark"]
  val get_size: t -> T.t QueuingStrategySize.t option [@@js.get "size"]
  val set_size: t -> T.t QueuingStrategySize.t -> unit [@@js.set "size"]
end
module ReadableStreamDefaultReadValueResult_Make (T : Ojs.T) : sig
  type 'T parent = 'T ReadableStreamDefaultReadValueResult.t
  type t = T.t parent
  val t_of_js: Ojs.t -> t
  val t_to_js: t -> Ojs.t
  
  val get_done: t -> ([`L_b_false[@js false]] [@js.enum]) [@@js.get "done"]
  val set_done: t -> ([`L_b_false[@js false]] [@js.enum]) -> unit [@@js.set "done"]
  val get_value: t -> T.t [@@js.get "value"]
  val set_value: t -> T.t -> unit [@@js.set "value"]
end
module ReadableWritablePair_Make (R : Ojs.T) (W : Ojs.T) : sig
  type ('R, 'W) parent = ('R, 'W) ReadableWritablePair.t
  type t = (R.t, W.t) parent
  val t_of_js: Ojs.t -> t
  val t_to_js: t -> Ojs.t
  
  val get_readable: t -> R.t ReadableStream.t [@@js.get "readable"]
  val set_readable: t -> R.t ReadableStream.t -> unit [@@js.set "readable"]
  
  (**
    Provides a convenient, chainable way of piping this readable stream through a transform stream (or any other \{ writable, readable \} pair). It simply pipes the stream into the writable side of the supplied pair, and returns the readable side for further use.
    
    Piping a stream will lock it for the duration of the pipe, preventing any other consumer from acquiring a reader.
  *)
  val get_writable: t -> W.t WritableStream.t [@@js.get "writable"]
  
  (**
    Provides a convenient, chainable way of piping this readable stream through a transform stream (or any other \{ writable, readable \} pair). It simply pipes the stream into the writable side of the supplied pair, and returns the readable side for further use.
    
    Piping a stream will lock it for the duration of the pipe, preventing any other consumer from acquiring a reader.
  *)
  val set_writable: t -> W.t WritableStream.t -> unit [@@js.set "writable"]
end
module Transformer_Make (I : Ojs.T) (O : Ojs.T) : sig
  type ('I, 'O) parent = ('I, 'O) Transformer.t
  type t = (I.t, O.t) parent
  val t_of_js: Ojs.t -> t
  val t_to_js: t -> Ojs.t
  
  val get_flush: t -> O.t TransformerFlushCallback.t option [@@js.get "flush"]
  val set_flush: t -> O.t TransformerFlushCallback.t -> unit [@@js.set "flush"]
  val get_readableType: t -> undefined [@@js.get "readableType"]
  val set_readableType: t -> undefined -> unit [@@js.set "readableType"]
  val get_start: t -> O.t TransformerStartCallback.t option [@@js.get "start"]
  val set_start: t -> O.t TransformerStartCallback.t -> unit [@@js.set "start"]
  val get_transform: t -> (I.t, O.t) TransformerTransformCallback.t option [@@js.get "transform"]
  val set_transform: t -> (I.t, O.t) TransformerTransformCallback.t -> unit [@@js.set "transform"]
  val get_writableType: t -> undefined [@@js.get "writableType"]
  val set_writableType: t -> undefined -> unit [@@js.set "writableType"]
end
module UnderlyingSink_Make (W : Ojs.T) : sig
  type 'W parent = 'W UnderlyingSink.t
  type t = W.t parent
  val t_of_js: Ojs.t -> t
  val t_to_js: t -> Ojs.t
  
  val get_abort: t -> UnderlyingSinkAbortCallback.t option [@@js.get "abort"]
  val set_abort: t -> UnderlyingSinkAbortCallback.t -> unit [@@js.set "abort"]
  val get_close: t -> UnderlyingSinkCloseCallback.t option [@@js.get "close"]
  val set_close: t -> UnderlyingSinkCloseCallback.t -> unit [@@js.set "close"]
  val get_start: t -> UnderlyingSinkStartCallback.t option [@@js.get "start"]
  val set_start: t -> UnderlyingSinkStartCallback.t -> unit [@@js.set "start"]
  val get_type: t -> undefined [@@js.get "type"]
  val set_type: t -> undefined -> unit [@@js.set "type"]
  val get_write: t -> W.t UnderlyingSinkWriteCallback.t option [@@js.get "write"]
  val set_write: t -> W.t UnderlyingSinkWriteCallback.t -> unit [@@js.set "write"]
end
module UnderlyingSource_Make (R : Ojs.T) : sig
  type 'R parent = 'R UnderlyingSource.t
  type t = R.t parent
  val t_of_js: Ojs.t -> t
  val t_to_js: t -> Ojs.t
  
  val get_cancel: t -> UnderlyingSourceCancelCallback.t option [@@js.get "cancel"]
  val set_cancel: t -> UnderlyingSourceCancelCallback.t -> unit [@@js.set "cancel"]
  val get_pull: t -> R.t UnderlyingSourcePullCallback.t option [@@js.get "pull"]
  val set_pull: t -> R.t UnderlyingSourcePullCallback.t -> unit [@@js.set "pull"]
  val get_start: t -> R.t UnderlyingSourceStartCallback.t option [@@js.get "start"]
  val set_start: t -> R.t UnderlyingSourceStartCallback.t -> unit [@@js.set "start"]
  val get_type: t -> undefined [@@js.get "type"]
  val set_type: t -> undefined -> unit [@@js.set "type"]
end
module CustomEvent_Make (T : Ojs.T) : sig
  type 'T parent = 'T CustomEvent.t
  type t = T.t parent
  val t_of_js: Ojs.t -> t
  val t_to_js: t -> Ojs.t
  
  
  (** Returns any custom data event was created with. Typically used for synthetic events. *)
  val get_detail: t -> T.t [@@js.get "detail"]
  
  (** @deprecated  *)
  val initCustomEvent: t -> type_:string -> ?bubbles:bool -> ?cancelable:bool -> ?detail:T.t -> unit -> unit [@@js.call "initCustomEvent"]
end
module HTMLCollectionOf_Make (T : Ojs.T) : sig
  type 'T parent = 'T HTMLCollectionOf.t
  type t = T.t parent
  val t_of_js: Ojs.t -> t
  val t_to_js: t -> Ojs.t
  
  (* [Symbol.iterator]: unit -> T.t IterableIterator.t_1 *)
  
  (** Retrieves an object from various collections. *)
  val item: t -> index:float -> T.t option [@@js.call "item"]
  val namedItem: t -> name:string -> T.t option [@@js.call "namedItem"]
  val get: t -> float -> T.t [@@js.index_get]
  val set: t -> float -> T.t -> unit [@@js.index_set]
end
module IDBRequest_Make (T : Ojs.T) : sig
  type 'T parent = 'T IDBRequest.t
  type t = T.t parent
  val t_of_js: Ojs.t -> t
  val t_to_js: t -> Ojs.t
  
  
  (** When a request is completed, returns the error (a DOMException), or null if the request succeeded. Throws a "InvalidStateError" DOMException if the request is still pending. *)
  val get_error: t -> DOMException.t option [@@js.get "error"]
  val get_onerror: t -> (this:t -> ev:Event.t -> any) option [@@js.get "onerror"]
  val set_onerror: t -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onerror"]
  val get_onsuccess: t -> (this:t -> ev:Event.t -> any) option [@@js.get "onsuccess"]
  val set_onsuccess: t -> (this:t -> ev:Event.t -> any) option -> unit [@@js.set "onsuccess"]
  
  (** Returns "pending" until a request is complete, then returns "done". *)
  val get_readyState: t -> IDBRequestReadyState.t [@@js.get "readyState"]
  
  (** When a request is completed, returns the result, or undefined if the request failed. Throws a "InvalidStateError" DOMException if the request is still pending. *)
  val get_result: t -> T.t [@@js.get "result"]
  
  (** Returns the IDBObjectStore, IDBIndex, or IDBCursor the request was made against, or null if is was an open request. *)
  val get_source: t -> (IDBCursor.t, IDBIndex.t, IDBObjectStore.t) union3 [@@js.get "source"]
  
  (** Returns the IDBTransaction the request was made within. If this as an open request, then it returns an upgrade transaction while it is running, or null otherwise. *)
  val get_transaction: t -> IDBTransaction.t option [@@js.get "transaction"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: t -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'IDBRequestEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (**
    Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
    
    The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
    
    When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
    
    When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
    
    When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
    
    If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
    
    The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
  *)
  val addEventListener: t -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of AddEventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "addEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: t -> type_:'K -> listener:(this:t -> ev:(* FIXME: unknown type 'IDBRequestEventMap[K]' *)any -> any) -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
  
  (** Removes the event listener in target's event listener list with the same type, callback, and options. *)
  val removeEventListener: t -> type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`U1 of bool | `U2 of EventListenerOptions.t] [@js.union]) -> unit -> unit [@@js.call "removeEventListener"]
end
module MessageEvent_Make (T : Ojs.T) : sig
  type 'T parent = 'T MessageEvent.t
  type t = T.t parent
  val t_of_js: Ojs.t -> t
  val t_to_js: t -> Ojs.t
  
  
  (** @deprecated  *)
  val initMessageEvent: t -> type_:string -> ?bubbles:bool -> ?cancelable:bool -> ?data:any -> ?origin:string -> ?lastEventId:string -> ?source:MessageEventSource.t option -> ?ports:MessagePort.t Iterable.t_1 -> unit -> unit [@@js.call "initMessageEvent"]
  
  (** Returns the data of the message. *)
  val get_data: t -> T.t [@@js.get "data"]
  
  (** Returns the last event ID string, for server-sent events. *)
  val get_lastEventId: t -> string [@@js.get "lastEventId"]
  
  (** Returns the origin of the message, for server-sent events and cross-document messaging. *)
  val get_origin: t -> string [@@js.get "origin"]
  
  (** Returns the MessagePort array sent with the message, for cross-document messaging and channel messaging. *)
  val get_ports: t -> MessagePort.t list [@@js.get "ports"]
  
  (** Returns the WindowProxy of the source window, for cross-document messaging, and the MessagePort being attached, in the connect event fired at SharedWorkerGlobalScope objects. *)
  val get_source: t -> MessageEventSource.t option [@@js.get "source"]
  
  (** @deprecated  *)
  val initMessageEvent: t -> type_:string -> ?bubbles:bool -> ?cancelable:bool -> ?data:any -> ?origin:string -> ?lastEventId:string -> ?source:MessageEventSource.t option -> ?ports:MessagePort.t list -> unit -> unit [@@js.call "initMessageEvent"]
end
module NodeListOf_Make (TNode : Ojs.T) : sig
  type 'TNode parent = 'TNode NodeListOf.t
  type t = TNode.t parent
  val t_of_js: Ojs.t -> t
  val t_to_js: t -> Ojs.t
  
  (* [Symbol.iterator]: unit -> TNode.t IterableIterator.t_1 *)
  
  (** Returns an array of key, value pairs for every entry in the list. *)
  val entries: t -> (float * TNode.t) IterableIterator.t_1 [@@js.call "entries"]
  
  (** Returns an list of keys in the list. *)
  val keys: t -> float IterableIterator.t_1 [@@js.call "keys"]
  
  (** Returns an list of values in the list. *)
  val values: t -> TNode.t IterableIterator.t_1 [@@js.call "values"]
  
  (** Returns the node with index index from the collection. The nodes are sorted in tree order. *)
  val item: t -> index:float -> TNode.t [@@js.call "item"]
  
  (**
    Performs the specified action for each node in an list.
    @param callbackfn A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the list.
    @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
  *)
  val forEach: t -> callbackfn:(value:TNode.t -> key:float -> parent:t -> unit) -> ?thisArg:any -> unit -> unit [@@js.call "forEach"]
  val get: t -> float -> TNode.t [@@js.index_get]
  val set: t -> float -> TNode.t -> unit [@@js.index_set]
end
module ProgressEvent_Make (T : Ojs.T) : sig
  type 'T parent = 'T ProgressEvent.t
  type t = T.t parent
  val t_of_js: Ojs.t -> t
  val t_to_js: t -> Ojs.t
  
  val get_lengthComputable: t -> bool [@@js.get "lengthComputable"]
  val get_loaded: t -> float [@@js.get "loaded"]
  
  (** Returns the object to which event is dispatched (its target). *)
  val get_target: t -> T.t option [@@js.get "target"]
  val get_total: t -> float [@@js.get "total"]
end
module ReadableStream_Make (R : Ojs.T) : sig
  type 'R parent = 'R ReadableStream.t
  type t = R.t parent
  val t_of_js: Ojs.t -> t
  val t_to_js: t -> Ojs.t
  
  val get_locked: t -> bool [@@js.get "locked"]
  val cancel: t -> ?reason:any -> unit -> unit Promise.t_1 [@@js.call "cancel"]
  val getReader: t -> R.t ReadableStreamDefaultReader.t [@@js.call "getReader"]
  val pipeThrough: t -> transform:('T, R.t) ReadableWritablePair.t -> ?options:StreamPipeOptions.t -> unit -> 'T parent [@@js.call "pipeThrough"]
  val pipeTo: t -> destination:R.t WritableStream.t -> ?options:StreamPipeOptions.t -> unit -> unit Promise.t_1 [@@js.call "pipeTo"]
  val tee: t -> (t * t) [@@js.call "tee"]
end
module ReadableStreamDefaultController_Make (R : Ojs.T) : sig
  type 'R parent = 'R ReadableStreamDefaultController.t
  type t = R.t parent
  val t_of_js: Ojs.t -> t
  val t_to_js: t -> Ojs.t
  
  val get_desiredSize: t -> float option [@@js.get "desiredSize"]
  val close: t -> unit [@@js.call "close"]
  val enqueue: t -> ?chunk:R.t -> unit -> unit [@@js.call "enqueue"]
  val error: t -> ?e:any -> unit -> unit [@@js.call "error"]
end
module ReadableStreamDefaultReader_Make (R : Ojs.T) : sig
  type 'R parent = 'R ReadableStreamDefaultReader.t
  type t = R.t parent
  val t_of_js: Ojs.t -> t
  val t_to_js: t -> Ojs.t
  
  val read: t -> R.t ReadableStreamDefaultReadResult.t Promise.t_1 [@@js.call "read"]
  val releaseLock: t -> unit [@@js.call "releaseLock"]
end
module TransformStream_Make (I : Ojs.T) (O : Ojs.T) : sig
  type ('I, 'O) parent = ('I, 'O) TransformStream.t
  type t = (I.t, O.t) parent
  val t_of_js: Ojs.t -> t
  val t_to_js: t -> Ojs.t
  
  val get_readable: t -> O.t ReadableStream.t [@@js.get "readable"]
  val get_writable: t -> I.t WritableStream.t [@@js.get "writable"]
end
module TransformStreamDefaultController_Make (O : Ojs.T) : sig
  type 'O parent = 'O TransformStreamDefaultController.t
  type t = O.t parent
  val t_of_js: Ojs.t -> t
  val t_to_js: t -> Ojs.t
  
  val get_desiredSize: t -> float option [@@js.get "desiredSize"]
  val enqueue: t -> ?chunk:O.t -> unit -> unit [@@js.call "enqueue"]
  val error: t -> ?reason:any -> unit -> unit [@@js.call "error"]
  val terminate: t -> unit [@@js.call "terminate"]
end
module WritableStream_Make (W : Ojs.T) : sig
  type 'W parent = 'W WritableStream.t
  type t = W.t parent
  val t_of_js: Ojs.t -> t
  val t_to_js: t -> Ojs.t
  
  val get_locked: t -> bool [@@js.get "locked"]
  val abort: t -> ?reason:any -> unit -> unit Promise.t_1 [@@js.call "abort"]
  val close: t -> unit Promise.t_1 [@@js.call "close"]
  val getWriter: t -> W.t WritableStreamDefaultWriter.t [@@js.call "getWriter"]
end
module WritableStreamDefaultWriter_Make (W : Ojs.T) : sig
  type 'W parent = 'W WritableStreamDefaultWriter.t
  type t = W.t parent
  val t_of_js: Ojs.t -> t
  val t_to_js: t -> Ojs.t
  
  val get_closed: t -> undefined Promise.t_1 [@@js.get "closed"]
  val get_desiredSize: t -> float option [@@js.get "desiredSize"]
  val get_ready: t -> undefined Promise.t_1 [@@js.get "ready"]
  val abort: t -> ?reason:any -> unit -> unit Promise.t_1 [@@js.call "abort"]
  val close: t -> unit Promise.t_1 [@@js.call "close"]
  val releaseLock: t -> unit [@@js.call "releaseLock"]
  val write: t -> ?chunk:W.t -> unit -> unit Promise.t_1 [@@js.call "write"]
end
module QueuingStrategySize_Make (T : Ojs.T) : sig
  type 'T parent = 'T QueuingStrategySize.t
  type t = T.t parent
  val t_of_js: Ojs.t -> t
  val t_to_js: t -> Ojs.t
  
  val apply: t -> chunk:T.t -> float [@@js.apply]
end
module TransformerFlushCallback_Make (O : Ojs.T) : sig
  type 'O parent = 'O TransformerFlushCallback.t
  type t = O.t parent
  val t_of_js: Ojs.t -> t
  val t_to_js: t -> Ojs.t
  
  val apply: t -> controller:O.t TransformStreamDefaultController.t -> (unit, unit PromiseLike.t_1) union2 [@@js.apply]
end
module TransformerStartCallback_Make (O : Ojs.T) : sig
  type 'O parent = 'O TransformerStartCallback.t
  type t = O.t parent
  val t_of_js: Ojs.t -> t
  val t_to_js: t -> Ojs.t
  
  val apply: t -> controller:O.t TransformStreamDefaultController.t -> any [@@js.apply]
end
module TransformerTransformCallback_Make (I : Ojs.T) (O : Ojs.T) : sig
  type ('I, 'O) parent = ('I, 'O) TransformerTransformCallback.t
  type t = (I.t, O.t) parent
  val t_of_js: Ojs.t -> t
  val t_to_js: t -> Ojs.t
  
  val apply: t -> chunk:I.t -> controller:O.t TransformStreamDefaultController.t -> (unit, unit PromiseLike.t_1) union2 [@@js.apply]
end
module UnderlyingSinkWriteCallback_Make (W : Ojs.T) : sig
  type 'W parent = 'W UnderlyingSinkWriteCallback.t
  type t = W.t parent
  val t_of_js: Ojs.t -> t
  val t_to_js: t -> Ojs.t
  
  val apply: t -> chunk:W.t -> controller:WritableStreamDefaultController.t -> (unit, unit PromiseLike.t_1) union2 [@@js.apply]
end
module UnderlyingSourcePullCallback_Make (R : Ojs.T) : sig
  type 'R parent = 'R UnderlyingSourcePullCallback.t
  type t = R.t parent
  val t_of_js: Ojs.t -> t
  val t_to_js: t -> Ojs.t
  
  val apply: t -> controller:R.t ReadableStreamController.t -> (unit, unit PromiseLike.t_1) union2 [@@js.apply]
end
module UnderlyingSourceStartCallback_Make (R : Ojs.T) : sig
  type 'R parent = 'R UnderlyingSourceStartCallback.t
  type t = R.t parent
  val t_of_js: Ojs.t -> t
  val t_to_js: t -> Ojs.t
  
  val apply: t -> controller:R.t ReadableStreamController.t -> any [@@js.apply]
end

(**
  The `console` module provides a simple debugging console that is similar to the
  JavaScript console mechanism provided by web browsers.
  
  The module exports two specific components:
  
  * A `Console` class with methods such as `console.log()`, `console.error()` and`console.warn()` that can be used to write to any Node.js stream.
  * A global `console` instance configured to write to `process.stdout` and `process.stderr`. The global `console` can be used without calling`require('console')`.
  
  _**Warning**_: The global console object's methods are neither consistently
  synchronous like the browser APIs they resemble, nor are they consistently
  asynchronous like all other Node.js streams. See the `note on process I/O` for
  more information.
  
  Example using the global `console`:
  
  ```js
  console.log('hello world');
  // Prints: hello world, to stdout
  console.log('hello %s', 'world');
  // Prints: hello world, to stdout
  console.error(new Error('Whoops, something bad happened'));
  // Prints error message and stack trace to stderr:
  //   Error: Whoops, something bad happened
  //     at \[eval\]:5:15
  //     at Script.runInThisContext (node:vm:132:18)
  //     at Object.runInThisContext (node:vm:309:38)
  //     at node:internal/process/execution:77:19
  //     at \[eval\]-wrapper:6:22
  //     at evalScript (node:internal/process/execution:76:60)
  //     at node:internal/main/eval_string:23:3
  
  const name = 'Will Robinson';
  console.warn(`Danger $\{name\}! Danger!`);
  // Prints: Danger Will Robinson! Danger!, to stderr
  ```
  
  Example using the `Console` class:
  
  ```js
  const out = getStreamSomehow();
  const err = getStreamSomehow();
  const myConsole = new console.Console(out, err);
  
  myConsole.log('hello world');
  // Prints: hello world, to out
  myConsole.log('hello %s', 'world');
  // Prints: hello world, to out
  myConsole.error(new Error('Whoops, something bad happened'));
  // Prints: \[Error: Whoops, something bad happened\], to err
  
  const name = 'Will Robinson';
  myConsole.warn(`Danger $\{name\}! Danger!`);
  // Prints: Danger Will Robinson! Danger!, to err
  ```
*)
val console: unit -> Console.t [@@js.get "console"]

(** @deprecated This is a legacy alias of `navigator`. *)
val clientInformation: unit -> Navigator.t [@@js.get "clientInformation"]

(** Returns true if the window has been closed, false otherwise. *)
val closed: unit -> bool [@@js.get "closed"]

(** Defines a new custom element, mapping the given name to the given constructor as an autonomous custom element. *)
val customElements: unit -> CustomElementRegistry.t [@@js.get "customElements"]
val devicePixelRatio: unit -> float [@@js.get "devicePixelRatio"]
val document: unit -> Document.t [@@js.get "document"]

(** @deprecated  *)
val event: unit -> Event.t option [@@js.get "event"]

(** @deprecated  *)
val external_: unit -> External.t [@@js.get "external"]
val frameElement: unit -> Element.t option [@@js.get "frameElement"]
val frames: unit -> WindowProxy.t [@@js.get "frames"]
val history: unit -> History.t [@@js.get "history"]
val innerHeight: unit -> float [@@js.get "innerHeight"]
val innerWidth: unit -> float [@@js.get "innerWidth"]
val length: unit -> float [@@js.get "length"]

(** Returns workerGlobal's WorkerLocation object. *)
val location: unit -> Location.t [@@js.get "location"]

(** Returns true if the location bar is visible; otherwise, returns false. *)
val locationbar: unit -> BarProp.t [@@js.get "locationbar"]

(** Returns true if the menu bar is visible; otherwise, returns false. *)
val menubar: unit -> BarProp.t [@@js.get "menubar"]

(** @deprecated  *)
val name: unit -> unit [@@js.get "name"]

(** Returns workerGlobal's WorkerNavigator object. *)
val navigator: unit -> Navigator.t [@@js.get "navigator"]

(** Available only in secure contexts. *)
val ondevicemotion: unit -> (this:Window.t -> ev:DeviceMotionEvent.t -> any) option [@@js.get "ondevicemotion"]

(** Available only in secure contexts. *)
val ondeviceorientation: unit -> (this:Window.t -> ev:DeviceOrientationEvent.t -> any) option [@@js.get "ondeviceorientation"]

(** @deprecated  *)
val onorientationchange: unit -> (this:Window.t -> ev:Event.t -> any) option [@@js.get "onorientationchange"]
val opener: unit -> any [@@js.get "opener"]

(** @deprecated  *)
val orientation: unit -> float [@@js.get "orientation"]
val outerHeight: unit -> float [@@js.get "outerHeight"]
val outerWidth: unit -> float [@@js.get "outerWidth"]

(** @deprecated This is a legacy alias of `scrollX`. *)
val pageXOffset: unit -> float [@@js.get "pageXOffset"]

(** @deprecated This is a legacy alias of `scrollY`. *)
val pageYOffset: unit -> float [@@js.get "pageYOffset"]

(**
  Refers to either the parent WindowProxy, or itself.
  
  It can rarely be null e.g. for contentWindow of an iframe that is already removed from the parent.
*)
val parent: unit -> WindowProxy.t [@@js.get "parent"]

(** Returns true if the personal bar is visible; otherwise, returns false. *)
val personalbar: unit -> BarProp.t [@@js.get "personalbar"]
val screen: unit -> Screen.t [@@js.get "screen"]
val screenLeft: unit -> float [@@js.get "screenLeft"]
val screenTop: unit -> float [@@js.get "screenTop"]
val screenX: unit -> float [@@js.get "screenX"]
val screenY: unit -> float [@@js.get "screenY"]
val scrollX: unit -> float [@@js.get "scrollX"]
val scrollY: unit -> float [@@js.get "scrollY"]

(** Returns true if the scrollbars are visible; otherwise, returns false. *)
val scrollbars: unit -> BarProp.t [@@js.get "scrollbars"]

(** Returns workerGlobal. *)
val self: unit -> (Window.t, (* FIXME: unknown type 'typeof globalThis' *)any) intersection2 [@@js.get "self"]
val speechSynthesis: unit -> SpeechSynthesis.t [@@js.get "speechSynthesis"]

(** @deprecated  *)
val status: unit -> string [@@js.get "status"]

(** Returns true if the status bar is visible; otherwise, returns false. *)
val statusbar: unit -> BarProp.t [@@js.get "statusbar"]

(** Returns true if the toolbar is visible; otherwise, returns false. *)
val toolbar: unit -> BarProp.t [@@js.get "toolbar"]
val top: unit -> WindowProxy.t option [@@js.get "top"]
val visualViewport: unit -> VisualViewport.t [@@js.get "visualViewport"]
val window: unit -> (Window.t, (* FIXME: unknown type 'typeof globalThis' *)any) intersection2 [@@js.get "window"]
val alert: ?message:any -> unit -> unit [@@js.global "alert"]
val blur: unit -> unit [@@js.global "blur"]
val cancelIdleCallback: float -> unit [@@js.global "cancelIdleCallback"]

(** @deprecated  *)
val captureEvents: unit -> unit [@@js.global "captureEvents"]

(** Closes the window. *)
val close: unit -> unit [@@js.global "close"]
val confirm: ?message:string -> unit -> bool [@@js.global "confirm"]

(** Moves the focus to the window's browsing context, if any. *)
val focus: unit -> unit [@@js.global "focus"]
val getComputedStyle: elt:Element.t -> ?pseudoElt:string option -> unit -> CSSStyleDeclaration.t [@@js.global "getComputedStyle"]
val getSelection: unit -> Selection.t option [@@js.global "getSelection"]
val matchMedia: string -> MediaQueryList.t [@@js.global "matchMedia"]
val moveBy: x:float -> y:float -> unit [@@js.global "moveBy"]
val moveTo: x:float -> y:float -> unit [@@js.global "moveTo"]
val open_: ?url:([`String of string | `Other of URL.t] [@js.union on_field "dummy"]) Primitive.t -> ?target:string -> ?features:string -> unit -> WindowProxy.t option [@@js.global "open"]

(**
  Posts a message to the given window. Messages can be structured objects, e.g. nested objects and arrays, can contain JavaScript values (strings, numbers, Date objects, etc), and can contain certain data objects such as File Blob, FileList, and ArrayBuffer objects.
  
  Objects listed in the transfer member of options are transferred, not just cloned, meaning that they are no longer usable on the sending side.
  
  A target origin can be specified using the targetOrigin member of options. If not provided, it defaults to "/". This default restricts the message to same-origin targets only.
  
  If the origin of the target window doesn't match the given target origin, the message is discarded, to avoid information leakage. To send the message to the target regardless of origin, set the target origin to "*".
  
  Throws a "DataCloneError" DOMException if transfer array contains duplicate objects or if message could not be cloned.
*)
val postMessage: message:any -> targetOrigin:string -> ?transfer:Transferable.t list -> unit -> unit [@@js.global "postMessage"]

(**
  Posts a message to the given window. Messages can be structured objects, e.g. nested objects and arrays, can contain JavaScript values (strings, numbers, Date objects, etc), and can contain certain data objects such as File Blob, FileList, and ArrayBuffer objects.
  
  Objects listed in the transfer member of options are transferred, not just cloned, meaning that they are no longer usable on the sending side.
  
  A target origin can be specified using the targetOrigin member of options. If not provided, it defaults to "/". This default restricts the message to same-origin targets only.
  
  If the origin of the target window doesn't match the given target origin, the message is discarded, to avoid information leakage. To send the message to the target regardless of origin, set the target origin to "*".
  
  Throws a "DataCloneError" DOMException if transfer array contains duplicate objects or if message could not be cloned.
  
  
  Clones message and transmits it to the Worker object associated with dedicatedWorkerGlobal. transfer can be passed as a list of objects that are to be transferred rather than cloned.
*)
val postMessage': message:any -> ?options:WindowPostMessageOptions.t -> unit -> unit [@@js.global "postMessage"]
val print: unit -> unit [@@js.global "print"]
val prompt: ?message:string -> ?_default:string -> unit -> string option [@@js.global "prompt"]

(** @deprecated  *)
val releaseEvents: unit -> unit [@@js.global "releaseEvents"]
val requestIdleCallback: callback:IdleRequestCallback.t -> ?options:IdleRequestOptions.t -> unit -> float [@@js.global "requestIdleCallback"]
val resizeBy: x:float -> y:float -> unit [@@js.global "resizeBy"]
val resizeTo: width:float -> height:float -> unit [@@js.global "resizeTo"]
val scroll: ?options:ScrollToOptions.t -> unit -> unit [@@js.global "scroll"]
val scroll': x:float -> y:float -> unit [@@js.global "scroll"]
val scrollBy: ?options:ScrollToOptions.t -> unit -> unit [@@js.global "scrollBy"]
val scrollBy': x:float -> y:float -> unit [@@js.global "scrollBy"]
val scrollTo: ?options:ScrollToOptions.t -> unit -> unit [@@js.global "scrollTo"]
val scrollTo': x:float -> y:float -> unit [@@js.global "scrollTo"]

(** Cancels the document load. *)
val stop: unit -> unit [@@js.global "stop"]
val toString: unit -> string [@@js.global "toString"]

(** Dispatches a synthetic event event to target and returns true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, and false otherwise. *)
val dispatchEvent: Event.t -> bool [@@js.global "dispatchEvent"]
val cancelAnimationFrame: float -> unit [@@js.global "cancelAnimationFrame"]
val requestAnimationFrame: FrameRequestCallback.t -> float [@@js.global "requestAnimationFrame"]

(**
  Fires when the user aborts the download.
  @param ev The event.
*)
val onabort: unit -> (this:Window.t -> ev:UIEvent.t -> any) option [@@js.get "onabort"]
val onanimationcancel: unit -> (this:Window.t -> ev:AnimationEvent.t -> any) option [@@js.get "onanimationcancel"]
val onanimationend: unit -> (this:Window.t -> ev:AnimationEvent.t -> any) option [@@js.get "onanimationend"]
val onanimationiteration: unit -> (this:Window.t -> ev:AnimationEvent.t -> any) option [@@js.get "onanimationiteration"]
val onanimationstart: unit -> (this:Window.t -> ev:AnimationEvent.t -> any) option [@@js.get "onanimationstart"]
val onauxclick: unit -> (this:Window.t -> ev:MouseEvent.t -> any) option [@@js.get "onauxclick"]

(**
  Fires when the object loses the input focus.
  @param ev The focus event.
*)
val onblur: unit -> (this:Window.t -> ev:FocusEvent.t -> any) option [@@js.get "onblur"]

(**
  Occurs when playback is possible, but would require further buffering.
  @param ev The event.
*)
val oncanplay: unit -> (this:Window.t -> ev:Event.t -> any) option [@@js.get "oncanplay"]
val oncanplaythrough: unit -> (this:Window.t -> ev:Event.t -> any) option [@@js.get "oncanplaythrough"]

(**
  Fires when the contents of the object or selection have changed.
  @param ev The event.
*)
val onchange: unit -> (this:Window.t -> ev:Event.t -> any) option [@@js.get "onchange"]

(**
  Fires when the user clicks the left mouse button on the object
  @param ev The mouse event.
*)
val onclick: unit -> (this:Window.t -> ev:MouseEvent.t -> any) option [@@js.get "onclick"]
val onclose: unit -> (this:Window.t -> ev:Event.t -> any) option [@@js.get "onclose"]

(**
  Fires when the user clicks the right mouse button in the client area, opening the context menu.
  @param ev The mouse event.
*)
val oncontextmenu: unit -> (this:Window.t -> ev:MouseEvent.t -> any) option [@@js.get "oncontextmenu"]
val oncuechange: unit -> (this:Window.t -> ev:Event.t -> any) option [@@js.get "oncuechange"]

(**
  Fires when the user double-clicks the object.
  @param ev The mouse event.
*)
val ondblclick: unit -> (this:Window.t -> ev:MouseEvent.t -> any) option [@@js.get "ondblclick"]

(**
  Fires on the source object continuously during a drag operation.
  @param ev The event.
*)
val ondrag: unit -> (this:Window.t -> ev:DragEvent.t -> any) option [@@js.get "ondrag"]

(**
  Fires on the source object when the user releases the mouse at the close of a drag operation.
  @param ev The event.
*)
val ondragend: unit -> (this:Window.t -> ev:DragEvent.t -> any) option [@@js.get "ondragend"]

(**
  Fires on the target element when the user drags the object to a valid drop target.
  @param ev The drag event.
*)
val ondragenter: unit -> (this:Window.t -> ev:DragEvent.t -> any) option [@@js.get "ondragenter"]

(**
  Fires on the target object when the user moves the mouse out of a valid drop target during a drag operation.
  @param ev The drag event.
*)
val ondragleave: unit -> (this:Window.t -> ev:DragEvent.t -> any) option [@@js.get "ondragleave"]

(**
  Fires on the target element continuously while the user drags the object over a valid drop target.
  @param ev The event.
*)
val ondragover: unit -> (this:Window.t -> ev:DragEvent.t -> any) option [@@js.get "ondragover"]

(**
  Fires on the source object when the user starts to drag a text selection or selected object.
  @param ev The event.
*)
val ondragstart: unit -> (this:Window.t -> ev:DragEvent.t -> any) option [@@js.get "ondragstart"]
val ondrop: unit -> (this:Window.t -> ev:DragEvent.t -> any) option [@@js.get "ondrop"]

(**
  Occurs when the duration attribute is updated.
  @param ev The event.
*)
val ondurationchange: unit -> (this:Window.t -> ev:Event.t -> any) option [@@js.get "ondurationchange"]

(**
  Occurs when the media element is reset to its initial state.
  @param ev The event.
*)
val onemptied: unit -> (this:Window.t -> ev:Event.t -> any) option [@@js.get "onemptied"]

(**
  Occurs when the end of playback is reached.
  @param ev The event
*)
val onended: unit -> (this:Window.t -> ev:Event.t -> any) option [@@js.get "onended"]

(**
  Fires when an error occurs during object loading.
  @param ev The event.
*)
val onerror: unit -> OnErrorEventHandler.t [@@js.get "onerror"]

(**
  Fires when the object receives focus.
  @param ev The event.
*)
val onfocus: unit -> (this:Window.t -> ev:FocusEvent.t -> any) option [@@js.get "onfocus"]
val onformdata: unit -> (this:Window.t -> ev:FormDataEvent.t -> any) option [@@js.get "onformdata"]
val ongotpointercapture: unit -> (this:Window.t -> ev:PointerEvent.t -> any) option [@@js.get "ongotpointercapture"]
val oninput: unit -> (this:Window.t -> ev:Event.t -> any) option [@@js.get "oninput"]
val oninvalid: unit -> (this:Window.t -> ev:Event.t -> any) option [@@js.get "oninvalid"]

(**
  Fires when the user presses a key.
  @param ev The keyboard event
*)
val onkeydown: unit -> (this:Window.t -> ev:KeyboardEvent.t -> any) option [@@js.get "onkeydown"]

(**
  Fires when the user presses an alphanumeric key.
  @param ev The event.
  @deprecated 
*)
val onkeypress: unit -> (this:Window.t -> ev:KeyboardEvent.t -> any) option [@@js.get "onkeypress"]

(**
  Fires when the user releases a key.
  @param ev The keyboard event
*)
val onkeyup: unit -> (this:Window.t -> ev:KeyboardEvent.t -> any) option [@@js.get "onkeyup"]

(**
  Fires immediately after the browser loads the object.
  @param ev The event.
*)
val onload: unit -> (this:Window.t -> ev:Event.t -> any) option [@@js.get "onload"]

(**
  Occurs when media data is loaded at the current playback position.
  @param ev The event.
*)
val onloadeddata: unit -> (this:Window.t -> ev:Event.t -> any) option [@@js.get "onloadeddata"]

(**
  Occurs when the duration and dimensions of the media have been determined.
  @param ev The event.
*)
val onloadedmetadata: unit -> (this:Window.t -> ev:Event.t -> any) option [@@js.get "onloadedmetadata"]

(**
  Occurs when Internet Explorer begins looking for media data.
  @param ev The event.
*)
val onloadstart: unit -> (this:Window.t -> ev:Event.t -> any) option [@@js.get "onloadstart"]
val onlostpointercapture: unit -> (this:Window.t -> ev:PointerEvent.t -> any) option [@@js.get "onlostpointercapture"]

(**
  Fires when the user clicks the object with either mouse button.
  @param ev The mouse event.
*)
val onmousedown: unit -> (this:Window.t -> ev:MouseEvent.t -> any) option [@@js.get "onmousedown"]
val onmouseenter: unit -> (this:Window.t -> ev:MouseEvent.t -> any) option [@@js.get "onmouseenter"]
val onmouseleave: unit -> (this:Window.t -> ev:MouseEvent.t -> any) option [@@js.get "onmouseleave"]

(**
  Fires when the user moves the mouse over the object.
  @param ev The mouse event.
*)
val onmousemove: unit -> (this:Window.t -> ev:MouseEvent.t -> any) option [@@js.get "onmousemove"]

(**
  Fires when the user moves the mouse pointer outside the boundaries of the object.
  @param ev The mouse event.
*)
val onmouseout: unit -> (this:Window.t -> ev:MouseEvent.t -> any) option [@@js.get "onmouseout"]

(**
  Fires when the user moves the mouse pointer into the object.
  @param ev The mouse event.
*)
val onmouseover: unit -> (this:Window.t -> ev:MouseEvent.t -> any) option [@@js.get "onmouseover"]

(**
  Fires when the user releases a mouse button while the mouse is over the object.
  @param ev The mouse event.
*)
val onmouseup: unit -> (this:Window.t -> ev:MouseEvent.t -> any) option [@@js.get "onmouseup"]

(**
  Occurs when playback is paused.
  @param ev The event.
*)
val onpause: unit -> (this:Window.t -> ev:Event.t -> any) option [@@js.get "onpause"]

(**
  Occurs when the play method is requested.
  @param ev The event.
*)
val onplay: unit -> (this:Window.t -> ev:Event.t -> any) option [@@js.get "onplay"]

(**
  Occurs when the audio or video has started playing.
  @param ev The event.
*)
val onplaying: unit -> (this:Window.t -> ev:Event.t -> any) option [@@js.get "onplaying"]
val onpointercancel: unit -> (this:Window.t -> ev:PointerEvent.t -> any) option [@@js.get "onpointercancel"]
val onpointerdown: unit -> (this:Window.t -> ev:PointerEvent.t -> any) option [@@js.get "onpointerdown"]
val onpointerenter: unit -> (this:Window.t -> ev:PointerEvent.t -> any) option [@@js.get "onpointerenter"]
val onpointerleave: unit -> (this:Window.t -> ev:PointerEvent.t -> any) option [@@js.get "onpointerleave"]
val onpointermove: unit -> (this:Window.t -> ev:PointerEvent.t -> any) option [@@js.get "onpointermove"]
val onpointerout: unit -> (this:Window.t -> ev:PointerEvent.t -> any) option [@@js.get "onpointerout"]
val onpointerover: unit -> (this:Window.t -> ev:PointerEvent.t -> any) option [@@js.get "onpointerover"]
val onpointerup: unit -> (this:Window.t -> ev:PointerEvent.t -> any) option [@@js.get "onpointerup"]

(**
  Occurs to indicate progress while downloading media data.
  @param ev The event.
*)
val onprogress: unit -> (this:Window.t -> ev:ProgressEvent.t_0 -> any) option [@@js.get "onprogress"]

(**
  Occurs when the playback rate is increased or decreased.
  @param ev The event.
*)
val onratechange: unit -> (this:Window.t -> ev:Event.t -> any) option [@@js.get "onratechange"]

(**
  Fires when the user resets a form.
  @param ev The event.
*)
val onreset: unit -> (this:Window.t -> ev:Event.t -> any) option [@@js.get "onreset"]
val onresize: unit -> (this:Window.t -> ev:UIEvent.t -> any) option [@@js.get "onresize"]

(**
  Fires when the user repositions the scroll box in the scroll bar on the object.
  @param ev The event.
*)
val onscroll: unit -> (this:Window.t -> ev:Event.t -> any) option [@@js.get "onscroll"]
val onsecuritypolicyviolation: unit -> (this:Window.t -> ev:SecurityPolicyViolationEvent.t -> any) option [@@js.get "onsecuritypolicyviolation"]

(**
  Occurs when the seek operation ends.
  @param ev The event.
*)
val onseeked: unit -> (this:Window.t -> ev:Event.t -> any) option [@@js.get "onseeked"]

(**
  Occurs when the current playback position is moved.
  @param ev The event.
*)
val onseeking: unit -> (this:Window.t -> ev:Event.t -> any) option [@@js.get "onseeking"]

(**
  Fires when the current selection changes.
  @param ev The event.
*)
val onselect: unit -> (this:Window.t -> ev:Event.t -> any) option [@@js.get "onselect"]
val onselectionchange: unit -> (this:Window.t -> ev:Event.t -> any) option [@@js.get "onselectionchange"]
val onselectstart: unit -> (this:Window.t -> ev:Event.t -> any) option [@@js.get "onselectstart"]
val onslotchange: unit -> (this:Window.t -> ev:Event.t -> any) option [@@js.get "onslotchange"]

(**
  Occurs when the download has stopped.
  @param ev The event.
*)
val onstalled: unit -> (this:Window.t -> ev:Event.t -> any) option [@@js.get "onstalled"]
val onsubmit: unit -> (this:Window.t -> ev:SubmitEvent.t -> any) option [@@js.get "onsubmit"]

(**
  Occurs if the load operation has been intentionally halted.
  @param ev The event.
*)
val onsuspend: unit -> (this:Window.t -> ev:Event.t -> any) option [@@js.get "onsuspend"]

(**
  Occurs to indicate the current playback position.
  @param ev The event.
*)
val ontimeupdate: unit -> (this:Window.t -> ev:Event.t -> any) option [@@js.get "ontimeupdate"]
val ontoggle: unit -> (this:Window.t -> ev:Event.t -> any) option [@@js.get "ontoggle"]
val ontouchcancel: unit -> (this:Window.t -> ev:TouchEvent.t -> any) option [@@js.get "ontouchcancel"]
val ontouchend: unit -> (this:Window.t -> ev:TouchEvent.t -> any) option [@@js.get "ontouchend"]
val ontouchmove: unit -> (this:Window.t -> ev:TouchEvent.t -> any) option [@@js.get "ontouchmove"]
val ontouchstart: unit -> (this:Window.t -> ev:TouchEvent.t -> any) option [@@js.get "ontouchstart"]
val ontransitioncancel: unit -> (this:Window.t -> ev:TransitionEvent.t -> any) option [@@js.get "ontransitioncancel"]
val ontransitionend: unit -> (this:Window.t -> ev:TransitionEvent.t -> any) option [@@js.get "ontransitionend"]
val ontransitionrun: unit -> (this:Window.t -> ev:TransitionEvent.t -> any) option [@@js.get "ontransitionrun"]
val ontransitionstart: unit -> (this:Window.t -> ev:TransitionEvent.t -> any) option [@@js.get "ontransitionstart"]

(**
  Occurs when the volume is changed, or playback is muted or unmuted.
  @param ev The event.
*)
val onvolumechange: unit -> (this:Window.t -> ev:Event.t -> any) option [@@js.get "onvolumechange"]

(**
  Occurs when playback stops because the next frame of a video resource is not available.
  @param ev The event.
*)
val onwaiting: unit -> (this:Window.t -> ev:Event.t -> any) option [@@js.get "onwaiting"]

(** @deprecated This is a legacy alias of `onanimationend`. *)
val onwebkitanimationend: unit -> (this:Window.t -> ev:Event.t -> any) option [@@js.get "onwebkitanimationend"]

(** @deprecated This is a legacy alias of `onanimationiteration`. *)
val onwebkitanimationiteration: unit -> (this:Window.t -> ev:Event.t -> any) option [@@js.get "onwebkitanimationiteration"]

(** @deprecated This is a legacy alias of `onanimationstart`. *)
val onwebkitanimationstart: unit -> (this:Window.t -> ev:Event.t -> any) option [@@js.get "onwebkitanimationstart"]

(** @deprecated This is a legacy alias of `ontransitionend`. *)
val onwebkittransitionend: unit -> (this:Window.t -> ev:Event.t -> any) option [@@js.get "onwebkittransitionend"]
val onwheel: unit -> (this:Window.t -> ev:WheelEvent.t -> any) option [@@js.get "onwheel"]
val onafterprint: unit -> (this:Window.t -> ev:Event.t -> any) option [@@js.get "onafterprint"]
val onbeforeprint: unit -> (this:Window.t -> ev:Event.t -> any) option [@@js.get "onbeforeprint"]
val onbeforeunload: unit -> (this:Window.t -> ev:BeforeUnloadEvent.t -> any) option [@@js.get "onbeforeunload"]
val ongamepadconnected: unit -> (this:Window.t -> ev:GamepadEvent.t -> any) option [@@js.get "ongamepadconnected"]
val ongamepaddisconnected: unit -> (this:Window.t -> ev:GamepadEvent.t -> any) option [@@js.get "ongamepaddisconnected"]
val onhashchange: unit -> (this:Window.t -> ev:HashChangeEvent.t -> any) option [@@js.get "onhashchange"]
val onlanguagechange: unit -> (this:Window.t -> ev:Event.t -> any) option [@@js.get "onlanguagechange"]
val onmessage: unit -> (this:Window.t -> ev:MessageEvent.t_0 -> any) option [@@js.get "onmessage"]
val onmessageerror: unit -> (this:Window.t -> ev:MessageEvent.t_0 -> any) option [@@js.get "onmessageerror"]
val onoffline: unit -> (this:Window.t -> ev:Event.t -> any) option [@@js.get "onoffline"]
val ononline: unit -> (this:Window.t -> ev:Event.t -> any) option [@@js.get "ononline"]
val onpagehide: unit -> (this:Window.t -> ev:PageTransitionEvent.t -> any) option [@@js.get "onpagehide"]
val onpageshow: unit -> (this:Window.t -> ev:PageTransitionEvent.t -> any) option [@@js.get "onpageshow"]
val onpopstate: unit -> (this:Window.t -> ev:PopStateEvent.t -> any) option [@@js.get "onpopstate"]
val onrejectionhandled: unit -> (this:Window.t -> ev:PromiseRejectionEvent.t -> any) option [@@js.get "onrejectionhandled"]
val onstorage: unit -> (this:Window.t -> ev:StorageEvent.t -> any) option [@@js.get "onstorage"]
val onunhandledrejection: unit -> (this:Window.t -> ev:PromiseRejectionEvent.t -> any) option [@@js.get "onunhandledrejection"]
val onunload: unit -> (this:Window.t -> ev:Event.t -> any) option [@@js.get "onunload"]
val localStorage: unit -> Storage.t [@@js.get "localStorage"]

(** Available only in secure contexts. *)
val caches: unit -> CacheStorage.t [@@js.get "caches"]
val crossOriginIsolated: unit -> bool [@@js.get "crossOriginIsolated"]
val crypto: unit -> Crypto.t [@@js.get "crypto"]
val indexedDB: unit -> IDBFactory.t [@@js.get "indexedDB"]
val isSecureContext: unit -> bool [@@js.get "isSecureContext"]
val origin: unit -> string [@@js.get "origin"]
val performance: unit -> Performance.t [@@js.get "performance"]

(**
  Decodes a string of Base64-encoded data into bytes, and encodes those bytes
  into a string using Latin-1 (ISO-8859-1).
  
  The `data` may be any JavaScript-value that can be coerced into a string.
  
  **This function is only provided for compatibility with legacy web platform APIs**
  **and should never be used in new code, because they use strings to represent**
  **binary data and predate the introduction of typed arrays in JavaScript.**
  **For code running using Node.js APIs, converting between base64-encoded strings**
  **and binary data should be performed using `Buffer.from(str, 'base64')` and`buf.toString('base64')`.**
*)
val atob: string -> string [@@js.global "atob"]

(**
  Decodes a string into bytes using Latin-1 (ISO-8859), and encodes those bytes
  into a string using Base64.
  
  The `data` may be any JavaScript-value that can be coerced into a string.
  
  **This function is only provided for compatibility with legacy web platform APIs**
  **and should never be used in new code, because they use strings to represent**
  **binary data and predate the introduction of typed arrays in JavaScript.**
  **For code running using Node.js APIs, converting between base64-encoded strings**
  **and binary data should be performed using `Buffer.from(str, 'base64')` and`buf.toString('base64')`.**
*)
val btoa: string -> string [@@js.global "btoa"]
val clearInterval: ?id:float -> unit -> unit [@@js.global "clearInterval"]
val clearTimeout: ?id:float -> unit -> unit [@@js.global "clearTimeout"]
val createImageBitmap: image:ImageBitmapSource.t -> ?options:ImageBitmapOptions.t -> unit -> ImageBitmap.t Promise.t_1 [@@js.global "createImageBitmap"]
val createImageBitmap': image:ImageBitmapSource.t -> sx:float -> sy:float -> sw:float -> sh:float -> ?options:ImageBitmapOptions.t -> unit -> ImageBitmap.t Promise.t_1 [@@js.global "createImageBitmap"]
val fetch: input:RequestInfo.t -> ?init:RequestInit.t -> unit -> Response.t Promise.t_1 [@@js.global "fetch"]
val queueMicrotask: VoidFunction.t -> unit [@@js.global "queueMicrotask"]
val reportError: any -> unit [@@js.global "reportError"]
val setInterval: handler:TimerHandler.t -> ?timeout:float -> arguments:(any list [@js.variadic]) -> unit -> float [@@js.global "setInterval"]
val setTimeout: handler:TimerHandler.t -> ?timeout:float -> arguments:(any list [@js.variadic]) -> unit -> float [@@js.global "setTimeout"]
val sessionStorage: unit -> Storage.t [@@js.get "sessionStorage"]
val addEventListener: type_:'K -> listener:(this:Window.t -> ev:(* FIXME: unknown type 'WindowEventMap[K]' *)any -> any) -> ?options:([`Boolean of bool | `Other of AddEventListenerOptions.t] [@js.union on_field "dummy"]) Primitive.t -> unit -> unit [@@js.global "addEventListener"]
val addEventListener': type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`Boolean of bool | `Other of AddEventListenerOptions.t] [@js.union on_field "dummy"]) Primitive.t -> unit -> unit [@@js.global "addEventListener"]
val removeEventListener: type_:'K -> listener:(this:Window.t -> ev:(* FIXME: unknown type 'WindowEventMap[K]' *)any -> any) -> ?options:([`Boolean of bool | `Other of EventListenerOptions.t] [@js.union on_field "dummy"]) Primitive.t -> unit -> unit [@@js.global "removeEventListener"]
val removeEventListener': type_:string -> listener:EventListenerOrEventListenerObject.t -> ?options:([`Boolean of bool | `Other of EventListenerOptions.t] [@js.union on_field "dummy"]) Primitive.t -> unit -> unit [@@js.global "removeEventListener"]